var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __glob = (map) => (path) => {
  var fn = map[path];
  if (fn)
    return fn();
  throw new Error("Module not found in bundle: " + path);
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// <define:import.meta.env>
var define_import_meta_env_default;
var init_define_import_meta_env = __esm({
  "<define:import.meta.env>"() {
    define_import_meta_env_default = { DEV: true };
  }
});

// css/variables.module.scss
var variables_module_default;
var init_variables_module = __esm({
  "css/variables.module.scss"() {
    variables_module_default = {};
  }
});

// colors.ts
import oc from "open-color";
var pick, MAX_CUSTOM_COLORS_USED_IN_CANVAS, COLORS_PER_ROW, DEFAULT_CHART_COLOR_INDEX, DEFAULT_ELEMENT_STROKE_COLOR_INDEX, DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX, ELEMENTS_PALETTE_SHADE_INDEXES, getSpecificColorShades, COLOR_PALETTE, COMMON_ELEMENT_SHADES, DEFAULT_ELEMENT_STROKE_PICKS, DEFAULT_ELEMENT_BACKGROUND_PICKS, DEFAULT_CANVAS_BACKGROUND_PICKS, DEFAULT_ELEMENT_STROKE_COLOR_PALETTE, DEFAULT_ELEMENT_BACKGROUND_COLOR_PALETTE, getAllColorsSpecificShade, rgbToHex;
var init_colors = __esm({
  "colors.ts"() {
    "use strict";
    init_define_import_meta_env();
    pick = (source, keys) => {
      return keys.reduce((acc, key) => {
        if (key in source) {
          acc[key] = source[key];
        }
        return acc;
      }, {});
    };
    MAX_CUSTOM_COLORS_USED_IN_CANVAS = 5;
    COLORS_PER_ROW = 5;
    DEFAULT_CHART_COLOR_INDEX = 4;
    DEFAULT_ELEMENT_STROKE_COLOR_INDEX = 4;
    DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX = 1;
    ELEMENTS_PALETTE_SHADE_INDEXES = [0, 2, 4, 6, 8];
    getSpecificColorShades = (color, indexArr) => {
      return indexArr.map((index) => oc[color][index]);
    };
    COLOR_PALETTE = {
      transparent: "transparent",
      black: "#1e1e1e",
      white: "#ffffff",
      // open-colors
      gray: getSpecificColorShades("gray", ELEMENTS_PALETTE_SHADE_INDEXES),
      red: getSpecificColorShades("red", ELEMENTS_PALETTE_SHADE_INDEXES),
      pink: getSpecificColorShades("pink", ELEMENTS_PALETTE_SHADE_INDEXES),
      grape: getSpecificColorShades("grape", ELEMENTS_PALETTE_SHADE_INDEXES),
      violet: getSpecificColorShades("violet", ELEMENTS_PALETTE_SHADE_INDEXES),
      blue: getSpecificColorShades("blue", ELEMENTS_PALETTE_SHADE_INDEXES),
      cyan: getSpecificColorShades("cyan", ELEMENTS_PALETTE_SHADE_INDEXES),
      teal: getSpecificColorShades("teal", ELEMENTS_PALETTE_SHADE_INDEXES),
      green: getSpecificColorShades("green", ELEMENTS_PALETTE_SHADE_INDEXES),
      yellow: getSpecificColorShades("yellow", ELEMENTS_PALETTE_SHADE_INDEXES),
      orange: getSpecificColorShades("orange", ELEMENTS_PALETTE_SHADE_INDEXES),
      // radix bronze shades 3,5,7,9,11
      bronze: ["#f8f1ee", "#eaddd7", "#d2bab0", "#a18072", "#846358"]
    };
    COMMON_ELEMENT_SHADES = pick(COLOR_PALETTE, [
      "cyan",
      "blue",
      "violet",
      "grape",
      "pink",
      "green",
      "teal",
      "yellow",
      "orange",
      "red"
    ]);
    DEFAULT_ELEMENT_STROKE_PICKS = [
      COLOR_PALETTE.black,
      COLOR_PALETTE.red[DEFAULT_ELEMENT_STROKE_COLOR_INDEX],
      COLOR_PALETTE.green[DEFAULT_ELEMENT_STROKE_COLOR_INDEX],
      COLOR_PALETTE.blue[DEFAULT_ELEMENT_STROKE_COLOR_INDEX],
      COLOR_PALETTE.yellow[DEFAULT_ELEMENT_STROKE_COLOR_INDEX]
    ];
    DEFAULT_ELEMENT_BACKGROUND_PICKS = [
      COLOR_PALETTE.transparent,
      COLOR_PALETTE.red[DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX],
      COLOR_PALETTE.green[DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX],
      COLOR_PALETTE.blue[DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX],
      COLOR_PALETTE.yellow[DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX]
    ];
    DEFAULT_CANVAS_BACKGROUND_PICKS = [
      COLOR_PALETTE.white,
      // radix slate2
      "#f8f9fa",
      // radix blue2
      "#f5faff",
      // radix yellow2
      "#fffce8",
      // radix bronze2
      "#fdf8f6"
    ];
    DEFAULT_ELEMENT_STROKE_COLOR_PALETTE = {
      // 1st row
      transparent: COLOR_PALETTE.transparent,
      white: COLOR_PALETTE.white,
      gray: COLOR_PALETTE.gray,
      black: COLOR_PALETTE.black,
      bronze: COLOR_PALETTE.bronze,
      // rest
      ...COMMON_ELEMENT_SHADES
    };
    DEFAULT_ELEMENT_BACKGROUND_COLOR_PALETTE = {
      transparent: COLOR_PALETTE.transparent,
      white: COLOR_PALETTE.white,
      gray: COLOR_PALETTE.gray,
      black: COLOR_PALETTE.black,
      bronze: COLOR_PALETTE.bronze,
      ...COMMON_ELEMENT_SHADES
    };
    getAllColorsSpecificShade = (index) => [
      // 2nd row
      COLOR_PALETTE.cyan[index],
      COLOR_PALETTE.blue[index],
      COLOR_PALETTE.violet[index],
      COLOR_PALETTE.grape[index],
      COLOR_PALETTE.pink[index],
      // 3rd row
      COLOR_PALETTE.green[index],
      COLOR_PALETTE.teal[index],
      COLOR_PALETTE.yellow[index],
      COLOR_PALETTE.orange[index],
      COLOR_PALETTE.red[index]
    ];
    rgbToHex = (r, g, b) => `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
  }
});

// constants.ts
var isDarwin, isWindows, isAndroid, isFirefox, isChrome, isSafari, isIOS, isBrave, supportsResizeObserver, APP_NAME, TEXT_AUTOWRAP_THRESHOLD, DRAGGING_THRESHOLD, LINE_CONFIRM_THRESHOLD, ELEMENT_SHIFT_TRANSLATE_AMOUNT, ELEMENT_TRANSLATE_AMOUNT, TEXT_TO_CENTER_SNAP_THRESHOLD, SHIFT_LOCKING_ANGLE, DEFAULT_LASER_COLOR, CURSOR_TYPE, POINTER_BUTTON, POINTER_EVENTS, YOUTUBE_STATES, ENV, CLASSES, FONT_FAMILY, THEME, FRAME_STYLE, WINDOWS_EMOJI_FALLBACK_FONT, MIN_FONT_SIZE, DEFAULT_FONT_SIZE, DEFAULT_FONT_FAMILY, DEFAULT_TEXT_ALIGN, DEFAULT_VERTICAL_ALIGN, DEFAULT_TRANSFORM_HANDLE_SPACING, SIDE_RESIZING_THRESHOLD, EPSILON, DEFAULT_COLLISION_THRESHOLD, COLOR_WHITE, COLOR_CHARCOAL_BLACK, COLOR_VOICE_CALL, DEFAULT_GRID_SIZE, DEFAULT_GRID_STEP, IMAGE_MIME_TYPES, ALLOWED_PASTE_MIME_TYPES, MIME_TYPES, EXPORT_IMAGE_TYPES, EXPORT_DATA_TYPES, EXPORT_SOURCE, IMAGE_RENDER_TIMEOUT, TAP_TWICE_TIMEOUT, TOUCH_CTX_MENU_TIMEOUT, SCROLL_TIMEOUT, ZOOM_STEP, MIN_ZOOM, MAX_ZOOM, HYPERLINK_TOOLTIP_DELAY, THEME_FILTER, URL_QUERY_KEYS, URL_HASH_KEYS, DEFAULT_UI_OPTIONS, MQ_MAX_WIDTH_PORTRAIT, MQ_MAX_WIDTH_LANDSCAPE, MQ_MAX_HEIGHT_LANDSCAPE, MQ_RIGHT_SIDEBAR_MIN_WIDTH, LIBRARY_SIDEBAR_WIDTH, MAX_DECIMALS_FOR_SVG_EXPORT, EXPORT_SCALES, DEFAULT_EXPORT_PADDING, DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT, MAX_ALLOWED_FILE_BYTES, SVG_NS, VERSIONS, BOUND_TEXT_PADDING, ARROW_LABEL_WIDTH_FRACTION, ARROW_LABEL_FONT_SIZE_TO_MIN_WIDTH_RATIO, VERTICAL_ALIGN, TEXT_ALIGN, ELEMENT_READY_TO_ERASE_OPACITY, DEFAULT_PROPORTIONAL_RADIUS, DEFAULT_ADAPTIVE_RADIUS, ROUNDNESS, ROUGHNESS, STROKE_WIDTH, DEFAULT_ELEMENT_PROPS, LIBRARY_SIDEBAR_TAB, CANVAS_SEARCH_TAB, DEFAULT_SIDEBAR, LIBRARY_DISABLED_TYPES, TOOL_TYPE, EDITOR_LS_KEYS, DEFAULT_FILENAME, STATS_PANELS, MIN_WIDTH_OR_HEIGHT, ARROW_TYPE;
var init_constants = __esm({
  "constants.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_variables_module();
    init_colors();
    isDarwin = /Mac|iPod|iPhone|iPad/.test(navigator.platform);
    isWindows = /^Win/.test(navigator.platform);
    isAndroid = /\b(android)\b/i.test(navigator.userAgent);
    isFirefox = "netscape" in window && navigator.userAgent.indexOf("rv:") > 1 && navigator.userAgent.indexOf("Gecko") > 1;
    isChrome = navigator.userAgent.indexOf("Chrome") !== -1;
    isSafari = !isChrome && navigator.userAgent.indexOf("Safari") !== -1;
    isIOS = /iPad|iPhone/.test(navigator.platform) || // iPadOS 13+
    navigator.userAgent.includes("Mac") && "ontouchend" in document;
    isBrave = () => navigator.brave?.isBrave?.name === "isBrave";
    supportsResizeObserver = typeof window !== "undefined" && "ResizeObserver" in window;
    APP_NAME = "Excalidraw";
    TEXT_AUTOWRAP_THRESHOLD = 36;
    DRAGGING_THRESHOLD = 10;
    LINE_CONFIRM_THRESHOLD = 8;
    ELEMENT_SHIFT_TRANSLATE_AMOUNT = 5;
    ELEMENT_TRANSLATE_AMOUNT = 1;
    TEXT_TO_CENTER_SNAP_THRESHOLD = 30;
    SHIFT_LOCKING_ANGLE = Math.PI / 12;
    DEFAULT_LASER_COLOR = "red";
    CURSOR_TYPE = {
      TEXT: "text",
      CROSSHAIR: "crosshair",
      GRABBING: "grabbing",
      GRAB: "grab",
      POINTER: "pointer",
      MOVE: "move",
      AUTO: ""
    };
    POINTER_BUTTON = {
      MAIN: 0,
      WHEEL: 1,
      SECONDARY: 2,
      TOUCH: -1,
      ERASER: 5
    };
    POINTER_EVENTS = {
      enabled: "all",
      disabled: "none",
      // asserted as any so it can be freely assigned to React Element
      // "pointerEnvets" CSS prop
      inheritFromUI: "var(--ui-pointerEvents)"
    };
    YOUTUBE_STATES = {
      UNSTARTED: -1,
      ENDED: 0,
      PLAYING: 1,
      PAUSED: 2,
      BUFFERING: 3,
      CUED: 5
    };
    ENV = {
      TEST: "test",
      DEVELOPMENT: "development"
    };
    CLASSES = {
      SHAPE_ACTIONS_MENU: "App-menu__left",
      ZOOM_ACTIONS: "zoom-actions",
      SEARCH_MENU_INPUT_WRAPPER: "layer-ui__search-inputWrapper"
    };
    FONT_FAMILY = {
      Virgil: 1,
      Helvetica: 2,
      Cascadia: 3,
      // leave 4 unused as it was historically used for Assistant (which we don't use anymore) or custom font (Obsidian)
      Excalifont: 5,
      Nunito: 6,
      "Lilita One": 7,
      "Comic Shanns": 8,
      "Liberation Sans": 9
    };
    THEME = {
      LIGHT: "light",
      DARK: "dark"
    };
    FRAME_STYLE = {
      strokeColor: "#bbb",
      strokeWidth: 2,
      strokeStyle: "solid",
      fillStyle: "solid",
      roughness: 0,
      roundness: null,
      backgroundColor: "transparent",
      radius: 8,
      nameOffsetY: 3,
      nameColorLightTheme: "#999999",
      nameColorDarkTheme: "#7a7a7a",
      nameFontSize: 14,
      nameLineHeight: 1.25
    };
    WINDOWS_EMOJI_FALLBACK_FONT = "Segoe UI Emoji";
    MIN_FONT_SIZE = 1;
    DEFAULT_FONT_SIZE = 20;
    DEFAULT_FONT_FAMILY = FONT_FAMILY.Excalifont;
    DEFAULT_TEXT_ALIGN = "left";
    DEFAULT_VERTICAL_ALIGN = "top";
    DEFAULT_TRANSFORM_HANDLE_SPACING = 2;
    SIDE_RESIZING_THRESHOLD = 2 * DEFAULT_TRANSFORM_HANDLE_SPACING;
    EPSILON = 1e-5;
    DEFAULT_COLLISION_THRESHOLD = 2 * SIDE_RESIZING_THRESHOLD - EPSILON;
    COLOR_WHITE = "#ffffff";
    COLOR_CHARCOAL_BLACK = "#1e1e1e";
    COLOR_VOICE_CALL = "#a2f1a6";
    DEFAULT_GRID_SIZE = 20;
    DEFAULT_GRID_STEP = 5;
    IMAGE_MIME_TYPES = {
      svg: "image/svg+xml",
      png: "image/png",
      jpg: "image/jpeg",
      gif: "image/gif",
      webp: "image/webp",
      bmp: "image/bmp",
      ico: "image/x-icon",
      avif: "image/avif",
      jfif: "image/jfif"
    };
    ALLOWED_PASTE_MIME_TYPES = ["text/plain", "text/html"];
    MIME_TYPES = {
      json: "application/json",
      // excalidraw data
      excalidraw: "application/vnd.excalidraw+json",
      excalidrawlib: "application/vnd.excalidrawlib+json",
      // image-encoded excalidraw data
      "excalidraw.svg": "image/svg+xml",
      "excalidraw.png": "image/png",
      // binary
      binary: "application/octet-stream",
      // image
      ...IMAGE_MIME_TYPES
    };
    EXPORT_IMAGE_TYPES = {
      png: "png",
      svg: "svg",
      clipboard: "clipboard"
    };
    EXPORT_DATA_TYPES = {
      excalidraw: "excalidraw",
      excalidrawClipboard: "excalidraw/clipboard",
      excalidrawLibrary: "excalidrawlib",
      excalidrawClipboardWithAPI: "excalidraw-api/clipboard"
    };
    EXPORT_SOURCE = window.EXCALIDRAW_EXPORT_SOURCE || window.location.origin;
    IMAGE_RENDER_TIMEOUT = 500;
    TAP_TWICE_TIMEOUT = 300;
    TOUCH_CTX_MENU_TIMEOUT = 500;
    SCROLL_TIMEOUT = 100;
    ZOOM_STEP = 0.1;
    MIN_ZOOM = 0.1;
    MAX_ZOOM = 30;
    HYPERLINK_TOOLTIP_DELAY = 300;
    THEME_FILTER = variables_module_default.themeFilter;
    URL_QUERY_KEYS = {
      addLibrary: "addLibrary"
    };
    URL_HASH_KEYS = {
      addLibrary: "addLibrary"
    };
    DEFAULT_UI_OPTIONS = {
      canvasActions: {
        changeViewBackgroundColor: true,
        clearCanvas: true,
        export: { saveFileToDisk: true },
        loadScene: true,
        saveToActiveFile: true,
        toggleTheme: null,
        saveAsImage: true
      },
      tools: {
        image: true
      }
    };
    MQ_MAX_WIDTH_PORTRAIT = 730;
    MQ_MAX_WIDTH_LANDSCAPE = 1e3;
    MQ_MAX_HEIGHT_LANDSCAPE = 500;
    MQ_RIGHT_SIDEBAR_MIN_WIDTH = 1229;
    LIBRARY_SIDEBAR_WIDTH = parseInt(variables_module_default.rightSidebarWidth);
    MAX_DECIMALS_FOR_SVG_EXPORT = 2;
    EXPORT_SCALES = [1, 2, 3];
    DEFAULT_EXPORT_PADDING = 10;
    DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT = 1440;
    MAX_ALLOWED_FILE_BYTES = 4 * 1024 * 1024;
    SVG_NS = "http://www.w3.org/2000/svg";
    VERSIONS = {
      excalidraw: 2,
      excalidrawLibrary: 2
    };
    BOUND_TEXT_PADDING = 5;
    ARROW_LABEL_WIDTH_FRACTION = 0.7;
    ARROW_LABEL_FONT_SIZE_TO_MIN_WIDTH_RATIO = 11;
    VERTICAL_ALIGN = {
      TOP: "top",
      MIDDLE: "middle",
      BOTTOM: "bottom"
    };
    TEXT_ALIGN = {
      LEFT: "left",
      CENTER: "center",
      RIGHT: "right"
    };
    ELEMENT_READY_TO_ERASE_OPACITY = 20;
    DEFAULT_PROPORTIONAL_RADIUS = 0.25;
    DEFAULT_ADAPTIVE_RADIUS = 32;
    ROUNDNESS = {
      // Used for legacy rounding (rectangles), which currently works the same
      // as PROPORTIONAL_RADIUS, but we need to differentiate for UI purposes and
      // forwards-compat.
      LEGACY: 1,
      // Used for linear elements & diamonds
      PROPORTIONAL_RADIUS: 2,
      // Current default algorithm for rectangles, using fixed pixel radius.
      // It's working similarly to a regular border-radius, but attemps to make
      // radius visually similar across differnt element sizes, especially
      // very large and very small elements.
      //
      // NOTE right now we don't allow configuration and use a constant radius
      // (see DEFAULT_ADAPTIVE_RADIUS constant)
      ADAPTIVE_RADIUS: 3
    };
    ROUGHNESS = {
      architect: 0,
      artist: 1,
      cartoonist: 2
    };
    STROKE_WIDTH = {
      thin: 1,
      bold: 2,
      extraBold: 4
    };
    DEFAULT_ELEMENT_PROPS = {
      strokeColor: COLOR_PALETTE.black,
      backgroundColor: COLOR_PALETTE.transparent,
      fillStyle: "solid",
      strokeWidth: 2,
      strokeStyle: "solid",
      roughness: ROUGHNESS.artist,
      opacity: 100,
      locked: false
    };
    LIBRARY_SIDEBAR_TAB = "library";
    CANVAS_SEARCH_TAB = "search";
    DEFAULT_SIDEBAR = {
      name: "default",
      defaultTab: LIBRARY_SIDEBAR_TAB
    };
    LIBRARY_DISABLED_TYPES = /* @__PURE__ */ new Set([
      "iframe",
      "embeddable",
      "image"
    ]);
    TOOL_TYPE = {
      selection: "selection",
      rectangle: "rectangle",
      diamond: "diamond",
      ellipse: "ellipse",
      arrow: "arrow",
      line: "line",
      freedraw: "freedraw",
      text: "text",
      image: "image",
      eraser: "eraser",
      hand: "hand",
      frame: "frame",
      magicframe: "magicframe",
      embeddable: "embeddable",
      laser: "laser"
    };
    EDITOR_LS_KEYS = {
      OAI_API_KEY: "excalidraw-oai-api-key",
      // legacy naming (non)scheme
      MERMAID_TO_EXCALIDRAW: "mermaid-to-excalidraw",
      PUBLISH_LIBRARY: "publish-library-data"
    };
    DEFAULT_FILENAME = "Untitled";
    STATS_PANELS = { generalStats: 1, elementProperties: 2 };
    MIN_WIDTH_OR_HEIGHT = 1;
    ARROW_TYPE = {
      sharp: "sharp",
      round: "round",
      elbow: "elbow"
    };
  }
});

// ../math/utils.ts
var PRECISION, clamp, round, roundToStep, average, isFiniteNumber;
var init_utils = __esm({
  "../math/utils.ts"() {
    "use strict";
    init_define_import_meta_env();
    PRECISION = 1e-4;
    clamp = (value, min, max) => {
      return Math.min(Math.max(value, min), max);
    };
    round = (value, precision, func = "round") => {
      const multiplier = Math.pow(10, precision);
      return Math[func]((value + Number.EPSILON) * multiplier) / multiplier;
    };
    roundToStep = (value, step, func = "round") => {
      const factor = 1 / step;
      return Math[func](value * factor) / factor;
    };
    average = (a, b) => (a + b) / 2;
    isFiniteNumber = (value) => {
      return typeof value === "number" && Number.isFinite(value);
    };
  }
});

// ../math/angle.ts
function degreesToRadians(degrees) {
  return degrees * Math.PI / 180;
}
function radiansToDegrees(degrees) {
  return degrees * 180 / Math.PI;
}
function isRightAngleRads(rads) {
  return Math.abs(Math.sin(2 * rads)) < PRECISION;
}
var normalizeRadians;
var init_angle = __esm({
  "../math/angle.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_utils();
    normalizeRadians = (angle) => {
      if (angle < 0) {
        return angle + 2 * Math.PI;
      }
      if (angle >= 2 * Math.PI) {
        return angle - 2 * Math.PI;
      }
      return angle;
    };
  }
});

// ../math/arc.ts
var init_arc = __esm({
  "../math/arc.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_angle();
    init_utils();
  }
});

// ../math/vector.ts
function vector(x, y, originX = 0, originY = 0) {
  return [x - originX, y - originY];
}
function vectorFromPoint(p, origin = [0, 0]) {
  return vector(p[0] - origin[0], p[1] - origin[1]);
}
function vectorCross(a, b) {
  return a[0] * b[1] - b[0] * a[1];
}
function vectorAdd(a, b) {
  return [a[0] + b[0], a[1] + b[1]];
}
function vectorSubtract(start2, end) {
  return [start2[0] - end[0], start2[1] - end[1]];
}
function vectorScale(v, scalar) {
  return vector(v[0] * scalar, v[1] * scalar);
}
var init_vector = __esm({
  "../math/vector.ts"() {
    "use strict";
    init_define_import_meta_env();
  }
});

// ../math/point.ts
function pointFrom(x, y) {
  return [x, y];
}
function pointFromArray(numberArray) {
  return numberArray.length === 2 ? pointFrom(numberArray[0], numberArray[1]) : void 0;
}
function pointFromPair(pair) {
  return pair;
}
function pointFromVector(v) {
  return v;
}
function isPoint(p) {
  return Array.isArray(p) && p.length === 2 && typeof p[0] === "number" && !isNaN(p[0]) && typeof p[1] === "number" && !isNaN(p[1]);
}
function pointsEqual(a, b) {
  const abs2 = Math.abs;
  return abs2(a[0] - b[0]) < PRECISION && abs2(a[1] - b[1]) < PRECISION;
}
function pointRotateRads([x, y], [cx, cy], angle) {
  return pointFrom(
    (x - cx) * Math.cos(angle) - (y - cy) * Math.sin(angle) + cx,
    (x - cx) * Math.sin(angle) + (y - cy) * Math.cos(angle) + cy
  );
}
function pointTranslate(p, v = [0, 0]) {
  return pointFrom(p[0] + v[0], p[1] + v[1]);
}
function pointCenter(a, b) {
  return pointFrom((a[0] + b[0]) / 2, (a[1] + b[1]) / 2);
}
function pointDistance(a, b) {
  return Math.hypot(b[0] - a[0], b[1] - a[1]);
}
function pointDistanceSq(a, b) {
  return Math.hypot(b[0] - a[0], b[1] - a[1]);
}
var pointScaleFromOrigin, isPointWithinBounds;
var init_point = __esm({
  "../math/point.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_angle();
    init_utils();
    init_vector();
    pointScaleFromOrigin = (p, mid, multiplier) => pointTranslate(mid, vectorScale(vectorFromPoint(p, mid), multiplier));
    isPointWithinBounds = (p, q, r) => {
      return q[0] <= Math.max(p[0], r[0]) && q[0] >= Math.min(p[0], r[0]) && q[1] <= Math.max(p[1], r[1]) && q[1] >= Math.min(p[1], r[1]);
    };
  }
});

// ../math/curve.ts
function curve(a, b, c, d) {
  return [a, b, c, d];
}
var init_curve = __esm({
  "../math/curve.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_point();
  }
});

// ../math/line.ts
var init_line = __esm({
  "../math/line.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_point();
  }
});

// ../math/segment.ts
function lineSegment(a, b) {
  return [a, b];
}
var segmentsIntersectAt, pointOnLineSegment, distanceToLineSegment;
var init_segment = __esm({
  "../math/segment.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_point();
    init_utils();
    init_vector();
    segmentsIntersectAt = (a, b) => {
      const a0 = vectorFromPoint(a[0]);
      const a1 = vectorFromPoint(a[1]);
      const b0 = vectorFromPoint(b[0]);
      const b1 = vectorFromPoint(b[1]);
      const r = vectorSubtract(a1, a0);
      const s = vectorSubtract(b1, b0);
      const denominator = vectorCross(r, s);
      if (denominator === 0) {
        return null;
      }
      const i = vectorSubtract(vectorFromPoint(b[0]), vectorFromPoint(a[0]));
      const u = vectorCross(i, r) / denominator;
      const t2 = vectorCross(i, s) / denominator;
      if (u === 0) {
        return null;
      }
      const p = vectorAdd(a0, vectorScale(r, t2));
      if (t2 >= 0 && t2 < 1 && u >= 0 && u < 1) {
        return pointFromVector(p);
      }
      return null;
    };
    pointOnLineSegment = (point2, line, threshold = PRECISION) => {
      const distance3 = distanceToLineSegment(point2, line);
      if (distance3 === 0) {
        return true;
      }
      return distance3 < threshold;
    };
    distanceToLineSegment = (point2, line) => {
      const [x, y] = point2;
      const [[x1, y1], [x2, y2]] = line;
      const A = x - x1;
      const B = y - y1;
      const C = x2 - x1;
      const D = y2 - y1;
      const dot2 = A * C + B * D;
      const len_sq = C * C + D * D;
      let param = -1;
      if (len_sq !== 0) {
        param = dot2 / len_sq;
      }
      let xx;
      let yy;
      if (param < 0) {
        xx = x1;
        yy = y1;
      } else if (param > 1) {
        xx = x2;
        yy = y2;
      } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
      }
      const dx = x - xx;
      const dy = y - yy;
      return Math.sqrt(dx * dx + dy * dy);
    };
  }
});

// ../math/polygon.ts
function polygon(...points) {
  return polygonClose(points);
}
function polygonFromPoints(points) {
  return polygonClose(points);
}
function polygonClose(polygon2) {
  return polygonIsClosed(polygon2) ? polygon2 : [...polygon2, polygon2[0]];
}
function polygonIsClosed(polygon2) {
  return pointsEqual(polygon2[0], polygon2[polygon2.length - 1]);
}
var polygonIncludesPoint, pointOnPolygon;
var init_polygon = __esm({
  "../math/polygon.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_point();
    init_segment();
    init_utils();
    polygonIncludesPoint = (point2, polygon2) => {
      const x = point2[0];
      const y = point2[1];
      let inside = false;
      for (let i = 0, j = polygon2.length - 1; i < polygon2.length; j = i++) {
        const xi = polygon2[i][0];
        const yi = polygon2[i][1];
        const xj = polygon2[j][0];
        const yj = polygon2[j][1];
        if ((yi > y && yj <= y || yi <= y && yj > y) && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {
          inside = !inside;
        }
      }
      return inside;
    };
    pointOnPolygon = (p, poly, threshold = PRECISION) => {
      let on = false;
      for (let i = 0, l = poly.length - 1; i < l; i++) {
        if (pointOnLineSegment(p, lineSegment(poly[i], poly[i + 1]), threshold)) {
          on = true;
          break;
        }
      }
      return on;
    };
  }
});

// ../math/range.ts
function rangeInclusive(start2, end) {
  return toBrandedType([start2, end]);
}
var rangesOverlap, rangeIntersection, rangeIncludesValue;
var init_range = __esm({
  "../math/range.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_utils2();
    rangesOverlap = ([a0, a1], [b0, b1]) => {
      if (a0 <= b0) {
        return a1 >= b0;
      }
      if (a0 >= b0) {
        return b1 >= a0;
      }
      return false;
    };
    rangeIntersection = ([a0, a1], [b0, b1]) => {
      const rangeStart = Math.max(a0, b0);
      const rangeEnd = Math.min(a1, b1);
      if (rangeStart <= rangeEnd) {
        return toBrandedType([rangeStart, rangeEnd]);
      }
      return null;
    };
    rangeIncludesValue = (value, [min, max]) => {
      return value >= min && value <= max;
    };
  }
});

// ../math/triangle.ts
function triangleIncludesPoint([a, b, c], p) {
  const triangleSign = (p1, p2, p3) => (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1]);
  const d1 = triangleSign(p, a, b);
  const d2 = triangleSign(p, b, c);
  const d3 = triangleSign(p, c, a);
  const has_neg = d1 < 0 || d2 < 0 || d3 < 0;
  const has_pos = d1 > 0 || d2 > 0 || d3 > 0;
  return !(has_neg && has_pos);
}
var init_triangle = __esm({
  "../math/triangle.ts"() {
    "use strict";
    init_define_import_meta_env();
  }
});

// ../math/types.ts
var init_types = __esm({
  "../math/types.ts"() {
    "use strict";
    init_define_import_meta_env();
  }
});

// ../math/index.ts
var init_math = __esm({
  "../math/index.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_arc();
    init_angle();
    init_curve();
    init_line();
    init_point();
    init_polygon();
    init_range();
    init_segment();
    init_triangle();
    init_types();
    init_vector();
    init_utils();
  }
});

// utils.ts
function invariant(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}
function addEventListener(target, type, listener, options) {
  if (!target) {
    return () => {
    };
  }
  target?.addEventListener?.(type, listener, options);
  return () => {
    target?.removeEventListener?.(type, listener, options);
  };
}
function getSvgPathFromStroke(points, closed = true) {
  const len = points.length;
  if (len < 4) {
    return ``;
  }
  let a = points[0];
  let b = points[1];
  const c = points[2];
  let result = `M${a[0].toFixed(2)},${a[1].toFixed(2)} Q${b[0].toFixed(
    2
  )},${b[1].toFixed(2)} ${average(b[0], c[0]).toFixed(2)},${average(
    b[1],
    c[1]
  ).toFixed(2)} T`;
  for (let i = 2, max = len - 1; i < max; i++) {
    a = points[i];
    b = points[i + 1];
    result += `${average(a[0], b[0]).toFixed(2)},${average(a[1], b[1]).toFixed(
      2
    )} `;
  }
  if (closed) {
    result += "Z";
  }
  return result;
}
var mockDateTime, getDateTime, capitalizeString, isToolIcon, isInputLike, isInteractive, isWritableElement, getFontFamilyString, getFontString, debounce, throttleRAF, easeOut, easeOutInterpolate, easeToValuesRAF, chunk, distance, updateActiveTool, getShortcutKey, viewportCoordsToSceneCoords, sceneCoordsToViewportCoords, getGlobalCSSVariable, RS_LTR_CHARS, RS_RTL_CHARS, RE_RTL_CHECK, isRTL, tupleToCoors, muteFSAbortError, findIndex, findLastIndex, isTransparent, resolvablePromise, getNearestScrollableContainer, focusNearestParent, preventUnload, bytesToHexString, getUpdatedTimestamp, arrayToMap, arrayToMapWithIndex, arrayToObject, arrayToList, isTestEnv, isDevEnv, wrapEvent, updateObject, getFrame, isPromiseLike, queryFocusableElements, _defaultIsShallowComparatorFallback, isShallowEqual, composeEventHandlers, assertNever, memoize, isMemberOf, cloneJSON, updateStable, normalizeEOL, toBrandedType, promiseTry, isAnyTrue;
var init_utils2 = __esm({
  "utils.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_math();
    init_colors();
    init_constants();
    mockDateTime = null;
    getDateTime = () => {
      if (mockDateTime) {
        return mockDateTime;
      }
      const date = /* @__PURE__ */ new Date();
      const year = date.getFullYear();
      const month = `${date.getMonth() + 1}`.padStart(2, "0");
      const day = `${date.getDate()}`.padStart(2, "0");
      const hr = `${date.getHours()}`.padStart(2, "0");
      const min = `${date.getMinutes()}`.padStart(2, "0");
      return `${year}-${month}-${day}-${hr}${min}`;
    };
    capitalizeString = (str) => str.charAt(0).toUpperCase() + str.slice(1);
    isToolIcon = (target) => target instanceof HTMLElement && target.className.includes("ToolIcon");
    isInputLike = (target) => target instanceof HTMLElement && target.dataset.type === "wysiwyg" || target instanceof HTMLBRElement || // newline in wysiwyg
    target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement || target instanceof HTMLSelectElement;
    isInteractive = (target) => {
      return isInputLike(target) || target instanceof Element && !!target.closest("label, button");
    };
    isWritableElement = (target) => target instanceof HTMLElement && target.dataset.type === "wysiwyg" || target instanceof HTMLBRElement || // newline in wysiwyg
    target instanceof HTMLTextAreaElement || target instanceof HTMLInputElement && (target.type === "text" || target.type === "number" || target.type === "password");
    getFontFamilyString = ({
      fontFamily
    }) => {
      for (const [fontFamilyString, id] of Object.entries(FONT_FAMILY)) {
        if (id === fontFamily) {
          return `${fontFamilyString}, ${WINDOWS_EMOJI_FALLBACK_FONT}`;
        }
      }
      return WINDOWS_EMOJI_FALLBACK_FONT;
    };
    getFontString = ({
      fontSize,
      fontFamily
    }) => {
      return `${fontSize}px ${getFontFamilyString({ fontFamily })}`;
    };
    debounce = (fn, timeout) => {
      let handle = 0;
      let lastArgs = null;
      const ret = (...args) => {
        lastArgs = args;
        clearTimeout(handle);
        handle = window.setTimeout(() => {
          lastArgs = null;
          fn(...args);
        }, timeout);
      };
      ret.flush = () => {
        clearTimeout(handle);
        if (lastArgs) {
          const _lastArgs = lastArgs;
          lastArgs = null;
          fn(..._lastArgs);
        }
      };
      ret.cancel = () => {
        lastArgs = null;
        clearTimeout(handle);
      };
      return ret;
    };
    throttleRAF = (fn, opts) => {
      let timerId = null;
      let lastArgs = null;
      let lastArgsTrailing = null;
      const scheduleFunc = (args) => {
        timerId = window.requestAnimationFrame(() => {
          timerId = null;
          fn(...args);
          lastArgs = null;
          if (lastArgsTrailing) {
            lastArgs = lastArgsTrailing;
            lastArgsTrailing = null;
            scheduleFunc(lastArgs);
          }
        });
      };
      const ret = (...args) => {
        if (define_import_meta_env_default.MODE === "test") {
          fn(...args);
          return;
        }
        lastArgs = args;
        if (timerId === null) {
          scheduleFunc(lastArgs);
        } else if (opts?.trailing) {
          lastArgsTrailing = args;
        }
      };
      ret.flush = () => {
        if (timerId !== null) {
          cancelAnimationFrame(timerId);
          timerId = null;
        }
        if (lastArgs) {
          fn(...lastArgsTrailing || lastArgs);
          lastArgs = lastArgsTrailing = null;
        }
      };
      ret.cancel = () => {
        lastArgs = lastArgsTrailing = null;
        if (timerId !== null) {
          cancelAnimationFrame(timerId);
          timerId = null;
        }
      };
      return ret;
    };
    easeOut = (k) => {
      return 1 - Math.pow(1 - k, 4);
    };
    easeOutInterpolate = (from3, to, progress) => {
      return (to - from3) * easeOut(progress) + from3;
    };
    easeToValuesRAF = ({
      fromValues,
      toValues,
      onStep,
      duration = 250,
      interpolateValue,
      onStart,
      onEnd,
      onCancel
    }) => {
      let canceled = false;
      let frameId = 0;
      let startTime;
      function step(timestamp) {
        if (canceled) {
          return;
        }
        if (startTime === void 0) {
          startTime = timestamp;
          onStart?.();
        }
        const elapsed = Math.min(timestamp - startTime, duration);
        const factor = easeOut(elapsed / duration);
        const newValues = {};
        Object.keys(fromValues).forEach((key) => {
          const _key = key;
          const result = (toValues[_key] - fromValues[_key]) * factor + fromValues[_key];
          newValues[_key] = result;
        });
        onStep(newValues);
        if (elapsed < duration) {
          const progress = elapsed / duration;
          const newValues2 = {};
          Object.keys(fromValues).forEach((key) => {
            const _key = key;
            const startValue = fromValues[_key];
            const endValue = toValues[_key];
            let result;
            result = interpolateValue ? interpolateValue(startValue, endValue, progress, _key) : easeOutInterpolate(startValue, endValue, progress);
            if (result == null) {
              result = easeOutInterpolate(startValue, endValue, progress);
            }
            newValues2[_key] = result;
          });
          onStep(newValues2);
          frameId = window.requestAnimationFrame(step);
        } else {
          onStep(toValues);
          onEnd?.();
        }
      }
      frameId = window.requestAnimationFrame(step);
      return () => {
        onCancel?.();
        canceled = true;
        window.cancelAnimationFrame(frameId);
      };
    };
    chunk = (array, size) => {
      if (!array.length || size < 1) {
        return [];
      }
      let index = 0;
      let resIndex = 0;
      const result = Array(Math.ceil(array.length / size));
      while (index < array.length) {
        result[resIndex++] = array.slice(index, index += size);
      }
      return result;
    };
    distance = (x, y) => Math.abs(x - y);
    updateActiveTool = (appState, data) => {
      if (data.type === "custom") {
        return {
          ...appState.activeTool,
          type: "custom",
          customType: data.customType,
          locked: data.locked ?? appState.activeTool.locked
        };
      }
      return {
        ...appState.activeTool,
        lastActiveTool: data.lastActiveToolBeforeEraser === void 0 ? appState.activeTool.lastActiveTool : data.lastActiveToolBeforeEraser,
        type: data.type,
        customType: null,
        locked: data.locked ?? appState.activeTool.locked
      };
    };
    getShortcutKey = (shortcut) => {
      shortcut = shortcut.replace(/\bAlt\b/i, "Alt").replace(/\bShift\b/i, "Shift").replace(/\b(Enter|Return)\b/i, "Enter");
      if (isDarwin) {
        return shortcut.replace(/\bCtrlOrCmd\b/gi, "Cmd").replace(/\bAlt\b/i, "Option");
      }
      return shortcut.replace(/\bCtrlOrCmd\b/gi, "Ctrl");
    };
    viewportCoordsToSceneCoords = ({ clientX, clientY }, {
      zoom,
      offsetLeft,
      offsetTop,
      scrollX,
      scrollY
    }) => {
      const x = (clientX - offsetLeft) / zoom.value - scrollX;
      const y = (clientY - offsetTop) / zoom.value - scrollY;
      return { x, y };
    };
    sceneCoordsToViewportCoords = ({ sceneX, sceneY }, {
      zoom,
      offsetLeft,
      offsetTop,
      scrollX,
      scrollY
    }) => {
      const x = (sceneX + scrollX) * zoom.value + offsetLeft;
      const y = (sceneY + scrollY) * zoom.value + offsetTop;
      return { x, y };
    };
    getGlobalCSSVariable = (name) => getComputedStyle(document.documentElement).getPropertyValue(`--${name}`);
    RS_LTR_CHARS = "A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u0300-\u0590\u0800-\u1FFF\u2C00-\uFB1C\uFDFE-\uFE6F\uFEFD-\uFFFF";
    RS_RTL_CHARS = "\u0591-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC";
    RE_RTL_CHECK = new RegExp(`^[^${RS_LTR_CHARS}]*[${RS_RTL_CHARS}]`);
    isRTL = (text) => RE_RTL_CHECK.test(text);
    tupleToCoors = (xyTuple) => {
      const [x, y] = xyTuple;
      return { x, y };
    };
    muteFSAbortError = (error) => {
      if (error?.name === "AbortError") {
        console.warn(error);
        return;
      }
      throw error;
    };
    findIndex = (array, cb, fromIndex = 0) => {
      if (fromIndex < 0) {
        fromIndex = array.length + fromIndex;
      }
      fromIndex = Math.min(array.length, Math.max(fromIndex, 0));
      let index = fromIndex - 1;
      while (++index < array.length) {
        if (cb(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    };
    findLastIndex = (array, cb, fromIndex = array.length - 1) => {
      if (fromIndex < 0) {
        fromIndex = array.length + fromIndex;
      }
      fromIndex = Math.min(array.length - 1, Math.max(fromIndex, 0));
      let index = fromIndex + 1;
      while (--index > -1) {
        if (cb(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    };
    isTransparent = (color) => {
      const isRGBTransparent = color.length === 5 && color.substr(4, 1) === "0";
      const isRRGGBBTransparent = color.length === 9 && color.substr(7, 2) === "00";
      return isRGBTransparent || isRRGGBBTransparent || color === COLOR_PALETTE.transparent;
    };
    resolvablePromise = () => {
      let resolve;
      let reject;
      const promise = new Promise((_resolve, _reject) => {
        resolve = _resolve;
        reject = _reject;
      });
      promise.resolve = resolve;
      promise.reject = reject;
      return promise;
    };
    getNearestScrollableContainer = (element) => {
      let parent = element.parentElement;
      while (parent) {
        if (parent === document.body) {
          return document;
        }
        const { overflowY } = window.getComputedStyle(parent);
        const hasScrollableContent = parent.scrollHeight > parent.clientHeight;
        if (hasScrollableContent && (overflowY === "auto" || overflowY === "scroll" || overflowY === "overlay")) {
          return parent;
        }
        parent = parent.parentElement;
      }
      return document;
    };
    focusNearestParent = (element) => {
      let parent = element.parentElement;
      while (parent) {
        if (parent.tabIndex > -1) {
          parent.focus();
          return;
        }
        parent = parent.parentElement;
      }
    };
    preventUnload = (event) => {
      event.preventDefault();
      event.returnValue = "";
    };
    bytesToHexString = (bytes) => {
      return Array.from(bytes).map((byte) => `0${byte.toString(16)}`.slice(-2)).join("");
    };
    getUpdatedTimestamp = () => isTestEnv() ? 1 : Date.now();
    arrayToMap = (items) => {
      if (items instanceof Map) {
        return items;
      }
      return items.reduce((acc, element) => {
        acc.set(typeof element === "string" ? element : element.id, element);
        return acc;
      }, /* @__PURE__ */ new Map());
    };
    arrayToMapWithIndex = (elements) => elements.reduce((acc, element, idx) => {
      acc.set(element.id, [element, idx]);
      return acc;
    }, /* @__PURE__ */ new Map());
    arrayToObject = (array, groupBy) => array.reduce((acc, value) => {
      acc[groupBy ? groupBy(value) : String(value)] = value;
      return acc;
    }, {});
    arrayToList = (array) => array.reduce((acc, curr, index) => {
      const node = { ...curr, prev: null, next: null };
      if (index !== 0) {
        const prevNode = acc[index - 1];
        node.prev = prevNode;
        prevNode.next = node;
        if (index === array.length - 1) {
          const firstNode = acc[0];
          node.next = firstNode;
          firstNode.prev = node;
        }
      }
      acc.push(node);
      return acc;
    }, []);
    isTestEnv = () => define_import_meta_env_default.MODE === "test";
    isDevEnv = () => define_import_meta_env_default.MODE === "development";
    wrapEvent = (name, nativeEvent) => {
      return new CustomEvent(name, {
        detail: {
          nativeEvent
        },
        cancelable: true
      });
    };
    updateObject = (obj, updates) => {
      let didChange = false;
      for (const key in updates) {
        const value = updates[key];
        if (typeof value !== "undefined") {
          if (obj[key] === value && // if object, always update because its attrs could have changed
          (typeof value !== "object" || value === null)) {
            continue;
          }
          didChange = true;
        }
      }
      if (!didChange) {
        return obj;
      }
      return {
        ...obj,
        ...updates
      };
    };
    getFrame = () => {
      try {
        return window.self === window.top ? "top" : "iframe";
      } catch (error) {
        return "iframe";
      }
    };
    isPromiseLike = (value) => {
      return !!value && typeof value === "object" && "then" in value && "catch" in value && "finally" in value;
    };
    queryFocusableElements = (container) => {
      const focusableElements = container?.querySelectorAll(
        "button, a, input, select, textarea, div[tabindex], label[tabindex]"
      );
      return focusableElements ? Array.from(focusableElements).filter(
        (element) => element.tabIndex > -1 && !element.disabled
      ) : [];
    };
    _defaultIsShallowComparatorFallback = (a, b) => {
      if (Array.isArray(a) && Array.isArray(b) && a.length === 0 && b.length === 0) {
        return true;
      }
      return a === b;
    };
    isShallowEqual = (objA, objB, comparators, debug = false) => {
      const aKeys = Object.keys(objA);
      const bKeys = Object.keys(objB);
      if (aKeys.length !== bKeys.length) {
        if (debug) {
          console.warn(
            `%cisShallowEqual: objects don't have same properties ->`,
            "color: #8B4000",
            objA,
            objB
          );
        }
        return false;
      }
      if (comparators && Array.isArray(comparators)) {
        for (const key of comparators) {
          const ret = objA[key] === objB[key] || _defaultIsShallowComparatorFallback(objA[key], objB[key]);
          if (!ret) {
            if (debug) {
              console.warn(
                `%cisShallowEqual: ${key} not equal ->`,
                "color: #8B4000",
                objA[key],
                objB[key]
              );
            }
            return false;
          }
        }
        return true;
      }
      return aKeys.every((key) => {
        const comparator = comparators?.[key];
        const ret = comparator ? comparator(objA[key], objB[key]) : objA[key] === objB[key] || _defaultIsShallowComparatorFallback(objA[key], objB[key]);
        if (!ret && debug) {
          console.warn(
            `%cisShallowEqual: ${key} not equal ->`,
            "color: #8B4000",
            objA[key],
            objB[key]
          );
        }
        return ret;
      });
    };
    composeEventHandlers = (originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) => {
      return function handleEvent(event) {
        originalEventHandler?.(event);
        if (!checkForDefaultPrevented || !event?.defaultPrevented) {
          return ourEventHandler?.(event);
        }
      };
    };
    assertNever = (value, message, softAssert) => {
      if (!message) {
        return value;
      }
      if (softAssert) {
        console.error(message);
        return value;
      }
      throw new Error(message);
    };
    memoize = (func) => {
      let lastArgs;
      let lastResult;
      const ret = function(opts) {
        const currentArgs = Object.entries(opts);
        if (lastArgs) {
          let argsAreEqual = true;
          for (const [key, value] of currentArgs) {
            if (lastArgs.get(key) !== value) {
              argsAreEqual = false;
              break;
            }
          }
          if (argsAreEqual) {
            return lastResult;
          }
        }
        const result = func(opts);
        lastArgs = new Map(currentArgs);
        lastResult = result;
        return result;
      };
      ret.clear = () => {
        lastArgs = void 0;
        lastResult = void 0;
      };
      return ret;
    };
    isMemberOf = (collection, value) => {
      return collection instanceof Set || collection instanceof Map ? collection.has(value) : "includes" in collection ? collection.includes(value) : collection.hasOwnProperty(value);
    };
    cloneJSON = (obj) => JSON.parse(JSON.stringify(obj));
    updateStable = (prevValue, nextValue) => {
      if (isShallowEqual(prevValue, nextValue)) {
        return prevValue;
      }
      return nextValue;
    };
    normalizeEOL = (str) => {
      return str.replace(/\r?\n|\r/g, "\n");
    };
    toBrandedType = (value) => {
      return value;
    };
    promiseTry = async (fn, ...args) => {
      return new Promise((resolve) => {
        resolve(fn(...args));
      });
    };
    isAnyTrue = (...args) => Math.max(...args.map((arg) => arg ? 1 : 0)) > 0;
  }
});

// element/typeChecks.ts
var isInitializedImageElement, isImageElement, isEmbeddableElement, isIframeElement, isIframeLikeElement, isTextElement, isFrameElement, isMagicFrameElement, isFrameLikeElement, isFreeDrawElement, isFreeDrawElementType, isLinearElement, isArrowElement, isElbowArrow, isLinearElementType, isBindingElement, isBindingElementType, isBindableElement, isRectanguloidElement, isRectangularElement, isTextBindableContainer, isExcalidrawElement, isFlowchartNodeElement, hasBoundTextElement, isBoundToContainer, isUsingAdaptiveRadius, isUsingProportionalRadius, canApplyRoundnessTypeToElement, getDefaultRoundnessTypeForElement, isFixedPointBinding;
var init_typeChecks = __esm({
  "element/typeChecks.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_utils2();
    isInitializedImageElement = (element) => {
      return !!element && element.type === "image" && !!element.fileId;
    };
    isImageElement = (element) => {
      return !!element && element.type === "image";
    };
    isEmbeddableElement = (element) => {
      return !!element && element.type === "embeddable";
    };
    isIframeElement = (element) => {
      return !!element && element.type === "iframe";
    };
    isIframeLikeElement = (element) => {
      return !!element && (element.type === "iframe" || element.type === "embeddable");
    };
    isTextElement = (element) => {
      return element != null && element.type === "text";
    };
    isFrameElement = (element) => {
      return element != null && element.type === "frame";
    };
    isMagicFrameElement = (element) => {
      return element != null && element.type === "magicframe";
    };
    isFrameLikeElement = (element) => {
      return element != null && (element.type === "frame" || element.type === "magicframe");
    };
    isFreeDrawElement = (element) => {
      return element != null && isFreeDrawElementType(element.type);
    };
    isFreeDrawElementType = (elementType) => {
      return elementType === "freedraw";
    };
    isLinearElement = (element) => {
      return element != null && isLinearElementType(element.type);
    };
    isArrowElement = (element) => {
      return element != null && element.type === "arrow";
    };
    isElbowArrow = (element) => {
      return isArrowElement(element) && element.elbowed;
    };
    isLinearElementType = (elementType) => {
      return elementType === "arrow" || elementType === "line";
    };
    isBindingElement = (element, includeLocked = true) => {
      return element != null && (!element.locked || includeLocked === true) && isBindingElementType(element.type);
    };
    isBindingElementType = (elementType) => {
      return elementType === "arrow";
    };
    isBindableElement = (element, includeLocked = true) => {
      return element != null && (!element.locked || includeLocked === true) && (element.type === "rectangle" || element.type === "diamond" || element.type === "ellipse" || element.type === "image" || element.type === "iframe" || element.type === "embeddable" || element.type === "frame" || element.type === "magicframe" || element.type === "text" && !element.containerId);
    };
    isRectanguloidElement = (element) => {
      return element != null && (element.type === "rectangle" || element.type === "diamond" || element.type === "image" || element.type === "iframe" || element.type === "embeddable" || element.type === "frame" || element.type === "magicframe" || element.type === "text" && !element.containerId);
    };
    isRectangularElement = (element) => {
      return element != null && (element.type === "rectangle" || element.type === "image" || element.type === "text" || element.type === "iframe" || element.type === "embeddable" || element.type === "frame" || element.type === "magicframe" || element.type === "freedraw");
    };
    isTextBindableContainer = (element, includeLocked = true) => {
      return element != null && (!element.locked || includeLocked === true) && (element.type === "rectangle" || element.type === "diamond" || element.type === "ellipse" || isArrowElement(element));
    };
    isExcalidrawElement = (element) => {
      const type = element?.type;
      if (!type) {
        return false;
      }
      switch (type) {
        case "text":
        case "diamond":
        case "rectangle":
        case "iframe":
        case "embeddable":
        case "ellipse":
        case "arrow":
        case "freedraw":
        case "line":
        case "frame":
        case "magicframe":
        case "image":
        case "selection": {
          return true;
        }
        default: {
          assertNever(type, null);
          return false;
        }
      }
    };
    isFlowchartNodeElement = (element) => {
      return element.type === "rectangle" || element.type === "ellipse" || element.type === "diamond";
    };
    hasBoundTextElement = (element) => {
      return isTextBindableContainer(element) && !!element.boundElements?.some(({ type }) => type === "text");
    };
    isBoundToContainer = (element) => {
      return element !== null && "containerId" in element && element.containerId !== null && isTextElement(element);
    };
    isUsingAdaptiveRadius = (type) => type === "rectangle" || type === "embeddable" || type === "iframe" || type === "image";
    isUsingProportionalRadius = (type) => type === "line" || type === "arrow" || type === "diamond";
    canApplyRoundnessTypeToElement = (roundnessType, element) => {
      if ((roundnessType === ROUNDNESS.ADAPTIVE_RADIUS || // if legacy roundness, it can be applied to elements that currently
      // use adaptive radius
      roundnessType === ROUNDNESS.LEGACY) && isUsingAdaptiveRadius(element.type)) {
        return true;
      }
      if (roundnessType === ROUNDNESS.PROPORTIONAL_RADIUS && isUsingProportionalRadius(element.type)) {
        return true;
      }
      return false;
    };
    getDefaultRoundnessTypeForElement = (element) => {
      if (isUsingProportionalRadius(element.type)) {
        return {
          type: ROUNDNESS.PROPORTIONAL_RADIUS
        };
      }
      if (isUsingAdaptiveRadius(element.type)) {
        return {
          type: ROUNDNESS.ADAPTIVE_RADIUS
        };
      }
      return null;
    };
    isFixedPointBinding = (binding) => {
      return Object.hasOwn(binding, "fixedPoint") && binding.fixedPoint != null;
    };
  }
});

// random.ts
import { Random } from "roughjs/bin/math";
import { nanoid } from "nanoid";
var random, testIdBase, randomInteger, randomId;
var init_random = __esm({
  "random.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_utils2();
    random = new Random(Date.now());
    testIdBase = 0;
    randomInteger = () => Math.floor(random.next() * 2 ** 31);
    randomId = () => isTestEnv() ? `id${testIdBase++}` : nanoid();
  }
});

// errors.ts
var CanvasError, AbortError, ImageSceneDataError, InvalidFractionalIndexError;
var init_errors = __esm({
  "errors.ts"() {
    "use strict";
    init_define_import_meta_env();
    CanvasError = class extends Error {
      constructor(message = "Couldn't export canvas.", name = "CANVAS_ERROR") {
        super();
        this.name = name;
        this.message = message;
      }
    };
    AbortError = class extends DOMException {
      constructor(message = "Request Aborted") {
        super(message, "AbortError");
      }
    };
    ImageSceneDataError = class extends Error {
      code;
      constructor(message = "Image Scene Data Error", code = "IMAGE_SCENE_DATA_ERROR") {
        super(message);
        this.name = "EncodingError";
        this.code = code;
      }
    };
    InvalidFractionalIndexError = class extends Error {
      code = "ELEMENT_HAS_INVALID_INDEX";
    };
  }
});

// appState.ts
var defaultExportScale, getDefaultAppState, APP_STATE_STORAGE_CONF, _clearAppStateForStorage, cleanAppStateForExport, clearAppStateForDatabase, isEraserActive, isHandToolActive;
var init_appState = __esm({
  "appState.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_colors();
    init_constants();
    defaultExportScale = EXPORT_SCALES.includes(devicePixelRatio) ? devicePixelRatio : 1;
    getDefaultAppState = () => {
      return {
        showWelcomeScreen: false,
        theme: THEME.LIGHT,
        collaborators: /* @__PURE__ */ new Map(),
        currentChartType: "bar",
        currentItemBackgroundColor: DEFAULT_ELEMENT_PROPS.backgroundColor,
        currentItemEndArrowhead: "arrow",
        currentItemFillStyle: DEFAULT_ELEMENT_PROPS.fillStyle,
        currentItemFontFamily: DEFAULT_FONT_FAMILY,
        currentItemFontSize: DEFAULT_FONT_SIZE,
        currentItemOpacity: DEFAULT_ELEMENT_PROPS.opacity,
        currentItemRoughness: DEFAULT_ELEMENT_PROPS.roughness,
        currentItemStartArrowhead: null,
        currentItemStrokeColor: DEFAULT_ELEMENT_PROPS.strokeColor,
        currentItemRoundness: "round",
        currentItemArrowType: ARROW_TYPE.round,
        currentItemStrokeStyle: DEFAULT_ELEMENT_PROPS.strokeStyle,
        currentItemStrokeWidth: DEFAULT_ELEMENT_PROPS.strokeWidth,
        currentItemTextAlign: DEFAULT_TEXT_ALIGN,
        currentHoveredFontFamily: null,
        cursorButton: "up",
        activeEmbeddable: null,
        newElement: null,
        editingTextElement: null,
        editingGroupId: null,
        editingLinearElement: null,
        activeTool: {
          type: "selection",
          customType: null,
          locked: DEFAULT_ELEMENT_PROPS.locked,
          lastActiveTool: null
        },
        penMode: false,
        penDetected: false,
        errorMessage: null,
        exportBackground: true,
        exportScale: defaultExportScale,
        exportEmbedScene: false,
        exportWithDarkMode: false,
        fileHandle: null,
        gridSize: DEFAULT_GRID_SIZE,
        gridStep: DEFAULT_GRID_STEP,
        gridModeEnabled: false,
        isBindingEnabled: true,
        defaultSidebarDockedPreference: false,
        isLoading: false,
        isResizing: false,
        isRotating: false,
        lastPointerDownWith: "mouse",
        multiElement: null,
        name: null,
        contextMenu: null,
        openMenu: null,
        openPopup: null,
        openSidebar: null,
        openDialog: null,
        pasteDialog: { shown: false, data: null },
        previousSelectedElementIds: {},
        resizingElement: null,
        scrolledOutside: false,
        scrollX: 0,
        scrollY: 0,
        selectedElementIds: {},
        selectedGroupIds: {},
        selectedElementsAreBeingDragged: false,
        selectionElement: null,
        shouldCacheIgnoreZoom: false,
        stats: {
          open: false,
          panels: STATS_PANELS.generalStats | STATS_PANELS.elementProperties
        },
        startBoundElement: null,
        suggestedBindings: [],
        frameRendering: { enabled: true, clip: true, name: true, outline: true },
        frameToHighlight: null,
        editingFrame: null,
        elementsToHighlight: null,
        toast: null,
        viewBackgroundColor: COLOR_PALETTE.white,
        zenModeEnabled: false,
        zoom: {
          value: 1
        },
        viewModeEnabled: false,
        pendingImageElementId: null,
        showHyperlinkPopup: false,
        selectedLinearElement: null,
        snapLines: [],
        originSnapOffset: {
          x: 0,
          y: 0
        },
        objectsSnapModeEnabled: false,
        userToFollow: null,
        followedBy: /* @__PURE__ */ new Set(),
        searchMatches: []
      };
    };
    APP_STATE_STORAGE_CONF = /* @__PURE__ */ ((config) => config)({
      showWelcomeScreen: { browser: true, export: false, server: false },
      theme: { browser: true, export: false, server: false },
      collaborators: { browser: false, export: false, server: false },
      currentChartType: { browser: true, export: false, server: false },
      currentItemBackgroundColor: { browser: true, export: false, server: false },
      currentItemEndArrowhead: { browser: true, export: false, server: false },
      currentItemFillStyle: { browser: true, export: false, server: false },
      currentItemFontFamily: { browser: true, export: false, server: false },
      currentItemFontSize: { browser: true, export: false, server: false },
      currentItemRoundness: {
        browser: true,
        export: false,
        server: false
      },
      currentItemArrowType: {
        browser: true,
        export: false,
        server: false
      },
      currentItemOpacity: { browser: true, export: false, server: false },
      currentItemRoughness: { browser: true, export: false, server: false },
      currentItemStartArrowhead: { browser: true, export: false, server: false },
      currentItemStrokeColor: { browser: true, export: false, server: false },
      currentItemStrokeStyle: { browser: true, export: false, server: false },
      currentItemStrokeWidth: { browser: true, export: false, server: false },
      currentItemTextAlign: { browser: true, export: false, server: false },
      currentHoveredFontFamily: { browser: false, export: false, server: false },
      cursorButton: { browser: true, export: false, server: false },
      activeEmbeddable: { browser: false, export: false, server: false },
      newElement: { browser: false, export: false, server: false },
      editingTextElement: { browser: false, export: false, server: false },
      editingGroupId: { browser: true, export: false, server: false },
      editingLinearElement: { browser: false, export: false, server: false },
      activeTool: { browser: true, export: false, server: false },
      penMode: { browser: true, export: false, server: false },
      penDetected: { browser: true, export: false, server: false },
      errorMessage: { browser: false, export: false, server: false },
      exportBackground: { browser: true, export: false, server: false },
      exportEmbedScene: { browser: true, export: false, server: false },
      exportScale: { browser: true, export: false, server: false },
      exportWithDarkMode: { browser: true, export: false, server: false },
      fileHandle: { browser: false, export: false, server: false },
      gridSize: { browser: true, export: true, server: true },
      gridStep: { browser: true, export: true, server: true },
      gridModeEnabled: { browser: true, export: true, server: true },
      height: { browser: false, export: false, server: false },
      isBindingEnabled: { browser: false, export: false, server: false },
      defaultSidebarDockedPreference: {
        browser: true,
        export: false,
        server: false
      },
      isLoading: { browser: false, export: false, server: false },
      isResizing: { browser: false, export: false, server: false },
      isRotating: { browser: false, export: false, server: false },
      lastPointerDownWith: { browser: true, export: false, server: false },
      multiElement: { browser: false, export: false, server: false },
      name: { browser: true, export: false, server: false },
      offsetLeft: { browser: false, export: false, server: false },
      offsetTop: { browser: false, export: false, server: false },
      contextMenu: { browser: false, export: false, server: false },
      openMenu: { browser: true, export: false, server: false },
      openPopup: { browser: false, export: false, server: false },
      openSidebar: { browser: true, export: false, server: false },
      openDialog: { browser: false, export: false, server: false },
      pasteDialog: { browser: false, export: false, server: false },
      previousSelectedElementIds: { browser: true, export: false, server: false },
      resizingElement: { browser: false, export: false, server: false },
      scrolledOutside: { browser: true, export: false, server: false },
      scrollX: { browser: true, export: false, server: false },
      scrollY: { browser: true, export: false, server: false },
      selectedElementIds: { browser: true, export: false, server: false },
      selectedGroupIds: { browser: true, export: false, server: false },
      selectedElementsAreBeingDragged: {
        browser: false,
        export: false,
        server: false
      },
      selectionElement: { browser: false, export: false, server: false },
      shouldCacheIgnoreZoom: { browser: true, export: false, server: false },
      stats: { browser: true, export: false, server: false },
      startBoundElement: { browser: false, export: false, server: false },
      suggestedBindings: { browser: false, export: false, server: false },
      frameRendering: { browser: false, export: false, server: false },
      frameToHighlight: { browser: false, export: false, server: false },
      editingFrame: { browser: false, export: false, server: false },
      elementsToHighlight: { browser: false, export: false, server: false },
      toast: { browser: false, export: false, server: false },
      viewBackgroundColor: { browser: true, export: true, server: true },
      width: { browser: false, export: false, server: false },
      zenModeEnabled: { browser: true, export: false, server: false },
      zoom: { browser: true, export: false, server: false },
      viewModeEnabled: { browser: false, export: false, server: false },
      pendingImageElementId: { browser: false, export: false, server: false },
      showHyperlinkPopup: { browser: false, export: false, server: false },
      selectedLinearElement: { browser: true, export: false, server: false },
      snapLines: { browser: false, export: false, server: false },
      originSnapOffset: { browser: false, export: false, server: false },
      objectsSnapModeEnabled: { browser: true, export: false, server: false },
      userToFollow: { browser: false, export: false, server: false },
      followedBy: { browser: false, export: false, server: false },
      searchMatches: { browser: false, export: false, server: false }
    });
    _clearAppStateForStorage = (appState, exportType) => {
      const stateForExport = {};
      for (const key of Object.keys(appState)) {
        const propConfig = APP_STATE_STORAGE_CONF[key];
        if (propConfig?.[exportType]) {
          const nextValue = appState[key];
          stateForExport[key] = nextValue;
        }
      }
      return stateForExport;
    };
    cleanAppStateForExport = (appState) => {
      return _clearAppStateForStorage(appState, "export");
    };
    clearAppStateForDatabase = (appState) => {
      return _clearAppStateForStorage(appState, "server");
    };
    isEraserActive = ({
      activeTool
    }) => activeTool.type === "eraser";
    isHandToolActive = ({
      activeTool
    }) => {
      return activeTool.type === "hand";
    };
  }
});

// groups.ts
var selectGroup, selectGroupsForSelectedElements, isSelectedViaGroup, getSelectedGroupForElement, getSelectedGroupIds, selectGroupsFromGivenElements, editGroupForSelectedElement, isElementInGroup, getElementsInGroup, getSelectedGroupIdForElement, getNewGroupIdsForDuplication, addToGroup, removeFromSelectedGroups, getMaximumGroups, getNonDeletedGroupIds, elementsAreInSameGroup, isInGroup;
var init_groups = __esm({
  "groups.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_scene();
    init_textElement();
    init_selection();
    selectGroup = (groupId, appState, elements) => {
      const elementsInGroup = elements.reduce(
        (acc, element) => {
          if (element.groupIds.includes(groupId)) {
            acc[element.id] = true;
          }
          return acc;
        },
        {}
      );
      if (Object.keys(elementsInGroup).length < 2) {
        if (appState.selectedGroupIds[groupId] || appState.editingGroupId === groupId) {
          return {
            selectedElementIds: appState.selectedElementIds,
            selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: false },
            editingGroupId: null
          };
        }
        return appState;
      }
      return {
        editingGroupId: appState.editingGroupId,
        selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: true },
        selectedElementIds: {
          ...appState.selectedElementIds,
          ...elementsInGroup
        }
      };
    };
    selectGroupsForSelectedElements = function() {
      let lastSelectedElements = null;
      let lastElements = null;
      let lastReturnValue = null;
      const _selectGroups = (selectedElements, elements, appState, prevAppState) => {
        if (lastReturnValue !== void 0 && elements === lastElements && selectedElements === lastSelectedElements && appState.editingGroupId === lastReturnValue?.editingGroupId) {
          return lastReturnValue;
        }
        const selectedGroupIds = {};
        for (const selectedElement of selectedElements) {
          let groupIds = selectedElement.groupIds;
          if (appState.editingGroupId) {
            const indexOfEditingGroup = groupIds.indexOf(appState.editingGroupId);
            if (indexOfEditingGroup > -1) {
              groupIds = groupIds.slice(0, indexOfEditingGroup);
            }
          }
          if (groupIds.length > 0) {
            const lastSelectedGroup = groupIds[groupIds.length - 1];
            selectedGroupIds[lastSelectedGroup] = true;
          }
        }
        const groupElementsIndex = {};
        const selectedElementIdsInGroups = elements.reduce(
          (acc, element) => {
            const groupId = element.groupIds.find((id) => selectedGroupIds[id]);
            if (groupId) {
              acc[element.id] = true;
              if (!Array.isArray(groupElementsIndex[groupId])) {
                groupElementsIndex[groupId] = [element.id];
              } else {
                groupElementsIndex[groupId].push(element.id);
              }
            }
            return acc;
          },
          {}
        );
        for (const groupId of Object.keys(groupElementsIndex)) {
          if (groupElementsIndex[groupId].length < 2) {
            if (selectedGroupIds[groupId]) {
              selectedGroupIds[groupId] = false;
            }
          }
        }
        lastElements = elements;
        lastSelectedElements = selectedElements;
        lastReturnValue = {
          editingGroupId: appState.editingGroupId,
          selectedGroupIds,
          selectedElementIds: makeNextSelectedElementIds(
            {
              ...appState.selectedElementIds,
              ...selectedElementIdsInGroups
            },
            prevAppState
          )
        };
        return lastReturnValue;
      };
      const selectGroupsForSelectedElements2 = (appState, elements, prevAppState, app) => {
        const selectedElements = app ? app.scene.getSelectedElements({
          selectedElementIds: appState.selectedElementIds,
          // supplying elements explicitly in case we're passed non-state elements
          elements
        }) : getSelectedElements(elements, appState);
        if (!selectedElements.length) {
          return {
            selectedGroupIds: {},
            editingGroupId: null,
            selectedElementIds: makeNextSelectedElementIds(
              appState.selectedElementIds,
              prevAppState
            )
          };
        }
        return _selectGroups(selectedElements, elements, appState, prevAppState);
      };
      selectGroupsForSelectedElements2.clearCache = () => {
        lastElements = null;
        lastSelectedElements = null;
        lastReturnValue = null;
      };
      return selectGroupsForSelectedElements2;
    }();
    isSelectedViaGroup = (appState, element) => getSelectedGroupForElement(appState, element) != null;
    getSelectedGroupForElement = (appState, element) => element.groupIds.filter((groupId) => groupId !== appState.editingGroupId).find((groupId) => appState.selectedGroupIds[groupId]);
    getSelectedGroupIds = (appState) => Object.entries(appState.selectedGroupIds).filter(([groupId, isSelected]) => isSelected).map(([groupId, isSelected]) => groupId);
    selectGroupsFromGivenElements = (elements, appState) => {
      let nextAppState = {
        ...appState,
        selectedGroupIds: {}
      };
      for (const element of elements) {
        let groupIds = element.groupIds;
        if (appState.editingGroupId) {
          const indexOfEditingGroup = groupIds.indexOf(appState.editingGroupId);
          if (indexOfEditingGroup > -1) {
            groupIds = groupIds.slice(0, indexOfEditingGroup);
          }
        }
        if (groupIds.length > 0) {
          const groupId = groupIds[groupIds.length - 1];
          nextAppState = {
            ...nextAppState,
            ...selectGroup(groupId, nextAppState, elements)
          };
        }
      }
      return nextAppState.selectedGroupIds;
    };
    editGroupForSelectedElement = (appState, element) => {
      return {
        ...appState,
        editingGroupId: element.groupIds.length ? element.groupIds[0] : null,
        selectedGroupIds: {},
        selectedElementIds: {
          [element.id]: true
        }
      };
    };
    isElementInGroup = (element, groupId) => element.groupIds.includes(groupId);
    getElementsInGroup = (elements, groupId) => {
      const elementsInGroup = [];
      for (const element of elements.values()) {
        if (isElementInGroup(element, groupId)) {
          elementsInGroup.push(element);
        }
      }
      return elementsInGroup;
    };
    getSelectedGroupIdForElement = (element, selectedGroupIds) => element.groupIds.find((groupId) => selectedGroupIds[groupId]);
    getNewGroupIdsForDuplication = (groupIds, editingGroupId, mapper) => {
      const copy = [...groupIds];
      const positionOfEditingGroupId = editingGroupId ? groupIds.indexOf(editingGroupId) : -1;
      const endIndex = positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;
      for (let index = 0; index < endIndex; index++) {
        copy[index] = mapper(copy[index]);
      }
      return copy;
    };
    addToGroup = (prevGroupIds, newGroupId, editingGroupId) => {
      const groupIds = [...prevGroupIds];
      const positionOfEditingGroupId = editingGroupId ? groupIds.indexOf(editingGroupId) : -1;
      const positionToInsert = positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;
      groupIds.splice(positionToInsert, 0, newGroupId);
      return groupIds;
    };
    removeFromSelectedGroups = (groupIds, selectedGroupIds) => groupIds.filter((groupId) => !selectedGroupIds[groupId]);
    getMaximumGroups = (elements, elementsMap) => {
      const groups = /* @__PURE__ */ new Map();
      elements.forEach((element) => {
        const groupId = element.groupIds.length === 0 ? element.id : element.groupIds[element.groupIds.length - 1];
        const currentGroupMembers = groups.get(groupId) || [];
        const boundTextElement = getBoundTextElement(element, elementsMap);
        if (boundTextElement) {
          currentGroupMembers.push(boundTextElement);
        }
        groups.set(groupId, [...currentGroupMembers, element]);
      });
      return Array.from(groups.values());
    };
    getNonDeletedGroupIds = (elements) => {
      const nonDeletedGroupIds = /* @__PURE__ */ new Set();
      for (const [, element] of elements) {
        if (element.isDeleted) {
          continue;
        }
        for (const groupId of element.groupIds ?? []) {
          nonDeletedGroupIds.add(groupId);
        }
      }
      return nonDeletedGroupIds;
    };
    elementsAreInSameGroup = (elements) => {
      const allGroups = elements.flatMap((element) => element.groupIds);
      const groupCount = /* @__PURE__ */ new Map();
      let maxGroup = 0;
      for (const group of allGroups) {
        groupCount.set(group, (groupCount.get(group) ?? 0) + 1);
        if (groupCount.get(group) > maxGroup) {
          maxGroup = groupCount.get(group);
        }
      }
      return maxGroup === elements.length;
    };
    isInGroup = (element) => {
      return element.groupIds.length > 0;
    };
  }
});

// data/url.ts
import { sanitizeUrl } from "@braintree/sanitize-url";
var sanitizeHTMLAttribute, normalizeLink, isLocalLink, toValidURL;
var init_url = __esm({
  "data/url.ts"() {
    "use strict";
    init_define_import_meta_env();
    sanitizeHTMLAttribute = (html) => {
      return html.replace(/"/g, "&quot;");
    };
    normalizeLink = (link) => {
      link = link.trim();
      if (!link) {
        return link;
      }
      return sanitizeUrl(sanitizeHTMLAttribute(link));
    };
    isLocalLink = (link) => {
      return !!(link?.includes(location.origin) || link?.startsWith("/"));
    };
    toValidURL = (link) => {
      link = normalizeLink(link);
      if (link.startsWith("/")) {
        return `${location.origin}${link}`;
      }
      try {
        new URL(link);
      } catch {
        return "about:blank";
      }
      return link;
    };
  }
});

// actions/register.ts
var actions, register;
var init_register = __esm({
  "actions/register.ts"() {
    "use strict";
    init_define_import_meta_env();
    actions = [];
    register = (action) => {
      actions = actions.concat(action);
      return action;
    };
  }
});

// cursor.ts
import OpenColor from "open-color";
var laserPointerCursorSVG_tag, laserPointerCursorBackgroundSVG, laserPointerCursorIconSVG, laserPointerCursorDataURL_lightMode, laserPointerCursorDataURL_darkMode, resetCursor, setCursor, eraserCanvasCache, previewDataURL, setEraserCursor, setCursorForShape;
var init_cursor = __esm({
  "cursor.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_appState();
    laserPointerCursorSVG_tag = `<svg viewBox="0 0 24 24" stroke-width="1" width="28" height="28" xmlns="http://www.w3.org/2000/svg">`;
    laserPointerCursorBackgroundSVG = `<path d="M6.164 11.755a5.314 5.314 0 0 1-4.932-5.298 5.314 5.314 0 0 1 5.311-5.311 5.314 5.314 0 0 1 5.307 5.113l8.773 8.773a3.322 3.322 0 0 1 0 4.696l-.895.895a3.322 3.322 0 0 1-4.696 0l-8.868-8.868Z" style="fill:#fff"/>`;
    laserPointerCursorIconSVG = `<path stroke="#1b1b1f" fill="#fff" d="m7.868 11.113 7.773 7.774a2.359 2.359 0 0 0 1.667.691 2.368 2.368 0 0 0 2.357-2.358c0-.625-.248-1.225-.69-1.667L11.201 7.78 9.558 9.469l-1.69 1.643v.001Zm10.273 3.606-3.333 3.333m-3.25-6.583 2 2m-7-7 3 3M3.664 3.625l1 1M2.529 6.922l1.407-.144m5.735-2.932-1.118.866M4.285 9.823l.758-1.194m1.863-6.207-.13 1.408"/>`;
    laserPointerCursorDataURL_lightMode = `data:${MIME_TYPES.svg},${encodeURIComponent(
      `${laserPointerCursorSVG_tag}${laserPointerCursorIconSVG}</svg>`
    )}`;
    laserPointerCursorDataURL_darkMode = `data:${MIME_TYPES.svg},${encodeURIComponent(
      `${laserPointerCursorSVG_tag}${laserPointerCursorBackgroundSVG}${laserPointerCursorIconSVG}</svg>`
    )}`;
    resetCursor = (interactiveCanvas) => {
      if (interactiveCanvas) {
        interactiveCanvas.style.cursor = "";
      }
    };
    setCursor = (interactiveCanvas, cursor) => {
      if (interactiveCanvas) {
        interactiveCanvas.style.cursor = cursor;
      }
    };
    setEraserCursor = (interactiveCanvas, theme) => {
      const cursorImageSizePx = 20;
      const drawCanvas = () => {
        const isDarkTheme = theme === THEME.DARK;
        eraserCanvasCache = document.createElement("canvas");
        eraserCanvasCache.theme = theme;
        eraserCanvasCache.height = cursorImageSizePx;
        eraserCanvasCache.width = cursorImageSizePx;
        const context = eraserCanvasCache.getContext("2d");
        context.lineWidth = 1;
        context.beginPath();
        context.arc(
          eraserCanvasCache.width / 2,
          eraserCanvasCache.height / 2,
          5,
          0,
          2 * Math.PI
        );
        context.fillStyle = isDarkTheme ? OpenColor.black : OpenColor.white;
        context.fill();
        context.strokeStyle = isDarkTheme ? OpenColor.white : OpenColor.black;
        context.stroke();
        previewDataURL = eraserCanvasCache.toDataURL(MIME_TYPES.svg);
      };
      if (!eraserCanvasCache || eraserCanvasCache.theme !== theme) {
        drawCanvas();
      }
      setCursor(
        interactiveCanvas,
        `url(${previewDataURL}) ${cursorImageSizePx / 2} ${cursorImageSizePx / 2}, auto`
      );
    };
    setCursorForShape = (interactiveCanvas, appState) => {
      if (!interactiveCanvas) {
        return;
      }
      if (appState.activeTool.type === "selection") {
        resetCursor(interactiveCanvas);
      } else if (isHandToolActive(appState)) {
        interactiveCanvas.style.cursor = CURSOR_TYPE.GRAB;
      } else if (isEraserActive(appState)) {
        setEraserCursor(interactiveCanvas, appState.theme);
      } else if (appState.activeTool.type === "laser") {
        const url = appState.theme === THEME.LIGHT ? laserPointerCursorDataURL_lightMode : laserPointerCursorDataURL_darkMode;
        interactiveCanvas.style.cursor = `url(${url}), auto`;
      } else if (!["image", "custom"].includes(appState.activeTool.type)) {
        interactiveCanvas.style.cursor = CURSOR_TYPE.CROSSHAIR;
      } else if (appState.activeTool.type !== "image") {
        interactiveCanvas.style.cursor = CURSOR_TYPE.AUTO;
      }
    };
  }
});

// scene/ShapeCache.ts
import { RoughGenerator } from "roughjs/bin/generator";
var ShapeCache;
var init_ShapeCache = __esm({
  "scene/ShapeCache.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_renderElement();
    init_Shape();
    init_colors();
    ShapeCache = class _ShapeCache {
      static rg = new RoughGenerator();
      static cache = /* @__PURE__ */ new WeakMap();
      /**
       * Retrieves shape from cache if available. Use this only if shape
       * is optional and you have a fallback in case it's not cached.
       */
      static get = (element) => {
        return _ShapeCache.cache.get(
          element
        );
      };
      static set = (element, shape) => _ShapeCache.cache.set(element, shape);
      static delete = (element) => _ShapeCache.cache.delete(element);
      static destroy = () => {
        _ShapeCache.cache = /* @__PURE__ */ new WeakMap();
      };
      /**
       * Generates & caches shape for element if not already cached, otherwise
       * returns cached shape.
       */
      static generateElementShape = (element, renderConfig) => {
        const cachedShape = renderConfig?.isExporting ? void 0 : _ShapeCache.get(element);
        if (cachedShape !== void 0) {
          return cachedShape;
        }
        elementWithCanvasCache.delete(element);
        const shape = _generateElementShape(
          element,
          _ShapeCache.rg,
          renderConfig || {
            isExporting: false,
            canvasBackgroundColor: COLOR_PALETTE.white,
            embedsValidationStatus: null
          }
        );
        _ShapeCache.cache.set(element, shape);
        return shape;
      };
    };
  }
});

// components/icons.tsx
import React3 from "react";
import oc2 from "open-color";
import clsx2 from "clsx";
import { Fragment, jsx as jsx4, jsxs as jsxs2 } from "react/jsx-runtime";
var iconFillColor, handlerColor, createIcon, tablerIconProps, modifiedTablerIconProps, PlusPromoIcon, LibraryIcon, PlusIcon, DotsIcon, PinIcon, UnlockedIcon, LockedIcon, WelcomeScreenMenuArrow, WelcomeScreenHelpArrow, WelcomeScreenTopToolbarArrow, ExcalLogo, SelectionIcon, RectangleIcon, DiamondIcon, EllipseIcon, ArrowIcon, LineIcon, PenModeIcon, FreedrawIcon, TextIcon, ImageIcon, EraserIcon, ZoomInIcon, ZoomOutIcon, ZoomResetIcon, TrashIcon, EmbedIcon, DuplicateIcon, MoonIcon, SunIcon, HamburgerMenuIcon, ExportIcon, HelpIcon, HelpIconThin, ExternalLinkIcon, GithubIcon, DiscordIcon, XBrandIcon, checkIcon, LinkIcon, save, saveAs, LoadIcon, clipboard, palette, bucketFillIcon, ExportImageIcon, exportToFileIcon, zoomIn, zoomOut, done, menu, UndoIcon, RedoIcon, questionCircle, share, warning, shareIOS, exportToPlus, shareWindows, resetZoom, arrowBarToTopJSX, arrownNarrowUpJSX, BringForwardIcon, SendBackwardIcon, BringToFrontIcon, SendToBackIcon, AlignTopIcon, AlignBottomIcon, AlignLeftIcon, AlignRightIcon, DistributeHorizontallyIcon, DistributeVerticallyIcon, CenterVerticallyIcon, CenterHorizontallyIcon, usersIcon, start, stop, CloseIcon, clone, shield, file, GroupIcon, UngroupIcon, FillZigZagIcon, FillHachureIcon, FillCrossHatchIcon, FillSolidIcon, StrokeWidthBaseIcon, StrokeWidthBoldIcon, StrokeWidthExtraBoldIcon, StrokeStyleSolidIcon, StrokeStyleDashedIcon, StrokeStyleDottedIcon, SloppinessArchitectIcon, SloppinessArtistIcon, SloppinessCartoonistIcon, EdgeSharpIcon, EdgeRoundIcon, ArrowheadNoneIcon, ArrowheadArrowIcon, ArrowheadCircleIcon, ArrowheadCircleOutlineIcon, ArrowheadBarIcon, ArrowheadTriangleIcon, ArrowheadTriangleOutlineIcon, ArrowheadDiamondIcon, ArrowheadDiamondOutlineIcon, FontSizeSmallIcon, FontSizeMediumIcon, FontSizeLargeIcon, FontSizeExtraLargeIcon, fontSizeIcon, FontFamilyHeadingIcon, FontFamilyNormalIcon, FontFamilyCodeIcon, TextAlignLeftIcon, TextAlignCenterIcon, TextAlignRightIcon, TextAlignTopIcon, TextAlignBottomIcon, TextAlignMiddleIcon, angleIcon, publishIcon, eraser, handIcon, downloadIcon, copyIcon, cutIcon, helpIcon, playerPlayIcon, playerStopFilledIcon, tablerCheckIcon, alertTriangleIcon, eyeDropperIcon, extraToolsIcon, frameToolIcon, mermaidLogoIcon, ArrowRightIcon, laserPointerToolIcon, MagicIcon, MagicIconThin, OpenAIIcon, fullscreenIcon, eyeIcon, eyeClosedIcon, brainIcon, brainIconThin, searchIcon, clockIcon, microphoneIcon, microphoneMutedIcon, boltIcon, selectAllIcon, abacusIcon, flipVertical, flipHorizontal, paintIcon, zoomAreaIcon, svgIcon, pngIcon, magnetIcon, coffeeIcon, DeviceDesktopIcon, loginIcon, youtubeIcon, gridIcon, lineEditorIcon, sharpArrowIcon, elbowArrowIcon, roundArrowIcon, collapseDownIcon, collapseUpIcon, upIcon;
var init_icons = __esm({
  "components/icons.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    iconFillColor = (theme) => "var(--icon-fill-color)";
    handlerColor = (theme) => theme === THEME.LIGHT ? oc2.white : "#1e1e1e";
    createIcon = (d, opts = 512) => {
      const {
        width = 512,
        height = width,
        mirror,
        style,
        ...rest
      } = typeof opts === "number" ? { width: opts } : opts;
      return /* @__PURE__ */ jsx4(
        "svg",
        {
          "aria-hidden": "true",
          focusable: "false",
          role: "img",
          viewBox: `0 0 ${width} ${height}`,
          className: clsx2({ "rtl-mirror": mirror }),
          style,
          ...rest,
          children: typeof d === "string" ? /* @__PURE__ */ jsx4("path", { fill: "currentColor", d }) : d
        }
      );
    };
    tablerIconProps = {
      width: 24,
      height: 24,
      fill: "none",
      strokeWidth: 2,
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    };
    modifiedTablerIconProps = {
      width: 20,
      height: 20,
      fill: "none",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    };
    PlusPromoIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("rect", { x: 3, y: 8, width: 18, height: 4, rx: 1 }),
        /* @__PURE__ */ jsx4("line", { x1: 12, y1: 8, x2: 12, y2: 21 }),
        /* @__PURE__ */ jsx4("path", { d: "M19 12v7a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2v-7" }),
        /* @__PURE__ */ jsx4("path", { d: "M7.5 8a2.5 2.5 0 0 1 0 -5a4.8 8 0 0 1 4.5 5a4.8 8 0 0 1 4.5 -5a2.5 2.5 0 0 1 0 5" })
      ] }),
      tablerIconProps
    );
    LibraryIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M3 19a9 9 0 0 1 9 0a9 9 0 0 1 9 0" }),
        /* @__PURE__ */ jsx4("path", { d: "M3 6a9 9 0 0 1 9 0a9 9 0 0 1 9 0" }),
        /* @__PURE__ */ jsx4("line", { x1: "3", y1: "6", x2: "3", y2: "19" }),
        /* @__PURE__ */ jsx4("line", { x1: "12", y1: "6", x2: "12", y2: "19" }),
        /* @__PURE__ */ jsx4("line", { x1: "21", y1: "6", x2: "21", y2: "19" })
      ] }),
      tablerIconProps
    );
    PlusIcon = createIcon(
      /* @__PURE__ */ jsxs2("svg", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("line", { x1: "12", y1: "5", x2: "12", y2: "19" }),
        /* @__PURE__ */ jsx4("line", { x1: "5", y1: "12", x2: "19", y2: "12" })
      ] }),
      tablerIconProps
    );
    DotsIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("circle", { cx: "12", cy: "12", r: "1" }),
        /* @__PURE__ */ jsx4("circle", { cx: "12", cy: "19", r: "1" }),
        /* @__PURE__ */ jsx4("circle", { cx: "12", cy: "5", r: "1" })
      ] }),
      tablerIconProps
    );
    PinIcon = createIcon(
      /* @__PURE__ */ jsxs2("svg", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M9 4v6l-2 4v2h10v-2l-2 -4v-6" }),
        /* @__PURE__ */ jsx4("line", { x1: "12", y1: "16", x2: "12", y2: "21" }),
        /* @__PURE__ */ jsx4("line", { x1: "8", y1: "4", x2: "16", y2: "4" })
      ] }),
      tablerIconProps
    );
    UnlockedIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { children: [
        /* @__PURE__ */ jsx4(
          "path",
          {
            d: "M13.542 8.542H6.458a2.5 2.5 0 0 0-2.5 2.5v3.75a2.5 2.5 0 0 0 2.5 2.5h7.084a2.5 2.5 0 0 0 2.5-2.5v-3.75a2.5 2.5 0 0 0-2.5-2.5Z",
            stroke: "currentColor",
            strokeWidth: "1.25"
          }
        ),
        /* @__PURE__ */ jsx4(
          "path",
          {
            d: "M10 13.958a1.042 1.042 0 1 0 0-2.083 1.042 1.042 0 0 0 0 2.083Z",
            stroke: "currentColor",
            strokeWidth: "1.25"
          }
        ),
        /* @__PURE__ */ jsx4(
          "mask",
          {
            id: "UnlockedIcon",
            style: { maskType: "alpha" },
            maskUnits: "userSpaceOnUse",
            x: 6,
            y: 1,
            width: 9,
            height: 9,
            children: /* @__PURE__ */ jsx4(
              "path",
              {
                stroke: "none",
                d: "M6.399 9.561V5.175c0-.93.401-1.823 1.116-2.48a3.981 3.981 0 0 1 2.693-1.028c1.01 0 1.98.37 2.694 1.027.715.658 1.116 1.55 1.116 2.481",
                fill: "#fff"
              }
            )
          }
        ),
        /* @__PURE__ */ jsx4("g", { mask: "url(#UnlockedIcon)", children: /* @__PURE__ */ jsx4(
          "path",
          {
            stroke: "none",
            d: "M5.149 9.561v1.25h2.5v-1.25h-2.5Zm5.06-7.894V.417v1.25Zm2.559 3.508v1.25h2.5v-1.25h-2.5ZM7.648 8.51V5.175h-2.5V8.51h2.5Zm0-3.334c0-.564.243-1.128.713-1.561L6.668 1.775c-.959.883-1.52 2.104-1.52 3.4h2.5Zm.713-1.561a2.732 2.732 0 0 1 1.847-.697v-2.5c-1.31 0-2.585.478-3.54 1.358L8.36 3.614Zm1.847-.697c.71 0 1.374.26 1.847.697l1.694-1.839a5.231 5.231 0 0 0-3.54-1.358v2.5Zm1.847.697c.47.433.713.997.713 1.561h2.5c0-1.296-.56-2.517-1.52-3.4l-1.693 1.839Z",
            fill: "currentColor"
          }
        ) })
      ] }),
      modifiedTablerIconProps
    );
    LockedIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx4("path", { d: "M13.542 8.542H6.458a2.5 2.5 0 0 0-2.5 2.5v3.75a2.5 2.5 0 0 0 2.5 2.5h7.084a2.5 2.5 0 0 0 2.5-2.5v-3.75a2.5 2.5 0 0 0-2.5-2.5Z" }),
        /* @__PURE__ */ jsx4("path", { d: "M10 13.958a1.042 1.042 0 1 0 0-2.083 1.042 1.042 0 0 0 0 2.083Z" }),
        /* @__PURE__ */ jsx4("path", { d: "M6.667 8.333V5.417C6.667 3.806 8.159 2.5 10 2.5c1.841 0 3.333 1.306 3.333 2.917v2.916" })
      ] }),
      modifiedTablerIconProps
    );
    WelcomeScreenMenuArrow = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsx4(
          "path",
          {
            d: "M38.5 83.5c-14-2-17.833-10.473-21-22.5C14.333 48.984 12 22 12 12.5",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round"
          }
        ),
        /* @__PURE__ */ jsx4(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "m12.005 10.478 7.905 14.423L6 25.75l6.005-15.273Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx4(
          "path",
          {
            d: "M12.005 10.478c1.92 3.495 3.838 7 7.905 14.423m-7.905-14.423c3.11 5.683 6.23 11.368 7.905 14.423m0 0c-3.68.226-7.35.455-13.91.85m13.91-.85c-5.279.33-10.566.647-13.91.85m0 0c1.936-4.931 3.882-9.86 6.005-15.273M6 25.75c2.069-5.257 4.135-10.505 6.005-15.272",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round"
          }
        )
      ] }),
      { width: 41, height: 94, fill: "none" }
    );
    WelcomeScreenHelpArrow = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsx4(
          "path",
          {
            d: "M18.026 1.232c-5.268 13.125-5.548 33.555 3.285 42.311 8.823 8.75 33.31 12.304 42.422 13.523",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round"
          }
        ),
        /* @__PURE__ */ jsx4(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "m72.181 59.247-13.058-10-2.948 13.62 16.006-3.62Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx4(
          "path",
          {
            d: "M72.181 59.247c-3.163-2.429-6.337-4.856-13.058-10m13.058 10c-5.145-3.936-10.292-7.882-13.058-10m0 0c-.78 3.603-1.563 7.196-2.948 13.62m2.948-13.62c-1.126 5.168-2.24 10.346-2.948 13.62m0 0c5.168-1.166 10.334-2.343 16.006-3.62m-16.006 3.62c5.51-1.248 11.01-2.495 16.006-3.62",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round"
          }
        )
      ] }),
      { width: 85, height: 71, fill: "none" }
    );
    WelcomeScreenTopToolbarArrow = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsx4(
          "path",
          {
            d: "M1 77c14-2 31.833-11.973 35-24 3.167-12.016-6-35-9.5-43.5",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round"
          }
        ),
        /* @__PURE__ */ jsx4(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "m24.165 1.093-2.132 16.309 13.27-4.258-11.138-12.05Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx4(
          "path",
          {
            d: "M24.165 1.093c-.522 3.953-1.037 7.916-2.132 16.309m2.131-16.309c-.835 6.424-1.68 12.854-2.13 16.308m0 0c3.51-1.125 7.013-2.243 13.27-4.257m-13.27 4.257c5.038-1.608 10.08-3.232 13.27-4.257m0 0c-3.595-3.892-7.197-7.777-11.14-12.05m11.14 12.05c-3.837-4.148-7.667-8.287-11.14-12.05",
            stroke: "currentColor",
            strokeWidth: 2,
            strokeLinecap: "round"
          }
        )
      ] }),
      { width: 38, height: 78, fill: "none" }
    );
    ExcalLogo = createIcon(
      /* @__PURE__ */ jsx4("g", { fill: "currentColor", children: /* @__PURE__ */ jsx4(
        "path",
        {
          d: "M39.9 32.889a.326.326 0 0 0-.279-.056c-2.094-3.083-4.774-6-7.343-8.833l-.419-.472a.212.212 0 0 0-.056-.139.586.586 0 0 0-.167-.111l-.084-.083-.056-.056c-.084-.167-.28-.278-.475-.167-.782.39-1.507.973-2.206 1.528-.92.722-1.842 1.445-2.708 2.25a8.405 8.405 0 0 0-.977 1.028c-.14.194-.028.361.14.444-.615.611-1.23 1.223-1.843 1.861a.315.315 0 0 0-.084.223c0 .083.056.166.111.194l1.09.833v.028c1.535 1.528 4.244 3.611 7.12 5.861.418.334.865.667 1.284 1 .195.223.39.473.558.695.084.11.28.139.391.055.056.056.14.111.196.167a.398.398 0 0 0 .167.056.255.255 0 0 0 .224-.111.394.394 0 0 0 .055-.167c.029 0 .028.028.056.028a.318.318 0 0 0 .224-.084l5.082-5.528a.309.309 0 0 0 0-.444Zm-14.63-1.917a.485.485 0 0 0 .111.14c.586.5 1.2 1 1.843 1.555l-2.569-1.945-.251-.166c-.056-.028-.112-.084-.168-.111l-.195-.167.056-.056.055-.055.112-.111c.866-.861 2.346-2.306 3.1-3.028-.81.805-2.43 3.167-2.095 3.944Zm8.767 6.89-2.122-1.612a44.713 44.713 0 0 0-2.625-2.5c1.145.861 2.122 1.611 2.262 1.75 1.117.972 1.06.806 1.815 1.445l.921.666a1.06 1.06 0 0 1-.251.25Zm.558.416-.056-.028c.084-.055.168-.111.252-.194l-.196.222ZM1.089 5.75c.055.361.14.722.195 1.056.335 1.833.67 3.5 1.284 4.75l.252.944c.084.361.223.806.363.917 1.424 1.25 3.602 3.11 5.947 4.889a.295.295 0 0 0 .363 0s0 .027.028.027a.254.254 0 0 0 .196.084.318.318 0 0 0 .223-.084c2.988-3.305 5.221-6.027 6.813-8.305.112-.111.14-.278.14-.417.111-.111.195-.25.307-.333.111-.111.111-.306 0-.39l-.028-.027c0-.055-.028-.139-.084-.167-.698-.666-1.2-1.138-1.731-1.638-.922-.862-1.871-1.75-3.881-3.75l-.028-.028c-.028-.028-.056-.056-.112-.056-.558-.194-1.703-.389-3.127-.639C6.087 2.223 3.21 1.723.614.944c0 0-.168 0-.196.028l-.083.084c-.028.027-.056.055-.224.11h.056-.056c.028.167.028.278.084.473 0 .055.112.5.112.555l.782 3.556Zm15.496 3.278-.335-.334c.084.112.196.195.335.334Zm-3.546 4.666-.056.056c0-.028.028-.056.056-.056Zm-2.038-10c.168.167.866.834 1.033.973-.726-.334-2.54-1.167-3.379-1.445.838.167 1.983.334 2.346.472ZM1.424 2.306c.419.722.754 3.222 1.089 5.666-.196-.778-.335-1.555-.503-2.278-.251-1.277-.503-2.416-.838-3.416.056 0 .14 0 .252.028Zm-.168-.584c-.112 0-.223-.028-.307-.028 0-.027 0-.055-.028-.055.14 0 .223.028.335.083Zm-1.089.222c0-.027 0-.027 0 0ZM39.453 1.333c.028-.11-.558-.61-.363-.639.42-.027.42-.666 0-.666-.558.028-1.144.166-1.675.25-.977.194-1.982.389-2.96.61-2.205.473-4.383.973-6.561 1.557-.67.194-1.424.333-2.066.666-.224.111-.196.333-.084.472-.056.028-.084.028-.14.056-.195.028-.363.056-.558.083-.168.028-.252.167-.224.334 0 .027.028.083.028.11-1.173 1.556-2.485 3.195-3.909 4.945-1.396 1.611-2.876 3.306-4.356 5.056-4.719 5.5-10.052 11.75-15.943 17.25a.268.268 0 0 0 0 .389c.028.027.056.055.084.055-.084.084-.168.14-.252.222-.056.056-.084.111-.084.167a.605.605 0 0 0-.111.139c-.112.111-.112.305.028.389.111.11.307.11.39-.028.029-.028.029-.056.056-.056a.44.44 0 0 1 .615 0c.335.362.67.723.977 1.028l-.698-.583c-.112-.111-.307-.083-.39.028-.113.11-.085.305.027.389l7.427 6.194c.056.056.112.056.196.056s.14-.028.195-.084l.168-.166c.028.027.083.027.111.027.084 0 .14-.027.196-.083 10.052-10.055 18.15-17.639 27.42-24.417.083-.055.111-.166.111-.25.112 0 .196-.083.251-.194 1.704-5.194 2.039-9.806 2.15-12.083v-.028c0-.028.028-.056.028-.083.028-.056.028-.084.028-.084a1.626 1.626 0 0 0-.111-1.028ZM21.472 9.5c.446-.5.893-1.028 1.34-1.5-2.876 3.778-7.65 9.583-14.408 16.5 4.607-5.083 9.242-10.333 13.068-15ZM5.193 35.778h.084-.084Zm3.462 3.194c-.027-.028-.027-.028 0-.028v.028Zm4.16-3.583c.224-.25.448-.472.699-.722 0 0 0 .027.028.027-.252.223-.475.445-.726.695Zm1.146-1.111c.14-.14.279-.334.446-.5l.028-.028c1.648-1.694 3.351-3.389 5.082-5.111l.028-.028c.419-.333.921-.694 1.368-1.028a379.003 379.003 0 0 0-6.952 6.695ZM24.794 6.472c-.921 1.195-1.954 2.778-2.82 4.028-2.736 3.944-11.532 13.583-11.727 13.75a1976.983 1976.983 0 0 1-8.042 7.639l-.167.167c-.14-.167-.14-.417.028-.556C14.49 19.861 22.03 10.167 25.074 5.917c-.084.194-.14.36-.28.555Zm4.83 5.695c-1.116-.64-1.646-1.64-1.34-2.611l.084-.334c.028-.083.084-.194.14-.277.307-.5.754-.917 1.257-1.167.027 0 .055 0 .083-.028-.028-.056-.028-.139-.028-.222.028-.167.14-.278.335-.278.335 0 1.369.306 1.76.639.111.083.223.194.335.305.14.167.363.445.474.667.056.028.112.306.196.445.056.222.111.472.084.694-.028.028 0 .194-.028.194a2.668 2.668 0 0 1-.363 1.028c-.028.028-.028.056-.056.084l-.028.027c-.14.223-.335.417-.53.556-.643.444-1.369.583-2.095.389 0 0-.195-.084-.28-.111Zm8.154-.834a39.098 39.098 0 0 1-.893 3.167c0 .028-.028.083 0 .111-.056 0-.084.028-.14.056-2.206 1.61-4.356 3.305-6.506 5.028 1.843-1.64 3.686-3.306 5.613-4.945.558-.5.949-1.139 1.06-1.861l.28-1.667v-.055c.14-.334.67-.195.586.166Z",
          fill: "currentColor"
        }
      ) }),
      { width: 40, height: 40, fill: "none" }
    );
    SelectionIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M6 6l4.153 11.793a0.365 .365 0 0 0 .331 .207a0.366 .366 0 0 0 .332 -.207l2.184 -4.793l4.787 -1.994a0.355 .355 0 0 0 .213 -.323a0.355 .355 0 0 0 -.213 -.323l-11.787 -4.36z" }),
        /* @__PURE__ */ jsx4("path", { d: "M13.5 13.5l4.5 4.5" })
      ] }),
      { fill: "none", width: 22, height: 22, strokeWidth: 1.25 }
    );
    RectangleIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("rect", { x: "4", y: "4", width: "16", height: "16", rx: "2" })
      ] }),
      tablerIconProps
    );
    DiamondIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M10.5 20.4l-6.9 -6.9c-.781 -.781 -.781 -2.219 0 -3l6.9 -6.9c.781 -.781 2.219 -.781 3 0l6.9 6.9c.781 .781 .781 2.219 0 3l-6.9 6.9c-.781 .781 -2.219 .781 -3 0z" })
      ] }),
      tablerIconProps
    );
    EllipseIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("circle", { cx: "12", cy: "12", r: "9" })
      ] }),
      tablerIconProps
    );
    ArrowIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("line", { x1: "5", y1: "12", x2: "19", y2: "12" }),
        /* @__PURE__ */ jsx4("line", { x1: "15", y1: "16", x2: "19", y2: "12" }),
        /* @__PURE__ */ jsx4("line", { x1: "15", y1: "8", x2: "19", y2: "12" })
      ] }),
      tablerIconProps
    );
    LineIcon = createIcon(
      /* @__PURE__ */ jsx4("path", { d: "M4.167 10h11.666", strokeWidth: "1.5" }),
      modifiedTablerIconProps
    );
    PenModeIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M20 17v-12c0 -1.121 -.879 -2 -2 -2s-2 .879 -2 2v12l2 2l2 -2z" }),
        /* @__PURE__ */ jsx4("path", { d: "M16 7h4" }),
        /* @__PURE__ */ jsx4("path", { d: "M18 19h-13a2 2 0 1 1 0 -4h4a2 2 0 1 0 0 -4h-3" })
      ] }),
      tablerIconProps
    );
    FreedrawIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx4(
          "path",
          {
            clipRule: "evenodd",
            d: "m7.643 15.69 7.774-7.773a2.357 2.357 0 1 0-3.334-3.334L4.31 12.357a3.333 3.333 0 0 0-.977 2.357v1.953h1.953c.884 0 1.732-.352 2.357-.977Z"
          }
        ),
        /* @__PURE__ */ jsx4("path", { d: "m11.25 5.417 3.333 3.333" })
      ] }),
      modifiedTablerIconProps
    );
    TextIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("line", { x1: "4", y1: "20", x2: "7", y2: "20" }),
        /* @__PURE__ */ jsx4("line", { x1: "14", y1: "20", x2: "21", y2: "20" }),
        /* @__PURE__ */ jsx4("line", { x1: "6.9", y1: "15", x2: "13.8", y2: "15" }),
        /* @__PURE__ */ jsx4("line", { x1: "10.2", y1: "6.3", x2: "16", y2: "20" }),
        /* @__PURE__ */ jsx4("polyline", { points: "5 20 11 4 13 4 20 20" })
      ] }),
      tablerIconProps
    );
    ImageIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx4("path", { d: "M12.5 6.667h.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M4.91 2.625h10.18a2.284 2.284 0 0 1 2.285 2.284v10.182a2.284 2.284 0 0 1-2.284 2.284H4.909a2.284 2.284 0 0 1-2.284-2.284V4.909a2.284 2.284 0 0 1 2.284-2.284Z" }),
        /* @__PURE__ */ jsx4("path", { d: "m3.333 12.5 3.334-3.333c.773-.745 1.726-.745 2.5 0l4.166 4.166" }),
        /* @__PURE__ */ jsx4("path", { d: "m11.667 11.667.833-.834c.774-.744 1.726-.744 2.5 0l1.667 1.667" })
      ] }),
      modifiedTablerIconProps
    );
    EraserIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M19 20h-10.5l-4.21 -4.3a1 1 0 0 1 0 -1.41l10 -10a1 1 0 0 1 1.41 0l5 5a1 1 0 0 1 0 1.41l-9.2 9.3" }),
        /* @__PURE__ */ jsx4("path", { d: "M18 13.3l-6.3 -6.3" })
      ] }),
      tablerIconProps
    );
    ZoomInIcon = createIcon(
      /* @__PURE__ */ jsx4("path", { strokeWidth: "1.25", d: "M10 4.167v11.666M4.167 10h11.666" }),
      modifiedTablerIconProps
    );
    ZoomOutIcon = createIcon(
      /* @__PURE__ */ jsx4("path", { d: "M5 10h10", strokeWidth: "1.25" }),
      modifiedTablerIconProps
    );
    ZoomResetIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.25, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M21 21l-6 -6" }),
        /* @__PURE__ */ jsx4("path", { d: "M3.268 12.043a7.017 7.017 0 0 0 6.634 4.957a7.012 7.012 0 0 0 7.043 -6.131a7 7 0 0 0 -5.314 -7.672a7.021 7.021 0 0 0 -8.241 4.403" }),
        /* @__PURE__ */ jsx4("path", { d: "M3 4v4h4" })
      ] }),
      tablerIconProps
    );
    TrashIcon = createIcon(
      /* @__PURE__ */ jsx4(
        "path",
        {
          strokeWidth: "1.25",
          d: "M3.333 5.833h13.334M8.333 9.167v5M11.667 9.167v5M4.167 5.833l.833 10c0 .92.746 1.667 1.667 1.667h6.666c.92 0 1.667-.746 1.667-1.667l.833-10M7.5 5.833v-2.5c0-.46.373-.833.833-.833h3.334c.46 0 .833.373.833.833v2.5"
        }
      ),
      modifiedTablerIconProps
    );
    EmbedIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx4("polyline", { points: "12 16 18 10 12 4" }),
        /* @__PURE__ */ jsx4("polyline", { points: "8 4 2 10 8 16" })
      ] }),
      modifiedTablerIconProps
    );
    DuplicateIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx4("path", { d: "M14.375 6.458H8.958a2.5 2.5 0 0 0-2.5 2.5v5.417a2.5 2.5 0 0 0 2.5 2.5h5.417a2.5 2.5 0 0 0 2.5-2.5V8.958a2.5 2.5 0 0 0-2.5-2.5Z" }),
        /* @__PURE__ */ jsx4(
          "path",
          {
            clipRule: "evenodd",
            d: "M11.667 3.125c.517 0 .986.21 1.325.55.34.338.55.807.55 1.325v1.458H8.333c-.485 0-.927.185-1.26.487-.343.312-.57.75-.609 1.24l-.005 5.357H5a1.87 1.87 0 0 1-1.326-.55 1.87 1.87 0 0 1-.549-1.325V5c0-.518.21-.987.55-1.326.338-.34.807-.549 1.325-.549h6.667Z"
          }
        )
      ] }),
      modifiedTablerIconProps
    );
    MoonIcon = createIcon(
      /* @__PURE__ */ jsx4(
        "path",
        {
          clipRule: "evenodd",
          d: "M10 2.5h.328a6.25 6.25 0 0 0 6.6 10.372A7.5 7.5 0 1 1 10 2.493V2.5Z",
          stroke: "currentColor"
        }
      ),
      modifiedTablerIconProps
    );
    SunIcon = createIcon(
      /* @__PURE__ */ jsx4("g", { stroke: "currentColor", strokeLinejoin: "round", children: /* @__PURE__ */ jsx4("path", { d: "M10 12.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM10 4.167V2.5M14.167 5.833l1.166-1.166M15.833 10H17.5M14.167 14.167l1.166 1.166M10 15.833V17.5M5.833 14.167l-1.166 1.166M5 10H3.333M5.833 5.833 4.667 4.667" }) }),
      { ...modifiedTablerIconProps, strokeWidth: 1.5 }
    );
    HamburgerMenuIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("line", { x1: "4", y1: "6", x2: "20", y2: "6" }),
        /* @__PURE__ */ jsx4("line", { x1: "4", y1: "12", x2: "20", y2: "12" }),
        /* @__PURE__ */ jsx4("line", { x1: "4", y1: "18", x2: "20", y2: "18" })
      ] }),
      tablerIconProps
    );
    ExportIcon = createIcon(
      /* @__PURE__ */ jsx4(
        "path",
        {
          strokeWidth: "1.25",
          d: "M3.333 14.167v1.666c0 .92.747 1.667 1.667 1.667h10c.92 0 1.667-.746 1.667-1.667v-1.666M5.833 9.167 10 13.333l4.167-4.166M10 3.333v10"
        }
      ),
      modifiedTablerIconProps
    );
    HelpIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("circle", { cx: "12", cy: "12", r: "9" }),
        /* @__PURE__ */ jsx4("line", { x1: "12", y1: "17", x2: "12", y2: "17.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M12 13.5a1.5 1.5 0 0 1 1 -1.5a2.6 2.6 0 1 0 -3 -4" })
      ] }),
      tablerIconProps
    );
    HelpIconThin = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("circle", { cx: "12", cy: "12", r: "9" }),
        /* @__PURE__ */ jsx4("line", { x1: "12", y1: "17", x2: "12", y2: "17.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M12 13.5a1.5 1.5 0 0 1 1 -1.5a2.6 2.6 0 1 0 -3 -4" })
      ] }),
      tablerIconProps
    );
    ExternalLinkIcon = createIcon(
      /* @__PURE__ */ jsx4(
        "path",
        {
          strokeWidth: "1.25",
          d: "M9.167 5.833H5.833c-1.254 0-2.5 1.282-2.5 2.5v5.834c0 1.283 1.252 2.5 2.5 2.5h5.834c1.251 0 2.5-1.25 2.5-2.5v-3.334M8.333 11.667l8.334-8.334M12.5 3.333h4.167V7.5"
        }
      ),
      modifiedTablerIconProps
    );
    GithubIcon = createIcon(
      /* @__PURE__ */ jsx4(
        "path",
        {
          d: "M7.5 15.833c-3.583 1.167-3.583-2.083-5-2.5m10 4.167v-2.917c0-.833.083-1.166-.417-1.666 2.334-.25 4.584-1.167 4.584-5a3.833 3.833 0 0 0-1.084-2.667 3.5 3.5 0 0 0-.083-2.667s-.917-.25-2.917 1.084a10.25 10.25 0 0 0-5.166 0C5.417 2.333 4.5 2.583 4.5 2.583a3.5 3.5 0 0 0-.083 2.667 3.833 3.833 0 0 0-1.084 2.667c0 3.833 2.25 4.75 4.584 5-.5.5-.5 1-.417 1.666V17.5",
          strokeWidth: "1.25"
        }
      ),
      modifiedTablerIconProps
    );
    DiscordIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx4("path", { d: "M7.5 10.833a.833.833 0 1 0 0-1.666.833.833 0 0 0 0 1.666ZM12.5 10.833a.833.833 0 1 0 0-1.666.833.833 0 0 0 0 1.666ZM6.25 6.25c2.917-.833 4.583-.833 7.5 0M5.833 13.75c2.917.833 5.417.833 8.334 0" }),
        /* @__PURE__ */ jsx4("path", { d: "M12.917 14.167c0 .833 1.25 2.5 1.666 2.5 1.25 0 2.361-1.39 2.917-2.5.556-1.39.417-4.861-1.25-9.584-1.214-.846-2.5-1.116-3.75-1.25l-.833 2.084M7.083 14.167c0 .833-1.13 2.5-1.526 2.5-1.191 0-2.249-1.39-2.778-2.5-.529-1.39-.397-4.861 1.19-9.584 1.157-.846 2.318-1.116 3.531-1.25l.833 2.084" })
      ] }),
      modifiedTablerIconProps
    );
    XBrandIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M4 4l11.733 16h4.267l-11.733 -16z" }),
        /* @__PURE__ */ jsx4("path", { d: "M4 20l6.768 -6.768m2.46 -2.46l6.772 -6.772" })
      ] }),
      tablerIconProps
    );
    checkIcon = createIcon(
      /* @__PURE__ */ jsx4("polyline", { fill: "none", stroke: "currentColor", points: "20 6 9 17 4 12" }),
      {
        width: 24,
        height: 24
      }
    );
    LinkIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx4("path", { d: "M8.333 11.667a2.917 2.917 0 0 0 4.167 0l3.333-3.334a2.946 2.946 0 1 0-4.166-4.166l-.417.416" }),
        /* @__PURE__ */ jsx4("path", { d: "M11.667 8.333a2.917 2.917 0 0 0-4.167 0l-3.333 3.334a2.946 2.946 0 0 0 4.166 4.166l.417-.416" })
      ] }),
      modifiedTablerIconProps
    );
    save = createIcon(
      "M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z",
      { width: 448, height: 512 }
    );
    saveAs = createIcon(
      "M252 54L203 8a28 27 0 00-20-8H28C12 0 0 12 0 27v195c0 15 12 26 28 26h204c15 0 28-11 28-26V73a28 27 0 00-8-19zM130 213c-21 0-37-16-37-36 0-19 16-35 37-35 20 0 37 16 37 35 0 20-17 36-37 36zm56-169v56c0 4-4 6-7 6H44c-4 0-7-2-7-6V42c0-4 3-7 7-7h133l4 2 3 2a7 7 0 012 5z M296 201l87 95-188 205-78 9c-10 1-19-8-18-20l9-84zm141-14l-41-44a31 31 0 00-46 0l-38 41 87 95 38-42c13-14 13-36 0-50z",
      { width: 448, height: 512 }
    );
    LoadIcon = createIcon(
      /* @__PURE__ */ jsx4(
        "path",
        {
          d: "m9.257 6.351.183.183H15.819c.34 0 .727.182 1.051.506.323.323.505.708.505 1.05v5.819c0 .316-.183.7-.52 1.035-.337.338-.723.522-1.037.522H4.182c-.352 0-.74-.181-1.058-.5-.318-.318-.499-.705-.499-1.057V5.182c0-.351.181-.736.5-1.054.32-.321.71-.503 1.057-.503H6.53l2.726 2.726Z",
          strokeWidth: "1.25"
        }
      ),
      modifiedTablerIconProps
    );
    clipboard = createIcon(
      "M384 112v352c0 26.51-21.49 48-48 48H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h80c0-35.29 28.71-64 64-64s64 28.71 64 64h80c26.51 0 48 21.49 48 48zM192 40c-13.255 0-24 10.745-24 24s10.745 24 24 24 24-10.745 24-24-10.745-24-24-24m96 114v-20a6 6 0 0 0-6-6H102a6 6 0 0 0-6 6v20a6 6 0 0 0 6 6h180a6 6 0 0 0 6-6z",
      { width: 384, height: 512 }
    );
    palette = createIcon(
      "M204.3 5C104.9 24.4 24.8 104.3 5.2 203.4c-37 187 131.7 326.4 258.8 306.7 41.2-6.4 61.4-54.6 42.5-91.7-23.1-45.4 9.9-98.4 60.9-98.4h79.7c35.8 0 64.8-29.6 64.9-65.3C511.5 97.1 368.1-26.9 204.3 5zM96 320c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm32-128c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128-64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128 64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32z"
    );
    bucketFillIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.25, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M5 16l1.465 1.638a2 2 0 1 1 -3.015 .099l1.55 -1.737z" }),
        /* @__PURE__ */ jsx4("path", { d: "M13.737 9.737c2.299 -2.3 3.23 -5.095 2.081 -6.245c-1.15 -1.15 -3.945 -.217 -6.244 2.082c-2.3 2.299 -3.231 5.095 -2.082 6.244c1.15 1.15 3.946 .218 6.245 -2.081z" }),
        /* @__PURE__ */ jsx4("path", { d: "M7.492 11.818c.362 .362 .768 .676 1.208 .934l6.895 4.047c1.078 .557 2.255 -.075 3.692 -1.512c1.437 -1.437 2.07 -2.614 1.512 -3.692c-.372 -.718 -1.72 -3.017 -4.047 -6.895a6.015 6.015 0 0 0 -.934 -1.208" })
      ] }),
      tablerIconProps
    );
    ExportImageIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M15 8h.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M12 20h-5a3 3 0 0 1 -3 -3v-10a3 3 0 0 1 3 -3h10a3 3 0 0 1 3 3v5" }),
        /* @__PURE__ */ jsx4("path", { d: "M4 15l4 -4c.928 -.893 2.072 -.893 3 0l4 4" }),
        /* @__PURE__ */ jsx4("path", { d: "M14 14l1 -1c.617 -.593 1.328 -.793 2.009 -.598" }),
        /* @__PURE__ */ jsx4("path", { d: "M19 16v6" }),
        /* @__PURE__ */ jsx4("path", { d: "M22 19l-3 3l-3 -3" })
      ] }),
      tablerIconProps
    );
    exportToFileIcon = createIcon(
      "M216 0h80c13.3 0 24 10.7 24 24v168h87.7c17.8 0 26.7 21.5 14.1 34.1L269.7 378.3c-7.5 7.5-19.8 7.5-27.3 0L90.1 226.1c-12.6-12.6-3.7-34.1 14.1-34.1H192V24c0-13.3 10.7-24 24-24zm296 376v112c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V376c0-13.3 10.7-24 24-24h146.7l49 49c20.1 20.1 52.5 20.1 72.6 0l49-49H488c13.3 0 24 10.7 24 24zm-124 88c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20zm64 0c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20z",
      { width: 512, height: 512 }
    );
    zoomIn = createIcon(
      "M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z",
      { width: 448, height: 512 }
    );
    zoomOut = createIcon(
      "M416 208H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z",
      { width: 448, height: 512 }
    );
    done = createIcon(
      "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"
    );
    menu = createIcon(
      "M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z"
    );
    UndoIcon = createIcon(
      /* @__PURE__ */ jsx4(
        "path",
        {
          d: "M7.5 10.833 4.167 7.5 7.5 4.167M4.167 7.5h9.166a3.333 3.333 0 0 1 0 6.667H12.5",
          strokeWidth: "1.25"
        }
      ),
      modifiedTablerIconProps
    );
    RedoIcon = createIcon(
      /* @__PURE__ */ jsx4(
        "path",
        {
          d: "M12.5 10.833 15.833 7.5 12.5 4.167M15.833 7.5H6.667a3.333 3.333 0 1 0 0 6.667H7.5",
          strokeWidth: "1.25"
        }
      ),
      modifiedTablerIconProps
    );
    questionCircle = createIcon(
      "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zM262.655 90c-54.497 0-89.255 22.957-116.549 63.758-3.536 5.286-2.353 12.415 2.715 16.258l34.699 26.31c5.205 3.947 12.621 3.008 16.665-2.122 17.864-22.658 30.113-35.797 57.303-35.797 20.429 0 45.698 13.148 45.698 32.958 0 14.976-12.363 22.667-32.534 33.976C247.128 238.528 216 254.941 216 296v4c0 6.627 5.373 12 12 12h56c6.627 0 12-5.373 12-12v-1.333c0-28.462 83.186-29.647 83.186-106.667 0-58.002-60.165-102-116.531-102zM256 338c-25.365 0-46 20.635-46 46 0 25.364 20.635 46 46 46s46-20.636 46-46c0-25.365-20.635-46-46-46z",
      { mirror: true }
    );
    share = createIcon(
      /* @__PURE__ */ jsx4(
        "path",
        {
          d: "M5 12.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM15 7.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM15 17.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM7.25 8.917l5.5-2.834M7.25 11.083l5.5 2.834",
          strokeWidth: "1.5"
        }
      ),
      modifiedTablerIconProps
    );
    warning = createIcon(
      "M256 32c14.2 0 27.3 7.5 34.5 19.8l216 368c7.3 12.4 7.3 27.7 .2 40.1S486.3 480 472 480H40c-14.3 0-27.6-7.7-34.7-20.1s-7-27.8 .2-40.1l216-368C228.7 39.5 241.8 32 256 32zm0 128c-13.3 0-24 10.7-24 24V296c0 13.3 10.7 24 24 24s24-10.7 24-24V184c0-13.3-10.7-24-24-24zm32 224a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z"
    );
    shareIOS = createIcon(
      "M16 5l-1.42 1.42-1.59-1.59V16h-1.98V4.83L9.42 6.42 8 5l4-4 4 4zm4 5v11c0 1.1-.9 2-2 2H6c-1.11 0-2-.9-2-2V10c0-1.11.89-2 2-2h3v2H6v11h12V10h-3V8h3c1.1 0 2 .89 2 2z",
      { width: 24, height: 24 }
    );
    exportToPlus = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.25, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M8 9h-1a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-8a2 2 0 0 0 -2 -2h-1" }),
        /* @__PURE__ */ jsx4("path", { d: "M12 14v-11" }),
        /* @__PURE__ */ jsx4("path", { d: "M9 6l3 -3l3 3" })
      ] }),
      tablerIconProps
    );
    shareWindows = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsx4(
          "path",
          {
            fill: "currentColor",
            d: "M40 5.6v6.1l-4.1.7c-8.9 1.4-16.5 6.9-20.6 15C13 32 10.9 43 12.4 43c.4 0 2.4-1.3 4.4-3 5-3.9 12.1-7 18.2-7.7l5-.6v12.8l11.2-11.3L62.5 22 51.2 10.8 40-.5v6.1zm10.2 22.6L44 34.5v-6.8l-6.9.6c-3.9.3-9.8 1.7-13.2 3.1-3.5 1.4-6.5 2.4-6.7 2.2-.9-1 3-7.5 6.4-10.8C28 18.6 34.4 16 40.1 16c3.7 0 3.9-.1 3.9-3.2V9.5l6.2 6.3 6.3 6.2-6.3 6.2z"
          }
        ),
        /* @__PURE__ */ jsx4(
          "path",
          {
            stroke: "currentColor",
            fill: "currentColor",
            d: "M0 36v20h48v-6.2c0-6 0-6.1-2-4.3-1.1 1-2 2.9-2 4.2V52H4V34c0-17.3-.1-18-2-18s-2 .7-2 20z"
          }
        )
      ] }),
      { width: 64, height: 64 }
    );
    resetZoom = createIcon(
      /* @__PURE__ */ jsx4(
        "path",
        {
          stroke: "currentColor",
          strokeWidth: "40",
          fill: "currentColor",
          d: "M148 560a318 318 0 0 0 522 110 316 316 0 0 0 0-450 316 316 0 0 0-450 0c-11 11-21 22-30 34v4h47c25 0 46 21 46 46s-21 45-46 45H90c-13 0-25-6-33-14-9-9-14-20-14-33V156c0-25 20-45 45-45s45 20 45 45v32l1 1a401 401 0 0 1 623 509l212 212a42 42 0 0 1-59 59L698 757A401 401 0 0 1 65 570a42 42 0 0 1 83-10z"
        }
      ),
      { width: 1024 }
    );
    arrowBarToTopJSX = /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.5, children: [
      /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
      /* @__PURE__ */ jsx4("path", { d: "M12 10l0 10" }),
      /* @__PURE__ */ jsx4("path", { d: "M12 10l4 4" }),
      /* @__PURE__ */ jsx4("path", { d: "M12 10l-4 4" }),
      /* @__PURE__ */ jsx4("path", { d: "M4 4l16 0" })
    ] });
    arrownNarrowUpJSX = /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.5, children: [
      /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
      /* @__PURE__ */ jsx4("path", { d: "M12 5l0 14" }),
      /* @__PURE__ */ jsx4("path", { d: "M16 9l-4 -4" }),
      /* @__PURE__ */ jsx4("path", { d: "M8 9l4 -4" })
    ] });
    BringForwardIcon = createIcon(arrownNarrowUpJSX, tablerIconProps);
    SendBackwardIcon = createIcon(arrownNarrowUpJSX, {
      ...tablerIconProps,
      style: {
        transform: "rotate(180deg)"
      }
    });
    BringToFrontIcon = createIcon(arrowBarToTopJSX, tablerIconProps);
    SendToBackIcon = createIcon(arrowBarToTopJSX, {
      ...tablerIconProps,
      style: {
        transform: "rotate(180deg)"
      }
    });
    AlignTopIcon = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsxs2("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
          /* @__PURE__ */ jsx4(
            "path",
            {
              d: "M3.333 3.333h13.334",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsx4("path", { d: "M13.542 6.458h-.417c-.92 0-1.667.747-1.667 1.667v7.083c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667V8.125c0-.92-.746-1.667-1.666-1.667ZM6.875 6.458h-.417c-.92 0-1.666.747-1.666 1.667v3.75c0 .92.746 1.667 1.666 1.667h.417c.92 0 1.667-.746 1.667-1.667v-3.75c0-.92-.747-1.667-1.667-1.667Z" })
        ] }),
        /* @__PURE__ */ jsx4("defs", { children: /* @__PURE__ */ jsx4("clipPath", { id: "a", children: /* @__PURE__ */ jsx4("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    AlignBottomIcon = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsxs2("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
          /* @__PURE__ */ jsx4(
            "path",
            {
              d: "M3.333 16.667h13.334",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsx4("path", { d: "M6.875 3.125h-.417c-.92 0-1.666.746-1.666 1.667v7.083c0 .92.746 1.667 1.666 1.667h.417c.92 0 1.667-.746 1.667-1.667V4.792c0-.92-.747-1.667-1.667-1.667ZM13.542 5.817h-.417c-.92 0-1.667.747-1.667 1.667v4.391c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667V7.484c0-.92-.746-1.667-1.666-1.667Z" })
        ] }),
        /* @__PURE__ */ jsx4("defs", { children: /* @__PURE__ */ jsx4("clipPath", { id: "a", children: /* @__PURE__ */ jsx4("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    AlignLeftIcon = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsxs2("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
          /* @__PURE__ */ jsx4(
            "path",
            {
              d: "M3.333 3.333v13.334",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsx4("path", { d: "M15.208 4.792H8.125c-.92 0-1.667.746-1.667 1.666v.417c0 .92.747 1.667 1.667 1.667h7.083c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666ZM12.516 11.458H8.125c-.92 0-1.667.746-1.667 1.667v.417c0 .92.747 1.666 1.667 1.666h4.391c.92 0 1.667-.746 1.667-1.666v-.417c0-.92-.746-1.667-1.667-1.667Z" })
        ] }),
        /* @__PURE__ */ jsx4("defs", { children: /* @__PURE__ */ jsx4("clipPath", { id: "a", children: /* @__PURE__ */ jsx4("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    AlignRightIcon = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsxs2("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
          /* @__PURE__ */ jsx4(
            "path",
            {
              d: "M16.667 3.333v13.334",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsx4("path", { d: "M11.875 4.792H4.792c-.92 0-1.667.746-1.667 1.666v.417c0 .92.746 1.667 1.667 1.667h7.083c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666ZM11.683 11.458H7.292c-.92 0-1.667.746-1.667 1.667v.417c0 .92.746 1.666 1.667 1.666h4.39c.921 0 1.667-.746 1.667-1.666v-.417c0-.92-.746-1.667-1.666-1.667Z" })
        ] }),
        /* @__PURE__ */ jsx4("defs", { children: /* @__PURE__ */ jsx4("clipPath", { id: "a", children: /* @__PURE__ */ jsx4("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    DistributeHorizontallyIcon = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsxs2("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
          /* @__PURE__ */ jsx4(
            "path",
            {
              d: "M16.667 3.333v13.334M3.333 3.333v13.334",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsx4("path", { d: "M14.375 10.208v-.416c0-.92-.746-1.667-1.667-1.667H7.292c-.92 0-1.667.746-1.667 1.667v.416c0 .92.746 1.667 1.667 1.667h5.416c.92 0 1.667-.746 1.667-1.667Z" })
        ] }),
        /* @__PURE__ */ jsx4("defs", { children: /* @__PURE__ */ jsx4("clipPath", { id: "a", children: /* @__PURE__ */ jsx4("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    DistributeVerticallyIcon = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsxs2("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [
          /* @__PURE__ */ jsx4(
            "path",
            {
              d: "M3.333 3.333h13.334M3.333 16.667h13.334",
              strokeLinecap: "round",
              strokeLinejoin: "round"
            }
          ),
          /* @__PURE__ */ jsx4("path", { d: "M10.208 5.625h-.416c-.92 0-1.667.746-1.667 1.667v5.416c0 .92.746 1.667 1.667 1.667h.416c.92 0 1.667-.746 1.667-1.667V7.292c0-.92-.746-1.667-1.667-1.667Z" })
        ] }),
        /* @__PURE__ */ jsx4("defs", { children: /* @__PURE__ */ jsx4("clipPath", { id: "a", children: /* @__PURE__ */ jsx4("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    CenterVerticallyIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { stroke: "currentColor", strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx4("path", { d: "M1.667 10h2.916", strokeLinecap: "round", strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx4("path", { d: "M8.333 10h3.334", strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx4("path", { d: "M15.417 10h2.916", strokeLinecap: "round", strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx4("path", { d: "M6.875 4.792h-.417c-.92 0-1.666.746-1.666 1.666v7.084c0 .92.746 1.666 1.666 1.666h.417c.92 0 1.667-.746 1.667-1.666V6.458c0-.92-.747-1.666-1.667-1.666ZM13.542 6.458h-.417c-.92 0-1.667.747-1.667 1.667v3.75c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667v-3.75c0-.92-.746-1.667-1.666-1.667Z" })
      ] }),
      modifiedTablerIconProps
    );
    CenterHorizontallyIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { stroke: "currentColor", strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx4("path", { d: "M10 18.333v-2.916", strokeLinecap: "round", strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx4("path", { d: "M10 11.667V8.333", strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx4("path", { d: "M10 4.583V1.667", strokeLinecap: "round", strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx4("path", { d: "M4.792 13.125v.417c0 .92.746 1.666 1.666 1.666h7.084c.92 0 1.666-.746 1.666-1.666v-.417c0-.92-.746-1.667-1.666-1.667H6.458c-.92 0-1.666.746-1.666 1.667ZM6.458 6.458v.417c0 .92.747 1.667 1.667 1.667h3.75c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666h-3.75c-.92 0-1.667.746-1.667 1.666Z" })
      ] }),
      modifiedTablerIconProps
    );
    usersIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("circle", { cx: "9", cy: "7", r: "4" }),
        /* @__PURE__ */ jsx4("path", { d: "M3 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" }),
        /* @__PURE__ */ jsx4("path", { d: "M16 3.13a4 4 0 0 1 0 7.75" }),
        /* @__PURE__ */ jsx4("path", { d: "M21 21v-2a4 4 0 0 0 -3 -3.85" })
      ] }),
      tablerIconProps
    );
    start = createIcon(
      "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm115.7 272l-176 101c-15.8 8.8-35.7-2.5-35.7-21V152c0-18.4 19.8-29.8 35.7-21l176 107c16.4 9.2 16.4 32.9 0 42z"
    );
    stop = createIcon(
      "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm96 328c0 8.8-7.2 16-16 16H176c-8.8 0-16-7.2-16-16V176c0-8.8 7.2-16 16-16h160c8.8 0 16 7.2 16 16v160z"
    );
    CloseIcon = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsx4(
          "g",
          {
            clipPath: "url(#a)",
            stroke: "currentColor",
            strokeWidth: "1.25",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: /* @__PURE__ */ jsx4("path", { d: "M15 5 5 15M5 5l10 10" })
          }
        ),
        /* @__PURE__ */ jsx4("defs", { children: /* @__PURE__ */ jsx4("clipPath", { id: "a", children: /* @__PURE__ */ jsx4("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    clone = createIcon(
      "M464 0c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48H176c-26.51 0-48-21.49-48-48V48c0-26.51 21.49-48 48-48h288M176 416c-44.112 0-80-35.888-80-80V128H48c-26.51 0-48 21.49-48 48v288c0 26.51 21.49 48 48 48h288c26.51 0 48-21.49 48-48v-48H176z",
      { mirror: true }
    );
    shield = createIcon(
      "M11.553 22.894a.998.998 0 00.894 0s3.037-1.516 5.465-4.097C19.616 16.987 21 14.663 21 12V5a1 1 0 00-.649-.936l-8-3a.998.998 0 00-.702 0l-8 3A1 1 0 003 5v7c0 2.663 1.384 4.987 3.088 6.797 2.428 2.581 5.465 4.097 5.465 4.097zm-1.303-8.481l6.644-6.644a.856.856 0 111.212 1.212l-7.25 7.25a.856.856 0 01-1.212 0l-3.75-3.75a.856.856 0 111.212-1.212l3.144 3.144z",
      { width: 24 }
    );
    file = createIcon(
      "M369.9 97.9L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zM332.1 128H256V51.9l76.1 76.1zM48 464V48h160v104c0 13.3 10.7 24 24 24h104v288H48zm32-48h224V288l-23.5-23.5c-4.7-4.7-12.3-4.7-17 0L176 352l-39.5-39.5c-4.7-4.7-12.3-4.7-17 0L80 352v64zm48-240c-26.5 0-48 21.5-48 48s21.5 48 48 48 48-21.5 48-48-21.5-48-48-48z",
      { width: 384, height: 512 }
    );
    GroupIcon = React3.memo(
      ({ theme }) => createIcon(
        /* @__PURE__ */ jsxs2(Fragment, { children: [
          /* @__PURE__ */ jsx4("path", { d: "M25 26H111V111H25", fill: iconFillColor(theme) }),
          /* @__PURE__ */ jsx4(
            "path",
            {
              d: "M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z",
              stroke: iconFillColor(theme),
              strokeWidth: "2"
            }
          ),
          /* @__PURE__ */ jsx4("path", { d: "M100 100H160V160H100", fill: iconFillColor(theme) }),
          /* @__PURE__ */ jsx4(
            "path",
            {
              d: "M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z",
              stroke: iconFillColor(theme),
              strokeWidth: "2"
            }
          ),
          /* @__PURE__ */ jsxs2(
            "g",
            {
              fill: handlerColor(theme),
              stroke: iconFillColor(theme),
              strokeWidth: "6",
              children: [
                /* @__PURE__ */ jsx4("rect", { x: "2.5", y: "2.5", width: "30", height: "30" }),
                /* @__PURE__ */ jsx4("rect", { x: "2.5", y: "149.5", width: "30", height: "30" }),
                /* @__PURE__ */ jsx4("rect", { x: "147.5", y: "149.5", width: "30", height: "30" }),
                /* @__PURE__ */ jsx4("rect", { x: "147.5", y: "2.5", width: "30", height: "30" })
              ]
            }
          )
        ] }),
        { width: 182, height: 182, mirror: true }
      )
    );
    UngroupIcon = React3.memo(
      ({ theme }) => createIcon(
        /* @__PURE__ */ jsxs2(Fragment, { children: [
          /* @__PURE__ */ jsx4("path", { d: "M25 26H111V111H25", fill: iconFillColor(theme) }),
          /* @__PURE__ */ jsx4(
            "path",
            {
              d: "M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z",
              stroke: iconFillColor(theme),
              strokeWidth: "2"
            }
          ),
          /* @__PURE__ */ jsx4("path", { d: "M100 100H160V160H100", fill: iconFillColor(theme) }),
          /* @__PURE__ */ jsx4(
            "path",
            {
              d: "M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z",
              stroke: iconFillColor(theme),
              strokeWidth: "2"
            }
          ),
          /* @__PURE__ */ jsxs2(
            "g",
            {
              fill: handlerColor(theme),
              stroke: iconFillColor(theme),
              strokeWidth: "6",
              children: [
                /* @__PURE__ */ jsx4("rect", { x: "2.5", y: "2.5", width: "30", height: "30" }),
                /* @__PURE__ */ jsx4("rect", { x: "78.5", y: "149.5", width: "30", height: "30" }),
                /* @__PURE__ */ jsx4("rect", { x: "147.5", y: "149.5", width: "30", height: "30" }),
                /* @__PURE__ */ jsx4("rect", { x: "147.5", y: "78.5", width: "30", height: "30" }),
                /* @__PURE__ */ jsx4("rect", { x: "105.5", y: "2.5", width: "30", height: "30" }),
                /* @__PURE__ */ jsx4("rect", { x: "2.5", y: "102.5", width: "30", height: "30" })
              ]
            }
          )
        ] }),
        { width: 182, height: 182, mirror: true }
      )
    );
    FillZigZagIcon = createIcon(
      /* @__PURE__ */ jsx4("g", { strokeWidth: 1.25, children: /* @__PURE__ */ jsx4("path", { d: "M5.879 2.625h8.242a3.27 3.27 0 0 1 3.254 3.254v8.242a3.27 3.27 0 0 1-3.254 3.254H5.88a3.27 3.27 0 0 1-3.254-3.254V5.88A3.27 3.27 0 0 1 5.88 2.626l-.001-.001ZM4.518 16.118l7.608-12.83m.198 13.934 5.051-9.897M2.778 9.675l9.348-6.387m-7.608 12.83 12.857-8.793" }) }),
      modifiedTablerIconProps
    );
    FillHachureIcon = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsx4(
          "path",
          {
            d: "M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z",
            stroke: "currentColor",
            strokeWidth: "1.25"
          }
        ),
        /* @__PURE__ */ jsx4(
          "mask",
          {
            id: "FillHachureIcon",
            style: { maskType: "alpha" },
            maskUnits: "userSpaceOnUse",
            x: 2,
            y: 2,
            width: 16,
            height: 16,
            children: /* @__PURE__ */ jsx4(
              "path",
              {
                d: "M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z",
                fill: "currentColor",
                stroke: "currentColor",
                strokeWidth: "1.25"
              }
            )
          }
        ),
        /* @__PURE__ */ jsx4("g", { mask: "url(#FillHachureIcon)", children: /* @__PURE__ */ jsx4(
          "path",
          {
            d: "M2.258 15.156 15.156 2.258M7.324 20.222 20.222 7.325m-20.444 5.35L12.675-.222m-8.157 18.34L17.416 5.22",
            stroke: "currentColor",
            strokeWidth: "1.25",
            strokeLinecap: "round",
            strokeLinejoin: "round"
          }
        ) })
      ] }),
      modifiedTablerIconProps
    );
    FillCrossHatchIcon = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsxs2("g", { clipPath: "url(#a)", children: [
          /* @__PURE__ */ jsx4(
            "path",
            {
              d: "M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z",
              stroke: "currentColor",
              strokeWidth: "1.25"
            }
          ),
          /* @__PURE__ */ jsx4(
            "mask",
            {
              id: "FillCrossHatchIcon",
              style: { maskType: "alpha" },
              maskUnits: "userSpaceOnUse",
              x: -1,
              y: -1,
              width: 22,
              height: 22,
              children: /* @__PURE__ */ jsx4(
                "path",
                {
                  d: "M2.426 15.044 15.044 2.426M7.383 20 20 7.383M0 12.617 12.617 0m-7.98 17.941L17.256 5.324m-2.211 12.25L2.426 4.956M20 12.617 7.383 0m5.234 20L0 7.383m17.941 7.98L5.324 2.745",
                  stroke: "currentColor",
                  strokeWidth: "1.25",
                  strokeLinecap: "round",
                  strokeLinejoin: "round"
                }
              )
            }
          ),
          /* @__PURE__ */ jsx4("g", { mask: "url(#FillCrossHatchIcon)", children: /* @__PURE__ */ jsx4(
            "path",
            {
              d: "M14.121 2H5.88A3.879 3.879 0 0 0 2 5.879v8.242A3.879 3.879 0 0 0 5.879 18h8.242A3.879 3.879 0 0 0 18 14.121V5.88A3.879 3.879 0 0 0 14.121 2Z",
              fill: "currentColor"
            }
          ) })
        ] }),
        /* @__PURE__ */ jsx4("defs", { children: /* @__PURE__ */ jsx4("clipPath", { id: "a", children: /* @__PURE__ */ jsx4("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    FillSolidIcon = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsx4("g", { clipPath: "url(#a)", children: /* @__PURE__ */ jsx4(
          "path",
          {
            d: "M4.91 2.625h10.18a2.284 2.284 0 0 1 2.285 2.284v10.182a2.284 2.284 0 0 1-2.284 2.284H4.909a2.284 2.284 0 0 1-2.284-2.284V4.909a2.284 2.284 0 0 1 2.284-2.284Z",
            stroke: "currentColor",
            strokeWidth: "1.25"
          }
        ) }),
        /* @__PURE__ */ jsx4("defs", { children: /* @__PURE__ */ jsx4("clipPath", { id: "a", children: /* @__PURE__ */ jsx4("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      { ...modifiedTablerIconProps, fill: "currentColor" }
    );
    StrokeWidthBaseIcon = createIcon(
      /* @__PURE__ */ jsx4(Fragment, { children: /* @__PURE__ */ jsx4(
        "path",
        {
          d: "M4.167 10h11.666",
          stroke: "currentColor",
          strokeWidth: "1.25",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ) }),
      modifiedTablerIconProps
    );
    StrokeWidthBoldIcon = createIcon(
      /* @__PURE__ */ jsx4(
        "path",
        {
          d: "M5 10h10",
          stroke: "currentColor",
          strokeWidth: "2.5",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      modifiedTablerIconProps
    );
    StrokeWidthExtraBoldIcon = createIcon(
      /* @__PURE__ */ jsx4(
        "path",
        {
          d: "M5 10h10",
          stroke: "currentColor",
          strokeWidth: "3.75",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ),
      modifiedTablerIconProps
    );
    StrokeStyleSolidIcon = React3.memo(
      ({ theme }) => createIcon(
        /* @__PURE__ */ jsx4(
          "path",
          {
            d: "M6 10H34",
            stroke: iconFillColor(theme),
            strokeWidth: 2,
            fill: "none",
            strokeLinecap: "round"
          }
        ),
        {
          width: 40,
          height: 20
        }
      )
    );
    StrokeStyleDashedIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "2", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M5 12h2" }),
        /* @__PURE__ */ jsx4("path", { d: "M17 12h2" }),
        /* @__PURE__ */ jsx4("path", { d: "M11 12h2" })
      ] }),
      tablerIconProps
    );
    StrokeStyleDottedIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "2", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M4 12v.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M8 12v.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M12 12v.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M16 12v.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M20 12v.01" })
      ] }),
      tablerIconProps
    );
    SloppinessArchitectIcon = createIcon(
      /* @__PURE__ */ jsx4(
        "path",
        {
          d: "M2.5 12.038c1.655-.885 5.9-3.292 8.568-4.354 2.668-1.063.101 2.821 1.32 3.104 1.218.283 5.112-1.814 5.112-1.814",
          strokeWidth: "1.25"
        }
      ),
      modifiedTablerIconProps
    );
    SloppinessArtistIcon = createIcon(
      /* @__PURE__ */ jsx4(
        "path",
        {
          d: "M2.5 12.563c1.655-.886 5.9-3.293 8.568-4.355 2.668-1.062.101 2.822 1.32 3.105 1.218.283 5.112-1.814 5.112-1.814m-13.469 2.23c2.963-1.586 6.13-5.62 7.468-4.998 1.338.623-1.153 4.11-.132 5.595 1.02 1.487 6.133-1.43 6.133-1.43",
          strokeWidth: "1.25"
        }
      ),
      modifiedTablerIconProps
    );
    SloppinessCartoonistIcon = createIcon(
      /* @__PURE__ */ jsx4(
        "path",
        {
          d: "M2.5 11.936c1.737-.879 8.627-5.346 10.42-5.268 1.795.078-.418 5.138.345 5.736.763.598 3.53-1.789 4.235-2.147M2.929 9.788c1.164-.519 5.47-3.28 6.987-3.114 1.519.165 1 3.827 2.121 4.109 1.122.281 3.839-2.016 4.606-2.42",
          strokeWidth: "1.25"
        }
      ),
      modifiedTablerIconProps
    );
    EdgeSharpIcon = createIcon(
      /* @__PURE__ */ jsxs2("svg", { strokeWidth: "1.5", children: [
        /* @__PURE__ */ jsx4("path", { d: "M3.33334 9.99998V6.66665C3.33334 6.04326 3.33403 4.9332 3.33539 3.33646C4.95233 3.33436 6.06276 3.33331 6.66668 3.33331H10" }),
        /* @__PURE__ */ jsx4("path", { d: "M13.3333 3.33331V3.34331" }),
        /* @__PURE__ */ jsx4("path", { d: "M16.6667 3.33331V3.34331" }),
        /* @__PURE__ */ jsx4("path", { d: "M16.6667 6.66669V6.67669" }),
        /* @__PURE__ */ jsx4("path", { d: "M16.6667 10V10.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M3.33334 13.3333V13.3433" }),
        /* @__PURE__ */ jsx4("path", { d: "M16.6667 13.3333V13.3433" }),
        /* @__PURE__ */ jsx4("path", { d: "M3.33334 16.6667V16.6767" }),
        /* @__PURE__ */ jsx4("path", { d: "M6.66666 16.6667V16.6767" }),
        /* @__PURE__ */ jsx4("path", { d: "M10 16.6667V16.6767" }),
        /* @__PURE__ */ jsx4("path", { d: "M13.3333 16.6667V16.6767" }),
        /* @__PURE__ */ jsx4("path", { d: "M16.6667 16.6667V16.6767" })
      ] }),
      modifiedTablerIconProps
    );
    EdgeRoundIcon = createIcon(
      /* @__PURE__ */ jsxs2(
        "g",
        {
          strokeWidth: "1.5",
          stroke: "currentColor",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          children: [
            /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
            /* @__PURE__ */ jsx4("path", { d: "M4 12v-4a4 4 0 0 1 4 -4h4" }),
            /* @__PURE__ */ jsx4("line", { x1: "16", y1: "4", x2: "16", y2: "4.01" }),
            /* @__PURE__ */ jsx4("line", { x1: "20", y1: "4", x2: "20", y2: "4.01" }),
            /* @__PURE__ */ jsx4("line", { x1: "20", y1: "8", x2: "20", y2: "8.01" }),
            /* @__PURE__ */ jsx4("line", { x1: "20", y1: "12", x2: "20", y2: "12.01" }),
            /* @__PURE__ */ jsx4("line", { x1: "4", y1: "16", x2: "4", y2: "16.01" }),
            /* @__PURE__ */ jsx4("line", { x1: "20", y1: "16", x2: "20", y2: "16.01" }),
            /* @__PURE__ */ jsx4("line", { x1: "4", y1: "20", x2: "4", y2: "20.01" }),
            /* @__PURE__ */ jsx4("line", { x1: "8", y1: "20", x2: "8", y2: "20.01" }),
            /* @__PURE__ */ jsx4("line", { x1: "12", y1: "20", x2: "12", y2: "20.01" }),
            /* @__PURE__ */ jsx4("line", { x1: "16", y1: "20", x2: "16", y2: "20.01" }),
            /* @__PURE__ */ jsx4("line", { x1: "20", y1: "20", x2: "20", y2: "20.01" })
          ]
        }
      ),
      tablerIconProps
    );
    ArrowheadNoneIcon = createIcon(
      /* @__PURE__ */ jsx4("path", { d: "M6 10H34", stroke: "currentColor", strokeWidth: 2, fill: "none" }),
      {
        width: 40,
        height: 20
      }
    );
    ArrowheadArrowIcon = React3.memo(
      ({ flip = false }) => createIcon(
        /* @__PURE__ */ jsxs2(
          "g",
          {
            transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
            stroke: "currentColor",
            strokeWidth: 2,
            fill: "none",
            children: [
              /* @__PURE__ */ jsx4("path", { d: "M34 10H6M34 10L27 5M34 10L27 15" }),
              /* @__PURE__ */ jsx4("path", { d: "M27.5 5L34.5 10L27.5 15" })
            ]
          }
        ),
        { width: 40, height: 20 }
      )
    );
    ArrowheadCircleIcon = React3.memo(
      ({ flip = false }) => createIcon(
        /* @__PURE__ */ jsxs2(
          "g",
          {
            stroke: "currentColor",
            fill: "currentColor",
            transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
            children: [
              /* @__PURE__ */ jsx4("path", { d: "M32 10L6 10", strokeWidth: 2 }),
              /* @__PURE__ */ jsx4("circle", { r: "4", transform: "matrix(-1 0 0 1 30 10)" })
            ]
          }
        ),
        { width: 40, height: 20 }
      )
    );
    ArrowheadCircleOutlineIcon = React3.memo(
      ({ flip = false }) => createIcon(
        /* @__PURE__ */ jsxs2(
          "g",
          {
            stroke: "currentColor",
            fill: "none",
            transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
            strokeWidth: 2,
            children: [
              /* @__PURE__ */ jsx4("path", { d: "M26 10L6 10" }),
              /* @__PURE__ */ jsx4("circle", { r: "4", transform: "matrix(-1 0 0 1 30 10)" })
            ]
          }
        ),
        { width: 40, height: 20 }
      )
    );
    ArrowheadBarIcon = React3.memo(
      ({ flip = false }) => createIcon(
        /* @__PURE__ */ jsx4("g", { transform: flip ? "translate(40, 0) scale(-1, 1)" : "", children: /* @__PURE__ */ jsx4(
          "path",
          {
            d: "M34 10H5.99996M34 10L34 5M34 10L34 15",
            stroke: "currentColor",
            strokeWidth: 2,
            fill: "none"
          }
        ) }),
        { width: 40, height: 20 }
      )
    );
    ArrowheadTriangleIcon = React3.memo(
      ({ flip = false }) => createIcon(
        /* @__PURE__ */ jsxs2(
          "g",
          {
            stroke: "currentColor",
            fill: "currentColor",
            transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
            children: [
              /* @__PURE__ */ jsx4("path", { d: "M32 10L6 10", strokeWidth: 2 }),
              /* @__PURE__ */ jsx4("path", { d: "M27.5 5.5L34.5 10L27.5 14.5L27.5 5.5" })
            ]
          }
        ),
        { width: 40, height: 20 }
      )
    );
    ArrowheadTriangleOutlineIcon = React3.memo(
      ({ flip = false }) => createIcon(
        /* @__PURE__ */ jsxs2(
          "g",
          {
            stroke: "currentColor",
            fill: "none",
            transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
            strokeWidth: 2,
            strokeLinejoin: "round",
            children: [
              /* @__PURE__ */ jsx4("path", { d: "M6,9.5H27" }),
              /* @__PURE__ */ jsx4("path", { d: "M27,5L34,10L27,14Z", fill: "none" })
            ]
          }
        ),
        { width: 40, height: 20 }
      )
    );
    ArrowheadDiamondIcon = React3.memo(
      ({ flip = false }) => createIcon(
        /* @__PURE__ */ jsxs2(
          "g",
          {
            stroke: "currentColor",
            fill: "currentColor",
            transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
            strokeLinejoin: "round",
            strokeWidth: 2,
            children: [
              /* @__PURE__ */ jsx4("path", { d: "M6,9.5H20" }),
              /* @__PURE__ */ jsx4("path", { d: "M27,5L34,10L27,14L20,9.5Z" })
            ]
          }
        ),
        { width: 40, height: 20 }
      )
    );
    ArrowheadDiamondOutlineIcon = React3.memo(
      ({ flip = false }) => createIcon(
        /* @__PURE__ */ jsxs2(
          "g",
          {
            stroke: "currentColor",
            fill: "none",
            transform: flip ? "translate(40, 0) scale(-1, 1)" : "",
            strokeLinejoin: "round",
            strokeWidth: 2,
            children: [
              /* @__PURE__ */ jsx4("path", { d: "M6,9.5H20" }),
              /* @__PURE__ */ jsx4("path", { d: "M27,5L34,10L27,14L20,9.5Z" })
            ]
          }
        ),
        { width: 40, height: 20 }
      )
    );
    FontSizeSmallIcon = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsx4("g", { clipPath: "url(#a)", children: /* @__PURE__ */ jsx4(
          "path",
          {
            d: "M14.167 6.667a3.333 3.333 0 0 0-3.334-3.334H9.167a3.333 3.333 0 0 0 0 6.667h1.666a3.333 3.333 0 0 1 0 6.667H9.167a3.333 3.333 0 0 1-3.334-3.334",
            stroke: "currentColor",
            strokeWidth: "1.25",
            strokeLinecap: "round",
            strokeLinejoin: "round"
          }
        ) }),
        /* @__PURE__ */ jsx4("defs", { children: /* @__PURE__ */ jsx4("clipPath", { id: "a", children: /* @__PURE__ */ jsx4("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    FontSizeMediumIcon = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsx4("g", { clipPath: "url(#a)", children: /* @__PURE__ */ jsx4(
          "path",
          {
            d: "M5 16.667V3.333L10 15l5-11.667v13.334",
            stroke: "currentColor",
            strokeWidth: "1.25",
            strokeLinecap: "round",
            strokeLinejoin: "round"
          }
        ) }),
        /* @__PURE__ */ jsx4("defs", { children: /* @__PURE__ */ jsx4("clipPath", { id: "a", children: /* @__PURE__ */ jsx4("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    FontSizeLargeIcon = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsx4("g", { clipPath: "url(#a)", children: /* @__PURE__ */ jsx4(
          "path",
          {
            d: "M5.833 3.333v13.334h8.334",
            stroke: "currentColor",
            strokeWidth: "1.25",
            strokeLinecap: "round",
            strokeLinejoin: "round"
          }
        ) }),
        /* @__PURE__ */ jsx4("defs", { children: /* @__PURE__ */ jsx4("clipPath", { id: "a", children: /* @__PURE__ */ jsx4("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    FontSizeExtraLargeIcon = createIcon(
      /* @__PURE__ */ jsx4(Fragment, { children: /* @__PURE__ */ jsx4(
        "path",
        {
          d: "m1.667 3.333 6.666 13.334M8.333 3.333 1.667 16.667M11.667 3.333v13.334h6.666",
          stroke: "currentColor",
          strokeWidth: "1.25",
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      ) }),
      modifiedTablerIconProps
    );
    fontSizeIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.25, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M3 7v-2h13v2" }),
        /* @__PURE__ */ jsx4("path", { d: "M10 5v14" }),
        /* @__PURE__ */ jsx4("path", { d: "M12 19h-4" }),
        /* @__PURE__ */ jsx4("path", { d: "M15 13v-1h6v1" }),
        /* @__PURE__ */ jsx4("path", { d: "M18 12v7" }),
        /* @__PURE__ */ jsx4("path", { d: "M17 19h2" })
      ] }),
      tablerIconProps
    );
    FontFamilyHeadingIcon = createIcon(
      /* @__PURE__ */ jsx4(Fragment, { children: /* @__PURE__ */ jsxs2(
        "g",
        {
          stroke: "currentColor",
          strokeWidth: "1.25",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          children: [
            /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
            /* @__PURE__ */ jsx4("path", { d: "M7 12h10" }),
            /* @__PURE__ */ jsx4("path", { d: "M7 5v14" }),
            /* @__PURE__ */ jsx4("path", { d: "M17 5v14" }),
            /* @__PURE__ */ jsx4("path", { d: "M15 19h4" }),
            /* @__PURE__ */ jsx4("path", { d: "M15 5h4" }),
            /* @__PURE__ */ jsx4("path", { d: "M5 19h4" }),
            /* @__PURE__ */ jsx4("path", { d: "M5 5h4" })
          ]
        }
      ) }),
      tablerIconProps
    );
    FontFamilyNormalIcon = createIcon(
      /* @__PURE__ */ jsx4(Fragment, { children: /* @__PURE__ */ jsx4(
        "g",
        {
          stroke: "currentColor",
          strokeWidth: "1.25",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          children: /* @__PURE__ */ jsx4("path", { d: "M5.833 16.667v-10a3.333 3.333 0 0 1 3.334-3.334h1.666a3.333 3.333 0 0 1 3.334 3.334v10M5.833 10.833h8.334" })
        }
      ) }),
      modifiedTablerIconProps
    );
    FontFamilyCodeIcon = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsx4(
          "g",
          {
            clipPath: "url(#a)",
            stroke: "currentColor",
            strokeWidth: "1.25",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: /* @__PURE__ */ jsx4("path", { d: "M5.833 6.667 2.5 10l3.333 3.333M14.167 6.667 17.5 10l-3.333 3.333M11.667 3.333 8.333 16.667" })
          }
        ),
        /* @__PURE__ */ jsx4("defs", { children: /* @__PURE__ */ jsx4("clipPath", { id: "a", children: /* @__PURE__ */ jsx4("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })
      ] }),
      modifiedTablerIconProps
    );
    TextAlignLeftIcon = createIcon(
      /* @__PURE__ */ jsxs2(
        "g",
        {
          stroke: "currentColor",
          fill: "none",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: 2,
          children: [
            /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
            /* @__PURE__ */ jsx4("line", { x1: "4", y1: "8", x2: "20", y2: "8" }),
            /* @__PURE__ */ jsx4("line", { x1: "4", y1: "12", x2: "12", y2: "12" }),
            /* @__PURE__ */ jsx4("line", { x1: "4", y1: "16", x2: "16", y2: "16" })
          ]
        }
      ),
      tablerIconProps
    );
    TextAlignCenterIcon = createIcon(
      /* @__PURE__ */ jsxs2(
        "g",
        {
          stroke: "currentColor",
          fill: "none",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          children: [
            /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
            /* @__PURE__ */ jsx4("line", { x1: "4", y1: "8", x2: "20", y2: "8" }),
            /* @__PURE__ */ jsx4("line", { x1: "8", y1: "12", x2: "16", y2: "12" }),
            /* @__PURE__ */ jsx4("line", { x1: "6", y1: "16", x2: "18", y2: "16" })
          ]
        }
      ),
      tablerIconProps
    );
    TextAlignRightIcon = createIcon(
      /* @__PURE__ */ jsxs2(
        "g",
        {
          stroke: "currentColor",
          fill: "none",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          children: [
            /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
            /* @__PURE__ */ jsx4("line", { x1: "4", y1: "8", x2: "20", y2: "8" }),
            /* @__PURE__ */ jsx4("line", { x1: "10", y1: "12", x2: "20", y2: "12" }),
            /* @__PURE__ */ jsx4("line", { x1: "8", y1: "16", x2: "20", y2: "16" })
          ]
        }
      ),
      tablerIconProps
    );
    TextAlignTopIcon = React3.memo(
      ({ theme }) => createIcon(
        /* @__PURE__ */ jsxs2(
          "g",
          {
            strokeWidth: "1.5",
            stroke: "currentColor",
            fill: "none",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [
              /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
              /* @__PURE__ */ jsx4("line", { x1: "4", y1: "4", x2: "20", y2: "4" }),
              /* @__PURE__ */ jsx4("rect", { x: "9", y: "8", width: "6", height: "12", rx: "2" })
            ]
          }
        ),
        tablerIconProps
      )
    );
    TextAlignBottomIcon = React3.memo(
      ({ theme }) => createIcon(
        /* @__PURE__ */ jsxs2(
          "g",
          {
            strokeWidth: "2",
            stroke: "currentColor",
            fill: "none",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [
              /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
              /* @__PURE__ */ jsx4("line", { x1: "4", y1: "20", x2: "20", y2: "20" }),
              /* @__PURE__ */ jsx4("rect", { x: "9", y: "4", width: "6", height: "12", rx: "2" })
            ]
          }
        ),
        tablerIconProps
      )
    );
    TextAlignMiddleIcon = React3.memo(
      ({ theme }) => createIcon(
        /* @__PURE__ */ jsxs2(
          "g",
          {
            strokeWidth: "1.5",
            stroke: "currentColor",
            fill: "none",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [
              /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
              /* @__PURE__ */ jsx4("line", { x1: "4", y1: "12", x2: "9", y2: "12" }),
              /* @__PURE__ */ jsx4("line", { x1: "15", y1: "12", x2: "20", y2: "12" }),
              /* @__PURE__ */ jsx4("rect", { x: "9", y: "6", width: "6", height: "12", rx: "2" })
            ]
          }
        ),
        tablerIconProps
      )
    );
    angleIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M21 19h-18l9 -15" }),
        /* @__PURE__ */ jsx4("path", { d: "M20.615 15.171h.015" }),
        /* @__PURE__ */ jsx4("path", { d: "M19.515 11.771h.015" }),
        /* @__PURE__ */ jsx4("path", { d: "M17.715 8.671h.015" }),
        /* @__PURE__ */ jsx4("path", { d: "M15.415 5.971h.015" })
      ] }),
      tablerIconProps
    );
    publishIcon = createIcon(
      /* @__PURE__ */ jsx4(
        "path",
        {
          d: "M537.6 226.6c4.1-10.7 6.4-22.4 6.4-34.6 0-53-43-96-96-96-19.7 0-38.1 6-53.3 16.2C367 64.2 315.3 32 256 32c-88.4 0-160 71.6-160 160 0 2.7.1 5.4.2 8.1C40.2 219.8 0 273.2 0 336c0 79.5 64.5 144 144 144h368c70.7 0 128-57.3 128-128 0-61.9-44-113.6-102.4-125.4zM393.4 288H328v112c0 8.8-7.2 16-16 16h-48c-8.8 0-16-7.2-16-16V288h-65.4c-14.3 0-21.4-17.2-11.3-27.3l105.4-105.4c6.2-6.2 16.4-6.2 22.6 0l105.4 105.4c10.1 10.1 2.9 27.3-11.3 27.3z",
          fill: "currentColor"
        }
      ),
      { width: 640, height: 512 }
    );
    eraser = createIcon(
      /* @__PURE__ */ jsx4("path", { d: "M480 416C497.7 416 512 430.3 512 448C512 465.7 497.7 480 480 480H150.6C133.7 480 117.4 473.3 105.4 461.3L25.37 381.3C.3786 356.3 .3786 315.7 25.37 290.7L258.7 57.37C283.7 32.38 324.3 32.38 349.3 57.37L486.6 194.7C511.6 219.7 511.6 260.3 486.6 285.3L355.9 416H480zM265.4 416L332.7 348.7L195.3 211.3L70.63 336L150.6 416L265.4 416z" })
    );
    handIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.25, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M8 13v-7.5a1.5 1.5 0 0 1 3 0v6.5" }),
        /* @__PURE__ */ jsx4("path", { d: "M11 5.5v-2a1.5 1.5 0 1 1 3 0v8.5" }),
        /* @__PURE__ */ jsx4("path", { d: "M14 5.5a1.5 1.5 0 0 1 3 0v6.5" }),
        /* @__PURE__ */ jsx4("path", { d: "M17 7.5a1.5 1.5 0 0 1 3 0v8.5a6 6 0 0 1 -6 6h-2h.208a6 6 0 0 1 -5.012 -2.7a69.74 69.74 0 0 1 -.196 -.3c-.312 -.479 -1.407 -2.388 -3.286 -5.728a1.5 1.5 0 0 1 .536 -2.022a1.867 1.867 0 0 1 2.28 .28l1.47 1.47" })
      ] }),
      tablerIconProps
    );
    downloadIcon = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2 -2v-2" }),
        /* @__PURE__ */ jsx4("path", { d: "M7 11l5 5l5 -5" }),
        /* @__PURE__ */ jsx4("path", { d: "M12 4l0 12" })
      ] }),
      tablerIconProps
    );
    copyIcon = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z" }),
        /* @__PURE__ */ jsx4("path", { d: "M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2" })
      ] }),
      tablerIconProps
    );
    cutIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.25, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M7 17m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0" }),
        /* @__PURE__ */ jsx4("path", { d: "M17 17m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0" }),
        /* @__PURE__ */ jsx4("path", { d: "M9.15 14.85l8.85 -10.85" }),
        /* @__PURE__ */ jsx4("path", { d: "M6 4l8.85 10.85" })
      ] }),
      tablerIconProps
    );
    helpIcon = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0" }),
        /* @__PURE__ */ jsx4("path", { d: "M12 17l0 .01" }),
        /* @__PURE__ */ jsx4("path", { d: "M12 13.5a1.5 1.5 0 0 1 1 -1.5a2.6 2.6 0 1 0 -3 -4" })
      ] }),
      tablerIconProps
    );
    playerPlayIcon = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M7 4v16l13 -8z" })
      ] }),
      tablerIconProps
    );
    playerStopFilledIcon = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4(
          "path",
          {
            d: "M17 4h-10a3 3 0 0 0 -3 3v10a3 3 0 0 0 3 3h10a3 3 0 0 0 3 -3v-10a3 3 0 0 0 -3 -3z",
            strokeWidth: "0",
            fill: "currentColor"
          }
        )
      ] }),
      tablerIconProps
    );
    tablerCheckIcon = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M5 12l5 5l10 -10" })
      ] }),
      tablerIconProps
    );
    alertTriangleIcon = createIcon(
      /* @__PURE__ */ jsxs2(Fragment, { children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M10.24 3.957l-8.422 14.06a1.989 1.989 0 0 0 1.7 2.983h16.845a1.989 1.989 0 0 0 1.7 -2.983l-8.423 -14.06a1.989 1.989 0 0 0 -3.4 0z" }),
        /* @__PURE__ */ jsx4("path", { d: "M12 9v4" }),
        /* @__PURE__ */ jsx4("path", { d: "M12 17h.01" })
      ] }),
      tablerIconProps
    );
    eyeDropperIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.25, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M11 7l6 6" }),
        /* @__PURE__ */ jsx4("path", { d: "M4 16l11.7 -11.7a1 1 0 0 1 1.4 0l2.6 2.6a1 1 0 0 1 0 1.4l-11.7 11.7h-4v-4z" })
      ] }),
      tablerIconProps
    );
    extraToolsIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.5, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M12 3l-4 7h8z" }),
        /* @__PURE__ */ jsx4("path", { d: "M17 17m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0" }),
        /* @__PURE__ */ jsx4("path", { d: "M4 14m0 1a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1z" })
      ] }),
      tablerIconProps
    );
    frameToolIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.5, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M4 7l16 0" }),
        /* @__PURE__ */ jsx4("path", { d: "M4 17l16 0" }),
        /* @__PURE__ */ jsx4("path", { d: "M7 4l0 16" }),
        /* @__PURE__ */ jsx4("path", { d: "M17 4l0 16" })
      ] }),
      tablerIconProps
    );
    mermaidLogoIcon = createIcon(
      /* @__PURE__ */ jsx4(
        "path",
        {
          fill: "currentColor",
          d: "M407.48,111.18C335.587,108.103 269.573,152.338 245.08,220C220.587,152.338 154.573,108.103 82.68,111.18C80.285,168.229 107.577,222.632 154.74,254.82C178.908,271.419 193.35,298.951 193.27,328.27L193.27,379.13L296.9,379.13L296.9,328.27C296.816,298.953 311.255,271.42 335.42,254.82C382.596,222.644 409.892,168.233 407.48,111.18Z"
        }
      )
    );
    ArrowRightIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: "1.25", children: [
        /* @__PURE__ */ jsx4("path", { d: "M4.16602 10H15.8327" }),
        /* @__PURE__ */ jsx4("path", { d: "M12.5 13.3333L15.8333 10" }),
        /* @__PURE__ */ jsx4("path", { d: "M12.5 6.66666L15.8333 9.99999" })
      ] }),
      modifiedTablerIconProps
    );
    laserPointerToolIcon = createIcon(
      /* @__PURE__ */ jsxs2(
        "g",
        {
          fill: "none",
          stroke: "currentColor",
          strokeWidth: "1.25",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          transform: "rotate(90 10 10)",
          children: [
            /* @__PURE__ */ jsx4(
              "path",
              {
                clipRule: "evenodd",
                d: "m9.644 13.69 7.774-7.773a2.357 2.357 0 0 0-3.334-3.334l-7.773 7.774L8 12l1.643 1.69Z"
              }
            ),
            /* @__PURE__ */ jsx4("path", { d: "m13.25 3.417 3.333 3.333M10 10l2-2M5 15l3-3M2.156 17.894l1-1M5.453 19.029l-.144-1.407M2.377 11.887l.866 1.118M8.354 17.273l-1.194-.758M.953 14.652l1.408.13" })
          ]
        }
      ),
      20
    );
    MagicIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { stroke: "currentColor", fill: "none", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z" }),
        /* @__PURE__ */ jsx4("path", { d: "M6 21l15 -15l-3 -3l-15 15l3 3" }),
        /* @__PURE__ */ jsx4("path", { d: "M15 6l3 3" }),
        /* @__PURE__ */ jsx4("path", { d: "M9 3a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" }),
        /* @__PURE__ */ jsx4("path", { d: "M19 13a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" })
      ] }),
      tablerIconProps
    );
    MagicIconThin = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.25, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z" }),
        /* @__PURE__ */ jsx4("path", { d: "M6 21l15 -15l-3 -3l-15 15l3 3" }),
        /* @__PURE__ */ jsx4("path", { d: "M15 6l3 3" }),
        /* @__PURE__ */ jsx4("path", { d: "M9 3a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" }),
        /* @__PURE__ */ jsx4("path", { d: "M19 13a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" })
      ] }),
      tablerIconProps
    );
    OpenAIIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { stroke: "currentColor", fill: "none", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M11.217 19.384a3.501 3.501 0 0 0 6.783 -1.217v-5.167l-6 -3.35" }),
        /* @__PURE__ */ jsx4("path", { d: "M5.214 15.014a3.501 3.501 0 0 0 4.446 5.266l4.34 -2.534v-6.946" }),
        /* @__PURE__ */ jsx4("path", { d: "M6 7.63c-1.391 -.236 -2.787 .395 -3.534 1.689a3.474 3.474 0 0 0 1.271 4.745l4.263 2.514l6 -3.348" }),
        /* @__PURE__ */ jsx4("path", { d: "M12.783 4.616a3.501 3.501 0 0 0 -6.783 1.217v5.067l6 3.45" }),
        /* @__PURE__ */ jsx4("path", { d: "M18.786 8.986a3.501 3.501 0 0 0 -4.446 -5.266l-4.34 2.534v6.946" }),
        /* @__PURE__ */ jsx4("path", { d: "M18 16.302c1.391 .236 2.787 -.395 3.534 -1.689a3.474 3.474 0 0 0 -1.271 -4.745l-4.308 -2.514l-5.955 3.42" })
      ] }),
      tablerIconProps
    );
    fullscreenIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { stroke: "currentColor", fill: "none", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M4 8v-2a2 2 0 0 1 2 -2h2" }),
        /* @__PURE__ */ jsx4("path", { d: "M4 16v2a2 2 0 0 0 2 2h2" }),
        /* @__PURE__ */ jsx4("path", { d: "M16 4h2a2 2 0 0 1 2 2v2" }),
        /* @__PURE__ */ jsx4("path", { d: "M16 20h2a2 2 0 0 0 2 -2v-2" })
      ] }),
      tablerIconProps
    );
    eyeIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { stroke: "currentColor", fill: "none", strokeWidth: 1.5, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" }),
        /* @__PURE__ */ jsx4("path", { d: "M21 12c-2.4 4 -5.4 6 -9 6c-3.6 0 -6.6 -2 -9 -6c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6" })
      ] }),
      tablerIconProps
    );
    eyeClosedIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { stroke: "currentColor", fill: "none", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M10.585 10.587a2 2 0 0 0 2.829 2.828" }),
        /* @__PURE__ */ jsx4("path", { d: "M16.681 16.673a8.717 8.717 0 0 1 -4.681 1.327c-3.6 0 -6.6 -2 -9 -6c1.272 -2.12 2.712 -3.678 4.32 -4.674m2.86 -1.146a9.055 9.055 0 0 1 1.82 -.18c3.6 0 6.6 2 9 6c-.666 1.11 -1.379 2.067 -2.138 2.87" }),
        /* @__PURE__ */ jsx4("path", { d: "M3 3l18 18" })
      ] }),
      tablerIconProps
    );
    brainIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { stroke: "currentColor", fill: "none", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M15.5 13a3.5 3.5 0 0 0 -3.5 3.5v1a3.5 3.5 0 0 0 7 0v-1.8" }),
        /* @__PURE__ */ jsx4("path", { d: "M8.5 13a3.5 3.5 0 0 1 3.5 3.5v1a3.5 3.5 0 0 1 -7 0v-1.8" }),
        /* @__PURE__ */ jsx4("path", { d: "M17.5 16a3.5 3.5 0 0 0 0 -7h-.5" }),
        /* @__PURE__ */ jsx4("path", { d: "M19 9.3v-2.8a3.5 3.5 0 0 0 -7 0" }),
        /* @__PURE__ */ jsx4("path", { d: "M6.5 16a3.5 3.5 0 0 1 0 -7h.5" }),
        /* @__PURE__ */ jsx4("path", { d: "M5 9.3v-2.8a3.5 3.5 0 0 1 7 0v10" })
      ] }),
      tablerIconProps
    );
    brainIconThin = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.25, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M15.5 13a3.5 3.5 0 0 0 -3.5 3.5v1a3.5 3.5 0 0 0 7 0v-1.8" }),
        /* @__PURE__ */ jsx4("path", { d: "M8.5 13a3.5 3.5 0 0 1 3.5 3.5v1a3.5 3.5 0 0 1 -7 0v-1.8" }),
        /* @__PURE__ */ jsx4("path", { d: "M17.5 16a3.5 3.5 0 0 0 0 -7h-.5" }),
        /* @__PURE__ */ jsx4("path", { d: "M19 9.3v-2.8a3.5 3.5 0 0 0 -7 0" }),
        /* @__PURE__ */ jsx4("path", { d: "M6.5 16a3.5 3.5 0 0 1 0 -7h.5" }),
        /* @__PURE__ */ jsx4("path", { d: "M5 9.3v-2.8a3.5 3.5 0 0 1 7 0v10" })
      ] }),
      tablerIconProps
    );
    searchIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.5, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" }),
        /* @__PURE__ */ jsx4("path", { d: "M21 21l-6 -6" })
      ] }),
      tablerIconProps
    );
    clockIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.5, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M20.984 12.53a9 9 0 1 0 -7.552 8.355" }),
        /* @__PURE__ */ jsx4("path", { d: "M12 7v5l3 3" }),
        /* @__PURE__ */ jsx4("path", { d: "M19 16l-2 3h4l-2 3" })
      ] }),
      tablerIconProps
    );
    microphoneIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.5, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M9 2m0 3a3 3 0 0 1 3 -3h0a3 3 0 0 1 3 3v5a3 3 0 0 1 -3 3h0a3 3 0 0 1 -3 -3z" }),
        /* @__PURE__ */ jsx4("path", { d: "M5 10a7 7 0 0 0 14 0" }),
        /* @__PURE__ */ jsx4("path", { d: "M8 21l8 0" }),
        /* @__PURE__ */ jsx4("path", { d: "M12 17l0 4" })
      ] }),
      tablerIconProps
    );
    microphoneMutedIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.5, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M3 3l18 18" }),
        /* @__PURE__ */ jsx4("path", { d: "M9 5a3 3 0 0 1 6 0v5a3 3 0 0 1 -.13 .874m-2 2a3 3 0 0 1 -3.87 -2.872v-1" }),
        /* @__PURE__ */ jsx4("path", { d: "M5 10a7 7 0 0 0 10.846 5.85m2 -2a6.967 6.967 0 0 0 1.152 -3.85" }),
        /* @__PURE__ */ jsx4("path", { d: "M8 21l8 0" }),
        /* @__PURE__ */ jsx4("path", { d: "M12 17l0 4" })
      ] }),
      tablerIconProps
    );
    boltIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.25, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M13 3l0 7l6 0l-8 11l0 -7l-6 0l8 -11" })
      ] }),
      tablerIconProps
    );
    selectAllIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M8 8m0 1a1 1 0 0 1 1 -1h6a1 1 0 0 1 1 1v6a1 1 0 0 1 -1 1h-6a1 1 0 0 1 -1 -1z" }),
        /* @__PURE__ */ jsx4("path", { d: "M12 20v.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M16 20v.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M8 20v.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M4 20v.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M4 16v.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M4 12v.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M4 8v.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M4 4v.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M8 4v.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M12 4v.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M16 4v.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M20 4v.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M20 8v.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M20 12v.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M20 16v.01" }),
        /* @__PURE__ */ jsx4("path", { d: "M20 20v.01" })
      ] }),
      tablerIconProps
    );
    abacusIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.25, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M5 3v18" }),
        /* @__PURE__ */ jsx4("path", { d: "M19 21v-18" }),
        /* @__PURE__ */ jsx4("path", { d: "M5 7h14" }),
        /* @__PURE__ */ jsx4("path", { d: "M5 15h14" }),
        /* @__PURE__ */ jsx4("path", { d: "M8 13v4" }),
        /* @__PURE__ */ jsx4("path", { d: "M11 13v4" }),
        /* @__PURE__ */ jsx4("path", { d: "M16 13v4" }),
        /* @__PURE__ */ jsx4("path", { d: "M14 5v4" }),
        /* @__PURE__ */ jsx4("path", { d: "M11 5v4" }),
        /* @__PURE__ */ jsx4("path", { d: "M8 5v4" }),
        /* @__PURE__ */ jsx4("path", { d: "M3 21h18" })
      ] }),
      tablerIconProps
    );
    flipVertical = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.25, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M3 12l18 0" }),
        /* @__PURE__ */ jsx4("path", { d: "M7 16l10 0l-10 5l0 -5" }),
        /* @__PURE__ */ jsx4("path", { d: "M7 8l10 0l-10 -5l0 5" })
      ] }),
      tablerIconProps
    );
    flipHorizontal = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.25, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M12 3l0 18" }),
        /* @__PURE__ */ jsx4("path", { d: "M16 7l0 10l5 0l-5 -10" }),
        /* @__PURE__ */ jsx4("path", { d: "M8 7l0 10l-5 0l5 -10" })
      ] }),
      tablerIconProps
    );
    paintIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.25, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M5 3m0 2a2 2 0 0 1 2 -2h10a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2z" }),
        /* @__PURE__ */ jsx4("path", { d: "M19 6h1a2 2 0 0 1 2 2a5 5 0 0 1 -5 5l-5 0v2" }),
        /* @__PURE__ */ jsx4("path", { d: "M10 15m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z" })
      ] }),
      tablerIconProps
    );
    zoomAreaIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.25, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M15 15m-5 0a5 5 0 1 0 10 0a5 5 0 1 0 -10 0" }),
        /* @__PURE__ */ jsx4("path", { d: "M22 22l-3 -3" }),
        /* @__PURE__ */ jsx4("path", { d: "M6 18h-1a2 2 0 0 1 -2 -2v-1" }),
        /* @__PURE__ */ jsx4("path", { d: "M3 11v-1" }),
        /* @__PURE__ */ jsx4("path", { d: "M3 6v-1a2 2 0 0 1 2 -2h1" }),
        /* @__PURE__ */ jsx4("path", { d: "M10 3h1" }),
        /* @__PURE__ */ jsx4("path", { d: "M15 3h1a2 2 0 0 1 2 2v1" })
      ] }),
      tablerIconProps
    );
    svgIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.25, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M14 3v4a1 1 0 0 0 1 1h4" }),
        /* @__PURE__ */ jsx4("path", { d: "M5 12v-7a2 2 0 0 1 2 -2h7l5 5v4" }),
        /* @__PURE__ */ jsx4("path", { d: "M4 20.25c0 .414 .336 .75 .75 .75h1.25a1 1 0 0 0 1 -1v-1a1 1 0 0 0 -1 -1h-1a1 1 0 0 1 -1 -1v-1a1 1 0 0 1 1 -1h1.25a.75 .75 0 0 1 .75 .75" }),
        /* @__PURE__ */ jsx4("path", { d: "M10 15l2 6l2 -6" }),
        /* @__PURE__ */ jsx4("path", { d: "M20 15h-1a2 2 0 0 0 -2 2v2a2 2 0 0 0 2 2h1v-3" })
      ] }),
      tablerIconProps
    );
    pngIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.25, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M14 3v4a1 1 0 0 0 1 1h4" }),
        /* @__PURE__ */ jsx4("path", { d: "M5 12v-7a2 2 0 0 1 2 -2h7l5 5v4" }),
        /* @__PURE__ */ jsx4("path", { d: "M20 15h-1a2 2 0 0 0 -2 2v2a2 2 0 0 0 2 2h1v-3" }),
        /* @__PURE__ */ jsx4("path", { d: "M5 18h1.5a1.5 1.5 0 0 0 0 -3h-1.5v6" }),
        /* @__PURE__ */ jsx4("path", { d: "M11 21v-6l3 6v-6" })
      ] }),
      tablerIconProps
    );
    magnetIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.25, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M4 13v-8a2 2 0 0 1 2 -2h1a2 2 0 0 1 2 2v8a2 2 0 0 0 6 0v-8a2 2 0 0 1 2 -2h1a2 2 0 0 1 2 2v8a8 8 0 0 1 -16 0" }),
        /* @__PURE__ */ jsx4("path", { d: "M4 8l5 0" }),
        /* @__PURE__ */ jsx4("path", { d: "M15 8l4 0" })
      ] }),
      tablerIconProps
    );
    coffeeIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.25, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M3 14c.83 .642 2.077 1.017 3.5 1c1.423 .017 2.67 -.358 3.5 -1c.83 -.642 2.077 -1.017 3.5 -1c1.423 -.017 2.67 .358 3.5 1" }),
        /* @__PURE__ */ jsx4("path", { d: "M8 3a2.4 2.4 0 0 0 -1 2a2.4 2.4 0 0 0 1 2" }),
        /* @__PURE__ */ jsx4("path", { d: "M12 3a2.4 2.4 0 0 0 -1 2a2.4 2.4 0 0 0 1 2" }),
        /* @__PURE__ */ jsx4("path", { d: "M3 10h14v5a6 6 0 0 1 -6 6h-2a6 6 0 0 1 -6 -6v-5z" }),
        /* @__PURE__ */ jsx4("path", { d: "M16.746 16.726a3 3 0 1 0 .252 -5.555" })
      ] }),
      tablerIconProps
    );
    DeviceDesktopIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { stroke: "currentColor", children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M3 5a1 1 0 0 1 1-1h16a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1h-16a1 1 0 0 1-1-1v-10zM7 20h10M9 16v4M15 16v4" })
      ] }),
      { ...tablerIconProps, strokeWidth: 1.5 }
    );
    loginIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.5, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M15 8v-2a2 2 0 0 0 -2 -2h-7a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h7a2 2 0 0 0 2 -2v-2" }),
        /* @__PURE__ */ jsx4("path", { d: "M21 12h-13l3 -3" }),
        /* @__PURE__ */ jsx4("path", { d: "M11 15l-3 -3" })
      ] }),
      tablerIconProps
    );
    youtubeIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M2 8a4 4 0 0 1 4 -4h12a4 4 0 0 1 4 4v8a4 4 0 0 1 -4 4h-12a4 4 0 0 1 -4 -4v-8z" }),
        /* @__PURE__ */ jsx4("path", { d: "M10 9l5 3l-5 3z" })
      ] }),
      tablerIconProps
    );
    gridIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.5, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M3 6h18" }),
        /* @__PURE__ */ jsx4("path", { d: "M3 12h18" }),
        /* @__PURE__ */ jsx4("path", { d: "M3 18h18" }),
        /* @__PURE__ */ jsx4("path", { d: "M6 3v18" }),
        /* @__PURE__ */ jsx4("path", { d: "M12 3v18" }),
        /* @__PURE__ */ jsx4("path", { d: "M18 3v18" })
      ] }),
      tablerIconProps
    );
    lineEditorIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { strokeWidth: 1.5, children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M17 3m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z" }),
        /* @__PURE__ */ jsx4("path", { d: "M3 17m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z" }),
        /* @__PURE__ */ jsx4("path", { d: "M17 5c-6.627 0 -12 5.373 -12 12" })
      ] }),
      tablerIconProps
    );
    sharpArrowIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M6 18l12 -12" }),
        /* @__PURE__ */ jsx4("path", { d: "M18 10v-4h-4" })
      ] }),
      tablerIconProps
    );
    elbowArrowIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M4,19L10,19C11.097,19 12,18.097 12,17L12,9C12,7.903 12.903,7 14,7L21,7" }),
        /* @__PURE__ */ jsx4("path", { d: "M18 4l3 3l-3 3" })
      ] }),
      tablerIconProps
    );
    roundArrowIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { children: [
        /* @__PURE__ */ jsx4("path", { d: "M16,12L20,9L16,6" }),
        /* @__PURE__ */ jsx4("path", { d: "M6 20c0 -6.075 4.925 -11 11 -11h3" })
      ] }),
      tablerIconProps
    );
    collapseDownIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M6 9l6 6l6 -6" })
      ] }),
      tablerIconProps
    );
    collapseUpIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M6 15l6 -6l6 6" })
      ] }),
      tablerIconProps
    );
    upIcon = createIcon(
      /* @__PURE__ */ jsxs2("g", { children: [
        /* @__PURE__ */ jsx4("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }),
        /* @__PURE__ */ jsx4("path", { d: "M6 15l6 -6l6 6" })
      ] }),
      tablerIconProps
    );
  }
});

// fonts/metadata.ts
var FONT_METADATA, RANGES, LOCAL_FONT_PROTOCOL;
var init_metadata = __esm({
  "fonts/metadata.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_icons();
    init_constants();
    FONT_METADATA = {
      [FONT_FAMILY.Excalifont]: {
        metrics: {
          unitsPerEm: 1e3,
          ascender: 886,
          descender: -374,
          lineHeight: 1.25
        },
        icon: FreedrawIcon
      },
      [FONT_FAMILY.Nunito]: {
        metrics: {
          unitsPerEm: 1e3,
          ascender: 1011,
          descender: -353,
          lineHeight: 1.35
        },
        icon: FontFamilyNormalIcon
      },
      [FONT_FAMILY["Lilita One"]]: {
        metrics: {
          unitsPerEm: 1e3,
          ascender: 923,
          descender: -220,
          lineHeight: 1.15
        },
        icon: FontFamilyHeadingIcon
      },
      [FONT_FAMILY["Comic Shanns"]]: {
        metrics: {
          unitsPerEm: 1e3,
          ascender: 750,
          descender: -250,
          lineHeight: 1.25
        },
        icon: FontFamilyCodeIcon
      },
      [FONT_FAMILY.Virgil]: {
        metrics: {
          unitsPerEm: 1e3,
          ascender: 886,
          descender: -374,
          lineHeight: 1.25
        },
        icon: FreedrawIcon,
        deprecated: true
      },
      [FONT_FAMILY.Helvetica]: {
        metrics: {
          unitsPerEm: 2048,
          ascender: 1577,
          descender: -471,
          lineHeight: 1.15
        },
        icon: FontFamilyNormalIcon,
        deprecated: true,
        local: true
      },
      [FONT_FAMILY.Cascadia]: {
        metrics: {
          unitsPerEm: 2048,
          ascender: 1900,
          descender: -480,
          lineHeight: 1.2
        },
        icon: FontFamilyCodeIcon,
        deprecated: true
      },
      [FONT_FAMILY["Liberation Sans"]]: {
        metrics: {
          unitsPerEm: 2048,
          ascender: 1854,
          descender: -434,
          lineHeight: 1.15
        },
        icon: FontFamilyNormalIcon,
        serverSide: true
      }
    };
    RANGES = {
      LATIN: "U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD",
      LATIN_EXT: "U+0100-02AF, U+0304, U+0308, U+0329, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF",
      CYRILIC_EXT: "U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F",
      CYRILIC: "U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116",
      VIETNAMESE: "U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+0300-0301, U+0303-0304, U+0308-0309, U+0323, U+0329, U+1EA0-1EF9, U+20AB"
    };
    LOCAL_FONT_PROTOCOL = "local:";
  }
});

// data/filesystem.ts
import {
  fileOpen as _fileOpen,
  fileSave as _fileSave,
  supported as nativeFileSystemSupported
} from "browser-fs-access";
var INPUT_CHANGE_INTERVAL_MS, fileOpen, fileSave;
var init_filesystem = __esm({
  "data/filesystem.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_errors();
    init_utils2();
    INPUT_CHANGE_INTERVAL_MS = 500;
    fileOpen = (opts) => {
      const mimeTypes = opts.extensions?.reduce((mimeTypes2, type) => {
        mimeTypes2.push(MIME_TYPES[type]);
        return mimeTypes2;
      }, []);
      const extensions = opts.extensions?.reduce((acc, ext) => {
        if (ext === "jpg") {
          return acc.concat(".jpg", ".jpeg");
        }
        return acc.concat(`.${ext}`);
      }, []);
      return _fileOpen({
        description: opts.description,
        extensions,
        mimeTypes,
        multiple: opts.multiple ?? false,
        legacySetup: (resolve, reject, input) => {
          const scheduleRejection = debounce(reject, INPUT_CHANGE_INTERVAL_MS);
          const focusHandler = () => {
            checkForFile();
            document.addEventListener("keyup" /* KEYUP */, scheduleRejection);
            document.addEventListener("pointerup" /* POINTER_UP */, scheduleRejection);
            scheduleRejection();
          };
          const checkForFile = () => {
            if (input.files?.length) {
              const ret = opts.multiple ? [...input.files] : input.files[0];
              resolve(ret);
            }
          };
          requestAnimationFrame(() => {
            window.addEventListener("focus" /* FOCUS */, focusHandler);
          });
          const interval = window.setInterval(() => {
            checkForFile();
          }, INPUT_CHANGE_INTERVAL_MS);
          return (rejectPromise) => {
            clearInterval(interval);
            scheduleRejection.cancel();
            window.removeEventListener("focus" /* FOCUS */, focusHandler);
            document.removeEventListener("keyup" /* KEYUP */, scheduleRejection);
            document.removeEventListener("pointerup" /* POINTER_UP */, scheduleRejection);
            if (rejectPromise) {
              console.warn("Opening the file was canceled (legacy-fs).");
              rejectPromise(new AbortError());
            }
          };
        }
      });
    };
    fileSave = (blob, opts) => {
      return _fileSave(
        blob,
        {
          fileName: `${opts.name}.${opts.extension}`,
          description: opts.description,
          extensions: [`.${opts.extension}`]
        },
        opts.fileHandle
      );
    };
  }
});

// data/json.ts
var filterOutDeletedFiles, serializeAsJSON, saveAsJSON, loadFromJSON, isValidExcalidrawData, isValidLibrary, serializeLibraryAsJSON, saveLibraryAsJSON;
var init_json = __esm({
  "data/json.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_filesystem();
    init_appState();
    init_constants();
    init_element();
    init_blob();
    filterOutDeletedFiles = (elements, files) => {
      const nextFiles = {};
      for (const element of elements) {
        if (!element.isDeleted && "fileId" in element && element.fileId && files[element.fileId]) {
          nextFiles[element.fileId] = files[element.fileId];
        }
      }
      return nextFiles;
    };
    serializeAsJSON = (elements, appState, files, type) => {
      const data = {
        type: EXPORT_DATA_TYPES.excalidraw,
        version: VERSIONS.excalidraw,
        source: EXPORT_SOURCE,
        elements: type === "local" ? clearElementsForExport(elements) : clearElementsForDatabase(elements),
        appState: type === "local" ? cleanAppStateForExport(appState) : clearAppStateForDatabase(appState),
        files: type === "local" ? filterOutDeletedFiles(elements, files) : (
          // will be stripped from JSON
          void 0
        )
      };
      return JSON.stringify(data, null, 2);
    };
    saveAsJSON = async (elements, appState, files, name = appState.name || DEFAULT_FILENAME) => {
      const serialized = serializeAsJSON(elements, appState, files, "local");
      const blob = new Blob([serialized], {
        type: MIME_TYPES.excalidraw
      });
      const fileHandle = await fileSave(blob, {
        name,
        extension: "excalidraw",
        description: "Excalidraw file",
        fileHandle: isImageFileHandle(appState.fileHandle) ? null : appState.fileHandle
      });
      return { fileHandle };
    };
    loadFromJSON = async (localAppState, localElements) => {
      const file2 = await fileOpen({
        description: "Excalidraw files"
        // ToDo: Be over-permissive until https://bugs.webkit.org/show_bug.cgi?id=34442
        // gets resolved. Else, iOS users cannot open `.excalidraw` files.
        // extensions: ["json", "excalidraw", "png", "svg"],
      });
      return loadFromBlob(
        await normalizeFile(file2),
        localAppState,
        localElements,
        file2.handle
      );
    };
    isValidExcalidrawData = (data) => {
      return data?.type === EXPORT_DATA_TYPES.excalidraw && (!data.elements || Array.isArray(data.elements) && (!data.appState || typeof data.appState === "object"));
    };
    isValidLibrary = (json) => {
      return typeof json === "object" && json && json.type === EXPORT_DATA_TYPES.excalidrawLibrary && (json.version === 1 || json.version === 2);
    };
    serializeLibraryAsJSON = (libraryItems) => {
      const data = {
        type: EXPORT_DATA_TYPES.excalidrawLibrary,
        version: VERSIONS.excalidrawLibrary,
        source: EXPORT_SOURCE,
        libraryItems
      };
      return JSON.stringify(data, null, 2);
    };
    saveLibraryAsJSON = async (libraryItems) => {
      const serialized = serializeLibraryAsJSON(libraryItems);
      await fileSave(
        new Blob([serialized], {
          type: MIME_TYPES.excalidrawlib
        }),
        {
          name: "library",
          extension: "excalidrawlib",
          description: "Excalidraw library file"
        }
      );
    };
  }
});

// points.ts
var getSizeFromPoints, rescalePoints;
var init_points = __esm({
  "points.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_math();
    getSizeFromPoints = (points) => {
      const xs = points.map((point2) => point2[0]);
      const ys = points.map((point2) => point2[1]);
      return {
        width: Math.max(...xs) - Math.min(...xs),
        height: Math.max(...ys) - Math.min(...ys)
      };
    };
    rescalePoints = (dimension, newSize, points, normalize) => {
      const coordinates = points.map((point2) => point2[dimension]);
      const maxCoordinate = Math.max(...coordinates);
      const minCoordinate = Math.min(...coordinates);
      const size = maxCoordinate - minCoordinate;
      const scale = size === 0 ? 1 : newSize / size;
      let nextMinCoordinate = Infinity;
      const scaledPoints = points.map((point2) => {
        const newCoordinate = point2[dimension] * scale;
        const newPoint = [...point2];
        newPoint[dimension] = newCoordinate;
        if (newCoordinate < nextMinCoordinate) {
          nextMinCoordinate = newCoordinate;
        }
        return newPoint;
      });
      if (!normalize) {
        return scaledPoints;
      }
      if (scaledPoints.length === 2) {
        return scaledPoints;
      }
      const translation2 = minCoordinate - nextMinCoordinate;
      const nextPoints = scaledPoints.map(
        (scaledPoint) => pointFromPair(
          scaledPoint.map((value, currentDimension) => {
            return currentDimension === dimension ? value + translation2 : value;
          })
        )
      );
      return nextPoints;
    };
  }
});

// ../math/ga/ga.ts
var point, offset, nvector, reverse, add, sub, mul, mulScalar, meet, join, joinScalar, dot, norm, inorm, normalized, inormalized, isNumber, E0, E1, E2, E01, E20, E12, E012;
var init_ga = __esm({
  "../math/ga/ga.ts"() {
    "use strict";
    init_define_import_meta_env();
    point = (x, y) => [0, 0, 0, 0, y, x, 1, 0];
    offset = (x, y) => [
      0,
      0,
      0,
      0,
      y,
      x,
      0,
      0
    ];
    nvector = (value = 0, index = 0) => {
      const result = [0, 0, 0, 0, 0, 0, 0, 0];
      if (index < 0 || index > 7) {
        throw new Error(`Expected \`index\` between 0 and 7, got \`${index}\``);
      }
      if (value !== 0) {
        result[index] = value;
      }
      return result;
    };
    reverse = (nvector2) => [
      nvector2[0],
      nvector2[1],
      nvector2[2],
      nvector2[3],
      -nvector2[4],
      -nvector2[5],
      -nvector2[6],
      -nvector2[7]
    ];
    add = (a, b) => {
      if (isNumber(b)) {
        return [a[0] + b, a[1], a[2], a[3], a[4], a[5], a[6], a[7]];
      }
      return [
        a[0] + b[0],
        a[1] + b[1],
        a[2] + b[2],
        a[3] + b[3],
        a[4] + b[4],
        a[5] + b[5],
        a[6] + b[6],
        a[7] + b[7]
      ];
    };
    sub = (a, b) => {
      if (isNumber(b)) {
        return [a[0] - b, a[1], a[2], a[3], a[4], a[5], a[6], a[7]];
      }
      return [
        a[0] - b[0],
        a[1] - b[1],
        a[2] - b[2],
        a[3] - b[3],
        a[4] - b[4],
        a[5] - b[5],
        a[6] - b[6],
        a[7] - b[7]
      ];
    };
    mul = (a, b) => {
      if (isNumber(b)) {
        return [
          a[0] * b,
          a[1] * b,
          a[2] * b,
          a[3] * b,
          a[4] * b,
          a[5] * b,
          a[6] * b,
          a[7] * b
        ];
      }
      return [
        mulScalar(a, b),
        b[1] * a[0] + b[0] * a[1] - b[4] * a[2] + b[5] * a[3] + b[2] * a[4] - b[3] * a[5] - b[7] * a[6] - b[6] * a[7],
        b[2] * a[0] + b[0] * a[2] - b[6] * a[3] + b[3] * a[6],
        b[3] * a[0] + b[6] * a[2] + b[0] * a[3] - b[2] * a[6],
        b[4] * a[0] + b[2] * a[1] - b[1] * a[2] + b[7] * a[3] + b[0] * a[4] + b[6] * a[5] - b[5] * a[6] + b[3] * a[7],
        b[5] * a[0] - b[3] * a[1] + b[7] * a[2] + b[1] * a[3] - b[6] * a[4] + b[0] * a[5] + b[4] * a[6] + b[2] * a[7],
        b[6] * a[0] + b[3] * a[2] - b[2] * a[3] + b[0] * a[6],
        b[7] * a[0] + b[6] * a[1] + b[5] * a[2] + b[4] * a[3] + b[3] * a[4] + b[2] * a[5] + b[1] * a[6] + b[0] * a[7]
      ];
    };
    mulScalar = (a, b) => b[0] * a[0] + b[2] * a[2] + b[3] * a[3] - b[6] * a[6];
    meet = (a, b) => [
      b[0] * a[0],
      b[1] * a[0] + b[0] * a[1],
      b[2] * a[0] + b[0] * a[2],
      b[3] * a[0] + b[0] * a[3],
      b[4] * a[0] + b[2] * a[1] - b[1] * a[2] + b[0] * a[4],
      b[5] * a[0] - b[3] * a[1] + b[1] * a[3] + b[0] * a[5],
      b[6] * a[0] + b[3] * a[2] - b[2] * a[3] + b[0] * a[6],
      b[7] * a[0] + b[6] * a[1] + b[5] * a[2] + b[4] * a[3] + b[3] * a[4] + b[2] * a[5] + b[1] * a[6]
    ];
    join = (a, b) => [
      joinScalar(a, b),
      a[1] * b[7] + a[4] * b[5] - a[5] * b[4] + a[7] * b[1],
      a[2] * b[7] - a[4] * b[6] + a[6] * b[4] + a[7] * b[2],
      a[3] * b[7] + a[5] * b[6] - a[6] * b[5] + a[7] * b[3],
      a[4] * b[7] + a[7] * b[4],
      a[5] * b[7] + a[7] * b[5],
      a[6] * b[7] + a[7] * b[6],
      a[7] * b[7]
    ];
    joinScalar = (a, b) => a[0] * b[7] + a[1] * b[6] + a[2] * b[5] + a[3] * b[4] + a[4] * b[3] + a[5] * b[2] + a[6] * b[1] + a[7] * b[0];
    dot = (a, b) => [
      b[0] * a[0] + b[2] * a[2] + b[3] * a[3] - b[6] * a[6],
      b[1] * a[0] + b[0] * a[1] - b[4] * a[2] + b[5] * a[3] + b[2] * a[4] - b[3] * a[5] - b[7] * a[6] - b[6] * a[7],
      b[2] * a[0] + b[0] * a[2] - b[6] * a[3] + b[3] * a[6],
      b[3] * a[0] + b[6] * a[2] + b[0] * a[3] - b[2] * a[6],
      b[4] * a[0] + b[7] * a[3] + b[0] * a[4] + b[3] * a[7],
      b[5] * a[0] + b[7] * a[2] + b[0] * a[5] + b[2] * a[7],
      b[6] * a[0] + b[0] * a[6],
      b[7] * a[0] + b[0] * a[7]
    ];
    norm = (a) => Math.sqrt(Math.abs(a[0] * a[0] - a[2] * a[2] - a[3] * a[3] + a[6] * a[6]));
    inorm = (a) => Math.sqrt(Math.abs(a[7] * a[7] - a[5] * a[5] - a[4] * a[4] + a[1] * a[1]));
    normalized = (a) => {
      const n = norm(a);
      if (n === 0 || n === 1) {
        return a;
      }
      const sign2 = a[6] < 0 ? -1 : 1;
      return mul(a, sign2 / n);
    };
    inormalized = (a) => {
      const n = inorm(a);
      if (n === 0 || n === 1) {
        return a;
      }
      return mul(a, 1 / n);
    };
    isNumber = (a) => typeof a === "number";
    E0 = nvector(1, 1);
    E1 = nvector(1, 2);
    E2 = nvector(1, 3);
    E01 = nvector(1, 4);
    E20 = nvector(1, 5);
    E12 = nvector(1, 6);
    E012 = nvector(1, 7);
  }
});

// ../math/ga/galines.ts
var equation, through, orthogonal, orthogonalThrough, sign;
var init_galines = __esm({
  "../math/ga/galines.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_ga();
    equation = (a, b, c) => normalized([0, c, a, b, 0, 0, 0, 0]);
    through = (from3, to) => normalized(join(to, from3));
    orthogonal = (line, point2) => dot(line, point2);
    orthogonalThrough = (against, intersection) => orthogonal(through(against, intersection), intersection);
    sign = (line) => Math.sign(line[1]);
  }
});

// ../math/ga/gapoints.ts
var from, toTuple, abs, intersect, distance2, distanceToLine;
var init_gapoints = __esm({
  "../math/ga/gapoints.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_ga();
    init_galines();
    init_ga();
    from = ([x, y]) => [
      0,
      0,
      0,
      0,
      y,
      x,
      1,
      0
    ];
    toTuple = (point2) => [point2[5], point2[4]];
    abs = (point2) => [
      0,
      0,
      0,
      0,
      Math.abs(point2[4]),
      Math.abs(point2[5]),
      1,
      0
    ];
    intersect = (line1, line2) => normalized(meet(line1, line2));
    distance2 = (point1, point2) => norm(join(point1, point2));
    distanceToLine = (point2, line) => joinScalar(point2, line);
  }
});

// ../math/ga/gadirections.ts
var from2, fromTo;
var init_gadirections = __esm({
  "../math/ga/gadirections.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_ga();
    from2 = (point2) => [
      0,
      0,
      0,
      0,
      point2[4],
      point2[5],
      0,
      0
    ];
    fromTo = (from3, to) => inormalized([0, 0, 0, 0, to[4] - from3[4], to[5] - from3[5], 0, 0]);
  }
});

// ../math/ga/gatransforms.ts
var rotation, translation, translationOrthogonal, compose, apply;
var init_gatransforms = __esm({
  "../math/ga/gatransforms.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_ga();
    init_gadirections();
    rotation = (pivot, angle) => add(mul(pivot, Math.sin(angle / 2)), Math.cos(angle / 2));
    translation = (direction) => [
      1,
      0,
      0,
      0,
      -(0.5 * direction[5]),
      0.5 * direction[4],
      0,
      0
    ];
    translationOrthogonal = (direction, distance3) => {
      const scale = 0.5 * distance3;
      return [1, 0, 0, 0, scale * direction[4], scale * direction[5], 0, 0];
    };
    compose = (motor1, motor2) => mul(motor2, motor1);
    apply = (motor, nvector2) => normalized(mul(mul(motor, nvector2), reverse(motor)));
  }
});

// ../utils/geometry/shape.ts
import { pointsOnBezierCurves } from "points-on-curve";
var getPolygonShape, getSelectionBoxShape, getEllipseShape, getCurvePathOps, getCurveShape, polylineFromPoints, getFreedrawShape, getClosedCurveShape, segmentIntersectRectangleElement, distanceToEllipse, pointOnEllipse, pointInEllipse;
var init_shape = __esm({
  "../utils/geometry/shape.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_math();
    init_element();
    init_utils2();
    getPolygonShape = (element) => {
      const { angle, width, height, x, y } = element;
      const cx = x + width / 2;
      const cy = y + height / 2;
      const center = pointFrom(cx, cy);
      let data;
      if (element.type === "diamond") {
        data = polygon(
          pointRotateRads(pointFrom(cx, y), center, angle),
          pointRotateRads(pointFrom(x + width, cy), center, angle),
          pointRotateRads(pointFrom(cx, y + height), center, angle),
          pointRotateRads(pointFrom(x, cy), center, angle)
        );
      } else {
        data = polygon(
          pointRotateRads(pointFrom(x, y), center, angle),
          pointRotateRads(pointFrom(x + width, y), center, angle),
          pointRotateRads(pointFrom(x + width, y + height), center, angle),
          pointRotateRads(pointFrom(x, y + height), center, angle)
        );
      }
      return {
        type: "polygon",
        data
      };
    };
    getSelectionBoxShape = (element, elementsMap, padding = 10) => {
      let [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(
        element,
        elementsMap,
        true
      );
      x1 -= padding;
      x2 += padding;
      y1 -= padding;
      y2 += padding;
      const center = pointFrom(cx, cy);
      const topLeft = pointRotateRads(pointFrom(x1, y1), center, element.angle);
      const topRight = pointRotateRads(pointFrom(x2, y1), center, element.angle);
      const bottomLeft = pointRotateRads(pointFrom(x1, y2), center, element.angle);
      const bottomRight = pointRotateRads(pointFrom(x2, y2), center, element.angle);
      return {
        type: "polygon",
        data: [topLeft, topRight, bottomRight, bottomLeft]
      };
    };
    getEllipseShape = (element) => {
      const { width, height, angle, x, y } = element;
      return {
        type: "ellipse",
        data: {
          center: pointFrom(x + width / 2, y + height / 2),
          angle,
          halfWidth: width / 2,
          halfHeight: height / 2
        }
      };
    };
    getCurvePathOps = (shape) => {
      for (const set of shape.sets) {
        if (set.type === "path") {
          return set.ops;
        }
      }
      return shape.sets[0].ops;
    };
    getCurveShape = (roughShape, startingPoint = pointFrom(0, 0), angleInRadian, center) => {
      const transform = (p) => pointRotateRads(
        pointFrom(p[0] + startingPoint[0], p[1] + startingPoint[1]),
        center,
        angleInRadian
      );
      const ops = getCurvePathOps(roughShape);
      const polycurve = [];
      let p0 = pointFrom(0, 0);
      for (const op of ops) {
        if (op.op === "move") {
          const p = pointFromArray(op.data);
          invariant(p != null, "Ops data is not a point");
          p0 = transform(p);
        }
        if (op.op === "bcurveTo") {
          const p1 = transform(pointFrom(op.data[0], op.data[1]));
          const p2 = transform(pointFrom(op.data[2], op.data[3]));
          const p3 = transform(pointFrom(op.data[4], op.data[5]));
          polycurve.push(curve(p0, p1, p2, p3));
          p0 = p3;
        }
      }
      return {
        type: "polycurve",
        data: polycurve
      };
    };
    polylineFromPoints = (points) => {
      let previousPoint = points[0];
      const polyline = [];
      for (let i = 1; i < points.length; i++) {
        const nextPoint = points[i];
        polyline.push(lineSegment(previousPoint, nextPoint));
        previousPoint = nextPoint;
      }
      return polyline;
    };
    getFreedrawShape = (element, center, isClosed = false) => {
      const transform = (p) => pointRotateRads(
        pointFromVector(
          vectorAdd(vectorFromPoint(p), vector(element.x, element.y))
        ),
        center,
        element.angle
      );
      const polyline = polylineFromPoints(
        element.points.map((p) => transform(p))
      );
      return isClosed ? {
        type: "polygon",
        data: polygonFromPoints(polyline.flat())
      } : {
        type: "polyline",
        data: polyline
      };
    };
    getClosedCurveShape = (element, roughShape, startingPoint = pointFrom(0, 0), angleInRadian, center) => {
      const transform = (p) => pointRotateRads(
        pointFrom(p[0] + startingPoint[0], p[1] + startingPoint[1]),
        center,
        angleInRadian
      );
      if (element.roundness === null) {
        return {
          type: "polygon",
          data: polygonFromPoints(
            element.points.map((p) => transform(p))
          )
        };
      }
      const ops = getCurvePathOps(roughShape);
      const points = [];
      let odd = false;
      for (const operation of ops) {
        if (operation.op === "move") {
          odd = !odd;
          if (odd) {
            points.push(pointFrom(operation.data[0], operation.data[1]));
          }
        } else if (operation.op === "bcurveTo") {
          if (odd) {
            points.push(pointFrom(operation.data[0], operation.data[1]));
            points.push(pointFrom(operation.data[2], operation.data[3]));
            points.push(pointFrom(operation.data[4], operation.data[5]));
          }
        } else if (operation.op === "lineTo") {
          if (odd) {
            points.push(pointFrom(operation.data[0], operation.data[1]));
          }
        }
      }
      const polygonPoints = pointsOnBezierCurves(points, 10, 5).map(
        (p) => transform(p)
      );
      return {
        type: "polygon",
        data: polygonFromPoints(polygonPoints)
      };
    };
    segmentIntersectRectangleElement = (element, segment, gap = 0) => {
      const bounds = [
        element.x - gap,
        element.y - gap,
        element.x + element.width + gap,
        element.y + element.height + gap
      ];
      const center = pointFrom(
        (bounds[0] + bounds[2]) / 2,
        (bounds[1] + bounds[3]) / 2
      );
      return [
        lineSegment(
          pointRotateRads(pointFrom(bounds[0], bounds[1]), center, element.angle),
          pointRotateRads(pointFrom(bounds[2], bounds[1]), center, element.angle)
        ),
        lineSegment(
          pointRotateRads(pointFrom(bounds[2], bounds[1]), center, element.angle),
          pointRotateRads(pointFrom(bounds[2], bounds[3]), center, element.angle)
        ),
        lineSegment(
          pointRotateRads(pointFrom(bounds[2], bounds[3]), center, element.angle),
          pointRotateRads(pointFrom(bounds[0], bounds[3]), center, element.angle)
        ),
        lineSegment(
          pointRotateRads(pointFrom(bounds[0], bounds[3]), center, element.angle),
          pointRotateRads(pointFrom(bounds[0], bounds[1]), center, element.angle)
        )
      ].map((s) => segmentsIntersectAt(segment, s)).filter((i) => !!i);
    };
    distanceToEllipse = (p, ellipse) => {
      const { angle, halfWidth, halfHeight, center } = ellipse;
      const a = halfWidth;
      const b = halfHeight;
      const translatedPoint = vectorAdd(
        vectorFromPoint(p),
        vectorScale(vectorFromPoint(center), -1)
      );
      const [rotatedPointX, rotatedPointY] = pointRotateRads(
        pointFromVector(translatedPoint),
        pointFrom(0, 0),
        -angle
      );
      const px = Math.abs(rotatedPointX);
      const py = Math.abs(rotatedPointY);
      let tx = 0.707;
      let ty = 0.707;
      for (let i = 0; i < 3; i++) {
        const x = a * tx;
        const y = b * ty;
        const ex = (a * a - b * b) * tx ** 3 / a;
        const ey = (b * b - a * a) * ty ** 3 / b;
        const rx = x - ex;
        const ry = y - ey;
        const qx = px - ex;
        const qy = py - ey;
        const r = Math.hypot(ry, rx);
        const q = Math.hypot(qy, qx);
        tx = Math.min(1, Math.max(0, (qx * r / q + ex) / a));
        ty = Math.min(1, Math.max(0, (qy * r / q + ey) / b));
        const t2 = Math.hypot(ty, tx);
        tx /= t2;
        ty /= t2;
      }
      const [minX, minY] = [
        a * tx * Math.sign(rotatedPointX),
        b * ty * Math.sign(rotatedPointY)
      ];
      return pointDistance(
        pointFrom(rotatedPointX, rotatedPointY),
        pointFrom(minX, minY)
      );
    };
    pointOnEllipse = (point2, ellipse, threshold = PRECISION) => {
      return distanceToEllipse(point2, ellipse) <= threshold;
    };
    pointInEllipse = (p, ellipse) => {
      const { center, angle, halfWidth, halfHeight } = ellipse;
      const translatedPoint = vectorAdd(
        vectorFromPoint(p),
        vectorScale(vectorFromPoint(center), -1)
      );
      const [rotatedPointX, rotatedPointY] = pointRotateRads(
        pointFromVector(translatedPoint),
        pointFrom(0, 0),
        -angle
      );
      return rotatedPointX / halfWidth * (rotatedPointX / halfWidth) + rotatedPointY / halfHeight * (rotatedPointY / halfHeight) <= 1;
    };
  }
});

// ../utils/collision.ts
var isPointOnShape, isPointInShape, pointOnPolycurve, cubicBezierEquation, polyLineFromCurve, pointOnCurve, pointOnPolyline;
var init_collision = __esm({
  "../utils/collision.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_shape();
    init_math();
    isPointOnShape = (point2, shape, tolerance = 0) => {
      switch (shape.type) {
        case "polygon":
          return pointOnPolygon(point2, shape.data, tolerance);
        case "ellipse":
          return pointOnEllipse(point2, shape.data, tolerance);
        case "line":
          return pointOnLineSegment(point2, shape.data, tolerance);
        case "polyline":
          return pointOnPolyline(point2, shape.data, tolerance);
        case "curve":
          return pointOnCurve(point2, shape.data, tolerance);
        case "polycurve":
          return pointOnPolycurve(point2, shape.data, tolerance);
        default:
          throw Error(`shape ${shape} is not implemented`);
      }
    };
    isPointInShape = (point2, shape) => {
      switch (shape.type) {
        case "polygon":
          return polygonIncludesPoint(point2, shape.data);
        case "line":
          return false;
        case "curve":
          return false;
        case "ellipse":
          return pointInEllipse(point2, shape.data);
        case "polyline": {
          const polygon2 = polygonFromPoints(shape.data.flat());
          return polygonIncludesPoint(point2, polygon2);
        }
        case "polycurve": {
          return false;
        }
        default:
          throw Error(`shape ${shape} is not implemented`);
      }
    };
    pointOnPolycurve = (point2, polycurve, tolerance) => {
      return polycurve.some((curve2) => pointOnCurve(point2, curve2, tolerance));
    };
    cubicBezierEquation = (curve2) => {
      const [p0, p1, p2, p3] = curve2;
      return (t2, idx) => Math.pow(1 - t2, 3) * p3[idx] + 3 * t2 * Math.pow(1 - t2, 2) * p2[idx] + 3 * Math.pow(t2, 2) * (1 - t2) * p1[idx] + p0[idx] * Math.pow(t2, 3);
    };
    polyLineFromCurve = (curve2, segments = 10) => {
      const equation2 = cubicBezierEquation(curve2);
      let startingPoint = [equation2(0, 0), equation2(0, 1)];
      const lineSegments = [];
      let t2 = 0;
      const increment = 1 / segments;
      for (let i = 0; i < segments; i++) {
        t2 += increment;
        if (t2 <= 1) {
          const nextPoint = pointFrom(equation2(t2, 0), equation2(t2, 1));
          lineSegments.push(lineSegment(startingPoint, nextPoint));
          startingPoint = nextPoint;
        }
      }
      return lineSegments;
    };
    pointOnCurve = (point2, curve2, threshold) => {
      return pointOnPolyline(point2, polyLineFromCurve(curve2), threshold);
    };
    pointOnPolyline = (point2, polyline, threshold = 1e-4) => {
      return polyline.some((line) => pointOnLineSegment(point2, line, threshold));
    };
  }
});

// keys.ts
var CODES, KEYS, isArrowKey, shouldResizeFromCenter, shouldMaintainAspectRatio, shouldRotateWithDiscreteAngle;
var init_keys = __esm({
  "keys.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    CODES = {
      EQUAL: "Equal",
      MINUS: "Minus",
      NUM_ADD: "NumpadAdd",
      NUM_SUBTRACT: "NumpadSubtract",
      NUM_ZERO: "Numpad0",
      BRACKET_RIGHT: "BracketRight",
      BRACKET_LEFT: "BracketLeft",
      ONE: "Digit1",
      TWO: "Digit2",
      THREE: "Digit3",
      NINE: "Digit9",
      QUOTE: "Quote",
      ZERO: "Digit0",
      SLASH: "Slash",
      C: "KeyC",
      D: "KeyD",
      H: "KeyH",
      V: "KeyV",
      Z: "KeyZ",
      R: "KeyR",
      S: "KeyS"
    };
    KEYS = {
      ARROW_DOWN: "ArrowDown",
      ARROW_LEFT: "ArrowLeft",
      ARROW_RIGHT: "ArrowRight",
      ARROW_UP: "ArrowUp",
      PAGE_UP: "PageUp",
      PAGE_DOWN: "PageDown",
      BACKSPACE: "Backspace",
      ALT: "Alt",
      CTRL_OR_CMD: isDarwin ? "metaKey" : "ctrlKey",
      DELETE: "Delete",
      ENTER: "Enter",
      ESCAPE: "Escape",
      QUESTION_MARK: "?",
      SPACE: " ",
      TAB: "Tab",
      CHEVRON_LEFT: "<",
      CHEVRON_RIGHT: ">",
      PERIOD: ".",
      COMMA: ",",
      SUBTRACT: "-",
      SLASH: "/",
      A: "a",
      C: "c",
      D: "d",
      E: "e",
      F: "f",
      G: "g",
      H: "h",
      I: "i",
      L: "l",
      O: "o",
      P: "p",
      Q: "q",
      R: "r",
      S: "s",
      T: "t",
      V: "v",
      X: "x",
      Y: "y",
      Z: "z",
      K: "k",
      W: "w",
      0: "0",
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9"
    };
    isArrowKey = (key) => key === KEYS.ARROW_LEFT || key === KEYS.ARROW_RIGHT || key === KEYS.ARROW_DOWN || key === KEYS.ARROW_UP;
    shouldResizeFromCenter = (event) => event.altKey;
    shouldMaintainAspectRatio = (event) => event.shiftKey;
    shouldRotateWithDiscreteAngle = (event) => event.shiftKey;
  }
});

// element/collision.ts
var shouldTestInside, hitElementItself, hitElementBoundingBox, hitElementBoundingBoxOnly, hitElementBoundText;
var init_collision2 = __esm({
  "element/collision.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_bounds();
    init_shape();
    init_collision();
    init_utils2();
    init_typeChecks();
    init_shapes();
    init_math();
    shouldTestInside = (element) => {
      if (element.type === "arrow") {
        return false;
      }
      const isDraggableFromInside = !isTransparent(element.backgroundColor) || hasBoundTextElement(element) || isIframeLikeElement(element) || isTextElement(element);
      if (element.type === "line") {
        return isDraggableFromInside && isPathALoop(element.points);
      }
      if (element.type === "freedraw") {
        return isDraggableFromInside && isPathALoop(element.points);
      }
      return isDraggableFromInside || isImageElement(element);
    };
    hitElementItself = ({
      x,
      y,
      element,
      shape,
      threshold = 10,
      frameNameBound = null
    }) => {
      let hit = shouldTestInside(element) ? (
        // Since `inShape` tests STRICTLY againt the insides of a shape
        // we would need `onShape` as well to include the "borders"
        isPointInShape(pointFrom(x, y), shape) || isPointOnShape(pointFrom(x, y), shape, threshold)
      ) : isPointOnShape(pointFrom(x, y), shape, threshold);
      if (!hit && frameNameBound) {
        hit = isPointInShape(pointFrom(x, y), {
          type: "polygon",
          data: getPolygonShape(frameNameBound).data
        });
      }
      return hit;
    };
    hitElementBoundingBox = (x, y, element, elementsMap, tolerance = 0) => {
      let [x1, y1, x2, y2] = getElementBounds(element, elementsMap);
      x1 -= tolerance;
      y1 -= tolerance;
      x2 += tolerance;
      y2 += tolerance;
      return isPointWithinBounds(
        pointFrom(x1, y1),
        pointFrom(x, y),
        pointFrom(x2, y2)
      );
    };
    hitElementBoundingBoxOnly = (hitArgs, elementsMap) => {
      return !hitElementItself(hitArgs) && // bound text is considered part of the element (even if it's outside the bounding box)
      !hitElementBoundText(
        hitArgs.x,
        hitArgs.y,
        getBoundTextShape(hitArgs.element, elementsMap)
      ) && hitElementBoundingBox(hitArgs.x, hitArgs.y, hitArgs.element, elementsMap);
    };
    hitElementBoundText = (x, y, textShape) => {
      return !!textShape && isPointInShape(pointFrom(x, y), textShape);
    };
  }
});

// shapes.tsx
var SHAPES, findShapeByKey, getElementShape, getBoundTextShape, getControlPointsForBezierCurve, getBezierXY, getPointsInBezierCurve, getBezierCurveArcLengths, getBezierCurveLength, mapIntervalToBezierT, aabbForElement, pointInsideBounds, getCornerRadius, isPathALoop;
var init_shapes = __esm({
  "shapes.tsx"() {
    "use strict";
    init_define_import_meta_env();
    init_math();
    init_shape();
    init_icons();
    init_constants();
    init_element();
    init_collision2();
    init_linearElementEditor();
    init_textElement();
    init_keys();
    init_ShapeCache();
    init_utils2();
    SHAPES = [
      {
        icon: SelectionIcon,
        value: "selection",
        key: KEYS.V,
        numericKey: KEYS["1"],
        fillable: true
      },
      {
        icon: RectangleIcon,
        value: "rectangle",
        key: KEYS.R,
        numericKey: KEYS["2"],
        fillable: true
      },
      {
        icon: DiamondIcon,
        value: "diamond",
        key: KEYS.D,
        numericKey: KEYS["3"],
        fillable: true
      },
      {
        icon: EllipseIcon,
        value: "ellipse",
        key: KEYS.O,
        numericKey: KEYS["4"],
        fillable: true
      },
      {
        icon: ArrowIcon,
        value: "arrow",
        key: KEYS.A,
        numericKey: KEYS["5"],
        fillable: true
      },
      {
        icon: LineIcon,
        value: "line",
        key: KEYS.L,
        numericKey: KEYS["6"],
        fillable: true
      },
      {
        icon: FreedrawIcon,
        value: "freedraw",
        key: [KEYS.P, KEYS.X],
        numericKey: KEYS["7"],
        fillable: false
      },
      {
        icon: TextIcon,
        value: "text",
        key: KEYS.T,
        numericKey: KEYS["8"],
        fillable: false
      },
      {
        icon: ImageIcon,
        value: "image",
        key: null,
        numericKey: KEYS["9"],
        fillable: false
      },
      {
        icon: EraserIcon,
        value: "eraser",
        key: KEYS.E,
        numericKey: KEYS["0"],
        fillable: false
      }
    ];
    findShapeByKey = (key) => {
      const shape = SHAPES.find((shape2, index) => {
        return shape2.numericKey != null && key === shape2.numericKey.toString() || shape2.key && (typeof shape2.key === "string" ? shape2.key === key : shape2.key.includes(key));
      });
      return shape?.value || null;
    };
    getElementShape = (element, elementsMap) => {
      switch (element.type) {
        case "rectangle":
        case "diamond":
        case "frame":
        case "magicframe":
        case "embeddable":
        case "image":
        case "iframe":
        case "text":
        case "selection":
          return getPolygonShape(element);
        case "arrow":
        case "line": {
          const roughShape = ShapeCache.get(element)?.[0] ?? ShapeCache.generateElementShape(element, null)[0];
          const [, , , , cx, cy] = getElementAbsoluteCoords(element, elementsMap);
          return shouldTestInside(element) ? getClosedCurveShape(
            element,
            roughShape,
            pointFrom(element.x, element.y),
            element.angle,
            pointFrom(cx, cy)
          ) : getCurveShape(
            roughShape,
            pointFrom(element.x, element.y),
            element.angle,
            pointFrom(cx, cy)
          );
        }
        case "ellipse":
          return getEllipseShape(element);
        case "freedraw": {
          const [, , , , cx, cy] = getElementAbsoluteCoords(element, elementsMap);
          return getFreedrawShape(
            element,
            pointFrom(cx, cy),
            shouldTestInside(element)
          );
        }
      }
    };
    getBoundTextShape = (element, elementsMap) => {
      const boundTextElement = getBoundTextElement(element, elementsMap);
      if (boundTextElement) {
        if (element.type === "arrow") {
          return getElementShape(
            {
              ...boundTextElement,
              // arrow's bound text accurate position is not stored in the element's property
              // but rather calculated and returned from the following static method
              ...LinearElementEditor.getBoundTextElementPosition(
                element,
                boundTextElement,
                elementsMap
              )
            },
            elementsMap
          );
        }
        return getElementShape(boundTextElement, elementsMap);
      }
      return null;
    };
    getControlPointsForBezierCurve = (element, endPoint) => {
      const shape = ShapeCache.generateElementShape(element, null);
      if (!shape) {
        return null;
      }
      const ops = getCurvePathOps(shape[0]);
      let currentP = pointFrom(0, 0);
      let index = 0;
      let minDistance = Infinity;
      let controlPoints = null;
      while (index < ops.length) {
        const { op, data } = ops[index];
        if (op === "move") {
          invariant(
            isPoint(data),
            "The returned ops is not compatible with a point"
          );
          currentP = pointFromPair(data);
        }
        if (op === "bcurveTo") {
          const p0 = currentP;
          const p1 = pointFrom(data[0], data[1]);
          const p2 = pointFrom(data[2], data[3]);
          const p3 = pointFrom(data[4], data[5]);
          const distance3 = pointDistance(p3, endPoint);
          if (distance3 < minDistance) {
            minDistance = distance3;
            controlPoints = [p0, p1, p2, p3];
          }
          currentP = p3;
        }
        index++;
      }
      return controlPoints;
    };
    getBezierXY = (p0, p1, p2, p3, t2) => {
      const equation2 = (t3, idx) => Math.pow(1 - t3, 3) * p3[idx] + 3 * t3 * Math.pow(1 - t3, 2) * p2[idx] + 3 * Math.pow(t3, 2) * (1 - t3) * p1[idx] + p0[idx] * Math.pow(t3, 3);
      const tx = equation2(t2, 0);
      const ty = equation2(t2, 1);
      return pointFrom(tx, ty);
    };
    getPointsInBezierCurve = (element, endPoint) => {
      const controlPoints = getControlPointsForBezierCurve(element, endPoint);
      if (!controlPoints) {
        return [];
      }
      const pointsOnCurve = [];
      let t2 = 1;
      while (t2 > 0) {
        const p = getBezierXY(
          controlPoints[0],
          controlPoints[1],
          controlPoints[2],
          controlPoints[3],
          t2
        );
        pointsOnCurve.push(pointFrom(p[0], p[1]));
        t2 -= 0.05;
      }
      if (pointsOnCurve.length) {
        if (pointsEqual(pointsOnCurve.at(-1), endPoint)) {
          pointsOnCurve.push(pointFrom(endPoint[0], endPoint[1]));
        }
      }
      return pointsOnCurve;
    };
    getBezierCurveArcLengths = (element, endPoint) => {
      const arcLengths = [];
      arcLengths[0] = 0;
      const points = getPointsInBezierCurve(element, endPoint);
      let index = 0;
      let distance3 = 0;
      while (index < points.length - 1) {
        const segmentDistance = pointDistance(points[index], points[index + 1]);
        distance3 += segmentDistance;
        arcLengths.push(distance3);
        index++;
      }
      return arcLengths;
    };
    getBezierCurveLength = (element, endPoint) => {
      const arcLengths = getBezierCurveArcLengths(element, endPoint);
      return arcLengths.at(-1);
    };
    mapIntervalToBezierT = (element, endPoint, interval) => {
      const arcLengths = getBezierCurveArcLengths(element, endPoint);
      const pointsCount = arcLengths.length - 1;
      const curveLength = arcLengths.at(-1);
      const targetLength = interval * curveLength;
      let low = 0;
      let high = pointsCount;
      let index = 0;
      while (low < high) {
        index = Math.floor(low + (high - low) / 2);
        if (arcLengths[index] < targetLength) {
          low = index + 1;
        } else {
          high = index;
        }
      }
      if (arcLengths[index] > targetLength) {
        index--;
      }
      if (arcLengths[index] === targetLength) {
        return index / pointsCount;
      }
      return 1 - (index + (targetLength - arcLengths[index]) / (arcLengths[index + 1] - arcLengths[index])) / pointsCount;
    };
    aabbForElement = (element, offset2) => {
      const bbox = {
        minX: element.x,
        minY: element.y,
        maxX: element.x + element.width,
        maxY: element.y + element.height,
        midX: element.x + element.width / 2,
        midY: element.y + element.height / 2
      };
      const center = pointFrom(bbox.midX, bbox.midY);
      const [topLeftX, topLeftY] = pointRotateRads(
        pointFrom(bbox.minX, bbox.minY),
        center,
        element.angle
      );
      const [topRightX, topRightY] = pointRotateRads(
        pointFrom(bbox.maxX, bbox.minY),
        center,
        element.angle
      );
      const [bottomRightX, bottomRightY] = pointRotateRads(
        pointFrom(bbox.maxX, bbox.maxY),
        center,
        element.angle
      );
      const [bottomLeftX, bottomLeftY] = pointRotateRads(
        pointFrom(bbox.minX, bbox.maxY),
        center,
        element.angle
      );
      const bounds = [
        Math.min(topLeftX, topRightX, bottomRightX, bottomLeftX),
        Math.min(topLeftY, topRightY, bottomRightY, bottomLeftY),
        Math.max(topLeftX, topRightX, bottomRightX, bottomLeftX),
        Math.max(topLeftY, topRightY, bottomRightY, bottomLeftY)
      ];
      if (offset2) {
        const [topOffset, rightOffset, downOffset, leftOffset] = offset2;
        return [
          bounds[0] - leftOffset,
          bounds[1] - topOffset,
          bounds[2] + rightOffset,
          bounds[3] + downOffset
        ];
      }
      return bounds;
    };
    pointInsideBounds = (p, bounds) => p[0] > bounds[0] && p[0] < bounds[2] && p[1] > bounds[1] && p[1] < bounds[3];
    getCornerRadius = (x, element) => {
      if (element.roundness?.type === ROUNDNESS.PROPORTIONAL_RADIUS || element.roundness?.type === ROUNDNESS.LEGACY) {
        return x * DEFAULT_PROPORTIONAL_RADIUS;
      }
      if (element.roundness?.type === ROUNDNESS.ADAPTIVE_RADIUS) {
        const fixedRadiusSize = element.roundness?.value ?? DEFAULT_ADAPTIVE_RADIUS;
        const CUTOFF_SIZE = fixedRadiusSize / DEFAULT_PROPORTIONAL_RADIUS;
        if (x <= CUTOFF_SIZE) {
          return x * DEFAULT_PROPORTIONAL_RADIUS;
        }
        return fixedRadiusSize;
      }
      return 0;
    };
    isPathALoop = (points, zoomValue = 1) => {
      if (points.length >= 3) {
        const [first, last] = [points[0], points[points.length - 1]];
        const distance3 = pointDistance(first, last);
        return distance3 <= LINE_CONFIRM_THRESHOLD / zoomValue;
      }
      return false;
    };
  }
});

// element/heading.ts
var HEADING_RIGHT, HEADING_DOWN, HEADING_LEFT, HEADING_UP, headingForDiamond, vectorToHeading, compareHeading, headingForPointFromElement, flipHeading;
var init_heading = __esm({
  "element/heading.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_math();
    init_bounds();
    HEADING_RIGHT = [1, 0];
    HEADING_DOWN = [0, 1];
    HEADING_LEFT = [-1, 0];
    HEADING_UP = [0, -1];
    headingForDiamond = (a, b) => {
      const angle = radiansToDegrees(
        Math.atan2(b[1] - a[1], b[0] - a[0])
      );
      if (angle >= 315 || angle < 45) {
        return HEADING_UP;
      } else if (angle >= 45 && angle < 135) {
        return HEADING_RIGHT;
      } else if (angle >= 135 && angle < 225) {
        return HEADING_DOWN;
      }
      return HEADING_LEFT;
    };
    vectorToHeading = (vec) => {
      const [x, y] = vec;
      const absX = Math.abs(x);
      const absY = Math.abs(y);
      if (x > absY) {
        return HEADING_RIGHT;
      } else if (x <= -absY) {
        return HEADING_LEFT;
      } else if (y > absX) {
        return HEADING_DOWN;
      }
      return HEADING_UP;
    };
    compareHeading = (a, b) => a[0] === b[0] && a[1] === b[1];
    headingForPointFromElement = (element, aabb, p) => {
      const SEARCH_CONE_MULTIPLIER = 2;
      const midPoint = getCenterForBounds(aabb);
      if (element.type === "diamond") {
        if (p[0] < element.x) {
          return HEADING_LEFT;
        } else if (p[1] < element.y) {
          return HEADING_UP;
        } else if (p[0] > element.x + element.width) {
          return HEADING_RIGHT;
        } else if (p[1] > element.y + element.height) {
          return HEADING_DOWN;
        }
        const top = pointRotateRads(
          pointScaleFromOrigin(
            pointFrom(element.x + element.width / 2, element.y),
            midPoint,
            SEARCH_CONE_MULTIPLIER
          ),
          midPoint,
          element.angle
        );
        const right = pointRotateRads(
          pointScaleFromOrigin(
            pointFrom(element.x + element.width, element.y + element.height / 2),
            midPoint,
            SEARCH_CONE_MULTIPLIER
          ),
          midPoint,
          element.angle
        );
        const bottom = pointRotateRads(
          pointScaleFromOrigin(
            pointFrom(element.x + element.width / 2, element.y + element.height),
            midPoint,
            SEARCH_CONE_MULTIPLIER
          ),
          midPoint,
          element.angle
        );
        const left = pointRotateRads(
          pointScaleFromOrigin(
            pointFrom(element.x, element.y + element.height / 2),
            midPoint,
            SEARCH_CONE_MULTIPLIER
          ),
          midPoint,
          element.angle
        );
        if (triangleIncludesPoint([top, right, midPoint], p)) {
          return headingForDiamond(top, right);
        } else if (triangleIncludesPoint([right, bottom, midPoint], p)) {
          return headingForDiamond(right, bottom);
        } else if (triangleIncludesPoint([bottom, left, midPoint], p)) {
          return headingForDiamond(bottom, left);
        }
        return headingForDiamond(left, top);
      }
      const topLeft = pointScaleFromOrigin(
        pointFrom(aabb[0], aabb[1]),
        midPoint,
        SEARCH_CONE_MULTIPLIER
      );
      const topRight = pointScaleFromOrigin(
        pointFrom(aabb[2], aabb[1]),
        midPoint,
        SEARCH_CONE_MULTIPLIER
      );
      const bottomLeft = pointScaleFromOrigin(
        pointFrom(aabb[0], aabb[3]),
        midPoint,
        SEARCH_CONE_MULTIPLIER
      );
      const bottomRight = pointScaleFromOrigin(
        pointFrom(aabb[2], aabb[3]),
        midPoint,
        SEARCH_CONE_MULTIPLIER
      );
      return triangleIncludesPoint(
        [topLeft, topRight, midPoint],
        p
      ) ? HEADING_UP : triangleIncludesPoint(
        [topRight, bottomRight, midPoint],
        p
      ) ? HEADING_RIGHT : triangleIncludesPoint(
        [bottomRight, bottomLeft, midPoint],
        p
      ) ? HEADING_DOWN : HEADING_LEFT;
    };
    flipHeading = (h) => [
      h[0] === 0 ? 0 : h[0] > 0 ? -1 : 1,
      h[1] === 0 ? 0 : h[1] > 0 ? -1 : 1
    ];
  }
});

// element/binding.ts
var shouldEnableBindingForPointerEvent, isBindingEnabled, FIXED_BINDING_DISTANCE, getNonDeletedElements, bindOrUnbindLinearElement, bindOrUnbindLinearElementEdge, getOriginalBindingIfStillCloseOfLinearElementEdge, getOriginalBindingsIfStillCloseToArrowEnds, getBindingStrategyForDraggingArrowEndpoints, getBindingStrategyForDraggingArrowOrJoints, bindOrUnbindLinearElements, getSuggestedBindingsForArrows, maybeBindLinearElement, bindLinearElement, isLinearElementSimpleAndAlreadyBoundOnOppositeEdge, isLinearElementSimpleAndAlreadyBound, isLinearElementSimple, unbindLinearElement, getHoveredElementForBinding, calculateFocusAndGap, updateBoundElements, doesNeedUpdate, getSimultaneouslyUpdatedElementIds, getHeadingForElbowArrowSnap, getDistanceForBinding, bindPointToSnapToElementOutline, headingToMidBindPoint, avoidRectangularCorner, snapToMid, updateBoundPoint, calculateFixedPointForElbowArrowBinding, maybeCalculateNewGapWhenScaling, getElligibleElementForBindingElement, getLinearElementEdgeCoors, fixBindingsAfterDuplication, newBindingAfterDuplication, fixBindingsAfterDeletion, newBoundElements, bindingBorderTest, maxBindingGap, distanceToBindableElement, distanceToRectangle, distanceToDiamond, distanceToEllipse2, ellipseParamsForTest, pointRelativeToElement, relativizationToElementCenter, coordsCenter, determineFocusDistance, determineFocusPoint, intersectElementWithLine, getSortedElementLineIntersections, getCorners, intersectSegment, offsetSegment, getEllipseIntersections, getCircleIntersections, findFocusPointForEllipse, findFocusPointForRectangulars, bindingProperties, boundElementsVisitor, bindableElementsVisitor, BoundElement, BindableElement, getGlobalFixedPointForBindableElement, getGlobalFixedPoints, getArrowLocalFixedPoints, normalizeFixedPoint;
var init_binding = __esm({
  "element/binding.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_ga();
    init_gapoints();
    init_gadirections();
    init_galines();
    init_gatransforms();
    init_bounds();
    init_collision();
    init_scene();
    init_typeChecks();
    init_mutateElement();
    init_linearElementEditor();
    init_utils2();
    init_keys();
    init_textElement();
    init_shapes();
    init_heading();
    init_math();
    init_shape();
    shouldEnableBindingForPointerEvent = (event) => {
      return !event[KEYS.CTRL_OR_CMD];
    };
    isBindingEnabled = (appState) => {
      return appState.isBindingEnabled;
    };
    FIXED_BINDING_DISTANCE = 5;
    getNonDeletedElements = (scene, ids) => {
      const result = [];
      ids.forEach((id) => {
        const element = scene.getNonDeletedElement(id);
        if (element != null) {
          result.push(element);
        }
      });
      return result;
    };
    bindOrUnbindLinearElement = (linearElement, startBindingElement, endBindingElement, elementsMap, scene) => {
      const boundToElementIds = /* @__PURE__ */ new Set();
      const unboundFromElementIds = /* @__PURE__ */ new Set();
      bindOrUnbindLinearElementEdge(
        linearElement,
        startBindingElement,
        endBindingElement,
        "start",
        boundToElementIds,
        unboundFromElementIds,
        elementsMap
      );
      bindOrUnbindLinearElementEdge(
        linearElement,
        endBindingElement,
        startBindingElement,
        "end",
        boundToElementIds,
        unboundFromElementIds,
        elementsMap
      );
      const onlyUnbound = Array.from(unboundFromElementIds).filter(
        (id) => !boundToElementIds.has(id)
      );
      getNonDeletedElements(scene, onlyUnbound).forEach((element) => {
        mutateElement(element, {
          boundElements: element.boundElements?.filter(
            (element2) => element2.type !== "arrow" || element2.id !== linearElement.id
          )
        });
      });
    };
    bindOrUnbindLinearElementEdge = (linearElement, bindableElement, otherEdgeBindableElement, startOrEnd, boundToElementIds, unboundFromElementIds, elementsMap) => {
      if (bindableElement === "keep") {
        return;
      }
      if (bindableElement === null) {
        const unbound = unbindLinearElement(linearElement, startOrEnd);
        if (unbound != null) {
          unboundFromElementIds.add(unbound);
        }
        return;
      }
      if (isLinearElementSimple(linearElement)) {
        if (otherEdgeBindableElement == null || (otherEdgeBindableElement === "keep" ? (
          // TODO: Refactor - Needlessly complex
          !isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(
            linearElement,
            bindableElement,
            startOrEnd
          )
        ) : startOrEnd === "start" || otherEdgeBindableElement.id !== bindableElement.id)) {
          bindLinearElement(
            linearElement,
            bindableElement,
            startOrEnd,
            elementsMap
          );
          boundToElementIds.add(bindableElement.id);
        }
      } else {
        bindLinearElement(linearElement, bindableElement, startOrEnd, elementsMap);
        boundToElementIds.add(bindableElement.id);
      }
    };
    getOriginalBindingIfStillCloseOfLinearElementEdge = (linearElement, edge, elementsMap) => {
      const coors = getLinearElementEdgeCoors(linearElement, edge, elementsMap);
      const elementId = edge === "start" ? linearElement.startBinding?.elementId : linearElement.endBinding?.elementId;
      if (elementId) {
        const element = elementsMap.get(elementId);
        if (isBindableElement(element) && bindingBorderTest(element, coors, elementsMap)) {
          return element;
        }
      }
      return null;
    };
    getOriginalBindingsIfStillCloseToArrowEnds = (linearElement, elementsMap) => ["start", "end"].map(
      (edge) => getOriginalBindingIfStillCloseOfLinearElementEdge(
        linearElement,
        edge,
        elementsMap
      )
    );
    getBindingStrategyForDraggingArrowEndpoints = (selectedElement, isBindingEnabled2, draggingPoints, elementsMap, elements) => {
      const startIdx = 0;
      const endIdx = selectedElement.points.length - 1;
      const startDragged = draggingPoints.findIndex((i) => i === startIdx) > -1;
      const endDragged = draggingPoints.findIndex((i) => i === endIdx) > -1;
      const start2 = startDragged ? isBindingEnabled2 ? getElligibleElementForBindingElement(
        selectedElement,
        "start",
        elementsMap,
        elements
      ) : null : (
        // We have to update the focus and gap of the binding, so let's rebind
        getElligibleElementForBindingElement(
          selectedElement,
          "start",
          elementsMap,
          elements
        )
      );
      const end = endDragged ? isBindingEnabled2 ? getElligibleElementForBindingElement(
        selectedElement,
        "end",
        elementsMap,
        elements
      ) : null : (
        // We have to update the focus and gap of the binding, so let's rebind
        getElligibleElementForBindingElement(
          selectedElement,
          "end",
          elementsMap,
          elements
        )
      );
      return [start2, end];
    };
    getBindingStrategyForDraggingArrowOrJoints = (selectedElement, elementsMap, elements, isBindingEnabled2) => {
      const [startIsClose, endIsClose] = getOriginalBindingsIfStillCloseToArrowEnds(
        selectedElement,
        elementsMap
      );
      const start2 = startIsClose ? isBindingEnabled2 ? getElligibleElementForBindingElement(
        selectedElement,
        "start",
        elementsMap,
        elements
      ) : null : null;
      const end = endIsClose ? isBindingEnabled2 ? getElligibleElementForBindingElement(
        selectedElement,
        "end",
        elementsMap,
        elements
      ) : null : null;
      return [start2, end];
    };
    bindOrUnbindLinearElements = (selectedElements, elementsMap, elements, scene, isBindingEnabled2, draggingPoints) => {
      selectedElements.forEach((selectedElement) => {
        const [start2, end] = draggingPoints?.length ? (
          // The arrow edge points are dragged (i.e. start, end)
          getBindingStrategyForDraggingArrowEndpoints(
            selectedElement,
            isBindingEnabled2,
            draggingPoints ?? [],
            elementsMap,
            elements
          )
        ) : (
          // The arrow itself (the shaft) or the inner joins are dragged
          getBindingStrategyForDraggingArrowOrJoints(
            selectedElement,
            elementsMap,
            elements,
            isBindingEnabled2
          )
        );
        bindOrUnbindLinearElement(selectedElement, start2, end, elementsMap, scene);
      });
    };
    getSuggestedBindingsForArrows = (selectedElements, elementsMap) => {
      if (selectedElements.length > 50) {
        return [];
      }
      return selectedElements.filter(isLinearElement).flatMap(
        (element) => getOriginalBindingsIfStillCloseToArrowEnds(element, elementsMap)
      ).filter(
        (element) => element !== null
      ).filter(
        (element) => selectedElements.filter((selected) => selected.id === element?.id).length === 0
      );
    };
    maybeBindLinearElement = (linearElement, appState, pointerCoords, elementsMap, elements) => {
      if (appState.startBoundElement != null) {
        bindLinearElement(
          linearElement,
          appState.startBoundElement,
          "start",
          elementsMap
        );
      }
      const hoveredElement = getHoveredElementForBinding(
        pointerCoords,
        elements,
        elementsMap,
        isElbowArrow(linearElement) && isElbowArrow(linearElement)
      );
      if (hoveredElement !== null) {
        if (!isLinearElementSimpleAndAlreadyBoundOnOppositeEdge(
          linearElement,
          hoveredElement,
          "end"
        )) {
          bindLinearElement(linearElement, hoveredElement, "end", elementsMap);
        }
      }
    };
    bindLinearElement = (linearElement, hoveredElement, startOrEnd, elementsMap) => {
      if (!isArrowElement(linearElement)) {
        return;
      }
      const binding = {
        elementId: hoveredElement.id,
        ...calculateFocusAndGap(
          linearElement,
          hoveredElement,
          startOrEnd,
          elementsMap
        ),
        ...isElbowArrow(linearElement) ? calculateFixedPointForElbowArrowBinding(
          linearElement,
          hoveredElement,
          startOrEnd,
          elementsMap
        ) : { fixedPoint: null }
      };
      mutateElement(linearElement, {
        [startOrEnd === "start" ? "startBinding" : "endBinding"]: binding
      });
      const boundElementsMap = arrayToMap(hoveredElement.boundElements || []);
      if (!boundElementsMap.has(linearElement.id)) {
        mutateElement(hoveredElement, {
          boundElements: (hoveredElement.boundElements || []).concat({
            id: linearElement.id,
            type: "arrow"
          })
        });
      }
    };
    isLinearElementSimpleAndAlreadyBoundOnOppositeEdge = (linearElement, bindableElement, startOrEnd) => {
      const otherBinding = linearElement[startOrEnd === "start" ? "endBinding" : "startBinding"];
      return isLinearElementSimpleAndAlreadyBound(
        linearElement,
        otherBinding?.elementId,
        bindableElement
      );
    };
    isLinearElementSimpleAndAlreadyBound = (linearElement, alreadyBoundToId, bindableElement) => {
      return alreadyBoundToId === bindableElement.id && isLinearElementSimple(linearElement);
    };
    isLinearElementSimple = (linearElement) => linearElement.points.length < 3;
    unbindLinearElement = (linearElement, startOrEnd) => {
      const field = startOrEnd === "start" ? "startBinding" : "endBinding";
      const binding = linearElement[field];
      if (binding == null) {
        return null;
      }
      mutateElement(linearElement, { [field]: null });
      return binding.elementId;
    };
    getHoveredElementForBinding = (pointerCoords, elements, elementsMap, fullShape) => {
      const hoveredElement = getElementAtPosition(
        elements,
        (element) => isBindableElement(element, false) && bindingBorderTest(
          element,
          pointerCoords,
          elementsMap,
          // disable fullshape snapping for frame elements so we
          // can bind to frame children
          fullShape && !isFrameLikeElement(element)
        )
      );
      return hoveredElement;
    };
    calculateFocusAndGap = (linearElement, hoveredElement, startOrEnd, elementsMap) => {
      const direction = startOrEnd === "start" ? -1 : 1;
      const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;
      const adjacentPointIndex = edgePointIndex - direction;
      const edgePoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(
        linearElement,
        edgePointIndex,
        elementsMap
      );
      const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(
        linearElement,
        adjacentPointIndex,
        elementsMap
      );
      return {
        focus: determineFocusDistance(
          hoveredElement,
          adjacentPoint,
          edgePoint,
          elementsMap
        ),
        gap: Math.max(
          1,
          distanceToBindableElement(hoveredElement, edgePoint, elementsMap)
        )
      };
    };
    updateBoundElements = (changedElement, elementsMap, options) => {
      const { oldSize, simultaneouslyUpdated, changedElements } = options ?? {};
      const simultaneouslyUpdatedElementIds = getSimultaneouslyUpdatedElementIds(
        simultaneouslyUpdated
      );
      if (!isBindableElement(changedElement)) {
        return;
      }
      boundElementsVisitor(elementsMap, changedElement, (element) => {
        if (!isLinearElement(element) || element.isDeleted) {
          return;
        }
        if (!doesNeedUpdate(element, changedElement)) {
          return;
        }
        const bindings = {
          startBinding: maybeCalculateNewGapWhenScaling(
            changedElement,
            element.startBinding,
            oldSize
          ),
          endBinding: maybeCalculateNewGapWhenScaling(
            changedElement,
            element.endBinding,
            oldSize
          )
        };
        if (simultaneouslyUpdatedElementIds.has(element.id)) {
          mutateElement(element, bindings);
          return;
        }
        const updates = bindableElementsVisitor(
          elementsMap,
          element,
          (bindableElement, bindingProp) => {
            if (bindableElement && isBindableElement(bindableElement) && (bindingProp === "startBinding" || bindingProp === "endBinding") && changedElement.id === element[bindingProp]?.elementId) {
              const point2 = updateBoundPoint(
                element,
                bindingProp,
                bindings[bindingProp],
                bindableElement,
                elementsMap
              );
              if (point2) {
                return {
                  index: bindingProp === "startBinding" ? 0 : element.points.length - 1,
                  point: point2
                };
              }
            }
            return null;
          }
        ).filter(
          (update) => update !== null
        );
        LinearElementEditor.movePoints(
          element,
          updates,
          elementsMap,
          {
            ...changedElement.id === element.startBinding?.elementId ? { startBinding: bindings.startBinding } : {},
            ...changedElement.id === element.endBinding?.elementId ? { endBinding: bindings.endBinding } : {}
          },
          {
            changedElements
          }
        );
        const boundText = getBoundTextElement(element, elementsMap);
        if (boundText && !boundText.isDeleted) {
          handleBindTextResize(element, elementsMap, false);
        }
      });
    };
    doesNeedUpdate = (boundElement, changedElement) => {
      return boundElement.startBinding?.elementId === changedElement.id || boundElement.endBinding?.elementId === changedElement.id;
    };
    getSimultaneouslyUpdatedElementIds = (simultaneouslyUpdated) => {
      return new Set((simultaneouslyUpdated || []).map((element) => element.id));
    };
    getHeadingForElbowArrowSnap = (p, otherPoint, bindableElement, aabb, elementsMap, origPoint) => {
      const otherPointHeading = vectorToHeading(vectorFromPoint(otherPoint, p));
      if (!bindableElement || !aabb) {
        return otherPointHeading;
      }
      const distance3 = getDistanceForBinding(
        origPoint,
        bindableElement,
        elementsMap
      );
      if (!distance3) {
        return vectorToHeading(
          vectorFromPoint(
            p,
            pointFrom(
              bindableElement.x + bindableElement.width / 2,
              bindableElement.y + bindableElement.height / 2
            )
          )
        );
      }
      const pointHeading = headingForPointFromElement(bindableElement, aabb, p);
      return pointHeading;
    };
    getDistanceForBinding = (point2, bindableElement, elementsMap) => {
      const distance3 = distanceToBindableElement(
        bindableElement,
        point2,
        elementsMap
      );
      const bindDistance = maxBindingGap(
        bindableElement,
        bindableElement.width,
        bindableElement.height
      );
      return distance3 > bindDistance ? null : distance3;
    };
    bindPointToSnapToElementOutline = (p, otherPoint, bindableElement, elementsMap) => {
      const aabb = bindableElement && aabbForElement(bindableElement);
      if (bindableElement && aabb) {
        const heading = headingForPointFromElement(bindableElement, aabb, p);
        const intersections = [
          ...intersectElementWithLine(
            bindableElement,
            pointFrom(p[0], p[1] - 2 * bindableElement.height),
            pointFrom(p[0], p[1] + 2 * bindableElement.height),
            FIXED_BINDING_DISTANCE,
            elementsMap
          ) ?? [],
          ...intersectElementWithLine(
            bindableElement,
            pointFrom(p[0] - 2 * bindableElement.width, p[1]),
            pointFrom(p[0] + 2 * bindableElement.width, p[1]),
            FIXED_BINDING_DISTANCE,
            elementsMap
          ) ?? []
        ];
        const isVertical = compareHeading(heading, HEADING_LEFT) || compareHeading(heading, HEADING_RIGHT);
        const dist = Math.abs(
          distanceToBindableElement(bindableElement, p, elementsMap)
        );
        const isInner = isVertical ? dist < bindableElement.width * -0.1 : dist < bindableElement.height * -0.1;
        intersections.sort((a, b) => pointDistanceSq(a, p) - pointDistanceSq(b, p));
        return isInner ? headingToMidBindPoint(otherPoint, bindableElement, aabb) : intersections.filter(
          (i) => isVertical ? Math.abs(p[1] - i[1]) < 0.1 : Math.abs(p[0] - i[0]) < 0.1
        )[0] ?? p;
      }
      return p;
    };
    headingToMidBindPoint = (p, bindableElement, aabb) => {
      const center = getCenterForBounds(aabb);
      const heading = vectorToHeading(vectorFromPoint(p, center));
      switch (true) {
        case compareHeading(heading, HEADING_UP):
          return pointRotateRads(
            pointFrom((aabb[0] + aabb[2]) / 2 + 0.1, aabb[1]),
            center,
            bindableElement.angle
          );
        case compareHeading(heading, HEADING_RIGHT):
          return pointRotateRads(
            pointFrom(aabb[2], (aabb[1] + aabb[3]) / 2 + 0.1),
            center,
            bindableElement.angle
          );
        case compareHeading(heading, HEADING_DOWN):
          return pointRotateRads(
            pointFrom((aabb[0] + aabb[2]) / 2 - 0.1, aabb[3]),
            center,
            bindableElement.angle
          );
        default:
          return pointRotateRads(
            pointFrom(aabb[0], (aabb[1] + aabb[3]) / 2 - 0.1),
            center,
            bindableElement.angle
          );
      }
    };
    avoidRectangularCorner = (element, p) => {
      const center = pointFrom(
        element.x + element.width / 2,
        element.y + element.height / 2
      );
      const nonRotatedPoint = pointRotateRads(p, center, -element.angle);
      if (nonRotatedPoint[0] < element.x && nonRotatedPoint[1] < element.y) {
        if (nonRotatedPoint[1] - element.y > -FIXED_BINDING_DISTANCE) {
          return pointRotateRads(
            pointFrom(element.x - FIXED_BINDING_DISTANCE, element.y),
            center,
            element.angle
          );
        }
        return pointRotateRads(
          pointFrom(element.x, element.y - FIXED_BINDING_DISTANCE),
          center,
          element.angle
        );
      } else if (nonRotatedPoint[0] < element.x && nonRotatedPoint[1] > element.y + element.height) {
        if (nonRotatedPoint[0] - element.x > -FIXED_BINDING_DISTANCE) {
          return pointRotateRads(
            pointFrom(
              element.x,
              element.y + element.height + FIXED_BINDING_DISTANCE
            ),
            center,
            element.angle
          );
        }
        return pointRotateRads(
          pointFrom(element.x - FIXED_BINDING_DISTANCE, element.y + element.height),
          center,
          element.angle
        );
      } else if (nonRotatedPoint[0] > element.x + element.width && nonRotatedPoint[1] > element.y + element.height) {
        if (nonRotatedPoint[0] - element.x < element.width + FIXED_BINDING_DISTANCE) {
          return pointRotateRads(
            pointFrom(
              element.x + element.width,
              element.y + element.height + FIXED_BINDING_DISTANCE
            ),
            center,
            element.angle
          );
        }
        return pointRotateRads(
          pointFrom(
            element.x + element.width + FIXED_BINDING_DISTANCE,
            element.y + element.height
          ),
          center,
          element.angle
        );
      } else if (nonRotatedPoint[0] > element.x + element.width && nonRotatedPoint[1] < element.y) {
        if (nonRotatedPoint[0] - element.x < element.width + FIXED_BINDING_DISTANCE) {
          return pointRotateRads(
            pointFrom(
              element.x + element.width,
              element.y - FIXED_BINDING_DISTANCE
            ),
            center,
            element.angle
          );
        }
        return pointRotateRads(
          pointFrom(element.x + element.width + FIXED_BINDING_DISTANCE, element.y),
          center,
          element.angle
        );
      }
      return p;
    };
    snapToMid = (element, p, tolerance = 0.05) => {
      const { x, y, width, height, angle } = element;
      const center = pointFrom(
        x + width / 2 - 0.1,
        y + height / 2 - 0.1
      );
      const nonRotated = pointRotateRads(p, center, -angle);
      const verticalThrehsold = clamp(tolerance * height, 5, 80);
      const horizontalThrehsold = clamp(tolerance * width, 5, 80);
      if (nonRotated[0] <= x + width / 2 && nonRotated[1] > center[1] - verticalThrehsold && nonRotated[1] < center[1] + verticalThrehsold) {
        return pointRotateRads(
          pointFrom(x - FIXED_BINDING_DISTANCE, center[1]),
          center,
          angle
        );
      } else if (nonRotated[1] <= y + height / 2 && nonRotated[0] > center[0] - horizontalThrehsold && nonRotated[0] < center[0] + horizontalThrehsold) {
        return pointRotateRads(
          pointFrom(center[0], y - FIXED_BINDING_DISTANCE),
          center,
          angle
        );
      } else if (nonRotated[0] >= x + width / 2 && nonRotated[1] > center[1] - verticalThrehsold && nonRotated[1] < center[1] + verticalThrehsold) {
        return pointRotateRads(
          pointFrom(x + width + FIXED_BINDING_DISTANCE, center[1]),
          center,
          angle
        );
      } else if (nonRotated[1] >= y + height / 2 && nonRotated[0] > center[0] - horizontalThrehsold && nonRotated[0] < center[0] + horizontalThrehsold) {
        return pointRotateRads(
          pointFrom(center[0], y + height + FIXED_BINDING_DISTANCE),
          center,
          angle
        );
      }
      return p;
    };
    updateBoundPoint = (linearElement, startOrEnd, binding, bindableElement, elementsMap) => {
      if (binding == null || // We only need to update the other end if this is a 2 point line element
      binding.elementId !== bindableElement.id && linearElement.points.length > 2) {
        return null;
      }
      const direction = startOrEnd === "startBinding" ? -1 : 1;
      const edgePointIndex = direction === -1 ? 0 : linearElement.points.length - 1;
      if (isElbowArrow(linearElement) && isFixedPointBinding(binding)) {
        const fixedPoint = normalizeFixedPoint(binding.fixedPoint) ?? calculateFixedPointForElbowArrowBinding(
          linearElement,
          bindableElement,
          startOrEnd === "startBinding" ? "start" : "end",
          elementsMap
        ).fixedPoint;
        const globalMidPoint = pointFrom(
          bindableElement.x + bindableElement.width / 2,
          bindableElement.y + bindableElement.height / 2
        );
        const global = pointFrom(
          bindableElement.x + fixedPoint[0] * bindableElement.width,
          bindableElement.y + fixedPoint[1] * bindableElement.height
        );
        const rotatedGlobal = pointRotateRads(
          global,
          globalMidPoint,
          bindableElement.angle
        );
        return LinearElementEditor.pointFromAbsoluteCoords(
          linearElement,
          rotatedGlobal,
          elementsMap
        );
      }
      const adjacentPointIndex = edgePointIndex - direction;
      const adjacentPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(
        linearElement,
        adjacentPointIndex,
        elementsMap
      );
      const focusPointAbsolute = determineFocusPoint(
        bindableElement,
        binding.focus,
        adjacentPoint,
        elementsMap
      );
      let newEdgePoint;
      if (binding.gap === 0) {
        newEdgePoint = focusPointAbsolute;
      } else {
        const intersections = intersectElementWithLine(
          bindableElement,
          adjacentPoint,
          focusPointAbsolute,
          binding.gap,
          elementsMap
        );
        if (!intersections || intersections.length === 0) {
          newEdgePoint = focusPointAbsolute;
        } else {
          newEdgePoint = intersections[0];
        }
      }
      return LinearElementEditor.pointFromAbsoluteCoords(
        linearElement,
        newEdgePoint,
        elementsMap
      );
    };
    calculateFixedPointForElbowArrowBinding = (linearElement, hoveredElement, startOrEnd, elementsMap) => {
      const bounds = [
        hoveredElement.x,
        hoveredElement.y,
        hoveredElement.x + hoveredElement.width,
        hoveredElement.y + hoveredElement.height
      ];
      const edgePointIndex = startOrEnd === "start" ? 0 : linearElement.points.length - 1;
      const globalPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(
        linearElement,
        edgePointIndex,
        elementsMap
      );
      const otherGlobalPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(
        linearElement,
        edgePointIndex,
        elementsMap
      );
      const snappedPoint = bindPointToSnapToElementOutline(
        globalPoint,
        otherGlobalPoint,
        hoveredElement,
        elementsMap
      );
      const globalMidPoint = pointFrom(
        bounds[0] + (bounds[2] - bounds[0]) / 2,
        bounds[1] + (bounds[3] - bounds[1]) / 2
      );
      const nonRotatedSnappedGlobalPoint = pointRotateRads(
        snappedPoint,
        globalMidPoint,
        -hoveredElement.angle
      );
      return {
        fixedPoint: normalizeFixedPoint([
          (nonRotatedSnappedGlobalPoint[0] - hoveredElement.x) / hoveredElement.width,
          (nonRotatedSnappedGlobalPoint[1] - hoveredElement.y) / hoveredElement.height
        ])
      };
    };
    maybeCalculateNewGapWhenScaling = (changedElement, currentBinding, newSize) => {
      if (currentBinding == null || newSize == null) {
        return currentBinding;
      }
      const { width: newWidth, height: newHeight } = newSize;
      const { width, height } = changedElement;
      const newGap = Math.max(
        1,
        Math.min(
          maxBindingGap(changedElement, newWidth, newHeight),
          currentBinding.gap * (newWidth < newHeight ? newWidth / width : newHeight / height)
        )
      );
      return { ...currentBinding, gap: newGap };
    };
    getElligibleElementForBindingElement = (linearElement, startOrEnd, elementsMap, elements) => {
      return getHoveredElementForBinding(
        getLinearElementEdgeCoors(linearElement, startOrEnd, elementsMap),
        elements,
        elementsMap
      );
    };
    getLinearElementEdgeCoors = (linearElement, startOrEnd, elementsMap) => {
      const index = startOrEnd === "start" ? 0 : -1;
      return tupleToCoors(
        LinearElementEditor.getPointAtIndexGlobalCoordinates(
          linearElement,
          index,
          elementsMap
        )
      );
    };
    fixBindingsAfterDuplication = (sceneElements, oldElements, oldIdToDuplicatedId, duplicatesServeAsOld) => {
      const allBoundElementIds = /* @__PURE__ */ new Set();
      const allBindableElementIds = /* @__PURE__ */ new Set();
      const shouldReverseRoles = duplicatesServeAsOld === "duplicatesServeAsOld";
      const duplicateIdToOldId = new Map(
        [...oldIdToDuplicatedId].map(([key, value]) => [value, key])
      );
      oldElements.forEach((oldElement) => {
        const { boundElements } = oldElement;
        if (boundElements != null && boundElements.length > 0) {
          boundElements.forEach((boundElement) => {
            if (shouldReverseRoles && !oldIdToDuplicatedId.has(boundElement.id)) {
              allBoundElementIds.add(boundElement.id);
            }
          });
          allBindableElementIds.add(oldIdToDuplicatedId.get(oldElement.id));
        }
        if (isBindingElement(oldElement)) {
          if (oldElement.startBinding != null) {
            const { elementId } = oldElement.startBinding;
            if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {
              allBindableElementIds.add(elementId);
            }
          }
          if (oldElement.endBinding != null) {
            const { elementId } = oldElement.endBinding;
            if (shouldReverseRoles && !oldIdToDuplicatedId.has(elementId)) {
              allBindableElementIds.add(elementId);
            }
          }
          if (oldElement.startBinding != null || oldElement.endBinding != null) {
            allBoundElementIds.add(oldIdToDuplicatedId.get(oldElement.id));
          }
        }
      });
      sceneElements.filter(
        ({ id }) => allBoundElementIds.has(id)
      ).forEach((element) => {
        const { startBinding, endBinding } = element;
        mutateElement(element, {
          startBinding: newBindingAfterDuplication(
            startBinding,
            oldIdToDuplicatedId
          ),
          endBinding: newBindingAfterDuplication(endBinding, oldIdToDuplicatedId)
        });
      });
      sceneElements.filter(({ id }) => allBindableElementIds.has(id)).forEach((bindableElement) => {
        const oldElementId = duplicateIdToOldId.get(bindableElement.id);
        const boundElements = sceneElements.find(
          ({ id }) => id === oldElementId
        )?.boundElements;
        if (boundElements && boundElements.length > 0) {
          mutateElement(bindableElement, {
            boundElements: boundElements.map(
              (boundElement) => oldIdToDuplicatedId.has(boundElement.id) ? {
                id: oldIdToDuplicatedId.get(boundElement.id),
                type: boundElement.type
              } : boundElement
            )
          });
        }
      });
    };
    newBindingAfterDuplication = (binding, oldIdToDuplicatedId) => {
      if (binding == null) {
        return null;
      }
      return {
        ...binding,
        elementId: oldIdToDuplicatedId.get(binding.elementId) ?? binding.elementId
      };
    };
    fixBindingsAfterDeletion = (sceneElements, deletedElements) => {
      const elements = arrayToMap(sceneElements);
      for (const element of deletedElements) {
        BoundElement.unbindAffected(elements, element, mutateElement);
        BindableElement.unbindAffected(elements, element, mutateElement);
      }
    };
    newBoundElements = (boundElements, idsToRemove, elementsToAdd = []) => {
      if (!boundElements) {
        return null;
      }
      const nextBoundElements = boundElements.filter(
        (boundElement) => !idsToRemove.has(boundElement.id)
      );
      nextBoundElements.push(
        ...elementsToAdd.map(
          (x) => ({ id: x.id, type: x.type })
        )
      );
      return nextBoundElements;
    };
    bindingBorderTest = (element, { x, y }, elementsMap, fullShape) => {
      const threshold = maxBindingGap(element, element.width, element.height);
      const shape = getElementShape(element, elementsMap);
      return isPointOnShape(pointFrom(x, y), shape, threshold) || fullShape === true && pointInsideBounds(pointFrom(x, y), aabbForElement(element));
    };
    maxBindingGap = (element, elementWidth, elementHeight) => {
      const shapeRatio = element.type === "diamond" ? 1 / Math.sqrt(2) : 1;
      const smallerDimension = shapeRatio * Math.min(elementWidth, elementHeight);
      return Math.max(16, Math.min(0.25 * smallerDimension, 32));
    };
    distanceToBindableElement = (element, point2, elementsMap) => {
      switch (element.type) {
        case "rectangle":
        case "image":
        case "text":
        case "iframe":
        case "embeddable":
        case "frame":
        case "magicframe":
          return distanceToRectangle(element, point2, elementsMap);
        case "diamond":
          return distanceToDiamond(element, point2, elementsMap);
        case "ellipse":
          return distanceToEllipse2(element, point2, elementsMap);
      }
    };
    distanceToRectangle = (element, p, elementsMap) => {
      const [, pointRel, hwidth, hheight] = pointRelativeToElement(
        element,
        p,
        elementsMap
      );
      return Math.max(
        distanceToLine(pointRel, equation(0, 1, -hheight)),
        distanceToLine(pointRel, equation(1, 0, -hwidth))
      );
    };
    distanceToDiamond = (element, point2, elementsMap) => {
      const [, pointRel, hwidth, hheight] = pointRelativeToElement(
        element,
        point2,
        elementsMap
      );
      const side = equation(hheight, hwidth, -hheight * hwidth);
      return distanceToLine(pointRel, side);
    };
    distanceToEllipse2 = (element, point2, elementsMap) => {
      const [pointRel, tangent] = ellipseParamsForTest(element, point2, elementsMap);
      return -sign(tangent) * distanceToLine(pointRel, tangent);
    };
    ellipseParamsForTest = (element, point2, elementsMap) => {
      const [, pointRel, hwidth, hheight] = pointRelativeToElement(
        element,
        point2,
        elementsMap
      );
      const [px, py] = toTuple(pointRel);
      let tx = 0.707;
      let ty = 0.707;
      const a = hwidth;
      const b = hheight;
      [0, 1, 2, 3].forEach((_) => {
        const xx = a * tx;
        const yy = b * ty;
        const ex = (a * a - b * b) * tx ** 3 / a;
        const ey = (b * b - a * a) * ty ** 3 / b;
        const rx = xx - ex;
        const ry = yy - ey;
        const qx = px - ex;
        const qy = py - ey;
        const r = Math.hypot(ry, rx);
        const q = Math.hypot(qy, qx);
        tx = Math.min(1, Math.max(0, (qx * r / q + ex) / a));
        ty = Math.min(1, Math.max(0, (qy * r / q + ey) / b));
        const t2 = Math.hypot(ty, tx);
        tx /= t2;
        ty /= t2;
      });
      const closestPoint = point(a * tx, b * ty);
      const tangent = orthogonalThrough(pointRel, closestPoint);
      return [pointRel, tangent];
    };
    pointRelativeToElement = (element, pointTuple, elementsMap) => {
      const point2 = from(pointTuple);
      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
      const center = coordsCenter(x1, y1, x2, y2);
      const rotate = rotation(center, element.angle);
      const pointRotated = apply(rotate, point2);
      const pointRelToCenter = sub(pointRotated, from2(center));
      const pointRelToCenterAbs = abs(pointRelToCenter);
      const elementPos = offset(element.x, element.y);
      const pointRelToPos = sub(pointRotated, elementPos);
      const halfWidth = (x2 - x1) / 2;
      const halfHeight = (y2 - y1) / 2;
      return [pointRelToPos, pointRelToCenterAbs, halfWidth, halfHeight];
    };
    relativizationToElementCenter = (element, elementsMap) => {
      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
      const center = coordsCenter(x1, y1, x2, y2);
      const rotate = rotation(center, element.angle);
      const translate = reverse(
        translation(from2(center))
      );
      return compose(rotate, translate);
    };
    coordsCenter = (x1, y1, x2, y2) => {
      return point((x1 + x2) / 2, (y1 + y2) / 2);
    };
    determineFocusDistance = (element, a, b, elementsMap) => {
      const relateToCenter = relativizationToElementCenter(element, elementsMap);
      const aRel = apply(relateToCenter, from(a));
      const bRel = apply(relateToCenter, from(b));
      const line = through(aRel, bRel);
      const q = element.height / element.width;
      const hwidth = element.width / 2;
      const hheight = element.height / 2;
      const n = line[2];
      const m = line[3];
      const c = line[1];
      const mabs = Math.abs(m);
      const nabs = Math.abs(n);
      let ret;
      switch (element.type) {
        case "rectangle":
        case "image":
        case "text":
        case "iframe":
        case "embeddable":
        case "frame":
        case "magicframe":
          ret = c / (hwidth * (nabs + q * mabs));
          break;
        case "diamond":
          ret = mabs < nabs ? c / (nabs * hwidth) : c / (mabs * hheight);
          break;
        case "ellipse":
          ret = c / (hwidth * Math.sqrt(n ** 2 + q ** 2 * m ** 2));
          break;
      }
      return ret || 0;
    };
    determineFocusPoint = (element, focus, adjecentPoint, elementsMap) => {
      if (focus === 0) {
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
        const center = coordsCenter(x1, y1, x2, y2);
        return pointFromPair(toTuple(center));
      }
      const relateToCenter = relativizationToElementCenter(element, elementsMap);
      const adjecentPointRel = apply(
        relateToCenter,
        from(adjecentPoint)
      );
      const reverseRelateToCenter = reverse(relateToCenter);
      let point2;
      switch (element.type) {
        case "rectangle":
        case "image":
        case "text":
        case "diamond":
        case "iframe":
        case "embeddable":
        case "frame":
        case "magicframe":
          point2 = findFocusPointForRectangulars(element, focus, adjecentPointRel);
          break;
        case "ellipse":
          point2 = findFocusPointForEllipse(element, focus, adjecentPointRel);
          break;
      }
      return pointFromPair(
        toTuple(apply(reverseRelateToCenter, point2))
      );
    };
    intersectElementWithLine = (element, a, b, gap = 0, elementsMap) => {
      if (isRectangularElement(element)) {
        return segmentIntersectRectangleElement(element, lineSegment(a, b), gap);
      }
      const relateToCenter = relativizationToElementCenter(element, elementsMap);
      const aRel = apply(relateToCenter, from(a));
      const bRel = apply(relateToCenter, from(b));
      const line = through(aRel, bRel);
      const reverseRelateToCenter = reverse(relateToCenter);
      const intersections = getSortedElementLineIntersections(
        element,
        line,
        aRel,
        gap
      );
      return intersections.map(
        (point2) => pointFromPair(
          toTuple(apply(reverseRelateToCenter, point2))
        )
        // pointFromArray(
        //   ,
        // ),
      );
    };
    getSortedElementLineIntersections = (element, line, nearPoint, gap = 0) => {
      let intersections;
      switch (element.type) {
        case "rectangle":
        case "image":
        case "text":
        case "diamond":
        case "iframe":
        case "embeddable":
        case "frame":
        case "magicframe":
          const corners = getCorners(element);
          intersections = corners.flatMap((point2, i) => {
            const edge = [point2, corners[(i + 1) % 4]];
            return intersectSegment(line, offsetSegment(edge, gap));
          }).concat(
            corners.flatMap((point2) => getCircleIntersections(point2, gap, line))
          );
          break;
        case "ellipse":
          intersections = getEllipseIntersections(element, gap, line);
          break;
      }
      if (intersections.length < 2) {
        return [];
      }
      const sortedIntersections = intersections.sort(
        (i1, i2) => distance2(i1, nearPoint) - distance2(i2, nearPoint)
      );
      return [
        sortedIntersections[0],
        sortedIntersections[sortedIntersections.length - 1]
      ];
    };
    getCorners = (element, scale = 1) => {
      const hx = scale * element.width / 2;
      const hy = scale * element.height / 2;
      switch (element.type) {
        case "rectangle":
        case "image":
        case "text":
        case "iframe":
        case "embeddable":
        case "frame":
        case "magicframe":
          return [
            point(hx, hy),
            point(hx, -hy),
            point(-hx, -hy),
            point(-hx, hy)
          ];
        case "diamond":
          return [
            point(0, hy),
            point(hx, 0),
            point(0, -hy),
            point(-hx, 0)
          ];
      }
    };
    intersectSegment = (line, segment) => {
      const [a, b] = segment;
      const aDist = distanceToLine(a, line);
      const bDist = distanceToLine(b, line);
      if (aDist * bDist >= 0) {
        return [];
      }
      return [intersect(line, through(a, b))];
    };
    offsetSegment = (segment, distance3) => {
      const [a, b] = segment;
      const offset2 = translationOrthogonal(
        fromTo(a, b),
        distance3
      );
      return [apply(offset2, a), apply(offset2, b)];
    };
    getEllipseIntersections = (element, gap, line) => {
      const a = element.width / 2 + gap;
      const b = element.height / 2 + gap;
      const m = line[2];
      const n = line[3];
      const c = line[1];
      const squares = a * a * m * m + b * b * n * n;
      const discr = squares - c * c;
      if (squares === 0 || discr <= 0) {
        return [];
      }
      const discrRoot = Math.sqrt(discr);
      const xn = -a * a * m * c;
      const yn = -b * b * n * c;
      return [
        point(
          (xn + a * b * n * discrRoot) / squares,
          (yn - a * b * m * discrRoot) / squares
        ),
        point(
          (xn - a * b * n * discrRoot) / squares,
          (yn + a * b * m * discrRoot) / squares
        )
      ];
    };
    getCircleIntersections = (center, radius, line) => {
      if (radius === 0) {
        return distanceToLine(line, center) === 0 ? [center] : [];
      }
      const m = line[2];
      const n = line[3];
      const c = line[1];
      const [a, b] = toTuple(center);
      const r = radius;
      const squares = m * m + n * n;
      const discr = r * r * squares - (m * a + n * b + c) ** 2;
      if (squares === 0 || discr <= 0) {
        return [];
      }
      const discrRoot = Math.sqrt(discr);
      const xn = a * n * n - b * m * n - m * c;
      const yn = b * m * m - a * m * n - n * c;
      return [
        point((xn + n * discrRoot) / squares, (yn - m * discrRoot) / squares),
        point((xn - n * discrRoot) / squares, (yn + m * discrRoot) / squares)
      ];
    };
    findFocusPointForEllipse = (ellipse, relativeDistance, point2) => {
      const relativeDistanceAbs = Math.abs(relativeDistance);
      const a = ellipse.width * relativeDistanceAbs / 2;
      const b = ellipse.height * relativeDistanceAbs / 2;
      const orientation = Math.sign(relativeDistance);
      const [px, pyo] = toTuple(point2);
      const py = pyo === 0 ? 1e-4 : pyo;
      const squares = px ** 2 * b ** 2 + py ** 2 * a ** 2;
      const m = (-px * b ** 2 + orientation * py * Math.sqrt(Math.max(0, squares - a ** 2 * b ** 2))) / squares;
      let n = (-m * px - 1) / py;
      if (n === 0) {
        n = (Object.is(n, -0) ? -1 : 1) * 0.01;
      }
      const x = -(a ** 2 * m) / (n ** 2 * b ** 2 + m ** 2 * a ** 2);
      return point(x, (-m * x - 1) / n);
    };
    findFocusPointForRectangulars = (element, relativeDistance, point2) => {
      const relativeDistanceAbs = Math.abs(relativeDistance);
      const orientation = Math.sign(relativeDistance);
      const corners = getCorners(element, relativeDistanceAbs);
      let maxDistance = 0;
      let tangentPoint = null;
      corners.forEach((corner) => {
        const distance3 = orientation * through(point2, corner)[1];
        if (distance3 > maxDistance) {
          maxDistance = distance3;
          tangentPoint = corner;
        }
      });
      return tangentPoint;
    };
    bindingProperties = /* @__PURE__ */ new Set([
      "boundElements",
      "frameId",
      "containerId",
      "startBinding",
      "endBinding"
    ]);
    boundElementsVisitor = (elements, element, visit) => {
      if (isBindableElement(element)) {
        const boundElements = element.boundElements?.slice() ?? [];
        boundElements.forEach(({ id }) => {
          visit(elements.get(id), "boundElements", id);
        });
      }
    };
    bindableElementsVisitor = (elements, element, visit) => {
      const result = [];
      if (element.frameId) {
        const id = element.frameId;
        result.push(visit(elements.get(id), "frameId", id));
      }
      if (isBoundToContainer(element)) {
        const id = element.containerId;
        result.push(visit(elements.get(id), "containerId", id));
      }
      if (isArrowElement(element)) {
        if (element.startBinding) {
          const id = element.startBinding.elementId;
          result.push(visit(elements.get(id), "startBinding", id));
        }
        if (element.endBinding) {
          const id = element.endBinding.elementId;
          result.push(visit(elements.get(id), "endBinding", id));
        }
      }
      return result;
    };
    BoundElement = class {
      /**
       * Unbind the affected non deleted bindable elements (removing element from `boundElements`).
       * - iterates non deleted bindable elements (`containerId` | `startBinding.elementId` | `endBinding.elementId`) of the current element
       * - prepares updates to unbind each bindable element's `boundElements` from the current element
       */
      static unbindAffected(elements, boundElement, updateElementWith) {
        if (!boundElement) {
          return;
        }
        bindableElementsVisitor(elements, boundElement, (bindableElement) => {
          if (!bindableElement || bindableElement.isDeleted) {
            return;
          }
          boundElementsVisitor(
            elements,
            bindableElement,
            (_, __, boundElementId) => {
              if (boundElementId === boundElement.id) {
                updateElementWith(bindableElement, {
                  boundElements: newBoundElements(
                    bindableElement.boundElements,
                    /* @__PURE__ */ new Set([boundElementId])
                  )
                });
              }
            }
          );
        });
      }
      /**
       * Rebind the next affected non deleted bindable elements (adding element to `boundElements`).
       * - iterates non deleted bindable elements (`containerId` | `startBinding.elementId` | `endBinding.elementId`) of the current element
       * - prepares updates to rebind each bindable element's `boundElements` to the current element
       *
       * NOTE: rebind expects that affected elements were previously unbound with `BoundElement.unbindAffected`
       */
      static rebindAffected = (elements, boundElement, updateElementWith) => {
        if (!boundElement || boundElement.isDeleted) {
          return;
        }
        bindableElementsVisitor(
          elements,
          boundElement,
          (bindableElement, bindingProp) => {
            if (!bindableElement || bindableElement.isDeleted) {
              updateElementWith(boundElement, { [bindingProp]: null });
              return;
            }
            if (bindingProp === "frameId") {
              return;
            }
            if (bindableElement.boundElements?.find((x) => x.id === boundElement.id)) {
              return;
            }
            if (isArrowElement(boundElement)) {
              updateElementWith(bindableElement, {
                boundElements: newBoundElements(
                  bindableElement.boundElements,
                  /* @__PURE__ */ new Set(),
                  new Array(boundElement)
                )
              });
            }
            if (isTextElement(boundElement)) {
              if (!bindableElement.boundElements?.find((x) => x.type === "text")) {
                updateElementWith(bindableElement, {
                  boundElements: newBoundElements(
                    bindableElement.boundElements,
                    /* @__PURE__ */ new Set(),
                    new Array(boundElement)
                  )
                });
              } else {
                updateElementWith(boundElement, { [bindingProp]: null });
              }
            }
          }
        );
      };
    };
    BindableElement = class {
      /**
       * Unbind the affected non deleted bound elements (resetting `containerId`, `startBinding`, `endBinding` to `null`).
       * - iterates through non deleted `boundElements` of the current element
       * - prepares updates to unbind each bound element from the current element
       */
      static unbindAffected(elements, bindableElement, updateElementWith) {
        if (!bindableElement) {
          return;
        }
        boundElementsVisitor(elements, bindableElement, (boundElement) => {
          if (!boundElement || boundElement.isDeleted) {
            return;
          }
          bindableElementsVisitor(
            elements,
            boundElement,
            (_, bindingProp, bindableElementId) => {
              if (bindableElementId === bindableElement.id) {
                updateElementWith(boundElement, { [bindingProp]: null });
              }
            }
          );
        });
      }
      /**
       * Rebind the affected non deleted bound elements (for now setting only `containerId`, as we cannot rebind arrows atm).
       * - iterates through non deleted `boundElements` of the current element
       * - prepares updates to rebind each bound element to the current element or unbind it from `boundElements` in case of conflicts
       *
       * NOTE: rebind expects that affected elements were previously unbound with `BindaleElement.unbindAffected`
       */
      static rebindAffected = (elements, bindableElement, updateElementWith) => {
        if (!bindableElement || bindableElement.isDeleted) {
          return;
        }
        boundElementsVisitor(
          elements,
          bindableElement,
          (boundElement, _, boundElementId) => {
            if (!boundElement || boundElement.isDeleted) {
              updateElementWith(bindableElement, {
                boundElements: newBoundElements(
                  bindableElement.boundElements,
                  /* @__PURE__ */ new Set([boundElementId])
                )
              });
              return;
            }
            if (isTextElement(boundElement)) {
              const boundElements = bindableElement.boundElements?.slice() ?? [];
              if (boundElements.reverse().find((x) => x.type === "text")?.id === boundElement.id) {
                if (boundElement.containerId !== bindableElement.id) {
                  updateElementWith(boundElement, {
                    containerId: bindableElement.id
                  });
                }
              } else {
                if (boundElement.containerId !== null) {
                  updateElementWith(boundElement, {
                    containerId: null
                  });
                }
                updateElementWith(bindableElement, {
                  boundElements: newBoundElements(
                    bindableElement.boundElements,
                    /* @__PURE__ */ new Set([boundElement.id])
                  )
                });
              }
            }
          }
        );
      };
    };
    getGlobalFixedPointForBindableElement = (fixedPointRatio, element) => {
      const [fixedX, fixedY] = normalizeFixedPoint(fixedPointRatio);
      return pointRotateRads(
        pointFrom(
          element.x + element.width * fixedX,
          element.y + element.height * fixedY
        ),
        pointFrom(
          element.x + element.width / 2,
          element.y + element.height / 2
        ),
        element.angle
      );
    };
    getGlobalFixedPoints = (arrow, elementsMap) => {
      const startElement = arrow.startBinding && elementsMap.get(arrow.startBinding.elementId);
      const endElement = arrow.endBinding && elementsMap.get(arrow.endBinding.elementId);
      const startPoint = startElement && arrow.startBinding ? getGlobalFixedPointForBindableElement(
        arrow.startBinding.fixedPoint,
        startElement
      ) : pointFrom(
        arrow.x + arrow.points[0][0],
        arrow.y + arrow.points[0][1]
      );
      const endPoint = endElement && arrow.endBinding ? getGlobalFixedPointForBindableElement(
        arrow.endBinding.fixedPoint,
        endElement
      ) : pointFrom(
        arrow.x + arrow.points[arrow.points.length - 1][0],
        arrow.y + arrow.points[arrow.points.length - 1][1]
      );
      return [startPoint, endPoint];
    };
    getArrowLocalFixedPoints = (arrow, elementsMap) => {
      const [startPoint, endPoint] = getGlobalFixedPoints(arrow, elementsMap);
      return [
        LinearElementEditor.pointFromAbsoluteCoords(arrow, startPoint, elementsMap),
        LinearElementEditor.pointFromAbsoluteCoords(arrow, endPoint, elementsMap)
      ];
    };
    normalizeFixedPoint = (fixedPoint) => {
      if (fixedPoint && (fixedPoint[0] === 0.5 || fixedPoint[1] === 0.5)) {
        return fixedPoint.map(
          (ratio) => ratio === 0.5 ? 0.5001 : ratio
        );
      }
      return fixedPoint;
    };
  }
});

// data/restore.ts
var AllowedExcalidrawActiveTools, getFontFamilyByName, repairBinding, restoreElementWithProperties, restoreElement, repairContainerElement, repairBoundElement, repairFrameMembership, restoreElements, coalesceAppStateValue, LegacyAppStateMigrations, restoreAppState, restore, restoreLibraryItem, restoreLibraryItems;
var init_restore = __esm({
  "data/restore.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_element();
    init_typeChecks();
    init_random();
    init_constants();
    init_appState();
    init_linearElementEditor();
    init_mutateElement();
    init_utils2();
    init_utils2();
    init_textElement();
    init_url();
    init_fractionalIndex();
    init_points();
    init_fonts();
    init_binding();
    init_scene();
    init_math();
    AllowedExcalidrawActiveTools = {
      selection: true,
      text: true,
      rectangle: true,
      diamond: true,
      ellipse: true,
      line: true,
      image: true,
      arrow: true,
      freedraw: true,
      eraser: false,
      custom: true,
      frame: true,
      embeddable: true,
      hand: true,
      laser: false,
      magicframe: false
    };
    getFontFamilyByName = (fontFamilyName) => {
      if (Object.keys(FONT_FAMILY).includes(fontFamilyName)) {
        return FONT_FAMILY[fontFamilyName];
      }
      return DEFAULT_FONT_FAMILY;
    };
    repairBinding = (element, binding) => {
      if (!binding) {
        return null;
      }
      return {
        ...binding,
        focus: binding.focus || 0,
        ...isElbowArrow(element) && isFixedPointBinding(binding) ? {
          fixedPoint: normalizeFixedPoint(binding.fixedPoint ?? [0, 0])
        } : {}
      };
    };
    restoreElementWithProperties = (element, extra) => {
      const base = {
        type: extra.type || element.type,
        // all elements must have version > 0 so getSceneVersion() will pick up
        // newly added elements
        version: element.version || 1,
        versionNonce: element.versionNonce ?? 0,
        index: element.index ?? null,
        isDeleted: element.isDeleted ?? false,
        id: element.id || randomId(),
        fillStyle: element.fillStyle || DEFAULT_ELEMENT_PROPS.fillStyle,
        strokeWidth: element.strokeWidth || DEFAULT_ELEMENT_PROPS.strokeWidth,
        strokeStyle: element.strokeStyle ?? DEFAULT_ELEMENT_PROPS.strokeStyle,
        roughness: element.roughness ?? DEFAULT_ELEMENT_PROPS.roughness,
        opacity: element.opacity == null ? DEFAULT_ELEMENT_PROPS.opacity : element.opacity,
        angle: element.angle || 0,
        x: extra.x ?? element.x ?? 0,
        y: extra.y ?? element.y ?? 0,
        strokeColor: element.strokeColor || DEFAULT_ELEMENT_PROPS.strokeColor,
        backgroundColor: element.backgroundColor || DEFAULT_ELEMENT_PROPS.backgroundColor,
        width: element.width || 0,
        height: element.height || 0,
        seed: element.seed ?? 1,
        groupIds: element.groupIds ?? [],
        frameId: element.frameId ?? null,
        roundness: element.roundness ? element.roundness : element.strokeSharpness === "round" ? {
          // for old elements that would now use adaptive radius algo,
          // use legacy algo instead
          type: isUsingAdaptiveRadius(element.type) ? ROUNDNESS.LEGACY : ROUNDNESS.PROPORTIONAL_RADIUS
        } : null,
        boundElements: element.boundElementIds ? element.boundElementIds.map((id) => ({ type: "arrow", id })) : element.boundElements ?? [],
        updated: element.updated ?? getUpdatedTimestamp(),
        link: element.link ? normalizeLink(element.link) : null,
        locked: element.locked ?? false
      };
      if ("customData" in element || "customData" in extra) {
        base.customData = "customData" in extra ? extra.customData : element.customData;
      }
      return {
        ...base,
        ...getNormalizedDimensions(base),
        ...extra
      };
    };
    restoreElement = (element) => {
      switch (element.type) {
        case "text":
          let fontSize = element.fontSize;
          let fontFamily = element.fontFamily;
          if ("font" in element) {
            const [fontPx, _fontFamily] = element.font.split(" ");
            fontSize = parseFloat(fontPx);
            fontFamily = getFontFamilyByName(_fontFamily);
          }
          const text = typeof element.text === "string" && element.text || "";
          const lineHeight = element.lineHeight || (element.height ? (
            // detect line-height from current element height and font-size
            detectLineHeight(element)
          ) : (
            // no element height likely means programmatic use, so default
            // to a fixed line height
            getLineHeight(element.fontFamily)
          ));
          element = restoreElementWithProperties(element, {
            fontSize,
            fontFamily,
            text,
            textAlign: element.textAlign || DEFAULT_TEXT_ALIGN,
            verticalAlign: element.verticalAlign || DEFAULT_VERTICAL_ALIGN,
            containerId: element.containerId ?? null,
            originalText: element.originalText || text,
            autoResize: element.autoResize ?? true,
            lineHeight
          });
          if (!text && !element.isDeleted) {
            element = { ...element, originalText: text, isDeleted: true };
            element = bumpVersion(element);
          }
          return element;
        case "freedraw": {
          return restoreElementWithProperties(element, {
            points: element.points,
            lastCommittedPoint: null,
            simulatePressure: element.simulatePressure,
            pressures: element.pressures
          });
        }
        case "image":
          return restoreElementWithProperties(element, {
            status: element.status || "pending",
            fileId: element.fileId,
            scale: element.scale || [1, 1]
          });
        case "line":
        case "draw":
          const { startArrowhead = null, endArrowhead = null } = element;
          let x = element.x;
          let y = element.y;
          let points = (
            // migrate old arrow model to new one
            !Array.isArray(element.points) || element.points.length < 2 ? [pointFrom(0, 0), pointFrom(element.width, element.height)] : element.points
          );
          if (points[0][0] !== 0 || points[0][1] !== 0) {
            ({ points, x, y } = LinearElementEditor.getNormalizedPoints(element));
          }
          return restoreElementWithProperties(element, {
            type: element.type === "draw" ? "line" : element.type,
            startBinding: repairBinding(element, element.startBinding),
            endBinding: repairBinding(element, element.endBinding),
            lastCommittedPoint: null,
            startArrowhead,
            endArrowhead,
            points,
            x,
            y,
            ...getSizeFromPoints(points)
          });
        case "arrow": {
          const { startArrowhead: startArrowhead2 = null, endArrowhead: endArrowhead2 = "arrow" } = element;
          let x2 = element.x;
          let y2 = element.y;
          let points2 = (
            // migrate old arrow model to new one
            !Array.isArray(element.points) || element.points.length < 2 ? [pointFrom(0, 0), pointFrom(element.width, element.height)] : element.points
          );
          if (points2[0][0] !== 0 || points2[0][1] !== 0) {
            ({ points: points2, x: x2, y: y2 } = LinearElementEditor.getNormalizedPoints(element));
          }
          return restoreElementWithProperties(element, {
            type: element.type,
            startBinding: repairBinding(element, element.startBinding),
            endBinding: repairBinding(element, element.endBinding),
            lastCommittedPoint: null,
            startArrowhead: startArrowhead2,
            endArrowhead: endArrowhead2,
            points: points2,
            x: x2,
            y: y2,
            elbowed: element.elbowed,
            ...getSizeFromPoints(points2)
          });
        }
        case "ellipse":
        case "rectangle":
        case "diamond":
        case "iframe":
        case "embeddable":
          return restoreElementWithProperties(element, {});
        case "magicframe":
        case "frame":
          return restoreElementWithProperties(element, {
            name: element.name ?? null
          });
      }
      return null;
    };
    repairContainerElement = (container, elementsMap) => {
      if (container.boundElements) {
        const boundElements = container.boundElements.slice();
        const boundIds = /* @__PURE__ */ new Set();
        container.boundElements = boundElements.reduce(
          (acc, binding) => {
            const boundElement = elementsMap.get(binding.id);
            if (boundElement && !boundIds.has(binding.id)) {
              boundIds.add(binding.id);
              if (boundElement.isDeleted) {
                return acc;
              }
              acc.push(binding);
              if (isTextElement(boundElement) && // being slightly conservative here, preserving existing containerId
              // if defined, lest boundElements is stale
              !boundElement.containerId) {
                boundElement.containerId = container.id;
              }
            }
            return acc;
          },
          []
        );
      }
    };
    repairBoundElement = (boundElement, elementsMap) => {
      const container = boundElement.containerId ? elementsMap.get(boundElement.containerId) : null;
      if (!container) {
        boundElement.containerId = null;
        return;
      }
      if (boundElement.isDeleted) {
        return;
      }
      if (container.boundElements && !container.boundElements.find((binding) => binding.id === boundElement.id)) {
        const boundElements = (container.boundElements || (container.boundElements = [])).slice();
        boundElements.push({ type: "text", id: boundElement.id });
        container.boundElements = boundElements;
      }
    };
    repairFrameMembership = (element, elementsMap) => {
      if (element.frameId) {
        const containingFrame = elementsMap.get(element.frameId);
        if (!containingFrame) {
          element.frameId = null;
        }
      }
    };
    restoreElements = (elements, localElements, opts) => {
      const existingIds = /* @__PURE__ */ new Set();
      const localElementsMap = localElements ? arrayToMap(localElements) : null;
      const restoredElements = syncInvalidIndices(
        (elements || []).reduce((elements2, element) => {
          if (element.type !== "selection" && !isInvisiblySmallElement(element)) {
            let migratedElement = restoreElement(element);
            if (migratedElement) {
              const localElement = localElementsMap?.get(element.id);
              if (localElement && localElement.version > migratedElement.version) {
                migratedElement = bumpVersion(
                  migratedElement,
                  localElement.version
                );
              }
              if (existingIds.has(migratedElement.id)) {
                migratedElement = { ...migratedElement, id: randomId() };
              }
              existingIds.add(migratedElement.id);
              elements2.push(migratedElement);
            }
          }
          return elements2;
        }, [])
      );
      if (!opts?.repairBindings) {
        return restoredElements;
      }
      const restoredElementsMap = arrayToMap(restoredElements);
      for (const element of restoredElements) {
        if (element.frameId) {
          repairFrameMembership(element, restoredElementsMap);
        }
        if (isTextElement(element) && element.containerId) {
          repairBoundElement(element, restoredElementsMap);
        } else if (element.boundElements) {
          repairContainerElement(element, restoredElementsMap);
        }
        if (opts.refreshDimensions && isTextElement(element)) {
          Object.assign(
            element,
            refreshTextDimensions(
              element,
              getContainerElement(element, restoredElementsMap),
              restoredElementsMap
            )
          );
        }
        if (isLinearElement(element)) {
          if (element.startBinding && (!restoredElementsMap.has(element.startBinding.elementId) || !isArrowElement(element))) {
            element.startBinding = null;
          }
          if (element.endBinding && (!restoredElementsMap.has(element.endBinding.elementId) || !isArrowElement(element))) {
            element.endBinding = null;
          }
        }
      }
      return restoredElements;
    };
    coalesceAppStateValue = (key, appState, defaultAppState2) => {
      const value = appState[key];
      return value !== void 0 ? value : defaultAppState2[key];
    };
    LegacyAppStateMigrations = {
      isSidebarDocked: (appState, defaultAppState2) => {
        return [
          "defaultSidebarDockedPreference",
          appState.isSidebarDocked ?? coalesceAppStateValue(
            "defaultSidebarDockedPreference",
            appState,
            defaultAppState2
          )
        ];
      }
    };
    restoreAppState = (appState, localAppState) => {
      appState = appState || {};
      const defaultAppState2 = getDefaultAppState();
      const nextAppState = {};
      for (const legacyKey of Object.keys(
        LegacyAppStateMigrations
      )) {
        if (legacyKey in appState) {
          const [nextKey, nextValue] = LegacyAppStateMigrations[legacyKey](
            appState,
            defaultAppState2
          );
          nextAppState[nextKey] = nextValue;
        }
      }
      for (const [key, defaultValue] of Object.entries(defaultAppState2)) {
        const suppliedValue = appState[key];
        const localValue = localAppState ? localAppState[key] : void 0;
        nextAppState[key] = suppliedValue !== void 0 ? suppliedValue : localValue !== void 0 ? localValue : defaultValue;
      }
      return {
        ...nextAppState,
        cursorButton: localAppState?.cursorButton || "up",
        // reset on fresh restore so as to hide the UI button if penMode not active
        penDetected: localAppState?.penDetected ?? (appState.penMode ? appState.penDetected ?? false : false),
        activeTool: {
          ...updateActiveTool(
            defaultAppState2,
            nextAppState.activeTool.type && AllowedExcalidrawActiveTools[nextAppState.activeTool.type] ? nextAppState.activeTool : { type: "selection" }
          ),
          lastActiveTool: null,
          locked: nextAppState.activeTool.locked ?? false
        },
        // Migrates from previous version where appState.zoom was a number
        zoom: {
          value: getNormalizedZoom(
            isFiniteNumber(appState.zoom) ? appState.zoom : appState.zoom?.value ?? defaultAppState2.zoom.value
          )
        },
        openSidebar: (
          // string (legacy)
          typeof appState.openSidebar === "string" ? { name: DEFAULT_SIDEBAR.name } : nextAppState.openSidebar
        ),
        gridSize: getNormalizedGridSize(
          isFiniteNumber(appState.gridSize) ? appState.gridSize : DEFAULT_GRID_SIZE
        ),
        gridStep: getNormalizedGridStep(
          isFiniteNumber(appState.gridStep) ? appState.gridStep : DEFAULT_GRID_STEP
        )
      };
    };
    restore = (data, localAppState, localElements, elementsConfig) => {
      return {
        elements: restoreElements(data?.elements, localElements, elementsConfig),
        appState: restoreAppState(data?.appState, localAppState || null),
        files: data?.files || {}
      };
    };
    restoreLibraryItem = (libraryItem) => {
      const elements = restoreElements(
        getNonDeletedElements2(libraryItem.elements),
        null
      );
      return elements.length ? { ...libraryItem, elements } : null;
    };
    restoreLibraryItems = (libraryItems = [], defaultStatus) => {
      const restoredItems = [];
      for (const item of libraryItems) {
        if (Array.isArray(item)) {
          const restoredItem = restoreLibraryItem({
            status: defaultStatus,
            elements: item,
            id: randomId(),
            created: Date.now()
          });
          if (restoredItem) {
            restoredItems.push(restoredItem);
          }
        } else {
          const _item = item;
          const restoredItem = restoreLibraryItem({
            ..._item,
            id: _item.id || randomId(),
            status: _item.status || defaultStatus,
            created: _item.created || Date.now()
          });
          if (restoredItem) {
            restoredItems.push(restoredItem);
          }
        }
      }
      return restoredItems;
    };
  }
});

// data/image.ts
var image_exports = {};
__export(image_exports, {
  decodePngMetadata: () => decodePngMetadata,
  decodeSvgMetadata: () => decodeSvgMetadata,
  encodePngMetadata: () => encodePngMetadata,
  encodeSvgMetadata: () => encodeSvgMetadata,
  getTEXtChunk: () => getTEXtChunk
});
import decodePng from "png-chunks-extract";
import tEXt from "png-chunk-text";
import encodePng from "png-chunks-encode";
var getTEXtChunk, encodePngMetadata, decodePngMetadata, encodeSvgMetadata, decodeSvgMetadata;
var init_image = __esm({
  "data/image.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_encode();
    init_constants();
    init_blob();
    getTEXtChunk = async (blob) => {
      const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));
      const metadataChunk = chunks.find((chunk2) => chunk2.name === "tEXt");
      if (metadataChunk) {
        return tEXt.decode(metadataChunk.data);
      }
      return null;
    };
    encodePngMetadata = async ({
      blob,
      metadata
    }) => {
      const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));
      const metadataChunk = tEXt.encode(
        MIME_TYPES.excalidraw,
        JSON.stringify(
          await encode({
            text: metadata,
            compress: true
          })
        )
      );
      chunks.splice(-1, 0, metadataChunk);
      return new Blob([encodePng(chunks)], { type: MIME_TYPES.png });
    };
    decodePngMetadata = async (blob) => {
      const metadata = await getTEXtChunk(blob);
      if (metadata?.keyword === MIME_TYPES.excalidraw) {
        try {
          const encodedData = JSON.parse(metadata.text);
          if (!("encoded" in encodedData)) {
            if ("type" in encodedData && encodedData.type === EXPORT_DATA_TYPES.excalidraw) {
              return metadata.text;
            }
            throw new Error("FAILED");
          }
          return await decode(encodedData);
        } catch (error) {
          console.error(error);
          throw new Error("FAILED");
        }
      }
      throw new Error("INVALID");
    };
    encodeSvgMetadata = async ({ text }) => {
      const base64 = await stringToBase64(
        JSON.stringify(await encode({ text })),
        true
      );
      let metadata = "";
      metadata += `<!-- payload-type:${MIME_TYPES.excalidraw} -->`;
      metadata += `<!-- payload-version:2 -->`;
      metadata += "<!-- payload-start -->";
      metadata += base64;
      metadata += "<!-- payload-end -->";
      return metadata;
    };
    decodeSvgMetadata = async ({ svg }) => {
      if (svg.includes(`payload-type:${MIME_TYPES.excalidraw}`)) {
        const match = svg.match(
          /<!-- payload-start -->\s*(.+?)\s*<!-- payload-end -->/
        );
        if (!match) {
          throw new Error("INVALID");
        }
        const versionMatch = svg.match(/<!-- payload-version:(\d+) -->/);
        const version = versionMatch?.[1] || "1";
        const isByteString = version !== "1";
        try {
          const json = await base64ToString(match[1], isByteString);
          const encodedData = JSON.parse(json);
          if (!("encoded" in encodedData)) {
            if ("type" in encodedData && encodedData.type === EXPORT_DATA_TYPES.excalidraw) {
              return json;
            }
            throw new Error("FAILED");
          }
          return await decode(encodedData);
        } catch (error) {
          console.error(error);
          throw new Error("FAILED");
        }
      }
      throw new Error("INVALID");
    };
  }
});

// data/blob.ts
import { nanoid as nanoid2 } from "nanoid";
var parseFileContents, getFileHandleType, isImageFileHandleType, isImageFileHandle, isSupportedImageFile, loadSceneOrLibraryFromBlob, loadFromBlob, parseLibraryJSON, loadLibraryFromBlob, canvasToBlob, generateIdFromFile, getDataURL, dataURLToFile, resizeImageFile, SVGStringToFile, ImageURLToFile, getFileFromEvent, getFileHandle, getActualMimeTypeFromImage, createFile, normalizeFile, blobToArrayBuffer;
var init_blob = __esm({
  "data/blob.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_appState();
    init_constants();
    init_element();
    init_errors();
    init_scene();
    init_utils2();
    init_filesystem();
    init_json();
    init_restore();
    parseFileContents = async (blob) => {
      let contents;
      if (blob.type === MIME_TYPES.png) {
        try {
          return await (await Promise.resolve().then(() => (init_image(), image_exports))).decodePngMetadata(blob);
        } catch (error) {
          if (error.message === "INVALID") {
            throw new ImageSceneDataError(
              "Image doesn't contain scene",
              "IMAGE_NOT_CONTAINS_SCENE_DATA"
            );
          } else {
            throw new ImageSceneDataError("Error: cannot restore image");
          }
        }
      } else {
        if ("text" in Blob) {
          contents = await blob.text();
        } else {
          contents = await new Promise((resolve) => {
            const reader = new FileReader();
            reader.readAsText(blob, "utf8");
            reader.onloadend = () => {
              if (reader.readyState === FileReader.DONE) {
                resolve(reader.result);
              }
            };
          });
        }
        if (blob.type === MIME_TYPES.svg) {
          try {
            return await (await Promise.resolve().then(() => (init_image(), image_exports))).decodeSvgMetadata({
              svg: contents
            });
          } catch (error) {
            if (error.message === "INVALID") {
              throw new ImageSceneDataError(
                "Image doesn't contain scene",
                "IMAGE_NOT_CONTAINS_SCENE_DATA"
              );
            } else {
              throw new ImageSceneDataError("Error: cannot restore image");
            }
          }
        }
      }
      return contents;
    };
    getFileHandleType = (handle) => {
      if (!handle) {
        return null;
      }
      return handle.name.match(/\.(json|excalidraw|png|svg)$/)?.[1] || null;
    };
    isImageFileHandleType = (type) => {
      return type === "png" || type === "svg";
    };
    isImageFileHandle = (handle) => {
      const type = getFileHandleType(handle);
      return type === "png" || type === "svg";
    };
    isSupportedImageFile = (blob) => {
      const { type } = blob || {};
      return !!type && Object.values(IMAGE_MIME_TYPES).includes(type);
    };
    loadSceneOrLibraryFromBlob = async (blob, localAppState, localElements, fileHandle) => {
      const contents = await parseFileContents(blob);
      let data;
      try {
        try {
          data = JSON.parse(contents);
        } catch (error) {
          if (isSupportedImageFile(blob)) {
            throw new ImageSceneDataError(
              "Image doesn't contain scene",
              "IMAGE_NOT_CONTAINS_SCENE_DATA"
            );
          }
          throw error;
        }
        if (isValidExcalidrawData(data)) {
          return {
            type: MIME_TYPES.excalidraw,
            data: restore(
              {
                elements: clearElementsForExport(data.elements || []),
                appState: {
                  theme: localAppState?.theme,
                  fileHandle: fileHandle || blob.handle || null,
                  ...cleanAppStateForExport(data.appState || {}),
                  ...localAppState ? calculateScrollCenter(data.elements || [], localAppState) : {}
                },
                files: data.files
              },
              localAppState,
              localElements,
              { repairBindings: true, refreshDimensions: false }
            )
          };
        } else if (isValidLibrary(data)) {
          return {
            type: MIME_TYPES.excalidrawlib,
            data
          };
        }
        throw new Error("Error: invalid file");
      } catch (error) {
        if (error instanceof ImageSceneDataError) {
          throw error;
        }
        throw new Error("Error: invalid file");
      }
    };
    loadFromBlob = async (blob, localAppState, localElements, fileHandle) => {
      const ret = await loadSceneOrLibraryFromBlob(
        blob,
        localAppState,
        localElements,
        fileHandle
      );
      if (ret.type !== MIME_TYPES.excalidraw) {
        throw new Error("Error: invalid file");
      }
      return ret.data;
    };
    parseLibraryJSON = (json, defaultStatus = "unpublished") => {
      const data = JSON.parse(json);
      if (!isValidLibrary(data)) {
        throw new Error("Invalid library");
      }
      const libraryItems = data.libraryItems || data.library;
      return restoreLibraryItems(libraryItems, defaultStatus);
    };
    loadLibraryFromBlob = async (blob, defaultStatus = "unpublished") => {
      return parseLibraryJSON(await parseFileContents(blob), defaultStatus);
    };
    canvasToBlob = async (canvas2) => {
      return new Promise(async (resolve, reject) => {
        try {
          if (isPromiseLike(canvas2)) {
            canvas2 = await canvas2;
          }
          canvas2.toBlob((blob) => {
            if (!blob) {
              return reject(
                new CanvasError("Error: Canvas too big", "CANVAS_POSSIBLY_TOO_BIG")
              );
            }
            resolve(blob);
          });
        } catch (error) {
          reject(error);
        }
      });
    };
    generateIdFromFile = async (file2) => {
      try {
        const hashBuffer = await window.crypto.subtle.digest(
          "SHA-1",
          await blobToArrayBuffer(file2)
        );
        return bytesToHexString(new Uint8Array(hashBuffer));
      } catch (error) {
        console.error(error);
        return nanoid2(40);
      }
    };
    getDataURL = async (file2) => {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          const dataURL = reader.result;
          resolve(dataURL);
        };
        reader.onerror = (error) => reject(error);
        reader.readAsDataURL(file2);
      });
    };
    dataURLToFile = (dataURL, filename = "") => {
      const dataIndexStart = dataURL.indexOf(",");
      const byteString = atob(dataURL.slice(dataIndexStart + 1));
      const mimeType = dataURL.slice(0, dataIndexStart).split(":")[1].split(";")[0];
      const ab = new ArrayBuffer(byteString.length);
      const ia = new Uint8Array(ab);
      for (let i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
      }
      return new File([ab], filename, { type: mimeType });
    };
    resizeImageFile = async (file2, opts) => {
      if (file2.type === MIME_TYPES.svg) {
        return file2;
      }
      const [pica, imageBlobReduce] = await Promise.all([
        import("pica").then((res) => res.default),
        // a wrapper for pica for better API
        import("image-blob-reduce").then((res) => res.default)
      ]);
      const reduce = imageBlobReduce({
        pica: pica({ features: ["js", "wasm"] })
      });
      if (opts.outputType) {
        const { outputType } = opts;
        reduce._create_blob = function(env) {
          return this.pica.toBlob(env.out_canvas, outputType, 0.8).then((blob) => {
            env.out_blob = blob;
            return env;
          });
        };
      }
      if (!isSupportedImageFile(file2)) {
        throw new Error("Error: unsupported file type", { cause: "UNSUPPORTED" });
      }
      return new File(
        [await reduce.toBlob(file2, { max: opts.maxWidthOrHeight })],
        file2.name,
        {
          type: opts.outputType || file2.type
        }
      );
    };
    SVGStringToFile = (SVGString, filename = "") => {
      return new File([new TextEncoder().encode(SVGString)], filename, {
        type: MIME_TYPES.svg
      });
    };
    ImageURLToFile = async (imageUrl, filename = "") => {
      let response;
      try {
        response = await fetch(imageUrl);
      } catch (error) {
        throw new Error("Error: failed to fetch image", { cause: "FETCH_ERROR" });
      }
      if (!response.ok) {
        throw new Error("Error: failed to fetch image", { cause: "FETCH_ERROR" });
      }
      const blob = await response.blob();
      if (blob.type && isSupportedImageFile(blob)) {
        const name = filename || blob.name || "";
        return new File([blob], name, { type: blob.type });
      }
      throw new Error("Error: unsupported file type", { cause: "UNSUPPORTED" });
    };
    getFileFromEvent = async (event) => {
      const file2 = event.dataTransfer.files.item(0);
      const fileHandle = await getFileHandle(event);
      return { file: file2 ? await normalizeFile(file2) : null, fileHandle };
    };
    getFileHandle = async (event) => {
      if (nativeFileSystemSupported) {
        try {
          const item = event.dataTransfer.items[0];
          const handle = await item.getAsFileSystemHandle() || null;
          return handle;
        } catch (error) {
          console.warn(error.name, error.message);
          return null;
        }
      }
      return null;
    };
    getActualMimeTypeFromImage = (buffer) => {
      let mimeType = null;
      const first8Bytes = `${[...new Uint8Array(buffer).slice(0, 8)].join(" ")} `;
      const headerBytes = {
        // https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header
        png: "137 80 78 71 13 10 26 10 ",
        // https://en.wikipedia.org/wiki/JPEG#Syntax_and_structure
        // jpg is a bit wonky. Checking the first three bytes should be enough,
        // but may yield false positives. (https://stackoverflow.com/a/23360709/927631)
        jpg: "255 216 255 ",
        // https://en.wikipedia.org/wiki/GIF#Example_GIF_file
        gif: "71 73 70 56 57 97 "
      };
      if (first8Bytes === headerBytes.png) {
        mimeType = MIME_TYPES.png;
      } else if (first8Bytes.startsWith(headerBytes.jpg)) {
        mimeType = MIME_TYPES.jpg;
      } else if (first8Bytes.startsWith(headerBytes.gif)) {
        mimeType = MIME_TYPES.gif;
      }
      return mimeType;
    };
    createFile = (blob, mimeType, name) => {
      return new File([blob], name || "", {
        type: mimeType
      });
    };
    normalizeFile = async (file2) => {
      if (!file2.type) {
        if (file2?.name?.endsWith(".excalidrawlib")) {
          file2 = createFile(
            await blobToArrayBuffer(file2),
            MIME_TYPES.excalidrawlib,
            file2.name
          );
        } else if (file2?.name?.endsWith(".excalidraw")) {
          file2 = createFile(
            await blobToArrayBuffer(file2),
            MIME_TYPES.excalidraw,
            file2.name
          );
        } else {
          const buffer = await blobToArrayBuffer(file2);
          const mimeType = getActualMimeTypeFromImage(buffer);
          if (mimeType) {
            file2 = createFile(buffer, mimeType, file2.name);
          }
        }
      } else if (isSupportedImageFile(file2)) {
        const buffer = await blobToArrayBuffer(file2);
        const mimeType = getActualMimeTypeFromImage(buffer);
        if (mimeType && mimeType !== file2.type) {
          file2 = createFile(buffer, mimeType, file2.name);
        }
      }
      return file2;
    };
    blobToArrayBuffer = (blob) => {
      if ("arrayBuffer" in blob) {
        return blob.arrayBuffer();
      }
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (event) => {
          if (!event.target?.result) {
            return reject(new Error("Couldn't convert blob to ArrayBuffer"));
          }
          resolve(event.target.result);
        };
        reader.readAsArrayBuffer(blob);
      });
    };
  }
});

// data/encryption.ts
var init_encryption = __esm({
  "data/encryption.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_blob();
  }
});

// data/encode.ts
import { deflate, inflate } from "pako";
var toByteString, byteStringToArrayBuffer, byteStringToString, stringToBase64, base64ToString, base64ToArrayBuffer, encode, decode;
var init_encode = __esm({
  "data/encode.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_encryption();
    toByteString = (data) => {
      return new Promise((resolve, reject) => {
        const blob = typeof data === "string" ? new Blob([new TextEncoder().encode(data)]) : new Blob([data instanceof Uint8Array ? data : new Uint8Array(data)]);
        const reader = new FileReader();
        reader.onload = (event) => {
          if (!event.target || typeof event.target.result !== "string") {
            return reject(new Error("couldn't convert to byte string"));
          }
          resolve(event.target.result);
        };
        reader.readAsBinaryString(blob);
      });
    };
    byteStringToArrayBuffer = (byteString) => {
      const buffer = new ArrayBuffer(byteString.length);
      const bufferView = new Uint8Array(buffer);
      for (let i = 0, len = byteString.length; i < len; i++) {
        bufferView[i] = byteString.charCodeAt(i);
      }
      return buffer;
    };
    byteStringToString = (byteString) => {
      return new TextDecoder("utf-8").decode(byteStringToArrayBuffer(byteString));
    };
    stringToBase64 = async (str, isByteString = false) => {
      return isByteString ? window.btoa(str) : window.btoa(await toByteString(str));
    };
    base64ToString = async (base64, isByteString = false) => {
      return isByteString ? window.atob(base64) : byteStringToString(window.atob(base64));
    };
    base64ToArrayBuffer = (base64) => {
      if (typeof Buffer !== "undefined") {
        return Buffer.from(base64, "base64").buffer;
      }
      return byteStringToArrayBuffer(atob(base64));
    };
    encode = async ({
      text,
      compress
    }) => {
      let deflated;
      if (compress !== false) {
        try {
          deflated = await toByteString(deflate(text));
        } catch (error) {
          console.error("encode: cannot deflate", error);
        }
      }
      return {
        version: "1",
        encoding: "bstring",
        compressed: !!deflated,
        encoded: deflated || await toByteString(text)
      };
    };
    decode = async (data) => {
      let decoded;
      switch (data.encoding) {
        case "bstring":
          decoded = data.compressed ? data.encoded : await byteStringToString(data.encoded);
          break;
        default:
          throw new Error(`decode: unknown encoding "${data.encoding}"`);
      }
      if (data.compressed) {
        return inflate(new Uint8Array(byteStringToArrayBuffer(decoded)), {
          to: "string"
        });
      }
      return decoded;
    };
  }
});

// fonts/wasm/woff2.wasm.ts
var woff2_wasm_exports = {};
__export(woff2_wasm_exports, {
  default: () => woff2_wasm_default
});
var __toBinary, woff2_wasm_default;
var init_woff2_wasm = __esm({
  "fonts/wasm/woff2.wasm.ts"() {
    "use strict";
    init_define_import_meta_env();
    __toBinary = /* @__PURE__ */ (() => {
      const table = new Uint8Array(128);
      for (let i = 0; i < 64; i++) {
        table[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i * 4 - 205] = i;
      }
      return (base64) => {
        const n = base64.length;
        const bytes = new Uint8Array((n - (base64[n - 1] == "=") - (base64[n - 2] == "=")) * 3 / 4 | 0);
        for (let i2 = 0, j = 0; i2 < n; ) {
          const c0 = table[base64.charCodeAt(i2++)];
          const c1 = table[base64.charCodeAt(i2++)];
          const c2 = table[base64.charCodeAt(i2++)];
          const c3 = table[base64.charCodeAt(i2++)];
          bytes[j++] = c0 << 2 | c1 >> 4;
          bytes[j++] = c1 << 4 | c2 >> 2;
          bytes[j++] = c2 << 6 | c3;
        }
        return bytes;
      };
    })();
    woff2_wasm_default = __toBinary(`AGFzbQEAAAABmwMrYAABf2ACf38AYAN/f38AYAF/AX9gA39/fwF/YAR/f39/AX9gAn9/AX9gBn98f39/fwF/YAN/fn8BfmAEf39/fwBgBn9/f39/fwBgBX9/f39/AGAAAGABfwBgDX9/f39/f39/f39/f38AYAh/f39/f39/fwBgAXwBfGAFf39/f38Bf2AGf39/f39/AX9gB39/f39/f38Bf2ABfwF+YAt/f39/f39/f39/fwBgCn9/f39/f39/f38AYAd/f39/f39/AGAIf39/f39/f38Bf2AOf39/f39/f39/f39/f38AYAl/f39/f39/f38AYAp/f39/f39/f39/AX9gDX9/f39/f39/f39/f38Bf2AEfX9/fwF/YAx/f39/f39/f39/f38AYAt/f39/f39/f39/fwF/YAF/AXxgD39/f39/f39/f39/f39/fwBgCX9/f39/f39/fwF/YAJ/fwF8YAF+AX9gEX9/f35/f39/f39/f39/f39/AGAGf39+f39/AX9gA35/fwF/YAJ+fwF/YAJ8fwF8YAd/f3x/f39/AX8CoQkyA2VudhJhYm9ydFN0YWNrT3ZlcmZsb3cADQNlbnYOX2xsdm1fbG9nMl9mNjQAEANlbnYGX2Fib3J0AAwDZW52HV9fZW1iaW5kX3JlZ2lzdGVyX21lbW9yeV92aWV3AAIDZW52DF9fX2N4YV90aHJvdwACA2VudhlfX19jeGFfYWxsb2NhdGVfZXhjZXB0aW9uAAMDZW52GV9fZW1iaW5kX3JlZ2lzdGVyX2ludGVnZXIACwNlbnYgX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfZnVuY3Rpb24ADwNlbnYcX19lbWJpbmRfcmVnaXN0ZXJfc3RkX3N0cmluZwABA2VudhdfX2VtYmluZF9yZWdpc3Rlcl9mbG9hdAACA2VudgtudWxsRnVuY192aQANA2VudgpudWxsRnVuY192AA0DZW52DW51bGxGdW5jX2ppamkADQNlbnYObnVsbEZ1bmNfaWlpaWkADQNlbnYNbnVsbEZ1bmNfaWlpaQANA2Vudg9fX193YXNpX2ZkX3NlZWsAEQNlbnYLc2V0VGVtcFJldDAADQNlbnYKX2xsdm1fdHJhcAAMA2VudgVfZXhpdAANA2VudhdfZW1zY3JpcHRlbl9yZXNpemVfaGVhcAADA2VudgxudWxsRnVuY19paWkADQNlbnYWX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZwAEA2VudhlfZW1zY3JpcHRlbl9nZXRfaGVhcF9zaXplAAADZW52El9fZW12YWxfdGFrZV92YWx1ZQAGA2Vudg5fX2VtdmFsX2luY3JlZgANA2Vudg5fX2VtdmFsX2RlY3JlZgANA2VudhZfX2VtYmluZF9yZWdpc3Rlcl92b2lkAAEDZW52HV9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nAAIDZW52EG51bGxGdW5jX2lpZGlpaWkADQNlbnYaX19lbWJpbmRfcmVnaXN0ZXJfZnVuY3Rpb24ACgNlbnYXX19lbWJpbmRfcmVnaXN0ZXJfZW12YWwAAQNlbnYjX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfY29uc3RydWN0b3IACgNlbnYXX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3MADgNlbnYWX19lbWJpbmRfcmVnaXN0ZXJfYm9vbAALA2VudhBfX193YXNpX2ZkX3dyaXRlAAUDZW52EF9fX3dhc2lfZmRfY2xvc2UAAwNlbnYLbnVsbEZ1bmNfaWkADQNlbnYJX19fdW5sb2NrAA0DZW52B19fX2xvY2sADQNlbnYOX19fYXNzZXJ0X2ZhaWwACQNlbnYQbnVsbEZ1bmNfdmlpaWlpaQANA2Vudg9udWxsRnVuY192aWlpaWkADQNlbnYObnVsbEZ1bmNfdmlpaWkADQNlbnYNbnVsbEZ1bmNfdmlpaQANA2VudgxudWxsRnVuY192aWkADQNlbnYKbnVsbEZ1bmNfaQANA2VudgxfX3RhYmxlX2Jhc2UDfwAGZ2xvYmFsCEluZmluaXR5A3wAA2VudgZtZW1vcnkCAIACA2VudgV0YWJsZQFwAeAC4AIDsgiwCAEBBgEEBAYGBg0GBgsBAw0NDQMBAwEGAQYGAQMGBAMJAgQCCwMCBAYCBAIDAgMGBgECDQIGBAIDBg8JBgYNFwQGAQYGBAYLAwYDAQ0DBgsTAwEBAQYBBAMCBAMDAgYJAwYGAQMBKAEDBA8BDQsBBgQGAQYNAw0DDQMGAwwNAyQBCwQGCQYNAg0LBAQDBAkNAw0GBgMBAgIJAQ0CIyIjIgIEFyAgAg0NAQYREQkNDQkJCg0DAQEBBAYBAQMDBgYBCQMBBgYNBgYBAwMDAQ0JAgIDBQMRBAMGAxQFAQEOCQIBCQkKCSAJFxoBDQEFAg0BCQEBDQEGEQMGAwIBAwERBQkCAg0BDAkBBg0NDQETAwkCAgQDAwEGAQUGBg0EAQYGBgkFAxIBAQMCBgQFBQYDAQIBBgMJAQMDAgYCBgQDBgYEDQEFAw0pAwQGAgMDCQ0mEQ0JCQkJCQkJAQENDQUNEQENBQECAQEBCgoVFyMiFxceDw0BBBcXCyERBgMGARwJCRsCFgUNAgEDAgMDDQkEAgIJAQQFAwMNAQ0FEgMDDQ0NBgMDEQ0BBg0DAwUEDQIGDQENBgENAQQFARQBAQEEDAgFBg8BAg0NDQ0NDQwMDAkLCgYGBAQNAwECBgYGBgYBAgYGBgYGAQYBARcTBgEDAQIEAQQBBgEGAQEKEgECBAECBAEBAQYGAgMDAwYGAQYEAQEBAgQBAQICAQEGAQkEAgIBBgECBAEGAwEGBgYGAQIECQEBBgYGBgEBBgELEQEJBQECBAQBAgQBAgEBCQUEAgEGAQMBBgMBAgUBBAECAwEBAwEJAQkJAgYCBAEKBgEJBAEEBAEGAQYGAQQBBgMDAwYBAgQBEwEGAQYBBgIEAxMDAwEBBgYGBgEGBAEGAQEBAgEBBgMBAQIGAQIGAQEGDQYMAQEBBgIEDQEDAwMNDQ0EAwkLCgkNCwoEDA0SBAYFAgYoJwQBBwUGCAMECAQDCQQNBgQJEw8lAg0EAgMSEgQSBRIDDQ0NAAQJCRcBCh4KBQoGAQoFCgENFRUVFQMCFRUPBAkCCgUPFxcMFwkFCwsBHxceHh0BAQkFBBkJCgsYDAkJCQoLGAkJCQoGDQsYCQkLCwsKBg0WCw8JDw8PDw8PDw8PDQYKCQkLAhUVFQ0VFRUVFRUVCQMCAg0BAgwBAwMDAwMNAAMFBAQNDQEBAQ0BAQEBAwABAQEBAQEGAgMBAQMEAgENAQEJAQEFEQIJDQIBAgIJAQQCCQIRAw0CAxEJAQQDDRENBQMCDQ0DAwYCBgMEAg0NAwMBAw0DAwYGAwIFDQYGEgUEBAIFBAEBAQENAQEJAQEBBAECAQIJAQENAQEMAQEGAQICBAEBAQEBAhEKCwcDABcKBQsJAgENEQUEKgYTAwMCCwILARIBAQADDAwMDAwMDAwMDAwMDAwMBAwGEAJ/AUHAvxoLfwFB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AiAAQQFqNgIAC3EBAX8gASABKAIAIgNBAWo2AgAgAiADaiAAQRh2OgAAIAEgASgCACIDQQFqNgIAIAIgA2ogAEEQdjoAACABIAEoAgAiA0EBajYCACACIANqIABBCHY6AAAgASABKAIAIgFBAWo2AgAgASACaiAAOgAAC0EAIAAgAWogAkEYdjoAACAAIAFBAWpqIAJBEHY6AAAgACABQQJqaiACQQh2OgAAIAAgAUEDamogAjoAACABQQRqCxgAIAAoAgBBIHFFBEAgASACIAAQ9QIaCwuRAQEDfyMCIQYjAkGAAmokAiMCIwNOBEBBgAIQAAsgBiEFIARBgMAEcUUgAiADSnEEQCAFIAFBGHRBGHUgAiADayIBQYACIAFBgAJJGxAzGiABQf8BSwRAAn8gAiADayEHA0AgACAFQYACEFAgAUGAfmoiAUH/AUsNAAsgBwtB/wFxIQELIAAgBSABEFALIAYkAgsXACAAKQAAQoCAgOj7tI2PvX9+QjCIpws5AQF/IAEgASgCACIDQQFqNgIAIAIgA2ogAEEIdjoAACABIAEoAgAiAUEBajYCACABIAJqIAA6AAALYgECfyABIABIIAAgASACakhxBEACfyAAIQQgASACaiEBIAAgAmohAANAIAJBAEoEQCACQQFrIQIgAEEBayIAIAFBAWsiASwAADoAAAwBCwsgBAshAAUgACABIAIQMhoLIAALOAECfyAAKAIIIgJBAmoiAyAAKAIESwR/QQAFIAEgAiAAKAIAai4AABDCCDsBACAAIAM2AghBAQsLFwAgACABNgIAIAAgAjYCBCAAQQA2AggLIQAgACABaiACQQh2OgAAIAAgAUEBamogAjoAACABQQJqCy4AIAAgASABQQhqIgAoAgAgAkECdGogACgCBBDhAiAAIAAoAgAgAkECdGo2AgQLDQAgACgCACAAKAIERgttAQF/IAEoAgAhAyACBEAgAUHuABA1GgsCQAJAIAEQTEUNACABKAIAIgIsAABBUGpBCk8NAANAAkAgARBMRQ0AIAIsAABBUGpBCk8NACABIAJBAWoiAjYCAAwBCwsgACADIAIQXwwBCyAAEGsLCwoAIAAoAiBBAEcLUQEDfyMCIQIjAkEQaiQCIwIjA04EQEEQEAALIAIiAyAAQQEQWiACEFkEf0EABSAAQcUAEDUEfyAAQfAC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AiMDTgRAQRAQAAsgBCICQQJqIgNBADoAACAAIAMQagR/An8CQAJAAkACQCADLAAAIgNBfWsOAwACAQMLIAJBADsBACAAIAIQVQR/IAEgAi8BADYCAEEBBUEACwwDCyACQQA6AAAgACACEGoEfyABIAItAABB/QFqNgIAQQEFQQALDAILIAJBADoAACAAIAIQagR/IAEgAi0AAEH6A2o2AgBBAQVBAAsMAQsgASADQf8BcTYCAEEBCwVBAAshBSAEJAIgBQvIBQEGfyMCIQQjAkEgaiQCIwIjA04EQEEgEAALIAQhAwJ/IAEgABBHIQcgAiABEEchBSAHCwR/An8gBQRAIAMgACkCADcCACADIAApAgg3AgggAyAAKQIQNwIQIAMgACkCGDcCGCAAIAIpAgA3AgAgACACKQIINwIIIAAgAikCEDcCECAAIAIpAhg3AhggAiADKQIANwIAIAIgAykCCDcCCCACIAMpAhA3AhAgAiADKQIYNwIYQQEMAQsgAyAAKQIANwIAIAMgACkCCDcCCCADIAApAhA3AhAgAyAAKQIYNwIYIAAgASkCADcCACAAIAEpAgg3AgggACABKQIQNwIQIAAgASkCGDcCGCABIAMpAgA3AgAgASADKQIINwIIIAEgAykCEDcCECABIAMpAhg3AhggAiABEEcEfyADIAEpAgA3AgAgAyABKQIINwIIIAMgASkCEDcCECADIAEpAhg3AhggASACKQIANwIAIAEgAikCCDcCCCABIAIpAhA3AhAgASACKQIYNwIYIAIgAykCADcCACACIAMpAgg3AgggAiADKQIQNwIQIAIgAykCGDcCGEECBUEBCwsFIAUEfyADIAEpAgA3AgAgAyABKQIINwIIIAMgASkCEDcCECADIAEpAhg3AhggASACKQIANwIAIAEgAikCCDcCCCABIAIpAhA3AhAgASACKQIYNwIYIAIgAykCADcCACACIAMpAgg3AgggAiADKQIQNwIQIAIgAykCGDcCGCABIAAQRwR/IAMgACkCADcCACADIAApAgg3AgggAyAAKQIQNwIQIAMgACkCGDcCGCAAIAEpAgA3AgAgACABKQIINwIIIAAgASkCEDcCECAAIAEpAhg3AhggASADKQIANwIAIAEgAykCCDcCCCABIAMpAhA3AhAgASADKQIYNwIYQQIFQQELBUEA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aigCAEcNACADQQFqDAELIABFIANBBEtxIABBAEcgA0EGS3FyBEAgByADa0EBIAMQMxoLIAVFBEAgBEECdCABaigCACEAC0EBCyEDIARBAWoiBCAGTQ0ACyAGQX5qIQhBACEFIAEoAgggASgCACABKAIEampBCHRBA25BpANqIQBBACEEQQAhAwNAAkACQCAFIAZGIgcNACACIAVqLAAADQAgBQRAIAIgBUF/amosAAANAQtB2AkgAGsgBUECdCABaigCACIJQQh0akGvE0sNACADIAlqIQcgBEEBaiIDQQNLBEAgAyEEIAdBCHQgA0EBdmogA24iAEH4AGogACADQQRGGyEABSADIQQLIAchAwwBCyADRSAEQQNGcSAEQQNLcgRAQQEgBEEBdiADaiIAIARuIAQgAEsbQQAgAxshAyAFQX9qIQlBACEAA0AgCSAAa0ECdCABaiADNgIAIAQgAEEBaiIARw0ACwsgBSAISQR/IAVBAmpBAnQgAWooAgAgBUECdCABaigCACAFQQFqQQJ0IAFqKAIAampBCHRBA25BpANqBSAFIAZJBH8gBUECdCABaigCAEEIdAVBAAsLIQAgBwRAQQAhAwUgBUECdCABaigCACEDC0EBIQQLIAVBAWoiBSAGTQ0ACwsLCwsLCy8BAX8gACgCBCIBIAAoAghHBEAgACABNgIICyAAKAIAIgEEQCAAKAIMGiABED8LC5kBAQR/IAFBBGoiAigCACAAKAIEIAAoAgAiA2siBWshBCACIAQ2AgAgBUEASgR/IAQgAyAFEDIaIAIhAyACKAIABSACIQMgBAshAiAAKAIAIQQgACACNgIAIAMgBDYCACAAKAIEIQIgACABKAIINgIEIAEgAjYCCCAAKAIIIQIgACABKAIMNgIIIAEgAjYCDCABIAMoAgA2AgALQAAgAEEANgIMIAAgAzYCECAAIAEEfyABEEIFQQALIgM2AgAgACACIANqIgI2AgggACACNgIEIAAgASADajYCDAsfACABBEAgACABKAIAEJ4CIAAgASgCBBCeAiABED8LCycAIAEEQCAAIAEoAgAQnwIgACABKAIEEJ8CIAFBEGoQywMgARA/CwsRACAAQQhqIgAgACgCBBCfAgsfACABBEAgACABKAIAEKECIAAgASgCBBChAiABED8LC0IBA38jAiECIwJBIGok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BEAgBCACQQEQYSAAKAIMIgIoAgAoAgwhACACIAEgAEEfcUEMahEGACEAIAQQYAsgAyQCIAALTgEDfyMCIQIjAkEQaiQCIwIjA04EQEEQEAALIAIhAyAAQRBqIgQsAAAEQEEAIQAFIAMgBEEBEGEgACgCDCABEHEhACADEGALIAIkAiAAC04BA38jAiECIwJBEGokAiMCIwNOBEBBEBAACyACIQMgAEEQaiIELAAABEBBACEABSADIARBARBhIAAoAgwgARBmIQAgAxBgCyACJAIgAAtPAQN/IwIhAiMCQRBqJAIjAiMDTgRAQRAQAAsgAiEDIABBEGoiBCwAAARAQQAhAAUgAyAEQQEQYSAAKAIMIAEQpwEhACADEGALIAIkAiAACywAIABBH0ECQQJBAhA6IABByN4ZNgIAIAAgATYCCCAAQQA2AgwgAEEAOgAQC1sBA38jAiECIwJBIGokAiMCIwNOBEBBIBAACyACQQhqIgRByo4aEC4gAkEQaiIDIAQpAgA3AgAgASADEC8gAiAAKQIINwMAIAMgAikCADcCACABIAMQLyACJAILYQEBfyMCIQIjAkEQaiQCIwIjA04EQEEQEAALIABBEBA0IQAgAiABKQIANwMAIAJBCGoiASACKQIANwIAIABBNkEBQQFBARA6IABBnN4ZNgIAIAAgASkCADcCCCACJAIgAAvVAgEGfyMCIQIjAkFAayQCIwIjA04EQEHAABAACyACQThqIQMgAkEwaiEGIAJBIGohByACIQQgAkEoaiIFIAE2AgAgBSAANgIEIAFBKBBIIAAsABgEQCAAKAIMIgQEQCAEIAEQOyABQSAQSCACIABBEGoiACkCADcDGCADIAIpAhg3AgAgASADEC8gAUEgEEgFIABBEGohAAsgBkGUjhoQLiADIAYpAgA3AgAgASADEC8gAiAAKQIANwMQIAMgAikCEDcCACABIAMQLyABQSAQSCAFEMgCBSAFEMgCIAFBIBBIIAIgACkCEDcDCCADIAIpAgg3AgAgASADEC8gB0GZjhoQLiADIAcpAgA3AgAgASADEC8gACgCDARAIAFBIBBIIAQgACkCEDcDACADIAQpAgA3AgAgASADEC8gAUEgEEggACgCDCABEDsLCyABQSkQSCACJAILOQAgAEE5QQFBAUEBEDogAEHw3Rk2AgAgACADNgII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AEHCAEEBQQFBARA6IABB3NgZNgIAIAAgATYCCCAAIAI2AgwgACADNgIQC28BBH8jAiEFIwJBEGokAiMCIwNOBEBBEBAACyABIAUiBCIGQQxqIAIQugEiBygCACICBH9BAAUgBCABIAMQhQUgASAGKAIMIAcgBCgCABCMASAEKAIAIQJBAQshASAAIAI2AgAgACABOgAEIAUkAguMAQEFfyMCIQMjAkEQaiQCIwIjA04EQEEQEAALIANBDGohBCADQQhqIQUgAyEGIABBADYCACAAQQA2AgQgAEEANgIIIAIoAgAiAiABKAIAIgFrIgcEQCAAIAcQmwEgAyABNgIEIAYgAjYCACAFIAMoAgQ2AgAgBCAGKAIANgIAIAAgBSAEEP0HCyADJAILSwEBfyMCIQIjAkEQaiQCIwIjA04EQEEQEAALIABBFBA0IQAgAiABKQIANwMAIAJBCGoiASACKQIANwIAIABBACABENUCIAIkAiAACygAIABBLEEBQQFBARA6IABBsNgZNgIAIAAgATYCCCAAIAIpAgA3AgwLTgEBfyMCIQMjAkEQaiQCIwIjA04EQEEQEAALIABBFBA0IQAgASgCACEBIAMgAhAuIANBCGoiAiADKQIANwIAIAAgASACEJYFIAMkAiAAC8ICAQV/IwIhBCMCQUBrJAIjAiMDTgRAQcAAEAALIARBOGohAiAEQTBqIQMgACwAHARAIANB84EaEC4gAiADKQIANwIAIAEgAhAvCyAEQSBqIQMgBEEoaiIFQf+BGhAuIAIgBSkCADcCACABIAIQLyAALAAdBEAgA0GDghoQLiACIAMpAgA3AgAgASACEC8LIARBGGohAyAEQRBqIQUgAUEgEEggAEEIaiIGENACRQRAIANBu/cZEC4gAiADKQIANwIAIAEgAhAvIAYgARBeIAVBt/cZEC4gAiAFKQIANwIAIAEgAhAvCyAEQQhqIQUgBCEDIAAoAhAgARA7IABBFGoiABDQAkUEQCAFQbv3GRAuIAIgBSkCADcCACABIAIQLyAAIAEQXiADQbf3GRAuIAIgAykCADcCACABIAIQLwsgBCQCC0YAIABBM0EBQQFBARA6IABBhNgZNgIAIAAgASkCADcCCCAAIAI2AhAgACADKQIANwIUIAAgBEEBcToAHCAAIAVBAXE6AB0LbAEDfyMCIQIjAkEg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BEAgB0EJaiIDBH8gBSADEDAFQQALIQYgACgCkAEiAwRAIAYgAyAAKAKIAUEJahAyGiAFIAAoApABEDEgAEEANgKQAQsgACAGNgKQASAAIAc2AogBIAAgBkECajYClAEgBkEAOgABIAAoApQBQX5qQQA6AABBACEDA0AgACgClAEgACgCiAEgA2pqQQA6AAAgA0EBaiIDQQdHDQALIAAoApQBIAQoAgBBfmpqQQA6AAAgACgClAEgBCgCAEF/ampBADoAACAAKAKMASEDCyAAKAKAASIFIABB/ABqIgcoAgAgA3EiBksEQCAAQZQBaiIDKAIAIAQoAgAgBmpqIAIgASAFIAZrIgUgBSABSxsQMhoFIABBlAFqIQMLIAMoAgAgBmohBSABIAZqIAQoAgBLBEAgBSACIAEgACgChAEgBmsiBSAFIAFLGxAyGiADKAIAIAIgBCgCACAGayICaiABIAJrEDIaBSAFIAIgARAyGgsgACgCjAFBAEghBSADKAIAIgJBfmogAiAEKAIAQX5qaiwAADoAACADKAIAIgJBf2ogAiAEKAIAQX9qaiwAADoAACAAIAAoAowBQf////8HcSABQf////8HcWoiAkGAgICAeHIgAiAFGyICNgKMAQsgACAAKQNwIAGtfDcDcCACIAcoAgBNBEAgAiAAKAKUAWoiAEEANgAAIABBADsABCAAQQA6AAYLCx8BAX4gABCGAiEBIAAQhQIiACABp2tBACABIACtVBsL+AUBHH8jAiEPIwJBEGokAiMCIwNOBEBBEBAACyAPQQRqIQsgDyEQIAEoAgAiCEEBIAAoAgh0IgwgCCAMSRsiB0GAgAggB0GAgAhJGyEGIABB4ABqIQggACgCBCIJQQJJBH8gCUEBRgR/An8gAEGsKWoiCigCACIJRSAHQf//B0txBEAgCiAIQYCAIBAwNgIAIABBsClqIAhBgIAIEDA2AgAgCigCACEJCyAJBEBBACEKIABBsClqKAIADAELIAYEfyAIIAZBAnQQMCIJIRggCCAGEDAiCgVBACEJQQAhCkEACwsFQQAhCUEACyEZIABBuClqIREgAEHUKWohEiAAQagiaiEaIABBqCNqIRsgAEGoKWohHCAAQaglaiEdIABBtClqIR4gAEG8KWohEyAFRSEfA0ACQCAAIAMgBCAFEIcCRQRAIBEoAgANASAS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AiAgACgCZCABQf8AcUHIAWoRAQAgAEEANgJkIAAoAhwhASAAKAIgIAAoAqwBIAFB/wBxQcgBahEBACAAQQA2AqwBC9cBACAAQQA2ArwBIABBgICACDYCxAEgAEGAgIAINgLIASAAQYCAgAg2AswBIABBATYC0AEgAEEBNgLUASAAQQE2AtgBIABBATYC3AEgAEEANgLgASAAQQE2AuQBIABBADYC6AEgAEEBNgLsASAAQQA2AvABIABB7CZqQQA2AgAgAEHwJmpBADYCACAAQQA2AoQCIABBADYCiAIgAEEAOgCMAiAAQQA2ApABIABBADYCjAEgAEEANgKgASAAQQA2ApwBIABCADcDcCAAQgA3A3ggAEEANgKAAQuFAwEDfyAAQRo2AhggAEHYADYCHCAAQQA2AiAgAEEANgJcIABBADYCCCAAQSA2AgwgAEEANgIAIABB3CZqIgIuAQAhAyAAQQA2AjAgAEEANgIEIABBADYCNCAAQQA2AqACIABBADYCpAIgAEEANgJkIABBQGtBADYCACAAQeQmakEANgIAIABBADYCRCAAQewmakEANgIAIABB8CZqQQA2AgAgAEEANgKEAiAAQQA2AmAgAEEANgKQASAAQQA2AowBIABBADYCoAEgAEEANgKcASAAQgA3AnQgAEIANwJ8IABBwCZqIgFCADcDACABQgA3AwggAUIANwMQIAFBADYCGCACIANBQHFBEHI7AQAgAEHgJmpBADYCACAAQQA2AjwgAEEQNgJMIABBDzYCUCAAQQs2AlQgAEEENgJYIABBADYCSCAAQQA2AqwBIABBADYCsAEgACAAQdgDajYCtAMgAEG4JGpBPzYCACAAQfQmakG4yxk2AgAgAEH4JmpB4MwZNgIAQQELLAECfyAAQUBrKAIAIgEgACgCNCICIAIgAUobIAEgACgCoAJsaiAAKAKkAmsLgQYBC38gASgCqAIiAyAASQR/An8gASgCsAIhBgNAAkBBASAGRQ0CGiACBEBBAiABKAIUIgRFDQMaIAEgASgCCEEIdiICNgIIIAEgASgCECIFLQAAQRh0IAJyNgIIIAEgASgCDEF4aiICNgIMIAEgBEF/ajYCFCABIAVBAWo2AhAFIAEoAgwhAgtBICACayIEBH8gASgCCCACdgVBAAshCyAEIAFBtAJqIAtBH3EiBUECdGot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AgAgAyAEKQIINwIIIAMgBCkCEDcCECADIAQpAhg3AhggBCEFA0ACQCAFIAIpAgA3AgAgBSACKQIINwIIIAUgAikCEDcCECAFIAIpAhg3AhggACACRgRAIAAhAgwBCyADIAJBYGoiBxBHBEAgAiEFIAchAgwCCwsLIAIgAykCADcCACACIAMpAgg3AgggAiADKQIQNwIQIAIgAykCGDcCGAsgBEEgaiIFIAFHBEAgBCECIAUhBAwBCwsLIAYkAgtrACAAIAEoAgA2AgAgACABLgEEOwEEIABBADYCCCAAQQA2AgwgAEEANgIQIAAgASgCCDYCCCAAIAEoAgw2AgwgACABKAIQNgIQIAFBADYCECABQQA2AgwgAUEANgIIIABBFGogAUEUahDjAwtKAQJ/IAAoAgQiAiAAKAIIIgFHBEADQCAAIAFBYGoiATYCCCABEPoBIAAoAggiASACRw0ACwsgACgCACIBBEAgACgCDBogARA/Cwu8AQEFfyABQQRqIQMgACgCACIGIAAoAgQiAkYEfyAAIQQgAygCACECIAMFIAMoAgAhBQNAIAVBYGogAkFgaiIEEJsIIAMgAygCAEFgaiICNgIAIAQgBkcEQCACIQUgBCECDAELCyAAIQQgACgCACEGIAMLIQUgBCACNgIAIAUgBjYCACAAKAIEIQIgACABKAIINgIEIAEgAjYCCCAAKAIIIQIgACABKAIMNgIIIAEgAjYCDCABIAUoAgA2AgALRwEBfyAAKAIIIQIDQCACQgA3AgAgAkIANwIIIAJCADcCECACQgA3AhggAhDiAyAAIAAoAghBIGoiAjYCCCABQX9qIgENAAsLsgEBAn8jAiEAIwJBEGokAiMCIwNOBEBBEBAAC0GguhlBuLoZQci6GUEAQajqGUEFQavqGUEAQavqGUEAQajoGUGt6hlB1QAQIBCaByAAQdcANgIAIABBADYCBCAAQQhqIgEgACkCADcCACABEIsHIABBAzYCACAAQQA2AgQgASAAKQIANwIAIAEQgQcgAEEGNgIAIABBADYCBCABIAApAgA3AgAgARDzBhDdBhDHBiAAJAILRwEBfyAAKAIEIQIDQCACQgA3AgAgAkIANwIIIAJCADcCECACQgA3AhggAhDiAyAAIAAoAgRBIGoiAjYCBCABQX9qIgENAAsLsgEBBn8jAiEEIwJBIGokAiMCIwNOBEBBIBAACyAEIQIgACgCCCAAKAIEIgNrQQV1IAFJBEBB////PyABIAMgACgCAGtBBXVqIgVJBEAQAgUgAiAFIAAoAgggACgCACIGayIHQQR1IgMgAyAFSRtB////PyAHQQV1Qf///x9JGyAAKAIEIAZrQQV1IABBCGoQrQIgAiABEJ4IIAAgAhCdCCACEJwICwUgACABEKAICyAEJAILQgEDfyMCIQIjAkEgaiQCIwIjA04EQEEgEAALIAIgATYCACACQQhqIgMgACABIAIQmQggAygCAEEUaiEEIAIkAiAEC0YBAn8gAEEANgIAIABBADYCBCAAQQA2AgggASgCBCABKAIAayIDQQV1IQIgAwRAIAAgAhCXCCAAIAEoAgAgASgCBBCWCAsLUQEBfyAAQQA2AgAgAEEANgIEIABBADYCCCABBEAgACABEJsBIAAoAgQhAwNAIAMgAiwAADoAACAAIAAoAgRBAWoiAzYCBCABQX9qIgENAAsLCzUBAX8gAEEANgIAIABBADYCBCAAQQA2AgggAiABayIDBEAgACADEJsBIAAgASACIAMQ2QELC1cBAn8gAQRAIAAoAgAhAyAAKAIEIQQDQCABKAIQIgAgA0kEfyABQQRqBQJ/IAMgAE8EQCABQQRqIAEoAhQgBEkNARoLIAEhAiABCwsoAgAiAQ0ACwsgAgsiAQF/IAAoAgQiAkEAIAFBAnQQMxogACABQQJ0IAJqNgIEC2EBAX9B/////wMgAUkEQBACCyABQf////8DSwRAQQgQBSIAQZbvGRBvIABBqOcZNgIAIABB0McZQc4AEAQFIAAgAUECdBBCIgI2AgQgACACNgIAIAAgAUECdCACajYCCAsLIgEBfyAAKAIIIgJBACABQQF0EDMaIAAgAUEBdCACajYCCAsiAQF/IAAoAgQiAkEAIAFBAXQQMxogACABQQF0IAJqNgIEC7ABAQV/IwIhBCMCQSBqJAIjAiMDTgRAQSAQAAsgBCECIAAoAgggACgCBCIDa0EBdSABSQRAQf////8HIAEgAyAAKAIAa0EBdWoiBUkEQBACBSACIAUgACgCCCAAKAIAIgNrIgYgBiAFSRtB/////wcgBkEBdUH/////A0kbIAAoAgQgA2tBAXUgAEEIahC8AiACIAEQqQggACACELkCIAIQuAILBSAA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AAUA0QAFAPEABgAxAQYAcQEHAPEBCADxAgkA8QQKAPEICwDxEAwA8SANAPFAGABBpg4L2oMDAgAAAAABAAADAAAAAAIAAAQAAAAAAwAABQAAAAADAAAGAAAAAAMAAAcAAAAAAwAACAAAAAADAAAJAAAAAAABAAIAAAAAAQEAAwAAAAACAQAEAAAAAAMBAAUAAAAAAwEABgAAAAADAQAHAAAAAAMBAAgAAAAAAwEACQAAAAAAAgACAAAAAAECAAMAAAAAAgIABAAAAAADAgAFAAAAAAMCAAYAAAAAAwIABwAAAAADAgAIAAAAAAMCAAkAAAAAAAMAAgAAAAABAwADAAAAAAIDAAQAAAAAAwMABQAAAAADAwAGAAAAAAMDAAcAAAAAAwMACAAAAAADAwAJAAAAAAAEAAIAAAAAAQQAAwAAAAACBAAEAAAAAAMEAAUAAAAAAwQABgAAAAADBAAHAAAAAAMEAAgAAAAAAwQACQAAAAAABQACAAAAAAEFAAMAAAAAAgUABAAAAAADBQAFAAAAAAMFAAYAAAAAAwUABwAAAAADBQAIAAAAAAMFAAkAAQAAAAYAAgABAAABBgADAAEAAAIGAAQAAQAAAwYABQABAAADBgAGAAEAAAMGAAcAAQAAAwYACAABAAADBgAJAAEAAAAIAAIAAQAAAQgAAwABAAACCAAEAAEAAAMIAAUAAQAAAwgABgABAAADCAAHAAEAAAMIAAgAAQAAAwgACQAAAQADAAAKAAABAAMAAAwAAAIAAwAADgAAAgADAAASAAADAAMAABYAAAMAAwAAHgAABAADAAAmAAAEAAMAADYAAAEAAwEACgAAAQADAQAMAAACAAMBAA4AAAIAAwEAEgAAAwADAQAWAAADAAMBAB4AAAQAAwEAJgAABAADAQA2AAABAAMCAAoAAAEAAwIADAAAAgADAgAOAAACAAMCABIAAAMAAwIAFgAAAwADAgAeAAAEAAMCACYAAAQAAwIANgAAAQADAwAKAAABAAMDAAwAAAIAAwMADgAAAgADAwASAAADAAMDABYAAAMAAwMAHgAABAADAwAmAAAEAAMDADYAAAEAAwQACgAAAQADBAAMAAACAAMEAA4AAAIAAwQAEgAAAwADBAAWAAADAAMEAB4AAAQAAwQAJgAABAADBAA2AAABAAMFAAoAAAEAAwUADAAAAgADBQAOAAACAAMFABIAAAMAAwUAFgAAAwADBQAeAAAEAAMFACYAAAQAAwUANgABAQADBgAKAAEBAAMGAAwAAQIAAwYADgABAgADBgASAAEDAAMGABYAAQMAAwYAHgABBAADBgAmAAEEAAMGADYAAQEAAwgACgABAQADCAAMAAECAAMIAA4AAQIAAwgAEgABAwADCAAWAAEDAAMIAB4AAQQAAwgAJgABBAADCAA2AAAA/wAAAAIAAAD/AQAAAwAAAP8CAAAEAAAA/wMAAAUAAAD/AwAABgAAAP8DAAAHAAAA/wMAAAgAAAD/AwAACQAAAP8AAQACAAAA/wEBAAMAAAD/AgEABAAAAP8DAQAFAAAA/wMBAAYAAAD/AwEABwAAAP8DAQAIAAAA/wMBAAkAAAD/AAIAAgAAAP8BAgADAAAA/wICAAQAAAD/AwIABQAAAP8DAgAGAAAA/wMCAAcAAAD/AwIACAAAAP8DAgAJAAAA/wADAAIAAAD/AQMAAwAAAP8CAwAEAAAA/wMDAAUAAAD/AwMABgAAAP8DAwAHAAAA/wMDAAgAAAD/AwMACQAAAP8ABAACAAAA/wEEAAMAAAD/AgQABAAAAP8DBAAFAAAA/wMEAAYAAAD/AwQABwAAAP8DBAAIAAAA/wMEAAkAAAD/AAUAAgAAAP8BBQADAAAA/wIFAAQAAAD/AwUABQAAAP8DBQAGAAAA/wMFAAcAAAD/AwUACAAAAP8DBQAJAAEA/wAGAAIAAQD/AQYAAwABAP8CBgAEAAEA/wMGAAUAAQD/AwYABgABAP8DBgAHAAEA/wMGAAgAAQD/AwYACQABAP8ACAACAAEA/wEIAAMAAQD/AggABAABAP8DCAAFAAEA/wMIAAYAAQD/AwgABwABAP8DCAAIAAEA/wMIAAkAAAH/AwAACgAAAf8DAAAMAAAC/wMAAA4AAAL/AwAAEgAAA/8DAAAWAAAD/wMAAB4AAAT/AwAAJgAABP8DAAA2AAAB/wMBAAoAAAH/AwEADAAAAv8DAQAOAAAC/wMBABIAAAP/AwEAFgAAA/8DAQAeAAAE/wMBACYAAAT/AwEANgAAAf8DAgAKAAAB/wMCAAwAAAL/AwIADgAAAv8DAgASAAAD/wMCABYAAAP/AwIAHgAABP8DAgAmAAAE/wMCADYAAAH/AwMACgAAAf8DAwAMAAAC/wMDAA4A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MgBGAQQJ/wMyAEYCBAr/AzIARgQEGP8DMgBGCAUF/wNCAEYABQX/A0IAZgAFBv8DQgCGAAUH/wNCAMYABQj/A0IARgEFCf8DQgBGAgUK/wNCAEYEBRj/A0IARggFBf8DYgBGAAUF/wNiAGYABQb/A2IAhgAFB/8DYgDGAAUI/wNiAEYBBQn/A2IARgIFCv8DYgBGBAUY/wNiAEYIBgH/A4IACgAGAf8DggAMAAYC/wOCAA4ABgL/A4IAEgAGA/8DggAWAAYD/wOCAB4ABgT/A4IAJgAGBP8DggA2AAcB/wPCAAoABwH/A8IADAAHAv8DwgAOAAcC/wPCABIABwP/A8IAFgAHA/8DwgAeAAcE/wPCACYABwT/A8IANgAIAf8DQgEKAAgB/wNCAQwACAL/A0IBDgAIAv8DQgESAAgD/wNCARYACAP/A0IBHgAIBP8DQgEmAAgE/wNCATYACQH/A0ICCgAJAf8DQgIMAAkC/wNCAg4ACQL/A0ICEgAJA/8DQgIWAAkD/wNCAh4ACQT/A0ICJgAJBP8DQgI2AAoB/wNCBAoACgH/A0IEDAAKAv8DQgQOAAoC/wNCBBIACgP/A0IEFgAKA/8DQgQeAAoE/wNCBCYACgT/A0IENgAMAf8DQggKAAwB/wNCCAwADAL/A0IIDgAMAv8DQggSAAwD/wNCCBYADAP/A0IIHgAMBP8DQggmAAwE/wNCCDYADgH/A0IYCgAOAf8DQhgMAA4C/wNCGA4ADgL/A0IYEgAOA/8DQhgWAA4D/wNCGB4ADgT/A0IYJgAOBP8DQhg2ABgB/wNCWAoAGAH/A0JYDAAYAv8DQlgOABgC/wNCWBIAGAP/A0JYFgAYA/8DQlgeABgE/wNCWCYAGAT/A0JYNgAGBf8DggBGAAYF/wOCAGYABgb/A4IAhgAGB/8DggDGAAYI/wOCAEYBBgn/A4IARgIGCv8DggBGBAYY/wOCAEYIBwX/A8IARgAHBf8DwgBmAAcG/wPCAIYABwf/A8IAxgAHCP8DwgBGAQcJ/wPCAEYCBwr/A8IARgQHGP8DwgBGCAgF/wNCAUYACAX/A0IBZgAIBv8DQgGGAAgH/wNCAcYACAj/A0IBRgEICf8DQgFGAggK/wNCAUYECBj/A0IBRggJBf8DQgJGAAkF/wNCAmYACQb/A0IChgAJB/8DQgLGAAkI/wNCAkYBCQn/A0ICRgIJCv8DQgJGBAkY/wNCAkYICgX/A0IERgAKBf8DQgRmAAoG/wNCBIYACgf/A0IExgAKCP8DQgRGAQoJ/wNCBEYCCgr/A0IERgQKGP8DQgRGCAwF/wNCCEYADAX/A0IIZgAMBv8DQgiGAAwH/wNCCMYADAj/A0IIRgEMCf8DQghGAgwK/wNCCEYEDBj/A0IIRggOBf8DQhhGAA4F/wNCGGYADgb/A0IYhgAOB/8DQhjGAA4I/wNCGEYBDgn/A0IYRgIOCv8DQhhGBA4Y/wNCGEYIGAX/A0JYRgAYBf8DQlhmABgG/wNCWIYAGAf/A0JYxgAYCP8DQlhGARgJ/wNCWEYCGAr/A0JYRgQYGP8DQlhGCAAAAAAEAAAADAAAABwAAABJAAAAfgAAAOQAAACoAQAAAgICAwICAgQCAgIDAgICBAAEAwIABAMBAAQDAgAEAwUAAZIBtAHUAfQBFgI2AlYCdgKWArYC1gL2AhYDNgNWA3YDmAO4A9gD+AMYBDgEWAR4BJgEuATYBPgEGAU4BVgFeAWYBbgF2AX4BQAAAAAAAHRpbWVkb3dubGlmZWxlZnRiYWNrY29kZWRhdGFzaG93b25seXNpdGVjaXR5b3Blbmp1c3RsaWtlZnJlZXdvcmt0ZXh0eWVhcm92ZXJib2R5bG92ZWZvcm1ib29rcGxheWxpdmVsaW5laGVscGhvbWVzaWRlbW9yZXdvcmRsb25ndGhlbXZpZXdmaW5kcGFnZWRheXNmdWxsaGVhZHRlcm1lYWNoYXJlYWZyb210cnVlbWFya2FibGV1cG9uaGlnaGRhdGVsYW5kbmV3c2V2ZW5uZXh0Y2FzZWJvdGhwb3N0dXNlZG1hZGVoYW5kaGVyZXdoYXRuYW1lTGlua2Jsb2dzaXplYmFzZWhlbGRtYWtlbWFpbnVzZXInKSAraG9sZGVuZHN3aXRoTmV3c3JlYWR3ZXJlc2lnbnRha2VoYXZlZ2FtZXNlZW5jYWxscGF0aHdlbGxwbHVzbWVudWZpbG1wYXJ0am9pbnRoaXNsaXN0Z29vZG5lZWR3YXlzd2VzdGpvYnNtaW5kYWxzb2xvZ29yaWNodXNlc2xhc3R0ZWFtYXJteWZvb2RraW5nd2lsbGVhc3R3YXJkYmVzdGZpcmVQYWdla25vd2F3YXkucG5nbW92ZXRoYW5sb2FkZ2l2ZXNlbGZub3RlbXVjaGZlZWRtYW55cm9ja2ljb25vbmNlbG9va2hpZGVkaWVkSG9tZXJ1bGVob3N0YWpheGluZm9jbHVibGF3c2xlc3NoYWxmc29tZXN1Y2h6b25lMTAwJW9uZXNjYXJlVGltZXJhY2VibHVlZm91cndlZWtmYWNlaG9wZWdhdmVoYXJkbG9zdHdoZW5wYXJra2VwdHBhc3NzaGlwcm9vbUhUTUxwbGFuVHlwZWRvbmVzYXZla2VlcGZsYWdsaW5rc29sZGZpdmV0b29rcmF0ZXRvd25qdW1wdGh1c2RhcmtjYXJkZmlsZWZlYXJzdGF5a2lsbHRoYXRmYWxsYXV0b2V2ZXIuY29tdGFsa3Nob3B2b3RlZGVlcG1vZGVyZXN0dHVybmJvcm5iYW5kZmVsbHJvc2V1cmwoc2tpbnJvbGVjb21lYWN0c2FnZXNtZWV0Z29sZC5qcGdpdGVtdmFyeWZlbHR0aGVuc2VuZGRyb3BWaWV3Y29weTEuMCI8L2E+c3RvcGVsc2VsaWVzdG91cnBhY2suZ2lmcGFzdGNzcz9ncmF5bWVhbiZndDtyaWRlc2hvdGxhdGVzYWlkcm9hZHZhciBmZWVsam9obnJpY2twb3J0ZmFzdCdVQS1kZWFkPC9iPnBvb3JiaWxsdHlwZVUuUy53b29kbXVzdDJweDtJbmZvcmFua3dpZGV3YW50d2FsbGxlYWRbMF07cGF1bHdhdmVzdXJlJCgnI3dhaXRtYXNzYXJtc2dvZXNnYWlubGFuZ3BhaWQhLS0gbG9ja3VuaXRyb290d2Fsa2Zpcm13aWZleG1sInNvbmd0ZXN0MjBweGtpbmRyb3dzdG9vbGZvbnRtYWlsc2FmZXN0YXJtYXBzY29yZXJhaW5mbG93YmFieXNwYW5zYXlzNHB4OzZweDthcnRzZm9vdHJlYWx3aWtpaGVhdHN0ZXB0cmlwb3JnL2xha2V3ZWFrdG9sZEZvcm1jYXN0ZmFuc2Jhbmt2ZXJ5cnVuc2p1bHl0YXNrMXB4O2dvYWxncmV3c2xvd2VkZ2VpZD0ic2V0czVweDsuanM/NDBweGlmIChzb29uc2VhdG5vbmV0dWJlemVyb3NlbnRyZWVkZmFjdGludG9naWZ0aGFybTE4cHhjYW1laGlsbGJvbGR6b29tdm9pZGVhc3lyaW5nZmlsbHBlYWtpbml0Y29zdDNweDtqYWNrdGFnc2JpdHNyb2xsZWRpdGtuZXduZWFyPCEtLWdyb3dKU09OZHV0eU5hbWVzYWxleW91IGxvdHNwYWluamF6emNvbGRleWVzZmlzaHd3dy5yaXNrdGFic3ByZXYxMHB4cmlzZTI1cHhCbHVlZGluZzMwMCxiYWxsZm9yZGVhcm53aWxkYm94LmZhaXJsYWNrdmVyc3BhaXJqdW5ldGVjaGlmKCFwaWNrZXZpbCQoIiN3YXJtbG9yZGRvZXNwdWxsLDAwMGlkZWFkcmF3aHVnZXNwb3RmdW5kYnVybmhyZWZjZWxsa2V5c3RpY2tob3VybG9zc2Z1ZWwxMnB4c3VpdGRlYWxSU1MiYWdlZGdyZXlHRVQiZWFzZWFpbXNnaXJsYWlkczhweDtuYXZ5Z3JpZHRpcHMjOTk5d2Fyc2xhZHljYXJzKTsgfXBocD9oZWxsdGFsbHdob216aDrlKi8NCiAxMDBoYWxsLgoKQTdweDtwdXNoY2hhdDBweDtjcmV3Ki88L2hhc2g3NXB4ZmxhdHJhcmUgJiYgdGVsbGNhbXBvbnRvbGFpZG1pc3Nza2lwdGVudGZpbmVtYWxlZ2V0c3Bsb3Q0MDAsDQoNCmNvb2xmZWV0LnBocDxicj5lcmljbW9zdGd1aWRiZWxsZGVzY2hhaXJtYXRoYXRvbS9pbWcmIzgybHVja2NlbnQwMDA7dGlueWdvbmVodG1sc2VsbGRydWdGUkVFbm9kZW5pY2s/aWQ9bG9zZW51bGx2YXN0d2luZFJTUyB3ZWFycmVseWJlZW5zYW1lZHVrZW5hc2FjYXBld2lzaGd1bGZUMjM6aGl0c3Nsb3RnYXRla2lja2JsdXJ0aGV5MTVweCcnKTspOyI+bXNpZXdpbnNiaXJkc29ydGJldGFzZWVrVDE4Om9yZHN0cmVlbWFsbDYwcHhmYXJt4oCZc2JveXNbMF0uJyk7IlBPU1RiZWFya2lkcyk7fX1tYXJ5dGVuZChVSylxdWFkemg65i1zaXotLS0tcHJvcCcpOw1saWZ0VDE5OnZpY2VhbmR5ZGVidD5SU1Nwb29sbmVja2Jsb3dUMTY6ZG9vcmV2YWxUMTc6bGV0c2ZhaWxvcmFscG9sbG5vdmFjb2xzZ2VuZSDigJRzb2Z0cm9tZXRpbGxyb3NzPGgzPnBvdXJmYWRlcGluazx0cj5taW5pKXwhKG1pbmV6aDroYmFyc2hlYXIwMCk7bWlsayAtLT5pcm9uZnJlZGRpc2t3ZW50c29pbHB1dHMvanMvaG9seVQyMjpJU0JOVDIwOmFkYW1zZWVzPGgyPmpzb24nLCAnY29udFQyMTogUlNTbG9vcGFzaWFtb29uPC9wPnNvdWxMSU5FZm9ydGNhcnRUMTQ6PGgxPjgwcHghLS08OXB4O1QwNDptaWtlOjQ2Wm5pY2VpbmNoWW9ya3JpY2V6aDrkJykpO3B1cmVtYWdlcGFyYXRvbmVib25kOjM3Wl9vZl8nXSk7MDAwLHpoOud0YW5reWFyZGJvd2xidXNoOjU2WkphdmEzMHB4Cnx9CiVDMyU6MzRaamVmZkVYUEljYXNodmlzYWdvbGZzbm93emg66XF1ZXIuY3Nzc2lja21lYXRtaW4uYmluZGRlbGxoaXJlcGljc3JlbnQ6MzZaSFRUUC0yMDFmb3Rvd29sZkVORCB4Ym94OjU0WkJPRFlkaWNrOwp9CmV4aXQ6MzVadmFyc2JlYXQnfSk7ZGlldDk5OTthbm5lfX08L1tpXS5MYW5na23CsndpcmV0b3lzYWRkc3NlYWxhbGV4OwoJfWVjaG9uaW5lLm9yZzAwNSl0b255amV3c3NhbmRsZWdzcm9vZjAwMCkgMjAwd2luZWdlYXJkb2dzYm9vdGdhcnljdXRzdHlsZXRlbXB0aW9uLnhtbGNvY2tnYW5nJCgnLjUwcHhQaC5EbWlzY2FsYW5sb2FuZGVza21pbGVyeWFudW5peGRpc2MpO30KZHVzdGNsaXApLgoKNzBweC0yMDBEVkRzN10+PHRhcGVkZW1vaSsrKXdhZ2VldXJvcGhpbG9wdHNob2xlRkFRc2FzaW4tMjZUbGFic3BldHNVUkwgYnVsa2Nvb2s7fQ0KSEVBRFswXSlhYmJyanVhbigxOThsZXNodHdpbjwvaT5zb255Z3V5c2Z1Y2twaXBlfC0KITAwMiluZG93WzFdO1tdOwpMb2cgc2FsdA0KCQliYW5ndHJpbWJhdGgpew0KMDBweAp9KTtrbzrsZmVlc2FkPg1zOi8vIFtdO3RvbGxwbHVnKCl7CnsNCiAuanMnMjAwcGR1YWxib2F0LkpQRyk7Cn1xdW90KTsKCicpOwoNCn0NMjAxNDIwMTUyMDE2MjAxNzIwMTgyMDE5MjAyMDIwMjEyMDIyMjAyMzIwMjQyMDI1MjAyNjIwMjcyMDI4MjAyOTIwMzAyMDMxMjAzMjIwMzMyMDM0MjAzNTIwMzYyMDM3MjAxMzIwMTIyMDExMjAxMDIwMDkyMDA4MjAwNzIwMDYyMDA1MjAwNDIwMDMyMDAyMjAwMTIwMDAxOTk5MTk5ODE5OTcxOTk2MTk5NTE5OTQxOTkzMTk5MjE5OTExOTkwMTk4OTE5ODgxOTg3MTk4NjE5ODUxOTg0MTk4MzE5ODIxOTgxMTk4MDE5NzkxOTc4MTk3NzE5NzYxOTc1MTk3NDE5NzMxOTcyMTk3MTE5NzAxOTY5MTk2ODE5NjcxOTY2MTk2NTE5NjQxOTYzMTk2MjE5NjExOTYwMTk1OTE5NTgxOTU3MTk1NjE5NTUxOTU0MTk1MzE5NTIxOTUxMTk1MDEwMDAxMDI0MTM5NDAwMDA5OTk5Y29tb23DoXNlc3RlZXN0YXBlcm90b2RvaGFjZWNhZGFhw7FvYmllbmTDrWFhc8OtdmlkYWNhc29vdHJvZm9yb3NvbG9vdHJhY3VhbGRpam9zaWRvZ3JhbnRpcG90ZW1hZGViZWFsZ29xdcOpZXN0b25hZGF0cmVzcG9jb2Nhc2FiYWpvdG9kYXNpbm9hZ3VhcHVlc3Vub3NhbnRlZGljZWx1aXNlbGxhbWF5b3pvbmFhbW9ycGlzb29icmFjbGljZWxsb2Rpb3Nob3JhY2FzadC30LDQvdCw0L7QvNGA0LDRgNGD0YLQsNC90LXQv9C+0L7RgtC40LfQvdC+0LTQvtGC0L7QttC10L7QvdC40YXQndCw0LXQtdCx0YvQvNGL0JLRi9GB0L7QstGL0LLQvtCd0L7QvtCx0J/QvtC70LjQvdC40KDQpNCd0LXQnNGL0YLRi9Ce0L3QuNC80LTQsNCX0LDQlNCw0J3Rg9Ce0LHRgtC10JjQt9C10LnQvdGD0LzQvNCi0YvRg9C22YHZitij2YbZhdin2YXYudmD2YTYo9mI2LHYr9mK2KfZgdmJ2YfZiNmE2YXZhNmD2KfZiNmE2YfYqNiz2KfZhNil2YbZh9mK2KPZitmC2K/Zh9mE2KvZhdio2YfZhNmI2YTZitio2YTYp9mK2KjZg9i02YrYp9mF2KPZhdmG2KrYqNmK2YTZhtit2KjZh9mF2YXYtNmI2LRmaXJzdHZpZGVvbGlnaHR3b3JsZG1lZGlhd2hpdGVjbG9zZWJsYWNrcmlnaHRzbWFsbGJvb2tzcGxhY2VtdXNpY2ZpZWxkb3JkZXJwb2ludHZhbHVlbGV2ZWx0YWJsZWJvYXJkaG91c2Vncm91cHdvcmtzeWVhcnNzdGF0ZXRvZGF5d2F0ZXJzdGFydHN0eWxlZGVhdGhwb3dlcnBob25lbmlnaHRlcnJvcmlucHV0YWJvdXR0ZXJtc3RpdGxldG9vbHNldmVudGxvY2FsdGltZXNsYXJnZXdvcmRzZ2FtZXNzaG9ydHNwYWNlZm9jdXNjbGVhcm1vZGVsYmxvY2tndWlkZXJhZGlvc2hhcmV3b21lbmFnYWlubW9uZXlpbWFnZW5hbWVzeW91bmdsaW5lc2xhdGVyY29sb3JncmVlbmZyb250JmFtcDt3YXRjaGZvcmNlcHJpY2VydWxlc2JlZ2luYWZ0ZXJ2aXNpdGlzc3VlYXJlYXNiZWxvd2luZGV4dG90YWxob3Vyc2xhYmVscHJpbnRwcmVzc2J1aWx0bGlua3NzcGVlZHN0dWR5dHJhZGVmb3VuZHNlbnNldW5kZXJzaG93bmZvcm1zcmFuZ2VhZGRlZHN0aWxsbW92ZWR0YWtlbmFib3ZlZmxhc2hmaXhlZG9mdGVub3RoZXJ2aWV3c2NoZWNrbGVnYWxyaXZlcml0ZW1zcXVpY2tzaGFwZWh1bWFuZXhpc3Rnb2luZ21vdmlldGhpcmRiYXNpY3BlYWNlc3RhZ2V3aWR0aGxvZ2luaWRlYXN3cm90ZXBhZ2VzdXNlcnNkcml2ZXN0b3JlYnJlYWtzb3V0aHZvaWNlc2l0ZXNtb250aHdoZXJlYnVpbGR3aGljaGVhcnRoZm9ydW10aHJlZXNwb3J0cGFydHlDbGlja2xvd2VybGl2ZXNjbGFzc2xheWVyZW50cnlzdG9yeXVzYWdlc291bmRjb3VydHlvdXIgYmlydGhwb3B1cHR5cGVzYXBwbHlJbWFnZWJlaW5ndXBwZXJub3Rlc2V2ZXJ5c2hvd3NtZWFuc2V4dHJhbWF0Y2h0cmFja2tub3duZWFybHliZWdhbnN1cGVycGFwZXJub3J0aGxlYXJuZ2l2ZW5uYW1lZGVuZGVkVGVybXNwYXJ0c0dyb3VwYnJhbmR1c2luZ3dvbWFuZmFsc2VyZWFkeWF1ZGlvdGFrZXN3aGlsZS5jb20vbGl2ZWRjYXNlc2RhaWx5Y2hpbGRncmVhdGp1ZGdldGhvc2V1bml0c25ldmVyYnJvYWRjb2FzdGNvdmVyYXBwbGVmaWxlc2N5Y2xlc2NlbmVwbGFuc2NsaWNrd3JpdGVxdWVlbnBpZWNlZW1haWxmcmFtZW9sZGVycGhvdG9saW1pdGNhY2hlY2l2aWxzY2FsZWVudGVydGhlbWV0aGVyZXRvdWNoYm91bmRyb3lhbGFza2Vkd2hvbGVzaW5jZXN0b2NrIG5hbWVmYWl0aGhlYXJ0ZW1wdHlvZmZlcnNjb3Blb3duZWRtaWdodGFsYnVtdGhpbmtibG9vZGFycmF5bWFqb3J0cnVzdGNhbm9udW5pb25jb3VudHZhbGlkc3RvbmVTdHlsZUxvZ2luaGFwcHlvY2N1cmxlZnQ6ZnJlc2hxdWl0ZWZpbG1zZ3JhZGVuZWVkc3VyYmFuZmlnaHRiYXNpc2hvdmVyYXV0bztyb3V0ZS5odG1sbWl4ZWRmaW5hbFlvdXIgc2xpZGV0b3BpY2Jyb3duYWxvbmVkcmF3bnNwbGl0cmVhY2hSaWdodGRhdGVzbWFyY2hxdW90ZWdvb2RzTGlua3Nkb3VidGFzeW5jdGh1bWJhbGxvd2NoaWVmeW91dGhub3ZlbDEwcHg7c2VydmV1bnRpbGhhbmRzQ2hlY2tTcGFjZXF1ZXJ5amFtZXNlcXVhbHR3aWNlMCwwMDBTdGFydHBhbmVsc29uZ3Nyb3VuZGVpZ2h0c2hpZnR3b3J0aHBvc3RzbGVhZHN3ZWVrc2F2b2lkdGhlc2VtaWxlc3BsYW5lc21hcnRhbHBoYXBsYW50bWFya3NyYXRlc3BsYXlzY2xhaW1zYWxlc3RleHRzc3RhcnN3cm9uZzwvaDM+dGhpbmcub3JnL211bHRpaGVhcmRQb3dlcnN0YW5kdG9rZW5zb2xpZCh0aGlzYnJpbmdzaGlwc3N0YWZmdHJpZWRjYWxsc2Z1bGx5ZmFjdHNhZ2VudFRoaXMgLy8tLT5hZG1pbmVneXB0RXZlbnQxNXB4O0VtYWlsdHJ1ZSJjcm9zc3NwZW50YmxvZ3Nib3giPm5vdGVkbGVhdmVjaGluYXNpemVzZ3Vlc3Q8L2g0PnJvYm90aGVhdnl0cnVlLHNldmVuZ3JhbmRjcmltZXNpZ25zYXdhcmVkYW5jZXBoYXNlPjwhLS1lbl9VUyYjMzk7MjAwcHhfbmFtZWxhdGluZW5qb3lhamF4LmF0aW9uc21pdGhVLlMuIGhvbGRzcGV0ZXJpbmRpYW5hdiI+Y2hhaW5zY29yZWNvbWVzZG9pbmdwcmlvclNoYXJlMTk5MHNyb21hbmxpc3RzamFwYW5mYWxsc3RyaWFsb3duZXJhZ3JlZTwvaDI+YWJ1c2VhbGVydG9wZXJhIi0vL1djYXJkc2hpbGxzdGVhbXNQaG90b3RydXRoY2xlYW4ucGhwP3NhaW50bWV0YWxsb3Vpc21lYW50cHJvb2ZicmllZnJvdyI+Z2VucmV0cnVja2xvb2tzVmFsdWVGcmFtZS5uZXQvLS0+Cjx0cnkgewp2YXIgbWFrZXNjb3N0c3BsYWluYWR1bHRxdWVzdHRyYWlubGFib3JoZWxwc2NhdXNlbWFnaWNtb3RvcnRoZWlyMjUwcHhsZWFzdHN0ZXBzQ291bnRjb3VsZGdsYXNzc2lkZXNmdW5kc2hvdGVsYXdhcmRtb3V0aG1vdmVzcGFyaXNnaXZlc2R1dGNodGV4YXNmcnVpdG51bGwsfHxbXTt0b3AiPgo8IS0tUE9TVCJvY2Vhbjxici8+Zmxvb3JzcGVha2RlcHRoIHNpemViYW5rc2NhdGNoY2hhcnQyMHB4O2FsaWduZGVhbHN3b3VsZDUwcHg7dXJsPSJwYXJrc21vdXNlTW9zdCAuLi48L2Ftb25nYnJhaW5ib2R5IG5vbmU7YmFzZWRjYXJyeWRyYWZ0cmVmZXJwYWdlX2hvbWUubWV0ZXJkZWxheWRyZWFtcHJvdmVqb2ludDwvdHI+ZHJ1Z3M8IS0tIGFwcmlsaWRlYWxhbGxlbmV4YWN0Zm9ydGhjb2Rlc2xvZ2ljVmlldyBzZWVtc2JsYW5rcG9ydHMgKDIwMHNhdmVkX2xpbmtnb2Fsc2dyYW50Z3JlZWtob21lc3JpbmdzcmF0ZWQzMHB4O3dob3NlcGFyc2UoKTsiIEJsb2NrbGludXhqb25lc3BpeGVsJyk7Ij4pO2lmKC1sZWZ0ZGF2aWRob3JzZUZvY3VzcmFpc2Vib3hlc1RyYWNrZW1lbnQ8L2VtPmJhciI+LnNyYz10b3dlcmFsdD0iY2FibGVoZW5yeTI0cHg7c2V0dXBpdGFseXNoYXJwbWlub3J0YXN0ZXdhbnRzdGhpcy5yZXNldHdoZWVsZ2lybHMvY3NzLzEwMCU7Y2x1YnNzdHVmZmJpYmxldm90ZXMgMTAwMGtvcmVhfSk7DQpiYW5kc3F1ZXVlPSB7fTs4MHB4O2NraW5new0KCQlhaGVhZGNsb2NraXJpc2hsaWtlIHJhdGlvc3RhdHNGb3JtInlhaG9vKVswXTtBYm91dGZpbmRzPC9oMT5kZWJ1Z3Rhc2tzVVJMID1jZWxsc30pKCk7MTJweDtwcmltZXRlbGxzdHVybnMweDYwMC5qcGcic3BhaW5iZWFjaHRheGVzbWljcm9hbmdlbC0tPjwvZ2lmdHNzdGV2ZS1saW5rYm9keS59KTsKCW1vdW50ICgxOTlGQVE8L3JvZ2VyZnJhbmtDbGFzczI4cHg7ZmVlZHM8aDE+PHNjb3R0dGVzdHMyMnB4O2RyaW5rKSB8fCBsZXdpc3NoYWxsIzAzOTsgZm9yIGxvdmVkd2FzdGUwMHB4O2phOuOCc2ltb248Zm9udHJlcGx5bWVldHN1bnRlcmNoZWFwdGlnaHRCcmFuZCkgIT0gZHJlc3NjbGlwc3Jvb21zb25rZXltb2JpbG1haW4uTmFtZSBwbGF0ZWZ1bm55dHJlZXNjb20vIjEuanBnd21vZGVwYXJhbVNUQVJUbGVmdCBpZGRlbiwgMjAxKTsKfQpmb3JtLnZpcnVzY2hhaXJ0cmFuc3dvcnN0UGFnZXNpdGlvbnBhdGNoPCEtLQpvLWNhY2Zpcm1zdG91cnMsMDAwIGFzaWFuaSsrKXthZG9iZScpWzBdaWQ9MTBib3RoO21lbnUgLjIubWkucG5nImtldmluY29hY2hDaGlsZGJydWNlMi5qcGdVUkwpKy5qcGd8c3VpdGVzbGljZWhhcnJ5MTIwIiBzd2VldHRyPg0KbmFtZT1kaWVnb3BhZ2Ugc3dpc3MtLT4KCiNmZmY7Ij5Mb2cuY29tInRyZWF0c2hlZXQpICYmIDE0cHg7c2xlZXBudGVudGZpbGVkamE644NpZD0iY05hbWUid29yc2VzaG90cy1ib3gtZGVsdGEKJmx0O2JlYXJzOjQ4WjxkYXRhLXJ1cmFsPC9hPiBzcGVuZGJha2Vyc2hvcHM9ICIiO3BocCI+Y3Rpb24xM3B4O2JyaWFuaGVsbG9zaXplPW89JTJGIGpvaW5tYXliZTxpbWcgaW1nIj4sIGZqc2ltZyIgIilbMF1NVG9wQlR5cGUibmV3bHlEYW5za2N6ZWNodHJhaWxrbm93czwvaDU+ZmFxIj56aC1jbjEwKTsKLTEiKTt0eXBlPWJsdWVzdHJ1bHlkYXZpcy5qcyc7Pg0KPCFzdGVlbCB5b3UgaDI+DQpmb3JtIGplc3VzMTAwJSBtZW51Lg0KCQ0Kd2FsZXNyaXNrc3VtZW50ZGRpbmdiLWxpa3RlYWNoZ2lmIiB2ZWdhc2RhbnNrZWVzdGlzaHFpcHN1b21pc29icmVkZXNkZWVudHJldG9kb3NwdWVkZWHDsW9zZXN0w6F0aWVuZWhhc3Rhb3Ryb3NwYXJ0ZWRvbmRlbnVldm9oYWNlcmZvcm1hbWlzbW9tZWpvcm11bmRvYXF1w61kw61hc3PDs2xvYXl1ZGFmZWNoYXRvZGFzdGFudG9tZW5vc2RhdG9zb3RyYXNzaXRpb211Y2hvYWhvcmFsdWdhcm1heW9yZXN0b3Nob3Jhc3RlbmVyYW50ZXNmb3Rvc2VzdGFzcGHDrXNudWV2YXNhbHVkZm9yb3NtZWRpb3F1aWVubWVzZXNwb2RlcmNoaWxlc2Vyw6F2ZWNlc2RlY2lyam9zw6llc3RhcnZlbnRhZ3J1cG9oZWNob2VsbG9zdGVuZ29hbWlnb2Nvc2Fzbml2ZWxnZW50ZW1pc21hYWlyZXNqdWxpb3RlbWFzaGFjaWFmYXZvcmp1bmlvbGlicmVwdW50b2J1ZW5vYXV0b3JhYnJpbGJ1ZW5hdGV4dG9tYXJ6b3NhYmVybGlzdGFsdWVnb2PDs21vZW5lcm9qdWVnb3BlcsO6aGFiZXJlc3RveW51bmNhbXVqZXJ2YWxvcmZ1ZXJhbGlicm9ndXN0YWlndWFsdm90b3NjYXNvc2d1w61hcHVlZG9zb21vc2F2aXNvdXN0ZWRkZWJlbm5vY2hlYnVzY2FmYWx0YWV1cm9zc2VyaWVkaWNob2N1cnNvY2xhdmVjYXNhc2xlw7NucGxhem9sYXJnb29icmFzdmlzdGFhcG95b2p1bnRvdHJhdGF2aXN0b2NyZWFyY2FtcG9oZW1vc2NpbmNvY2FyZ29waXNvc29yZGVuaGFjZW7DoXJlYWRpc2NvcGVkcm9jZXJjYXB1ZWRhcGFwZWxtZW5vcsO6dGlsY2xhcm9qb3JnZWNhbGxlcG9uZXJ0YXJkZW5hZGllbWFyY2FzaWd1ZWVsbGFzc2lnbG9jb2NoZW1vdG9zbWFkcmVjbGFzZXJlc3RvbmnDsW9xdWVkYXBhc2FyYmFuY29oaWpvc3ZpYWplcGFibG/DqXN0ZXZpZW5lcmVpbm9kZWphcmZvbmRvY2FuYWxub3J0ZWxldHJhY2F1c2F0b21hcm1hbm9zbHVuZXNhdXRvc3ZpbGxhdmVuZG9wZXNhcnRpcG9zdGVuZ2FtYXJjb2xsZXZhcGFkcmV1bmlkb3ZhbW9zem9uYXNhbWJvc2JhbmRhbWFyaWFhYnVzb211Y2hhc3ViaXJyaW9qYXZpdmlyZ3JhZG9jaGljYWFsbMOtam92ZW5kaWNoYWVzdGFudGFsZXNzYWxpcnN1ZWxvcGVzb3NmaW5lc2xsYW1hYnVzY2/DqXN0YWxsZWdhbmVncm9wbGF6YWh1bW9ycGFnYXJqdW50YWRvYmxlaXNsYXNib2xzYWJhw7FvaGFibGFsdWNoYcOBcmVhZGljZW5qdWdhcm5vdGFzdmFsbGVhbGzDoWNhcmdhZG9sb3JhYmFqb2VzdMOpZ3VzdG9tZW50ZW1hcmlvZmlybWFjb3N0b2ZpY2hhcGxhdGFob2dhcmFydGVzbGV5ZXNhcXVlbG11c2VvYmFzZXNwb2Nvc21pdGFkY2llbG9jaGljb21pZWRvZ2FuYXJzYW50b2V0YXBhZGViZXNwbGF5YXJlZGVzc2lldGVjb3J0ZWNvcmVhZHVkYXNkZXNlb3ZpZWpvZGVzZWFhZ3VhcyZxdW90O2RvbWFpbmNvbW1vbnN0YXR1c2V2ZW50c21hc3RlcnN5c3RlbWFjdGlvbmJhbm5lcnJlbW92ZXNjcm9sbHVwZGF0ZWdsb2JhbG1lZGl1bWZpbHRlcm51bWJlcmNoYW5nZXJlc3VsdHB1YmxpY3NjcmVlbmNob29zZW5vcm1hbHRyYXZlbGlzc3Vlc3NvdXJjZXRhcmdldHNwcmluZ21vZHVsZW1vYmlsZXN3aXRjaHBob3Rvc2JvcmRlcnJlZ2lvbml0c2VsZnNvY2lhbGFjdGl2ZWNvbHVtbnJlY29yZGZvbGxvd3RpdGxlPmVpdGhlcmxlbmd0aGZhbWlseWZyaWVuZGxheW91dGF1dGhvcmNyZWF0ZXJldmlld3N1bW1lcnNlcnZlcnBsYXllZHBsYXllcmV4cGFuZHBvbGljeWZvcm1hdGRvdWJsZXBvaW50c3Nlcmllc3BlcnNvbmxpdmluZ2Rlc2lnbm1vbnRoc2ZvcmNlc3VuaXF1ZXdlaWdodHBlb3BsZWVuZXJneW5hdHVyZXNlYXJjaGZpZ3VyZWhhdmluZ2N1c3RvbW9mZnNldGxldHRlcndpbmRvd3N1Ym1pdHJlbmRlcmdyb3Vwc3VwbG9hZGhlYWx0aG1ldGhvZHZpZGVvc3NjaG9vbGZ1dHVyZXNoYWRvd2RlYmF0ZXZhbHVlc09iamVjdG90aGVyc3JpZ2h0c2xlYWd1ZWNocm9tZXNpbXBsZW5vdGljZXNoYXJlZGVuZGluZ3NlYXNvbnJlcG9ydG9ubGluZXNxdWFyZWJ1dHRvbmltYWdlc2VuYWJsZW1vdmluZ2xhdGVzdHdpbnRlckZyYW5jZXBlcmlvZHN0cm9uZ3JlcGVhdExvbmRvbmRldGFpbGZvcm1lZGRlbWFuZHNlY3VyZXBhc3NlZHRvZ2dsZXBsYWNlc2RldmljZXN0YXRpY2NpdGllc3N0cmVhbXllbGxvd2F0dGFja3N0cmVldGZsaWdodGhpZGRlbmluZm8iPm9wZW5lZHVzZWZ1bHZhbGxleWNhdXNlc2xlYWRlcnNlY3JldHNlY29uZGRhbWFnZXNwb3J0c2V4Y2VwdHJhdGluZ3NpZ25lZHRoaW5nc2VmZmVjdGZpZWxkc3N0YXRlc29mZmljZXZpc3VhbGVkaXRvcnZvbHVtZVJlcG9ydG11c2V1bW1vdmllc3BhcmVudGFjY2Vzc21vc3RseW1vdGhlciIgaWQ9Im1hcmtldGdyb3VuZGNoYW5jZXN1cnZleWJlZm9yZXN5bWJvbG1vbWVudHNwZWVjaG1vdGlvbmluc2lkZW1hdHRlckNlbnRlcm9iamVjdGV4aXN0c21pZGRsZUV1cm9wZWdyb3d0aGxlZ2FjeW1hbm5lcmVub3VnaGNhcmVlcmFuc3dlcm9yaWdpbnBvcnRhbGNsaWVudHNlbGVjdHJhbmRvbWNsb3NlZHRvcGljc2NvbWluZ2ZhdGhlcm9wdGlvbnNpbXBseXJhaXNlZGVzY2FwZWNob3NlbmNodXJjaGRlZmluZXJlYXNvbmNvcm5lcm91dHB1dG1lbW9yeWlmcmFtZXBvbGljZW1vZGVsc051bWJlcmR1cmluZ29mZmVyc3N0eWxlc2tpbGxlZGxpc3RlZGNhbGxlZHNpbHZlcm1hcmdpbmRlbGV0ZWJldHRlcmJyb3dzZWxpbWl0c0dsb2JhbHNpbmdsZXdpZGdldGNlbnRlcmJ1ZGdldG5vd3JhcGNyZWRpdGNsYWltc2VuZ2luZXNhZmV0eWNob2ljZXNwaXJpdC1zdHlsZXNwcmVhZG1ha2luZ25lZWRlZHJ1c3NpYXBsZWFzZWV4dGVudFNjcmlwdGJyb2tlbmFsbG93c2NoYXJnZWRpdmlkZWZhY3Rvcm1lbWJlci1iYXNlZHRoZW9yeWNvbmZpZ2Fyb3VuZHdvcmtlZGhlbHBlZENodXJjaGltcGFjdHNob3VsZGFsd2F5c2xvZ28iIGJvdHRvbWxpc3QiPil7dmFyIHByZWZpeG9yYW5nZUhlYWRlci5wdXNoKGNvdXBsZWdhcmRlbmJyaWRnZWxhdW5jaFJldmlld3Rha2luZ3Zpc2lvbmxpdHRsZWRhdGluZ0J1dHRvbmJlYXV0eXRoZW1lc2ZvcmdvdFNlYXJjaGFuY2hvcmFsbW9zdGxvYWRlZENoYW5nZXJldHVybnN0cmluZ3JlbG9hZE1vYmlsZWluY29tZXN1cHBseVNvdXJjZW9yZGVyc3ZpZXdlZCZuYnNwO2NvdXJzZUFib3V0IGlzbGFuZDxodG1sIGNvb2tpZW5hbWU9ImFtYXpvbm1vZGVybmFkdmljZWluPC9hPjogVGhlIGRpYWxvZ2hvdXNlc0JFR0lOIE1leGljb3N0YXJ0c2NlbnRyZWhlaWdodGFkZGluZ0lzbGFuZGFzc2V0c0VtcGlyZVNjaG9vbGVmZm9ydGRpcmVjdG5lYXJseW1hbnVhbFNlbGVjdC4KCk9uZWpvaW5lZG1lbnUiPlBoaWxpcGF3YXJkc2hhbmRsZWltcG9ydE9mZmljZXJlZ2FyZHNraWxsc25hdGlvblNwb3J0c2RlZ3JlZXdlZWtseSAoZS5nLmJlaGluZGRvY3RvcmxvZ2dlZHVuaXRlZDwvYj48L2JlZ2luc3BsYW50c2Fzc2lzdGFydGlzdGlzc3VlZDMwMHB4fGNhbmFkYWFnZW5jeXNjaGVtZXJlbWFpbkJyYXppbHNhbXBsZWxvZ28iPmJleW9uZC1zY2FsZWFjY2VwdHNlcnZlZG1hcmluZUZvb3RlcmNhbWVyYTwvaDE+Cl9mb3JtImxlYXZlc3N0cmVzcyIgLz4NCi5naWYiIG9ubG9hZGxvYWRlck94Zm9yZHNpc3RlcnN1cnZpdmxpc3RlbmZlbWFsZURlc2lnbnNpemU9ImFwcGVhbHRleHQiPmxldmVsc3RoYW5rc2hpZ2hlcmZvcmNlZGFuaW1hbGFueW9uZUFmcmljYWFncmVlZHJlY2VudFBlb3BsZTxiciAvPndvbmRlcnByaWNlc3R1cm5lZHx8IHt9O21haW4iPmlubGluZXN1bmRheXdyYXAiPmZhaWxlZGNlbnN1c21pbnV0ZWJlYWNvbnF1b3RlczE1MHB4fGVzdGF0ZXJlbW90ZWVtYWlsImxpbmtlZHJpZ2h0O3NpZ25hbGZvcm1hbDEuaHRtbHNpZ251cHByaW5jZWZsb2F0Oi5wbmciIGZvcnVtLkFjY2Vzc3BhcGVyc3NvdW5kc2V4dGVuZEhlaWdodHNsaWRlclVURi04IiZhbXA7IEJlZm9yZS4gV2l0aHN0dWRpb293bmVyc21hbmFnZXByb2ZpdGpRdWVyeWFubnVhbHBhcmFtc2JvdWdodGZhbW91c2dvb2dsZWxvbmdlcmkrKykge2lzcmFlbHNheWluZ2RlY2lkZWhvbWUiPmhlYWRlcmVuc3VyZWJyYW5jaHBpZWNlc2Jsb2NrO3N0YXRlZHRvcCI+PHJhY2luZ3Jlc2l6ZS0tJmd0O3BhY2l0eXNleHVhbGJ1cmVhdS5qcGciIDEwLDAwMG9idGFpbnRpdGxlc2Ftb3VudCwgSW5jLmNvbWVkeW1lbnUiIGx5cmljc3RvZGF5LmluZGVlZGNvdW50eV9sb2dvLkZhbWlseWxvb2tlZE1hcmtldGxzZSBpZlBsYXllcnR1cmtleSk7dmFyIGZvcmVzdGdpdmluZ2Vycm9yc0RvbWFpbn1lbHNle2luc2VydEJsb2c8L2Zvb3RlcmxvZ2luLmZhc3RlcmFnZW50czxib2R5IDEwcHggMHByYWdtYWZyaWRheWp1bmlvcmRvbGxhcnBsYWNlZGNvdmVyc3BsdWdpbjUsMDAwIHBhZ2UiPmJvc3Rvbi50ZXN0KGF2YXRhcnRlc3RlZF9jb3VudGZvcnVtc3NjaGVtYWluZGV4LGZpbGxlZHNoYXJlc3JlYWRlcmFsZXJ0KGFwcGVhclN1Ym1pdGxpbmUiPmJvZHkiPgoqIFRoZVRob3VnaHNlZWluZ2plcnNleU5ld3M8L3ZlcmlmeWV4cGVydGluanVyeXdpZHRoPUNvb2tpZVNUQVJUIGFjcm9zc19pbWFnZXRocmVhZG5hdGl2ZXBvY2tldGJveCI+ClN5c3RlbSBEYXZpZGNhbmNlcnRhYmxlc3Byb3ZlZEFwcmlsIHJlYWxseWRyaXZlcml0ZW0iPm1vcmUiPmJvYXJkc2NvbG9yc2NhbXB1c2ZpcnN0IHx8IFtdO21lZGlhLmd1aXRhcmZpbmlzaHdpZHRoOnNob3dlZE90aGVyIC5waHAiIGFzc3VtZWxheWVyc3dpbHNvbnN0b3Jlc3JlbGllZnN3ZWRlbkN1c3RvbWVhc2lseSB5b3VyIFN0cmluZwoKV2hpbHRheWxvcmNsZWFyOnJlc29ydGZyZW5jaHRob3VnaCIpICsgIjxib2R5PmJ1eWluZ2JyYW5kc01lbWJlcm5hbWUiPm9wcGluZ3NlY3RvcjVweDsiPnZzcGFjZXBvc3Rlcm1ham9yIGNvZmZlZW1hcnRpbm1hdHVyZWhhcHBlbjwvbmF2PmthbnNhc2xpbmsiPkltYWdlcz1mYWxzZXdoaWxlIGhzcGFjZTAmYW1wOyAKCkluICBwb3dlclBvbHNraS1jb2xvcmpvcmRhbkJvdHRvbVN0YXJ0IC1jb3VudDIuaHRtbG5ld3MiPjAxLmpwZ09ubGluZS1yaWdodG1pbGxlcnNlbmlvcklTQk4gMDAsMDAwIGd1aWRlc3ZhbHVlKWVjdGlvbnJlcGFpci54bWwiICByaWdodHMuaHRtbC1ibG9ja3JlZ0V4cDpob3ZlcndpdGhpbnZpcmdpbnBob25lczwvdHI+DXVzaW5nIAoJdmFyID4nKTsKCTwvdGQ+CjwvdHI+CmJhaGFzYWJyYXNpbGdhbGVnb21hZ3lhcnBvbHNraXNycHNradix2K/ZiOS4reaWh+eugOS9k+e5gemrlOS/oeaBr+S4reWbveaIkeS7rOS4gOS4quWFrOWPuOeuoeeQhuiuuuWdm+WPr+S7peacjeWKoeaXtumXtOS4quS6uuS6p+WTgeiHquW3seS8geS4muafpeeci+W3peS9nOiBlOezu+ayoeaciee9keermeaJgOacieivhOiuuuS4reW/g+aWh+eroOeUqOaIt+mmlumhteS9nOiAheaKgOacr+mXrumimOebuOWFs+S4i+i9veaQnOe0ouS9v+eUqOi9r+S7tuWcqOe6v+S4u+mimOi1hOaWmeinhumikeWbnuWkjeazqOWGjOe9kee7nOaUtuiXj+WGheWuueaOqOiNkOW4guWcuua2iOaBr+epuumXtOWPkeW4g+S7gOS5iOWlveWPi+eUn+a0u+WbvueJh+WPkeWxleWmguaenOaJi+acuuaWsOmXu+acgOaWsOaWueW8j+WMl+S6rOaPkOS+m+WFs+S6juabtOWkmui/meS4quezu+e7n+efpemBk+a4uOaIj+W5v+WRiuWFtuS7luWPkeihqOWuieWFqOesrOS4gOS8muWRmOi/m+ihjOeCueWHu+eJiOadg+eUteWtkOS4lueVjOiuvuiuoeWFjei0ueaVmeiCsuWKoOWFpea0u+WKqOS7luS7rOWVhuWTgeWNmuWuoueOsOWcqOS4iua1t+WmguS9leW3sue7j+eVmeiogOivpue7huekvuWMuueZu+W9leacrOermemcgOimgeS7t+agvOaUr+aMgeWbvemZhemTvuaOpeWbveWutuW7uuiuvuaci+WPi+mYheivu+azleW+i+S9jee9rue7j+a1jumAieaLqei/meagt+W9k+WJjeWIhuexu+aOkuihjOWboOS4uuS6pOaYk+acgOWQjumfs+S5kOS4jeiDvemAmui/h+ihjOS4muenkeaKgOWPr+iDveiuvuWkh+WQiOS9nOWkp+WutuekvuS8mueglOeptuS4k+S4muWFqOmDqOmhueebrui/memHjOi/mOaYr+W8gOWni+aDheWGteeUteiEkeaWh+S7tuWTgeeJjOW4ruWKqeaWh+WMlui1hOa6kOWkp+WtpuWtpuS5oOWcsOWdgOa1j+iniOaKlei1hOW3peeoi+imgeaxguaAjuS5iOaXtuWAmeWKn+iDveS4u+imgeebruWJjei1hOiur+WfjuW4guaWueazleeUteW9seaLm+iBmOWjsOaYjuS7u+S9leWBpeW6t+aVsOaNrue+juWbveaxvei9puS7i+e7jeS9huaYr+S6pOa1geeUn+S6p+aJgOS7peeUteivneaYvuekuuS4gOS6m+WNleS9jeS6uuWRmOWIhuaekOWcsOWbvuaXhea4uOW3peWFt+WtpueUn+ezu+WIl+e9keWPi+W4luWtkOWvhueggemikemBk+aOp+WItuWcsOWMuuWfuuacrOWFqOWbvee9keS4iumHjeimgeesrOS6jOWWnOasoui/m+WFpeWPi+aDhei/meS6m+iAg+ivleWPkeeOsOWfueiureS7peS4iuaUv+W6nOaIkOS4uueOr+Wig+mmmea4r+WQjOaXtuWoseS5kOWPkemAgeS4gOWumuW8gOWPkeS9nOWTgeagh+WHhuasoui/juino+WGs+WcsOaWueS4gOS4i+S7peWPiui0o+S7u+aIluiAheWuouaIt+S7o+ihqOenr+WIhuWls+S6uuaVsOeggemUgOWUruWHuueOsOemu+e6v+W6lOeUqOWIl+ihqOS4jeWQjOe8lui+kee7n+iuoeafpeivouS4jeimgeacieWFs+acuuaehOW+iOWkmuaSreaUvue7hOe7h+aUv+etluebtOaOpeiDveWKm+adpea6kOaZgumWk+eci+WIsOeDremXqOWFs+mUruS4k+WMuumdnuW4uOiLseivreeZvuW6puW4jOacm+e+juWls+avlOi+g+efpeivhuinhOWumuW7uuiurumDqOmXqOaEj+ingeeyvuW9qeaXpeacrOaPkOmrmOWPkeiogOaWuemdouWfuumHkeWkhOeQhuadg+mZkOW9seeJh+mTtuihjOi/mOacieWIhuS6q+eJqeWTgee7j+iQpea3u+WKoOS4k+Wutui/meenjeivnemimOi1t+adpeS4muWKoeWFrOWRiuiusOW9leeugOS7i+i0qOmHj+eUt+S6uuW9seWTjeW8leeUqOaKpeWRiumDqOWIhuW/q+mAn+WSqOivouaXtuWwmuazqOaEj+eUs+ivt+WtpuagoeW6lOivpeWOhuWPsuWPquaYr+i/lOWbnui0reS5sOWQjeensOS4uuS6huaIkOWKn+ivtOaYjuS+m+W6lOWtqeWtkOS4k+mimOeoi+W6j+S4gOiIrOacg+WToeWPquacieWFtuWug+S/neaKpOiAjOS4lOS7iuWkqeeql+WPo+WKqOaAgeeKtuaAgeeJueWIq+iupOS4uuW/hemhu+abtOaWsOWwj+ivtOaIkeWAkeS9nOS4uuWqkuS9k+WMheaLrOmCo+S5iOS4gOagt+WbveWGheaYr+WQpuagueaNrueUteinhuWtpumZouWFt+aciei/h+eoi+eUseS6juS6uuaJjeWHuuadpeS4jei/h+ato+WcqOaYjuaYn+aVheS6i+WFs+ezu+agh+mimOWVhuWKoei+k+WFpeS4gOebtOWfuuehgOaVmeWtpuS6huino+W7uuetkee7k+aenOWFqOeQg+mAmuefpeiuoeWIkuWvueS6juiJuuacr+ebuOWGjOWPkeeUn+ecn+eahOW7uueri+etiee6p+exu+Wei+e7j+mqjOWunueOsOWItuS9nOadpeiHquagh+etvuS7peS4i+WOn+WIm+aXoOazleWFtuS4reWAi+S6uuS4gOWIh+aMh+WNl+WFs+mXrembhuWbouesrOS4ieWFs+azqOWboOatpOeFp+eJh+a3seWcs+WVhuS4muW5v+W3nuaXpeacn+mrmOe6p+acgOi/kee7vOWQiOihqOekuuS4k+i+keihjOS4uuS6pOmAmuivhOS7t+inieW+l+eyvuWNjuWutuW6reWujOaIkOaEn+inieWuieijheW+l+WIsOmCruS7tuWItuW6pumjn+WTgeiZveeEtui9rOi9veaKpeS7t+iusOiAheaWueahiOihjOaUv+S6uuawkeeUqOWTgeS4nOilv+aPkOWHuumFkuW6l+eEtuWQjuS7mOasvueDreeCueS7peWJjeWujOWFqOWPkeW4luiuvue9rumihuWvvOW3peS4muWMu+mZoueci+eci+e7j+WFuOWOn+WboOW5s+WPsOWQhOenjeWinuWKoOadkOaWmeaWsOWinuS5i+WQjuiBjOS4muaViOaenOS7iuW5tOiuuuaWh+aIkeWbveWRiuivieeJiOS4u+S/ruaUueWPguS4juaJk+WNsOW/q+S5kOacuuaisOingueCueWtmOWcqOeyvuelnuiOt+W+l+WIqeeUqOe7p+e7reS9oOS7rOi/meS5iOaooeW8j+ivreiogOiDveWkn+mbheiZjuaTjeS9nOmjjuagvOS4gOi1t+enkeWtpuS9k+iCsuefreS/oeadoeS7tuayu+eWl+i/kOWKqOS6p+S4muS8muiuruWvvOiIquWFiOeUn+iBlOebn+WPr+aYr+WVj+mhjOe7k+aehOS9nOeUqOiwg+afpeizh+aWmeiHquWKqOi0n+i0o+WGnOS4muiuv+mXruWunuaWveaOpeWPl+iuqOiuuumCo+S4quWPjemmiOWKoOW8uuWls+aAp+iMg+WbtOacjeWLmeS8kemXsuS7iuaXpeWuouacjeingOeci+WPguWKoOeahOivneS4gOeCueS/neivgeWbvuS5puacieaViOa1i+ivleenu+WKqOaJjeiDveWGs+WumuiCoeelqOS4jeaWremcgOaxguS4jeW+l+WKnuazleS5i+mXtOmHh+eUqOiQpemUgOaKleivieebruagh+eIseaDheaRhOW9seacieS6m+ikh+ijveaWh+WtpuacuuS8muaVsOWtl+ijheS/rui0reeJqeWGnOadkeWFqOmdoueyvuWTgeWFtuWunuS6i+aDheawtOW5s+aPkOekuuS4iuW4guiwouiwouaZrumAmuaVmeW4iOS4iuS8oOexu+WIq+atjOabsuaLpeacieWIm+aWsOmFjeS7tuWPquimgeaXtuS7o+izh+ioiui+vuWIsOS6uueUn+iuoumYheiAgeW4iOWxleekuuW/g+eQhui0tOWtkOe2suermeS4u+mhjOiHqueEtue6p+WIq+eugOWNleaUuemdqemCo+S6m+adpeivtOaJk+W8gOS7o+eggeWIoOmZpOivgeWIuOiKguebrumHjeeCueasoeaVuOWkmuWwkeinhOWIkui1hOmHkeaJvuWIsOS7peWQjuWkp+WFqOS4u+mhteacgOS9s+WbnuetlOWkqeS4i+S/nemanOeOsOS7o+ajgOafpeaKleelqOWwj+aXtuaykuacieato+W4uOeUmuiHs+S7o+eQhuebruW9leWFrOW8gOWkjeWItumHkeiejeW5uOemj+eJiOacrOW9ouaIkOWHhuWkh+ihjOaDheWbnuWIsOaAneaDs+aAjuagt+WNj+iuruiupOivgeacgOWlveS6p+eUn+aMieeFp+acjeijheW5v+S4nOWKqOa8q+mHh+i0reaWsOaJi+e7hOWbvumdouadv+WPguiAg+aUv+ayu+WuueaYk+WkqeWcsOWKquWKm+S6uuS7rOWNh+e6p+mAn+W6puS6uueJqeiwg+aVtOa1geihjOmAoOaIkOaWh+Wtl+mfqeWbvei0uOaYk+W8gOWxleebuOmXnOihqOeOsOW9seinhuWmguatpOe+juWuueWkp+Wwj+aKpemBk+adoeasvuW/g+aDheiuuOWkmuazleinhOWutuWxheS5puW6l+i/nuaOpeeri+WNs+S4vuaKpeaKgOW3p+Wlpei/kOeZu+WFpeS7peadpeeQhuiuuuS6i+S7tuiHqueUseS4reWNjuWKnuWFrOWmiOWmiOecn+ato+S4jemUmeWFqOaWh+WQiOWQjOS7t+WAvOWIq+S6uuebkeedo+WFt+S9k+S4lue6quWboumYn+WIm+S4muaJv+aLheWinumVv+acieS6uuS/neaMgeWVhuWutue7tOS/ruWPsOa5vuW3puWPs+iCoeS7veetlOahiOWunumZheeUteS/oee7j+eQhueUn+WRveWuo+S8oOS7u+WKoeato+W8j+eJueiJsuS4i+adpeWNj+S8muWPquiDveW9k+eEtumHjeaWsOWFp+WuueaMh+WvvOi/kOihjOaXpeW/l+izo+Wutui2hei/h+Wcn+WcsOa1meaxn+aUr+S7mOaOqOWHuuermemVv+adreW3nuaJp+ihjOWItumAoOS5i+S4gOaOqOW5v+eOsOWcuuaPj+i/sOWPmOWMluS8oOe7n+atjOaJi+S/nemZqeivvueoi+WMu+eWl+e7j+i/h+i/h+WOu+S5i+WJjeaUtuWFpeW5tOW6puadguW/l+e+juS4veacgOmrmOeZu+mZhuacquadpeWKoOW3peWFjei0o+aVmeeoi+eJiOWdl+i6q+S9k+mHjeW6huWHuuWUruaIkOacrOW9ouW8j+Wcn+ixhuWHuuWDueS4nOaWuemCrueuseWNl+S6rOaxguiBjOWPluW+l+iBjOS9jeebuOS/oemhtemdouWIhumSn+e9kemhteehruWumuWbvuS+i+e9keWdgOenr+aegemUmeivr+ebrueahOWunei0neacuuWFs+mjjumZqeaOiOadg+eXheavkuWuoOeJqemZpOS6huipleirlueWvueXheWPiuaXtuaxgui0reermeeCueWEv+erpeavj+WkqeS4reWkruiupOivhuavj+S4quWkqea0peWtl+S9k+WPsOeBo+e7tOaKpOacrOmhteS4quaAp+WumOaWueW4uOingeebuOacuuaImOeVpeW6lOW9k+W+i+W4iOaWueS+v+agoeWbreiCoeW4guaIv+Wxi+agj+ebruWRmOW3peWvvOiHtOeqgeeEtumBk+WFt+acrOe9kee7k+WQiOaho+ahiOWKs+WKqOWPpuWklue+juWFg+W8lei1t+aUueWPmOesrOWbm+S8muiuoeiqquaYjumakOengeWuneWuneinhOiMg+a2iOi0ueWFseWQjOW/mOiusOS9k+ezu+W4puadpeWQjeWtl+eZvOihqOW8gOaUvuWKoOebn+WPl+WIsOS6jOaJi+Wkp+mHj+aIkOS6uuaVsOmHj+WFseS6q+WMuuWfn+Wls+WtqeWOn+WImeaJgOWcqOe7k+adn+mAmuS/oei2hee6p+mFjee9ruW9k+aXtuS8mOengOaAp+aEn+aIv+S6p+mBiuaIsuWHuuWPo+aPkOS6pOWwseS4muS/neWBpeeoi+W6puWPguaVsOS6i+S4muaVtOS4quWxseS4nOaDheaEn+eJueauiuWIhumhnuaQnOWwi+WxnuS6jumXqOaIt+i0ouWKoeWjsOmfs+WPiuWFtui0oue7j+WdmuaMgeW5sumDqOaIkOeri+WIqeebiuiAg+iZkeaIkOmDveWMheijheeUqOaItuavlOi1m+aWh+aYjuaLm+WVhuWujOaVtOecn+aYr+ecvOedm+S8meS8tOWogeacm+mihuWfn+WNq+eUn+S8mOaDoOirluWjh+WFrOWFseiJr+WlveWFheWIhuespuWQiOmZhOS7tueJueeCueS4jeWPr+iLseaWh+i1hOS6p+agueacrOaYjuaYvuWvhueivOWFrOS8l+awkeaXj+abtOWKoOS6q+WPl+WQjOWtpuWQr+WKqOmAguWQiOWOn+adpemXruetlOacrOaWh+e+jumjn+e7v+iJsueos+Wumue7iOS6jueUn+eJqeS+m+axguaQnOeLkOWKm+mHj+S4pemHjeawuOi/nOWGmeecn+aciemZkOernuS6ieWvueixoei0ueeUqOS4jeWlvee7neWvueWNgeWIhuS/g+i/m+eCueivhOW9semfs+S8mOWKv+S4jeWwkeaso+i1j+W5tuS4lOacieeCueaWueWQkeWFqOaWsOS/oeeUqOiuvuaWveW9ouixoei1hOagvOeqgeegtOmaj+edgOmHjeWkp+S6juaYr+avleS4muaZuuiDveWMluW3peWujOe+juWVhuWfjue7n+S4gOWHuueJiOaJk+mAoOeUouWTgeamguWGteeUqOS6juS/neeVmeWboOe0oOS4reWci+WtmOWCqOi0tOWbvuacgOaEm+mVv+acn+WPo+S7t+eQhui0ouWfuuWcsOWuieaOkuatpuaxiemHjOmdouWIm+W7uuWkqeepuummluWFiOWujOWWhOmpseWKqOS4i+mdouS4jeWGjeivmuS/oeaEj+S5iemYs+WFieiLseWbvea8guS6ruWGm+S6i+eOqeWutue+pOS8l+WGnOawkeWNs+WPr+WQjeeoseWutuWFt+WKqOeUu+aDs+WIsOazqOaYjuWwj+WtpuaAp+iDveiAg+eglOehrOS7tuingueci+a4healmuaQnueskemmlumggem7hOmHkemAgueUqOaxn+iLj+ecn+WunuS4u+euoemYtuauteiou+WGiue/u+ivkeadg+WIqeWBmuWlveS8vOS5jumAmuiur+aWveW3peeLgOaFi+S5n+iuuOeOr+S/neWfueWFu+amguW/teWkp+Wei+acuuelqOeQhuino+WMv+WQjWN1YW5kb2Vudmlhcm1hZHJpZGJ1c2NhcmluaWNpb3RpZW1wb3BvcnF1ZWN1ZW50YWVzdGFkb3B1ZWRlbmp1ZWdvc2NvbnRyYWVzdMOhbm5vbWJyZXRpZW5lbnBlcmZpbG1hbmVyYWFtaWdvc2NpdWRhZGNlbnRyb2F1bnF1ZXB1ZWRlc2RlbnRyb3ByaW1lcnByZWNpb3NlZ8O6bmJ1ZW5vc3ZvbHZlcnB1bnRvc3NlbWFuYWhhYsOtYWFnb3N0b251ZXZvc3VuaWRvc2Nhcmxvc2VxdWlwb25pw7Fvc211Y2hvc2FsZ3VuYWNvcnJlb2ltYWdlbnBhcnRpcmFycmliYW1hcsOtYWhvbWJyZWVtcGxlb3ZlcmRhZGNhbWJpb211Y2hhc2Z1ZXJvbnBhc2Fkb2zDrW5lYXBhcmVjZW51ZXZhc2N1cnNvc2VzdGFiYXF1aWVyb2xpYnJvc2N1YW50b2FjY2Vzb21pZ3VlbHZhcmlvc2N1YXRyb3RpZW5lc2dydXBvc3NlcsOhbmV1cm9wYW1lZGlvc2ZyZW50ZWFjZXJjYWRlbcOhc29mZXJ0YWNvY2hlc21vZGVsb2l0YWxpYWxldHJhc2FsZ8O6bmNvbXByYWN1YWxlc2V4aXN0ZWN1ZXJwb3NpZW5kb3ByZW5zYWxsZWdhcnZpYWplc2RpbmVyb211cmNpYXBvZHLDoXB1ZXN0b2RpYXJpb3B1ZWJsb3F1aWVyZW1hbnVlbHByb3Bpb2NyaXNpc2NpZXJ0b3NlZ3Vyb211ZXJ0ZWZ1ZW50ZWNlcnJhcmdyYW5kZWVmZWN0b3BhcnRlc21lZGlkYXByb3BpYW9mcmVjZXRpZXJyYWUtbWFpbHZhcmlhc2Zvcm1hc2Z1dHVyb29iamV0b3NlZ3VpcnJpZXNnb25vcm1hc21pc21vc8O6bmljb2NhbWlub3NpdGlvc3JhesOzbmRlYmlkb3BydWViYXRvbGVkb3RlbsOtYWplc8O6c2VzcGVyb2NvY2luYW9yaWdlbnRpZW5kYWNpZW50b2PDoWRpemhhYmxhcnNlcsOtYWxhdGluYWZ1ZXJ6YWVzdGlsb2d1ZXJyYWVudHJhcsOpeGl0b2zDs3BlemFnZW5kYXbDrWRlb2V2aXRhcnBhZ2luYW1ldHJvc2phdmllcnBhZHJlc2bDoWNpbGNhYmV6YcOhcmVhc3NhbGlkYWVudsOtb2phcMOzbmFidXNvc2JpZW5lc3RleHRvc2xsZXZhcnB1ZWRhbmZ1ZXJ0ZWNvbcO6bmNsYXNlc2h1bWFub3Rlbmlkb2JpbGJhb3VuaWRhZGVzdMOhc2VkaXRhcmNyZWFkb9C00LvRj9GH0YLQvtC60LDQutC40LvQuNGN0YLQvtCy0YHQtdC10LPQvtC/0YDQuNGC0LDQutC10YnQtdGD0LbQtdCa0LDQutCx0LXQt9Cx0YvQu9C+0L3QuNCS0YHQtdC/0L7QtNCt0YLQvtGC0L7QvNGH0LXQvNC90LXRgtC70LXRgtGA0LDQt9C+0L3QsNCz0LTQtdC80L3QtdCU0LvRj9Cf0YDQuNC90LDRgdC90LjRhdGC0LXQvNC60YLQvtCz0L7QtNCy0L7RgtGC0LDQvNCh0KjQkNC80LDRj9Cn0YLQvtCy0LDRgdCy0LDQvNC10LzRg9Ci0LDQutC00LLQsNC90LDQvNGN0YLQuNGN0YLRg9CS0LDQvNGC0LXRhdC/0YDQvtGC0YPRgtC90LDQtNC00L3Rj9CS0L7RgtGC0YDQuNC90LXQudCS0LDRgdC90LjQvNGB0LDQvNGC0L7RgtGA0YPQsdCe0L3QuNC80LjRgNC90LXQtdCe0J7QntC70LjRhtGN0YLQsNCe0L3QsNC90LXQvNC00L7QvNC80L7QudC00LLQtdC+0L3QvtGB0YPQtOCkleClh+CkueCliOCkleClgOCkuOClh+CkleCkvuCkleCli+CklOCksOCkquCksOCkqOClh+Ckj+CkleCkleCkv+CkreClgOCkh+CkuOCkleCksOCkpOCli+CkueCli+CkhuCkquCkueClgOCkr+CkueCkr+CkvuCkpOCkleCkpeCkvmphZ3JhbuCkhuCknOCknOCli+CkheCkrOCkpuCli+Ckl+CkiOCknOCkvuCkl+Ckj+CkueCkruCkh+CkqOCkteCkueCkr+Clh+CkpeClh+CkpeClgOCkmOCksOCknOCkrOCkpuClgOCkleCkiOCknOClgOCkteClh+CkqOCkiOCkqOCkj+CkueCksOCkieCkuOCkruClh+CkleCkruCkteCli+CksuClh+CkuOCkrOCkruCkiOCkpuClh+Ckk+CksOCkhuCkruCkrOCkuOCkreCksOCkrOCkqOCkmuCksuCkruCkqOCkhuCkl+CkuOClgOCksuClgNi52YTZidil2YTZidmH2LDYp9ii2K7Ysdi52K/Yr9in2YTZidmH2LDZh9i12YjYsdi62YrYsdmD2KfZhtmI2YTYp9io2YrZhti52LHYttiw2YTZg9mH2YbYp9mK2YjZhdmC2KfZhNi52YTZitin2YbYp9mE2YPZhtit2KrZidmC2KjZhNmI2K3Yqdin2K7YsdmB2YLYt9i52KjYr9ix2YPZhtil2LDYp9mD2YXYp9in2K3Yr9il2YTYp9mB2YrZh9io2LnYttmD2YrZgdio2K3Yq9mI2YXZhtmI2YfZiNij2YbYp9is2K/Yp9mE2YfYp9iz2YTZhdi52YbYr9mE2YrYs9i52KjYsdi12YTZidmF2YbYsNio2YfYp9ij2YbZh9mF2KvZhNmD2YbYqtin2YTYp9it2YrYq9mF2LXYsdi02LHYrdit2YjZhNmI2YHZitin2LDYp9mE2YPZhNmF2LHYqdin2YbYqtin2YTZgdij2KjZiNiu2KfYtdij2YbYqtin2YbZh9in2YTZiti52LbZiNmI2YLYr9in2KjZhtiu2YrYsdio2YbYqtmE2YPZhdi02KfYodmI2YfZitin2KjZiNmC2LXYtdmI2YXYp9ix2YLZhdij2K3Yr9mG2K3Zhti52K/Zhdix2KPZitin2K3YqdmD2KrYqNiv2YjZhtmK2KzYqNmF2YbZh9iq2K3Yqtis2YfYqdiz2YbYqdmK2KrZhdmD2LHYqdi62LLYqdmG2YHYs9io2YrYqtmE2YTZh9mE2YbYp9iq2YTZg9mC2YTYqNmE2YXYp9i52YbZh9ij2YjZhNi02YrYodmG2YjYsdij2YXYp9mB2YrZg9io2YPZhNiw2KfYqtix2KrYqNio2KPZhtmH2YXYs9in2YbZg9io2YrYudmB2YLYr9it2LPZhtmE2YfZhdi02LnYsdij2YfZhNi02YfYsdmC2LfYsdi32YTYqHByb2ZpbGVzZXJ2aWNlZGVmYXVsdGhpbXNlbGZkZXRhaWxzY29udGVudHN1cHBvcnRzdGFydGVkbWVzc2FnZXN1Y2Nlc3NmYXNoaW9uPHRpdGxlPmNvdW50cnlhY2NvdW50Y3JlYXRlZHN0b3JpZXNyZXN1bHRzcnVubmluZ3Byb2Nlc3N3cml0aW5nb2JqZWN0c3Zpc2libGV3ZWxjb21lYXJ0aWNsZXVua25vd25uZXR3b3JrY29tcGFueWR5bmFtaWNicm93c2VycHJpdmFjeXByb2JsZW1TZXJ2aWNlcmVzcGVjdGRpc3BsYXlyZXF1ZXN0cmVzZXJ2ZXdlYnNpdGVoaXN0b3J5ZnJpZW5kc29wdGlvbnN3b3JraW5ndmVyc2lvbm1pbGxpb25jaGFubmVsd2luZG93LmFkZHJlc3N2aXNpdGVkd2VhdGhlcmNvcnJlY3Rwcm9kdWN0ZWRpcmVjdGZvcndhcmR5b3UgY2FucmVtb3ZlZHN1YmplY3Rjb250cm9sYXJjaGl2ZWN1cnJlbnRyZWFkaW5nbGlicmFyeWxpbWl0ZWRtYW5hZ2VyZnVydGhlcnN1bW1hcnltYWNoaW5lbWludXRlc3ByaXZhdGVjb250ZXh0cHJvZ3JhbXNvY2lldHludW1iZXJzd3JpdHRlbmVuYWJsZWR0cmlnZ2Vyc291cmNlc2xvYWRpbmdlbGVtZW50cGFydG5lcmZpbmFsbHlwZXJmZWN0bWVhbmluZ3N5c3RlbXNrZWVwaW5nY3VsdHVyZSZxdW90Oyxqb3VybmFscHJvamVjdHN1cmZhY2VzJnF1b3Q7ZXhwaXJlc3Jldmlld3NiYWxhbmNlRW5nbGlzaENvbnRlbnR0aHJvdWdoUGxlYXNlIG9waW5pb25jb250YWN0YXZlcmFnZXByaW1hcnl2aWxsYWdlU3BhbmlzaGdhbGxlcnlkZWNsaW5lbWVldGluZ21pc3Npb25wb3B1bGFycXVhbGl0eW1lYXN1cmVnZW5lcmFsc3BlY2llc3Nlc3Npb25zZWN0aW9ud3JpdGVyc2NvdW50ZXJpbml0aWFscmVwb3J0c2ZpZ3VyZXNtZW1iZXJzaG9sZGluZ2Rpc3B1dGVlYXJsaWVyZXhwcmVzc2RpZ2l0YWxwaWN0dXJlQW5vdGhlcm1hcnJpZWR0cmFmZmljbGVhZGluZ2NoYW5nZWRjZW50cmFsdmljdG9yeWltYWdlcy9yZWFzb25zc3R1ZGllc2ZlYXR1cmVsaXN0aW5nbXVzdCBiZXNjaG9vbHNWZXJzaW9udXN1YWxseWVwaXNvZGVwbGF5aW5nZ3Jvd2luZ29idmlvdXNvdmVybGF5cHJlc2VudGFjdGlvbnM8L3VsPg0Kd3JhcHBlcmFscmVhZHljZXJ0YWlucmVhbGl0eXN0b3JhZ2Vhbm90aGVyZGVza3RvcG9mZmVyZWRwYXR0ZXJudW51c3VhbERpZ2l0YWxjYXBpdGFsV2Vic2l0ZWZhaWx1cmVjb25uZWN0cmVkdWNlZEFuZHJvaWRkZWNhZGVzcmVndWxhciAmYW1wOyBhbmltYWxzcmVsZWFzZUF1dG9tYXRnZXR0aW5nbWV0aG9kc25vdGhpbmdQb3B1bGFyY2FwdGlvbmxldHRlcnNjYXB0dXJlc2NpZW5jZWxpY2Vuc2VjaGFuZ2VzRW5nbGFuZD0xJmFtcDtIaXN0b3J5ID0gbmV3IENlbnRyYWx1cGRhdGVkU3BlY2lhbE5ldHdvcmtyZXF1aXJlY29tbWVudHdhcm5pbmdDb2xsZWdldG9vbGJhcnJlbWFpbnNiZWNhdXNlZWxlY3RlZERldXRzY2hmaW5hbmNld29ya2Vyc3F1aWNrbHliZXR3ZWVuZXhhY3RseXNldHRpbmdkaXNlYXNlU29jaWV0eXdlYXBvbnNleGhpYml0Jmx0OyEtLUNvbnRyb2xjbGFzc2VzY292ZXJlZG91dGxpbmVhdHRhY2tzZGV2aWNlcyh3aW5kb3dwdXJwb3NldGl0bGU9Ik1vYmlsZSBraWxsaW5nc2hvd2luZ0l0YWxpYW5kcm9wcGVkaGVhdmlseWVmZmVjdHMtMSddKTsKY29uZmlybUN1cnJlbnRhZHZhbmNlc2hhcmluZ29wZW5pbmdkcmF3aW5nYmlsbGlvbm9yZGVyZWRHZXJtYW55cmVsYXRlZDwvZm9ybT5pbmNsdWRld2hldGhlcmRlZmluZWRTY2llbmNlY2F0YWxvZ0FydGljbGVidXR0b25zbGFyZ2VzdHVuaWZvcm1qb3VybmV5c2lkZWJhckNoaWNhZ29ob2xpZGF5R2VuZXJhbHBhc3NhZ2UsJnF1b3Q7YW5pbWF0ZWZlZWxpbmdhcnJpdmVkcGFzc2luZ25hdHVyYWxyb3VnaGx5LgoKVGhlIGJ1dCBub3RkZW5zaXR5QnJpdGFpbkNoaW5lc2VsYWNrIG9mdHJpYnV0ZUlyZWxhbmQiIGRhdGEtZmFjdG9yc3JlY2VpdmV0aGF0IGlzTGlicmFyeWh1c2JhbmRpbiBmYWN0YWZmYWlyc0NoYXJsZXNyYWRpY2FsYnJvdWdodGZpbmRpbmdsYW5kaW5nOmxhbmc9InJldHVybiBsZWFkZXJzcGxhbm5lZHByZW1pdW1wYWNrYWdlQW1lcmljYUVkaXRpb25dJnF1b3Q7TWVzc2FnZW5lZWQgdG92YWx1ZT0iY29tcGxleGxvb2tpbmdzdGF0aW9uYmVsaWV2ZXNtYWxsZXItbW9iaWxlcmVjb3Jkc3dhbnQgdG9raW5kIG9mRmlyZWZveHlvdSBhcmVzaW1pbGFyc3R1ZGllZG1heGltdW1oZWFkaW5ncmFwaWRseWNsaW1hdGVraW5nZG9tZW1lcmdlZGFtb3VudHNmb3VuZGVkcGlvbmVlcmZvcm11bGFkeW5hc3R5aG93IHRvIFN1cHBvcnRyZXZlbnVlZWNvbm9teVJlc3VsdHNicm90aGVyc29sZGllcmxhcmdlbHljYWxsaW5nLiZxdW90O0FjY291bnRFZHdhcmQgc2VnbWVudFJvYmVydCBlZmZvcnRzUGFjaWZpY2xlYXJuZWR1cCB3aXRoaGVpZ2h0OndlIGhhdmVBbmdlbGVzbmF0aW9uc19zZWFyY2hhcHBsaWVkYWNxdWlyZW1hc3NpdmVncmFudGVkOiBmYWxzZXRyZWF0ZWRiaWdnZXN0YmVuZWZpdGRyaXZpbmdTdHVkaWVzbWluaW11bXBlcmhhcHNtb3JuaW5nc2VsbGluZ2lzIHVzZWRyZXZlcnNldmFyaWFudCByb2xlPSJtaXNzaW5nYWNoaWV2ZXByb21vdGVzdHVkZW50c29tZW9uZWV4dHJlbWVyZXN0b3JlYm90dG9tOmV2b2x2ZWRhbGwgdGhlc2l0ZW1hcGVuZ2xpc2h3YXkgdG8gIEF1Z3VzdHN5bWJvbHNDb21wYW55bWF0dGVyc211c2ljYWxhZ2FpbnN0c2VydmluZ30pKCk7DQpwYXltZW50dHJvdWJsZWNvbmNlcHRjb21wYXJlcGFyZW50c3BsYXllcnNyZWdpb25zbW9uaXRvciAnJ1RoZSB3aW5uaW5nZXhwbG9yZWFkYXB0ZWRHYWxsZXJ5cHJvZHVjZWFiaWxpdHllbmhhbmNlY2FyZWVycykuIFRoZSBjb2xsZWN0U2VhcmNoIGFuY2llbnRleGlzdGVkZm9vdGVyIGhhbmRsZXJwcmludGVkY29uc29sZUVhc3Rlcm5leHBvcnRzd2luZG93c0NoYW5uZWxpbGxlZ2FsbmV1dHJhbHN1Z2dlc3RfaGVhZGVyc2lnbmluZy5odG1sIj5zZXR0bGVkd2VzdGVybmNhdXNpbmctd2Via2l0Y2xhaW1lZEp1c3RpY2VjaGFwdGVydmljdGltc1Rob21hcyBtb3ppbGxhcHJvbWlzZXBhcnRpZXNlZGl0aW9ub3V0c2lkZTpmYWxzZSxodW5kcmVkT2x5bXBpY19idXR0b25hdXRob3JzcmVhY2hlZGNocm9uaWNkZW1hbmRzc2Vjb25kc3Byb3RlY3RhZG9wdGVkcHJlcGFyZW5laXRoZXJncmVhdGx5Z3JlYXRlcm92ZXJhbGxpbXByb3ZlY29tbWFuZHNwZWNpYWxzZWFyY2gud29yc2hpcGZ1bmRpbmd0aG91Z2h0aGlnaGVzdGluc3RlYWR1dGlsaXR5cXVhcnRlckN1bHR1cmV0ZXN0aW5nY2xlYXJseWV4cG9zZWRCcm93c2VybGliZXJhbH0gY2F0Y2hQcm9qZWN0ZXhhbXBsZWhpZGUoKTtGbG9yaWRhYW5zd2Vyc2FsbG93ZWRFbXBlcm9yZGVmZW5zZXNlcmlvdXNmcmVlZG9tU2V2ZXJhbC1idXR0b25GdXJ0aGVyb3V0IG9mICE9IG51bGx0cmFpbmVkRGVubWFya3ZvaWQoMCkvYWxsLmpzcHJldmVudFJlcXVlc3RTdGVwaGVuCgpXaGVuIG9ic2VydmU8L2gyPg0KTW9kZXJuIHByb3ZpZGUiIGFsdD0iYm9yZGVycy4KCkZvciAKCk1hbnkgYXJ0aXN0c3Bvd2VyZWRwZXJmb3JtZmljdGlvbnR5cGUgb2ZtZWRpY2FsdGlja2V0c29wcG9zZWRDb3VuY2lsd2l0bmVzc2p1c3RpY2VHZW9yZ2UgQmVsZ2l1bS4uLjwvYT50d2l0dGVybm90YWJseXdhaXRpbmd3YXJmYXJlIE90aGVyIHJhbmtpbmdwaHJhc2VzbWVudGlvbnN1cnZpdmVzY2hvbGFyPC9wPg0KIENvdW50cnlpZ25vcmVkbG9zcyBvZmp1c3QgYXNHZW9yZ2lhc3RyYW5nZTxoZWFkPjxzdG9wcGVkMSddKTsNCmlzbGFuZHNub3RhYmxlYm9yZGVyOmxpc3Qgb2ZjYXJyaWVkMTAwLDAwMDwvaDM+CiBzZXZlcmFsYmVjb21lc3NlbGVjdCB3ZWRkaW5nMDAuaHRtbG1vbmFyY2hvZmYgdGhldGVhY2hlcmhpZ2hseSBiaW9sb2d5bGlmZSBvZm9yIGV2ZW5yaXNlIG9mJnJhcXVvO3BsdXNvbmVodW50aW5nKHRob3VnaERvdWdsYXNqb2luaW5nY2lyY2xlc0ZvciB0aGVBbmNpZW50VmlldG5hbXZlaGljbGVzdWNoIGFzY3J5c3RhbHZhbHVlID1XaW5kb3dzZW5qb3llZGEgc21hbGxhc3N1bWVkPGEgaWQ9ImZvcmVpZ24gQWxsIHJpaG93IHRoZURpc3BsYXlyZXRpcmVkaG93ZXZlcmhpZGRlbjtiYXR0bGVzc2Vla2luZ2NhYmluZXR3YXMgbm90bG9vayBhdGNvbmR1Y3RnZXQgdGhlSmFudWFyeWhhcHBlbnN0dXJuaW5nYTpob3Zlck9ubGluZSBGcmVuY2ggbGFja2luZ3R5cGljYWxleHRyYWN0ZW5lbWllc2V2ZW4gaWZnZW5lcmF0ZGVjaWRlZGFyZSBub3Qvc2VhcmNoYmVsaWVmcy1pbWFnZTpsb2NhdGVkc3RhdGljLmxvZ2luIj5jb252ZXJ0dmlvbGVudGVudGVyZWRmaXJzdCI+Y2lyY3VpdEZpbmxhbmRjaGVtaXN0c2hlIHdhczEwcHg7Ij5hcyBzdWNoZGl2aWRlZDwvc3Bhbj53aWxsIGJlbGluZSBvZmEgZ3JlYXRteXN0ZXJ5L2luZGV4LmZhbGxpbmdkdWUgdG8gcmFpbHdheWNvbGxlZ2Vtb25zdGVyZGVzY2VudGl0IHdpdGhudWNsZWFySmV3aXNoIHByb3Rlc3RCcml0aXNoZmxvd2Vyc3ByZWRpY3RyZWZvcm1zYnV0dG9uIHdobyB3YXNsZWN0dXJlaW5zdGFudHN1aWNpZGVnZW5lcmljcGVyaW9kc21hcmtldHNTb2NpYWwgZmlzaGluZ2NvbWJpbmVncmFwaGljd2lubmVyczxiciAvPjxieSB0aGUgTmF0dXJhbFByaXZhY3ljb29raWVzb3V0Y29tZXJlc29sdmVTd2VkaXNoYnJpZWZseVBlcnNpYW5zbyBtdWNoQ2VudHVyeWRlcGljdHNjb2x1bW5zaG91c2luZ3NjcmlwdHNuZXh0IHRvYmVhcmluZ21hcHBpbmdyZXZpc2VkalF1ZXJ5KC13aWR0aDp0aXRsZSI+dG9vbHRpcFNlY3Rpb25kZXNpZ25zVHVya2lzaHlvdW5nZXIubWF0Y2gofSkoKTsKCmJ1cm5pbmdvcGVyYXRlZGVncmVlc3NvdXJjZT1SaWNoYXJkY2xvc2VseXBsYXN0aWNlbnRyaWVzPC90cj4NCmNvbG9yOiN1bCBpZD0icG9zc2Vzc3JvbGxpbmdwaHlzaWNzZmFpbGluZ2V4ZWN1dGVjb250ZXN0bGluayB0b0RlZmF1bHQ8YnIgLz4KOiB0cnVlLGNoYXJ0ZXJ0b3VyaXNtY2xhc3NpY3Byb2NlZWRleHBsYWluPC9oMT4NCm9ubGluZS4/eG1sIHZlaGVscGluZ2RpYW1vbmR1c2UgdGhlYWlybGluZWVuZCAtLT4pLmF0dHIocmVhZGVyc2hvc3RpbmcjZmZmZmZmcmVhbGl6ZVZpbmNlbnRzaWduYWxzIHNyYz0iL1Byb2R1Y3RkZXNwaXRlZGl2ZXJzZXRlbGxpbmdQdWJsaWMgaGVsZCBpbkpvc2VwaCB0aGVhdHJlYWZmZWN0czxzdHlsZT5hIGxhcmdlZG9lc24ndGxhdGVyLCBFbGVtZW50ZmF2aWNvbmNyZWF0b3JIdW5nYXJ5QWlycG9ydHNlZSB0aGVzbyB0aGF0TWljaGFlbFN5c3RlbXNQcm9ncmFtcywgYW5kICB3aWR0aD1lJnF1b3Q7dHJhZGluZ2xlZnQiPgpwZXJzb25zR29sZGVuIEFmZmFpcnNncmFtbWFyZm9ybWluZ2Rlc3Ryb3lpZGVhIG9mY2FzZSBvZm9sZGVzdCB0aGlzIGlzLnNyYyA9IGNhcnRvb25yZWdpc3RyQ29tbW9uc011c2xpbXNXaGF0IGlzaW4gbWFueW1hcmtpbmdyZXZlYWxzSW5kZWVkLGVxdWFsbHkvc2hvd19hb3V0ZG9vcmVzY2FwZShBdXN0cmlhZ2VuZXRpY3N5c3RlbSxJbiB0aGUgc2l0dGluZ0hlIGFsc29Jc2xhbmRzQWNhZGVteQoJCTwhLS1EYW5pZWwgYmluZGluZ2Jsb2NrIj5pbXBvc2VkdXRpbGl6ZUFicmFoYW0oZXhjZXB0e3dpZHRoOnB1dHRpbmcpLmh0bWwofHwgW107CkRBVEFbICpraXRjaGVubW91bnRlZGFjdHVhbCBkaWFsZWN0bWFpbmx5IF9ibGFuaydpbnN0YWxsZXhwZXJ0c2lmKHR5cGVJdCBhbHNvJmNvcHk7ICI+VGVybXNib3JuIGluT3B0aW9uc2Vhc3Rlcm50YWxraW5nY29uY2VybmdhaW5lZCBvbmdvaW5nanVzdGlmeWNyaXRpY3NmYWN0b3J5aXRzIG93bmFzc2F1bHRpbnZpdGVkbGFzdGluZ2hpcyBvd25ocmVmPSIvIiByZWw9ImRldmVsb3Bjb25jZXJ0ZGlhZ3JhbWRvbGxhcnNjbHVzdGVycGhwP2lkPWFsY29ob2wpO30pKCk7dXNpbmcgYT48c3Bhbj52ZXNzZWxzcmV2aXZhbEFkZHJlc3NhbWF0ZXVyYW5kcm9pZGFsbGVnZWRpbGxuZXNzd2Fsa2luZ2NlbnRlcnNxdWFsaWZ5bWF0Y2hlc3VuaWZpZWRleHRpbmN0RGVmZW5zZWRpZWQgaW4KCTwhLS0gY3VzdG9tc2xpbmtpbmdMaXR0bGUgQm9vayBvZmV2ZW5pbmdtaW4uanM/YXJlIHRoZWtvbnRha3R0b2RheSdzLmh0bWwiIHRhcmdldD13ZWFyaW5nQWxsIFJpZzsKfSkoKTtyYWlzaW5nIEFsc28sIGNydWNpYWxhYm91dCI+ZGVjbGFyZS0tPgo8c2NmaXJlZm94YXMgbXVjaGFwcGxpZXNpbmRleCwgcywgYnV0IHR5cGUgPSAKDQo8IS0tdG93YXJkc1JlY29yZHNQcml2YXRlRm9yZWlnblByZW1pZXJjaG9pY2VzVmlydHVhbHJldHVybnNDb21tZW50UG93ZXJlZGlubGluZTtwb3ZlcnR5Y2hhbWJlckxpdmluZyB2b2x1bWVzQW50aG9ueWxvZ2luIiBSZWxhdGVkRWNvbm9teXJlYWNoZXNjdXR0aW5nZ3Jhdml0eWxpZmUgaW5DaGFwdGVyLXNoYWRvd05vdGFibGU8L3RkPg0KIHJldHVybnN0YWRpdW13aWRnZXRzdmFyeWluZ3RyYXZlbHNoZWxkIGJ5d2hvIGFyZXdvcmsgaW5mYWN1bHR5YW5ndWxhcndobyBoYWRhaXJwb3J0dG93biBvZgoKU29tZSAnY2xpY2snY2hhcmdlc2tleXdvcmRpdCB3aWxsY2l0eSBvZih0aGlzKTtBbmRyZXcgdW5pcXVlIGNoZWNrZWRvciBtb3JlMzAwcHg7IHJldHVybjtyc2lvbj0icGx1Z2luc3dpdGhpbiBoZXJzZWxmU3RhdGlvbkZlZGVyYWx2ZW50dXJlcHVibGlzaHNlbnQgdG90ZW5zaW9uYWN0cmVzc2NvbWUgdG9maW5nZXJzRHVrZSBvZnBlb3BsZSxleHBsb2l0d2hhdCBpc2hhcm1vbnlhIG1ham9yIjoiaHR0cGluIGhpcyBtZW51Ij4KbW9udGhseW9mZmljZXJjb3VuY2lsZ2FpbmluZ2V2ZW4gaW5TdW1tYXJ5ZGF0ZSBvZmxveWFsdHlmaXRuZXNzYW5kIHdhc2VtcGVyb3JzdXByZW1lU2Vjb25kIGhlYXJpbmdSdXNzaWFubG9uZ2VzdEFsYmVydGFsYXRlcmFsc2V0IG9mIHNtYWxsIj4uYXBwZW5kZG8gd2l0aGZlZGVyYWxiYW5rIG9mYmVuZWF0aERlc3BpdGVDYXBpdGFsZ3JvdW5kcyksIGFuZCBwZXJjZW50aXQgZnJvbWNsb3Npbmdjb250YWluSW5zdGVhZGZpZnRlZW5hcyB3ZWxsLnlhaG9vLnJlc3BvbmRmaWdodGVyb2JzY3VyZXJlZmxlY3RvcmdhbmljPSBNYXRoLmVkaXRpbmdvbmxpbmUgcGFkZGluZ2Egd2hvbGVvbmVycm9yeWVhciBvZmVuZCBvZiBiYXJyaWVyd2hlbiBpdGhlYWRlciBob21lIG9mcmVzdW1lZHJlbmFtZWRzdHJvbmc+aGVhdGluZ3JldGFpbnNjbG91ZGZyd2F5IG9mIE1hcmNoIDFrbm93aW5naW4gcGFydEJldHdlZW5sZXNzb25zY2xvc2VzdHZpcnR1YWxsaW5rcyI+Y3Jvc3NlZEVORCAtLT5mYW1vdXMgYXdhcmRlZExpY2Vuc2VIZWFsdGggZmFpcmx5IHdlYWx0aHltaW5pbWFsQWZyaWNhbmNvbXBldGVsYWJlbCI+c2luZ2luZ2Zhcm1lcnNCcmFzaWwpZGlzY3Vzc3JlcGxhY2VHcmVnb3J5Zm9udCBjb3B1cnN1ZWRhcHBlYXJzbWFrZSB1cHJvdW5kZWRib3RoIG9mYmxvY2tlZHNhdyB0aGVvZmZpY2VzY29sb3Vyc2lmKGRvY3V3aGVuIGhlZW5mb3JjZXB1c2goZnVBdWd1c3QgVVRGLTgiPkZhbnRhc3lpbiBtb3N0aW5qdXJlZFVzdWFsbHlmYXJtaW5nY2xvc3VyZW9iamVjdCBkZWZlbmNldXNlIG9mIE1lZGljYWw8Ym9keT4KZXZpZGVudGJlIHVzZWRrZXlDb2Rlc2l4dGVlbklzbGFtaWMjMDAwMDAwZW50aXJlIHdpZGVseSBhY3RpdmUgKHR5cGVvZm9uZSBjYW5jb2xvciA9c3BlYWtlcmV4dGVuZHNQaHlzaWNzdGVycmFpbjx0Ym9keT5mdW5lcmFsdmlld2luZ21pZGRsZSBjcmlja2V0cHJvcGhldHNoaWZ0ZWRkb2N0b3JzUnVzc2VsbCB0YXJnZXRjb21wYWN0YWxnZWJyYXNvY2lhbC1idWxrIG9mbWFuIGFuZDwvdGQ+CiBoZSBsZWZ0KS52YWwoKWZhbHNlKTtsb2dpY2FsYmFua2luZ2hvbWUgdG9uYW1pbmcgQXJpem9uYWNyZWRpdHMpOwp9KTsKZm91bmRlcmluIHR1cm5Db2xsaW5zYmVmb3JlIEJ1dCB0aGVjaGFyZ2VkVGl0bGUiPkNhcHRhaW5zcGVsbGVkZ29kZGVzc1RhZyAtLT5BZGRpbmc6YnV0IHdhc1JlY2VudCBwYXRpZW50YmFjayBpbj1mYWxzZSZMaW5jb2xud2Uga25vd0NvdW50ZXJKdWRhaXNtc2NyaXB0IGFsdGVyZWQnXSk7CiAgaGFzIHRoZXVuY2xlYXJFdmVudCcsYm90aCBpbm5vdCBhbGwKCjwhLS0gcGxhY2luZ2hhcmQgdG8gY2VudGVyc29ydCBvZmNsaWVudHNzdHJlZXRzQmVybmFyZGFzc2VydHN0ZW5kIHRvZmFudGFzeWRvd24gaW5oYXJib3VyRnJlZWRvbWpld2VscnkvYWJvdXQuLnNlYXJjaGxlZ2VuZHNpcyBtYWRlbW9kZXJuIG9ubHkgb25vbmx5IHRvaW1hZ2UiIGxpbmVhciBwYWludGVyYW5kIG5vdHJhcmVseSBhY3JvbnltZGVsaXZlcnNob3J0ZXIwMCZhbXA7YXMgbWFueXdpZHRoPSIvKiA8IVtDdGl0bGUgPW9mIHRoZSBsb3dlc3QgcGlja2VkIGVzY2FwZWR1c2VzIG9mcGVvcGxlcyBQdWJsaWNNYXR0aGV3dGFjdGljc2RhbWFnZWR3YXkgZm9ybGF3cyBvZmVhc3kgdG8gd2luZG93c3Ryb25nICBzaW1wbGV9Y2F0Y2goc2V2ZW50aGluZm9ib3h3ZW50IHRvcGFpbnRlZGNpdGl6ZW5JIGRvbid0cmV0cmVhdC4gU29tZSB3dy4iKTsKYm9tYmluZ21haWx0bzptYWRlIGluLiBNYW55IGNhcnJpZXN8fHt9O3dpd29yayBvZnN5bm9ueW1kZWZlYXRzZmF2b3JlZG9wdGljYWxwYWdlVHJhdW5sZXNzIHNlbmRpbmdsZWZ0Ij48Y29tU2NvckFsbCB0aGVqUXVlcnkudG91cmlzdENsYXNzaWNmYWxzZSIgV2lsaGVsbXN1YnVyYnNnZW51aW5lYmlzaG9wcy5zcGxpdChnbG9iYWwgZm9sbG93c2JvZHkgb2Zub21pbmFsQ29udGFjdHNlY3VsYXJsZWZ0IHRvY2hpZWZseS1oaWRkZW4tYmFubmVyPC9saT4KCi4gV2hlbiBpbiBib3RoZGlzbWlzc0V4cGxvcmVhbHdheXMgdmlhIHRoZXNwYcOxb2x3ZWxmYXJlcnVsaW5nIGFycmFuZ2VjYXB0YWluaGlzIHNvbnJ1bGUgb2ZoZSB0b29raXRzZWxmLD0wJmFtcDsoY2FsbGVkc2FtcGxlc3RvIG1ha2Vjb20vcGFnTWFydGluIEtlbm5lZHlhY2NlcHRzZnVsbCBvZmhhbmRsZWRCZXNpZGVzLy8tLT48L2FibGUgdG90YXJnZXRzZXNzZW5jZWhpbSB0byBpdHMgYnkgY29tbW9uLm1pbmVyYWx0byB0YWtld2F5cyB0b3Mub3JnL2xhZHZpc2VkcGVuYWx0eXNpbXBsZTppZiB0aGV5TGV0dGVyc2Egc2hvcnRIZXJiZXJ0c3RyaWtlcyBncm91cHMubGVuZ3RoZmxpZ2h0c292ZXJsYXBzbG93bHkgbGVzc2VyIHNvY2lhbCA8L3A+CgkJaXQgaW50b3JhbmtlZCByYXRlIG9mdWw+DQogIGF0dGVtcHRwYWlyIG9mbWFrZSBpdEtvbnRha3RBbnRvbmlvaGF2aW5nIHJhdGluZ3MgYWN0aXZlc3RyZWFtc3RyYXBwZWQiKS5jc3MoaG9zdGlsZWxlYWQgdG9saXR0bGUgZ3JvdXBzLFBpY3R1cmUtLT4NCg0KIHJvd3M9IiBvYmplY3RpbnZlcnNlPGZvb3RlckN1c3RvbVY+PFwvc2Nyc29sdmluZ0NoYW1iZXJzbGF2ZXJ5d291bmRlZHdoZXJlYXMhPSAndW5kZm9yIGFsbHBhcnRseSAtcmlnaHQ6QXJhYmlhbmJhY2tlZCBjZW50dXJ5dW5pdCBvZm1vYmlsZS1FdXJvcGUsaXMgaG9tZXJpc2sgb2ZkZXNpcmVkQ2xpbnRvbmNvc3Qgb2ZhZ2Ugb2YgYmVjb21lIG5vbmUgb2ZwJnF1b3Q7TWlkZGxlIGVhZCcpWzBDcml0aWNzc3R1ZGlvcz4mY29weTtncm91cCI+YXNzZW1ibG1ha2luZyBwcmVzc2Vkd2lkZ2V0LnBzOiIgPyByZWJ1aWx0Ynkgc29tZUZvcm1lciBlZGl0b3JzZGVsYXllZENhbm9uaWNoYWQgdGhlcHVzaGluZ2NsYXNzPSJidXQgYXJlcGFydGlhbEJhYnlsb25ib3R0b20gY2FycmllckNvbW1hbmRpdHMgdXNlQXMgd2l0aGNvdXJzZXNhIHRoaXJkZGVub3Rlc2Fsc28gaW5Ib3VzdG9uMjBweDsiPmFjY3VzZWRkb3VibGUgZ29hbCBvZkZhbW91cyApLmJpbmQocHJpZXN0cyBPbmxpbmVpbiBKdWx5c3QgKyAiZ2NvbnN1bHRkZWNpbWFsaGVscGZ1bHJldml2ZWRpcyB2ZXJ5cicrJ2lwdGxvc2luZyBmZW1hbGVzaXMgYWxzb3N0cmluZ3NkYXlzIG9mYXJyaXZhbGZ1dHVyZSA8b2JqZWN0Zm9yY2luZ1N0cmluZygiIC8+CgkJaGVyZSBpc2VuY29kZWQuICBUaGUgYmFsbG9vbmRvbmUgYnkvY29tbW9uYmdjb2xvcmxhdyBvZiBJbmRpYW5hYXZvaWRlZGJ1dCB0aGUycHggM3B4anF1ZXJ5LmFmdGVyIGFwb2xpY3kubWVuIGFuZGZvb3Rlci09IHRydWU7Zm9yIHVzZXNjcmVlbi5JbmRpYW4gaW1hZ2UgPWZhbWlseSxodHRwOi8vICZuYnNwO2RyaXZlcnNldGVybmFsc2FtZSBhc25vdGljZWR2aWV3ZXJzfSkoKTsKIGlzIG1vcmVzZWFzb25zZm9ybWVyIHRoZSBuZXdpcyBqdXN0Y29uc2VudCBTZWFyY2h3YXMgdGhld2h5IHRoZXNoaXBwZWRicj48YnI+d2lkdGg6IGhlaWdodD1tYWRlIG9mY3Vpc2luZWlzIHRoYXRhIHZlcnkgQWRtaXJhbCBmaXhlZDtub3JtYWwgTWlzc2lvblByZXNzLCBvbnRhcmlvY2hhcnNldHRyeSB0byBpbnZhZGVkPSJ0cnVlInNwYWNpbmdpcyBtb3N0YSBtb3JlIHRvdGFsbHlmYWxsIG9mfSk7DQogIGltbWVuc2V0aW1lIGluc2V0IG91dHNhdGlzZnl0byBmaW5kZG93biB0b2xvdCBvZiBQbGF5ZXJzaW4gSnVuZXF1YW50dW1ub3QgdGhldGltZSB0b2Rpc3RhbnRGaW5uaXNoc3JjID0gKHNpbmdsZSBoZWxwIG9mR2VybWFuIGxhdyBhbmRsYWJlbGVkZm9yZXN0c2Nvb2tpbmdzcGFjZSI+aGVhZGVyLXdlbGwgYXNTdGFubGV5YnJpZGdlcy9nbG9iYWxDcm9hdGlhIEFib3V0IFswXTsKICBpdCwgYW5kZ3JvdXBlZGJlaW5nIGEpe3Rocm93aGUgbWFkZWxpZ2h0ZXJldGhpY2FsRkZGRkZGImJvdHRvbSJsaWtlIGEgZW1wbG95c2xpdmUgaW5hcyBzZWVucHJpbnRlcm1vc3Qgb2Z1Yi1saW5rcmVqZWN0c2FuZCB1c2VpbWFnZSI+c3VjY2VlZGZlZWRpbmdOdWNsZWFyaW5mb3JtYXRvIGhlbHBXb21lbidzTmVpdGhlck1leGljYW5wcm90ZWluPHRhYmxlIGJ5IG1hbnloZWFsdGh5bGF3c3VpdGRldmlzZWQucHVzaCh7c2VsbGVyc3NpbXBseSBUaHJvdWdoLmNvb2tpZSBJbWFnZShvbGRlciI+dXMuanMiPiBTaW5jZSB1bml2ZXJzbGFyZ2VyIG9wZW4gdG8hLS0gZW5kbGllcyBpbiddKTsNCiAgbWFya2V0d2hvIGlzICgiRE9NQ29tYW5hZ2Vkb25lIGZvcnR5cGVvZiBLaW5nZG9tcHJvZml0c3Byb3Bvc2V0byBzaG93Y2VudGVyO21hZGUgaXRkcmVzc2Vkd2VyZSBpbm1peHR1cmVwcmVjaXNlYXJpc2luZ3NyYyA9ICdtYWtlIGEgc2VjdXJlZEJhcHRpc3R2b3RpbmcgCgkJdmFyIE1hcmNoIDJncmV3IHVwQ2xpbWF0ZS5yZW1vdmVza2lsbGVkd2F5IHRoZTwvaGVhZD5mYWNlIG9mYWN0aW5nIHJpZ2h0Ij50byB3b3JrcmVkdWNlc2hhcyBoYWRlcmVjdGVkc2hvdygpO2FjdGlvbj1ib29rIG9mYW4gYXJlYT09ICJodHQ8aGVhZGVyCjxodG1sPmNvbmZvcm1mYWNpbmcgY29va2llLnJlbHkgb25ob3N0ZWQgLmN1c3RvbWhlIHdlbnRidXQgZm9yc3ByZWFkIEZhbWlseSBhIG1lYW5zb3V0IHRoZWZvcnVtcy5mb290YWdlIj5Nb2JpbENsZW1lbnRzIiBpZD0iYXMgaGlnaGludGVuc2UtLT48IS0tZmVtYWxlIGlzIHNlZW5pbXBsaWVkc2V0IHRoZWEgc3RhdGVhbmQgaGlzZmFzdGVzdGJlc2lkZXNidXR0b25fYm91bmRlZCI+PGltZyBJbmZvYm94ZXZlbnRzLGEgeW91bmdhbmQgYXJlTmF0aXZlIGNoZWFwZXJUaW1lb3V0YW5kIGhhc2VuZ2luZXN3b24gdGhlKG1vc3RseXJpZ2h0OiBmaW5kIGEgLWJvdHRvbVByaW5jZSBhcmVhIG9mbW9yZSBvZnNlYXJjaF9uYXR1cmUsbGVnYWxseXBlcmlvZCxsYW5kIG9mb3Igd2l0aGluZHVjZWRwcm92aW5nbWlzc2lsZWxvY2FsbHlBZ2FpbnN0dGhlIHdheWsmcXVvdDtweDsiPg0KcHVzaGVkIGFiYW5kb25udW1lcmFsQ2VydGFpbkluIHRoaXNtb3JlIGlub3Igc29tZW5hbWUgaXNhbmQsIGluY3Jvd25lZElTQk4gMC1jcmVhdGVzT2N0b2Jlcm1heSBub3RjZW50ZXIgbGF0ZSBpbkRlZmVuY2VlbmFjdGVkd2lzaCB0b2Jyb2FkbHljb29saW5nb25sb2FkPWl0LiBUaGVyZWNvdmVyTWVtYmVyc2hlaWdodCBhc3N1bWVzPGh0bWw+CnBlb3BsZS5pbiBvbmUgPXdpbmRvd2Zvb3Rlcl9hIGdvb2QgcmVrbGFtYW90aGVycyx0byB0aGlzX2Nvb2tpZXBhbmVsIj5Mb25kb24sZGVmaW5lc2NydXNoZWRiYXB0aXNtY29hc3RhbHN0YXR1cyB0aXRsZSIgbW92ZSB0b2xvc3QgaW5iZXR0ZXIgaW1wbGllc3JpdmFscnlzZXJ2ZXJzIFN5c3RlbVBlcmhhcHNlcyBhbmQgY29udGVuZGZsb3dpbmdsYXN0ZWQgcmlzZSBpbkdlbmVzaXN2aWV3IG9mcmlzaW5nIHNlZW0gdG9idXQgaW4gYmFja2luZ2hlIHdpbGxnaXZlbiBhZ2l2aW5nIGNpdGllcy5mbG93IG9mIExhdGVyIGFsbCBidXRIaWdod2F5b25seSBieXNpZ24gb2ZoZSBkb2VzZGlmZmVyc2JhdHRlcnkmYW1wO2xhc2luZ2xlc3RocmVhdHNpbnRlZ2VydGFrZSBvbnJlZnVzZWRjYWxsZWQgPVVTJmFtcFNlZSB0aGVuYXRpdmVzYnkgdGhpc3N5c3RlbS5oZWFkIG9mOmhvdmVyLGxlc2JpYW5zdXJuYW1lYW5kIGFsbGNvbW1vbi9oZWFkZXJfX3BhcmFtc0hhcnZhcmQvcGl4ZWwucmVtb3ZhbHNvIGxvbmdyb2xlIG9mam9pbnRseXNreXNjcmFVbmljb2RlYnIgLz4NCkF0bGFudGFudWNsZXVzQ291bnR5LHB1cmVseSBjb3VudCI+ZWFzaWx5IGJ1aWxkIGFvbmNsaWNrYSBnaXZlbnBvaW50ZXJoJnF1b3Q7ZXZlbnRzIGVsc2UgewpkaXRpb25zbm93IHRoZSwgd2l0aCBtYW4gd2hvb3JnL1dlYm9uZSBhbmRjYXZhbHJ5SGUgZGllZHNlYXR0bGUwMCwwMDAge3dpbmRvd2hhdmUgdG9pZih3aW5kYW5kIGl0c3NvbGVseSBtJnF1b3Q7cmVuZXdlZERldHJvaXRhbW9uZ3N0ZWl0aGVyIHRoZW0gaW5TZW5hdG9yVXM8L2E+PEtpbmcgb2ZGcmFuY2lzLXByb2R1Y2hlIHVzZWRhcnQgYW5kaGltIGFuZHVzZWQgYnlzY29yaW5nYXQgaG9tZXRvIGhhdmVyZWxhdGVzaWJpbGl0eWZhY3Rpb25CdWZmYWxvbGluayI+PHdoYXQgaGVmcmVlIHRvQ2l0eSBvZmNvbWUgaW5zZWN0b3JzY291bnRlZG9uZSBkYXluZXJ2b3Vzc3F1YXJlIH07aWYoZ29pbiB3aGF0aW1nIiBhbGlzIG9ubHlzZWFyY2gvdHVlc2RheWxvb3NlbHlTb2xvbW9uc2V4dWFsIC0gPGEgaHJtZWRpdW0iRE8gTk9UIEZyYW5jZSx3aXRoIGEgd2FyIGFuZHNlY29uZCB0YWtlIGEgPg0KDQoNCm1hcmtldC5oaWdod2F5ZG9uZSBpbmN0aXZpdHkibGFzdCI+b2JsaWdlZHJpc2UgdG8idW5kZWZpbWFkZSB0byBFYXJseSBwcmFpc2VkaW4gaXRzIGZvciBoaXNhdGhsZXRlSnVwaXRlcllhaG9vISB0ZXJtZWQgc28gbWFueXJlYWxseSBzLiBUaGUgYSB3b21hbj92YWx1ZT1kaXJlY3QgcmlnaHQiIGJpY3ljbGVhY2luZz0iZGF5IGFuZHN0YXRpbmdSYXRoZXIsaGlnaGVyIE9mZmljZSBhcmUgbm93dGltZXMsIHdoZW4gYSBwYXkgZm9yb24gdGhpcy1saW5rIj47Ym9yZGVyYXJvdW5kIGFubnVhbCB0aGUgTmV3cHV0IHRoZS5jb20iIHRha2luIHRvYSBicmllZihpbiB0aGVncm91cHMuOyB3aWR0aGVuenltZXNzaW1wbGUgaW4gbGF0ZXtyZXR1cm50aGVyYXB5YSBwb2ludGJhbm5pbmdpbmtzIj4KKCk7IiByZWEgcGxhY2VcdTAwM0NhYWJvdXQgYXRyPg0KCQljY291bnQgZ2l2ZXMgYTxTQ1JJUFRSYWlsd2F5dGhlbWVzL3Rvb2xib3hCeUlkKCJ4aHVtYW5zLHdhdGNoZXNpbiBzb21lIGlmICh3aWNvbWluZyBmb3JtYXRzIFVuZGVyIGJ1dCBoYXNoYW5kZWQgbWFkZSBieXRoYW4gaW5mZWFyIG9mZGVub3RlZC9pZnJhbWVsZWZ0IGludm9sdGFnZWluIGVhY2hhJnF1b3Q7YmFzZSBvZkluIG1hbnl1bmRlcmdvcmVnaW1lc2FjdGlvbiA8L3A+DQo8dXN0b21WYTsmZ3Q7PC9pbXBvcnRzb3IgdGhhdG1vc3RseSAmYW1wO3JlIHNpemU9IjwvYT48L2hhIGNsYXNzcGFzc2l2ZUhvc3QgPSBXaGV0aGVyZmVydGlsZVZhcmlvdXM9W107KGZ1Y2FtZXJhcy8+PC90ZD5hY3RzIGFzSW4gc29tZT4NCg0KPCFvcmdhbmlzIDxiciAvPkJlaWppbmdjYXRhbMOgZGV1dHNjaGV1cm9wZXVldXNrYXJhZ2FlaWxnZXN2ZW5za2Flc3Bhw7FhbWVuc2FqZXVzdWFyaW90cmFiYWpvbcOpeGljb3DDoWdpbmFzaWVtcHJlc2lzdGVtYW9jdHVicmVkdXJhbnRlYcOxYWRpcmVtcHJlc2Ftb21lbnRvbnVlc3Ryb3ByaW1lcmF0cmF2w6lzZ3JhY2lhc251ZXN0cmFwcm9jZXNvZXN0YWRvc2NhbGlkYWRwZXJzb25hbsO6bWVyb2FjdWVyZG9tw7pzaWNhbWllbWJyb29mZXJ0YXNhbGd1bm9zcGHDrXNlc2VqZW1wbG9kZXJlY2hvYWRlbcOhc3ByaXZhZG9hZ3JlZ2FyZW5sYWNlc3Bvc2libGVob3RlbGVzc2V2aWxsYXByaW1lcm/Dumx0aW1vZXZlbnRvc2FyY2hpdm9jdWx0dXJhbXVqZXJlc2VudHJhZGFhbnVuY2lvZW1iYXJnb21lcmNhZG9ncmFuZGVzZXN0dWRpb21lam9yZXNmZWJyZXJvZGlzZcOxb3R1cmlzbW9jw7NkaWdvcG9ydGFkYWVzcGFjaW9mYW1pbGlhYW50b25pb3Blcm1pdGVndWFyZGFyYWxndW5hc3ByZWNpb3NhbGd1aWVuc2VudGlkb3Zpc2l0YXN0w610dWxvY29ub2NlcnNlZ3VuZG9jb25zZWpvZnJhbmNpYW1pbnV0b3NzZWd1bmRhdGVuZW1vc2VmZWN0b3Ntw6FsYWdhc2VzacOzbnJldmlzdGFncmFuYWRhY29tcHJhcmluZ3Jlc29nYXJjw61hYWNjacOzbmVjdWFkb3JxdWllbmVzaW5jbHVzb2RlYmVyw6FtYXRlcmlhaG9tYnJlc211ZXN0cmFwb2Ryw61hbWHDsWFuYcO6bHRpbWFlc3RhbW9zb2ZpY2lhbHRhbWJpZW5uaW5nw7puc2FsdWRvc3BvZGVtb3NtZWpvcmFycG9zaXRpb25idXNpbmVzc2hvbWVwYWdlc2VjdXJpdHlsYW5ndWFnZXN0YW5kYXJkY2FtcGFpZ25mZWF0dXJlc2NhdGVnb3J5ZXh0ZXJuYWxjaGlsZHJlbnJlc2VydmVkcmVzZWFyY2hleGNoYW5nZWZhdm9yaXRldGVtcGxhdGVtaWxpdGFyeWluZHVzdHJ5c2VydmljZXNtYXRlcmlhbHByb2R1Y3Rzei1pbmRleDpjb21tZW50c3NvZnR3YXJlY29tcGxldGVjYWxlbmRhcnBsYXRmb3JtYXJ0aWNsZXNyZXF1aXJlZG1vdmVtZW50cXVlc3Rpb25idWlsZGluZ3BvbGl0aWNzcG9zc2libGVyZWxpZ2lvbnBoeXNpY2FsZmVlZGJhY2tyZWdpc3RlcnBpY3R1cmVzZGlzYWJsZWRwcm90b2NvbGF1ZGllbmNlc2V0dGluZ3NhY3Rpdml0eWVsZW1lbnRzbGVhcm5pbmdhbnl0aGluZ2Fic3RyYWN0cHJvZ3Jlc3NvdmVydmlld21hZ2F6aW5lZWNvbm9taWN0cmFpbmluZ3ByZXNzdXJldmFyaW91cyA8c3Ryb25nPnByb3BlcnR5c2hvcHBpbmd0b2dldGhlcmFkdmFuY2VkYmVoYXZpb3Jkb3dubG9hZGZlYXR1cmVkZm9vdGJhbGxzZWxlY3RlZExhbmd1YWdlZGlzdGFuY2VyZW1lbWJlcnRyYWNraW5ncGFzc3dvcmRtb2RpZmllZHN0dWRlbnRzZGlyZWN0bHlmaWdodGluZ25vcnRoZXJuZGF0YWJhc2VmZXN0aXZhbGJyZWFraW5nbG9jYXRpb25pbnRlcm5ldGRyb3Bkb3ducHJhY3RpY2VldmlkZW5jZWZ1bmN0aW9ubWFycmlhZ2VyZXNwb25zZXByb2JsZW1zbmVnYXRpdmVwcm9ncmFtc2FuYWx5c2lzcmVsZWFzZWRiYW5uZXIiPnB1cmNoYXNlcG9saWNpZXNyZWdpb25hbGNyZWF0aXZlYXJndW1lbnRib29rbWFya3JlZmVycmVyY2hlbWljYWxkaXZpc2lvbmNhbGxiYWNrc2VwYXJhdGVwcm9qZWN0c2NvbmZsaWN0aGFyZHdhcmVpbnRlcmVzdGRlbGl2ZXJ5bW91bnRhaW5vYnRhaW5lZD0gZmFsc2U7Zm9yKHZhciBhY2NlcHRlZGNhcGFjaXR5Y29tcHV0ZXJpZGVudGl0eWFpcmNyYWZ0ZW1wbG95ZWRwcm9wb3NlZGRvbWVzdGljaW5jbHVkZXNwcm92aWRlZGhvc3BpdGFsdmVydGljYWxjb2xsYXBzZWFwcHJvYWNocGFydG5lcnNsb2dvIj48YWRhdWdodGVyYXV0aG9yIiBjdWx0dXJhbGZhbWlsaWVzL2ltYWdlcy9hc3NlbWJseXBvd2VyZnVsdGVhY2hpbmdmaW5pc2hlZGRpc3RyaWN0Y3JpdGljYWxjZ2ktYmluL3B1cnBvc2VzcmVxdWlyZXNlbGVjdGlvbmJlY29taW5ncHJvdmlkZXNhY2FkZW1pY2V4ZXJjaXNlYWN0dWFsbHltZWRpY2luZWNvbnN0YW50YWNjaWRlbnRNYWdhemluZWRvY3VtZW50c3RhcnRpbmdib3R0b20iPm9ic2VydmVkOiAmcXVvdDtleHRlbmRlZHByZXZpb3VzU29mdHdhcmVjdXN0b21lcmRlY2lzaW9uc3RyZW5ndGhkZXRhaWxlZHNsaWdodGx5cGxhbm5pbmd0ZXh0YXJlYWN1cnJlbmN5ZXZlcnlvbmVzdHJhaWdodHRyYW5zZmVycG9zaXRpdmVwcm9kdWNlZGhlcml0YWdlc2hpcHBpbmdhYnNvbHV0ZXJlY2VpdmVkcmVsZXZhbnRidXR0b24iIHZpb2xlbmNlYW55d2hlcmViZW5lZml0c2xhdW5jaGVkcmVjZW50bHlhbGxpYW5jZWZvbGxvd2VkbXVsdGlwbGVidWxsZXRpbmluY2x1ZGVkb2NjdXJyZWRpbnRlcm5hbCQodGhpcykucmVwdWJsaWM+PHRyPjx0ZGNvbmdyZXNzcmVjb3JkZWR1bHRpbWF0ZXNvbHV0aW9uPHVsIGlkPSJkaXNjb3ZlckhvbWU8L2E+d2Vic2l0ZXNuZXR3b3Jrc2FsdGhvdWdoZW50aXJlbHltZW1vcmlhbG1lc3NhZ2VzY29udGludWVhY3RpdmUiPnNvbWV3aGF0dmljdG9yaWFXZXN0ZXJuICB0aXRsZT0iTG9jYXRpb25jb250cmFjdHZpc2l0b3JzRG93bmxvYWR3aXRob3V0IHJpZ2h0Ij4KbWVhc3VyZXN3aWR0aCA9IHZhcmlhYmxlaW52b2x2ZWR2aXJnaW5pYW5vcm1hbGx5aGFwcGVuZWRhY2NvdW50c3N0YW5kaW5nbmF0aW9uYWxSZWdpc3RlcnByZXBhcmVkY29udHJvbHNhY2N1cmF0ZWJpcnRoZGF5c3RyYXRlZ3lvZmZpY2lhbGdyYXBoaWNzY3JpbWluYWxwb3NzaWJseWNvbnN1bWVyUGVyc29uYWxzcGVha2luZ3ZhbGlkYXRlYWNoaWV2ZWQuanBnIiAvPm1hY2hpbmVzPC9oMj4KICBrZXl3b3Jkc2ZyaWVuZGx5YnJvdGhlcnNjb21iaW5lZG9yaWdpbmFsY29tcG9zZWRleHBlY3RlZGFkZXF1YXRlcGFraXN0YW5mb2xsb3ciIHZhbHVhYmxlPC9sYWJlbD5yZWxhdGl2ZWJyaW5naW5naW5jcmVhc2Vnb3Zlcm5vcnBsdWdpbnMvTGlzdCBvZiBIZWFkZXIiPiIgbmFtZT0iICgmcXVvdDtncmFkdWF0ZTwvaGVhZD4KY29tbWVyY2VtYWxheXNpYWRpcmVjdG9ybWFpbnRhaW47aGVpZ2h0OnNjaGVkdWxlY2hhbmdpbmdiYWNrIHRvIGNhdGhvbGljcGF0dGVybnNjb2xvcjogI2dyZWF0ZXN0c3VwcGxpZXNyZWxpYWJsZTwvdWw+CgkJPHNlbGVjdCBjaXRpemVuc2Nsb3RoaW5nd2F0Y2hpbmc8bGkgaWQ9InNwZWNpZmljY2FycnlpbmdzZW50ZW5jZTxjZW50ZXI+Y29udHJhc3R0aGlua2luZ2NhdGNoKGUpc291dGhlcm5NaWNoYWVsIG1lcmNoYW50Y2Fyb3VzZWxwYWRkaW5nOmludGVyaW9yLnNwbGl0KCJsaXphdGlvbk9jdG9iZXIgKXtyZXR1cm5pbXByb3ZlZC0tJmd0OwoKY292ZXJhZ2VjaGFpcm1hbi5wbmciIC8+c3ViamVjdHNSaWNoYXJkIHdoYXRldmVycHJvYmFibHlyZWNvdmVyeWJhc2ViYWxsanVkZ21lbnRjb25uZWN0Li5jc3MiIC8+IHdlYnNpdGVyZXBvcnRlZGRlZmF1bHQiLz48L2E+DQplbGVjdHJpY3Njb3RsYW5kY3JlYXRpb25xdWFudGl0eS4gSVNCTiAwZGlkIG5vdCBpbnN0YW5jZS1zZWFyY2gtIiBsYW5nPSJzcGVha2Vyc0NvbXB1dGVyY29udGFpbnNhcmNoaXZlc21pbmlzdGVycmVhY3Rpb25kaXNjb3VudEl0YWxpYW5vY3JpdGVyaWFzdHJvbmdseTogJ2h0dHA6J3NjcmlwdCdjb3ZlcmluZ29mZmVyaW5nYXBwZWFyZWRCcml0aXNoIGlkZW50aWZ5RmFjZWJvb2tudW1lcm91c3ZlaGljbGVzY29uY2VybnNBbWVyaWNhbmhhbmRsaW5nZGl2IGlkPSJXaWxsaWFtIHByb3ZpZGVyX2NvbnRlbnRhY2N1cmFjeXNlY3Rpb24gYW5kZXJzb25mbGV4aWJsZUNhdGVnb3J5bGF3cmVuY2U8c2NyaXB0PmxheW91dD0iYXBwcm92ZWQgbWF4aW11bWhlYWRlciI+PC90YWJsZT5TZXJ2aWNlc2hhbWlsdG9uY3VycmVudCBjYW5hZGlhbmNoYW5uZWxzL3RoZW1lcy8vYXJ0aWNsZW9wdGlvbmFscG9ydHVnYWx2YWx1ZT0iImludGVydmFsd2lyZWxlc3NlbnRpdGxlZGFnZW5jaWVzU2VhcmNoIiBtZWFzdXJlZHRob3VzYW5kc3BlbmRpbmcmaGVsbGlwO25ldyBEYXRlIiBzaXplPSJwYWdlTmFtZW1pZGRsZSIgIiAvPjwvYT5oaWRkZW4iPnNlcXVlbmNlcGVyc29uYWxvdmVyZmxvd29waW5pb25zaWxsaW5vaXNsaW5rcyI+Cgk8dGl0bGU+dmVyc2lvbnNzYXR1cmRheXRlcm1pbmFsaXRlbXByb3BlbmdpbmVlcnNlY3Rpb25zZGVzaWduZXJwcm9wb3NhbD0iZmFsc2UiRXNwYcOxb2xyZWxlYXNlc3N1Ym1pdCIgZXImcXVvdDthZGRpdGlvbnN5bXB0b21zb3JpZW50ZWRyZXNvdXJjZXJpZ2h0Ij48cGxlYXN1cmVzdGF0aW9uc2hpc3RvcnkubGVhdmluZyAgYm9yZGVyPWNvbnRlbnRzY2VudGVyIj4uCgpTb21lIGRpcmVjdGVkc3VpdGFibGVidWxnYXJpYS5zaG93KCk7ZGVzaWduZWRHZW5lcmFsIGNvbmNlcHRzRXhhbXBsZXN3aWxsaWFtc09yaWdpbmFsIj48c3Bhbj5zZWFyY2giPm9wZXJhdG9ycmVxdWVzdHNhICZxdW90O2FsbG93aW5nRG9jdW1lbnRyZXZpc2lvbi4gCgpUaGUgeW91cnNlbGZDb250YWN0IG1pY2hpZ2FuRW5nbGlzaCBjb2x1bWJpYXByaW9yaXR5cHJpbnRpbmdkcmlua2luZ2ZhY2lsaXR5cmV0dXJuZWRDb250ZW50IG9mZmljZXJzUnVzc2lhbiBnZW5lcmF0ZS04ODU5LTEiaW5kaWNhdGVmYW1pbGlhciBxdWFsaXR5bWFyZ2luOjAgY29udGVudHZpZXdwb3J0Y29udGFjdHMtdGl0bGUiPnBvcnRhYmxlLmxlbmd0aCBlbGlnaWJsZWludm9sdmVzYXRsYW50aWNvbmxvYWQ9ImRlZmF1bHQuc3VwcGxpZWRwYXltZW50c2dsb3NzYXJ5CgpBZnRlciBndWlkYW5jZTwvdGQ+PHRkZW5jb2RpbmdtaWRkbGUiPmNhbWUgdG8gZGlzcGxheXNzY290dGlzaGpvbmF0aGFubWFqb3JpdHl3aWRnZXRzLmNsaW5pY2FsdGhhaWxhbmR0ZWFjaGVyczxoZWFkPgoJYWZmZWN0ZWRzdXBwb3J0c3BvaW50ZXI7dG9TdHJpbmc8L3NtYWxsPm9rbGFob21hd2lsbCBiZSBpbnZlc3RvcjAiIGFsdD0iaG9saWRheXNSZXNvdXJjZWxpY2Vuc2VkICh3aGljaCAuIEFmdGVyIGNvbnNpZGVydmlzaXRpbmdleHBsb3JlcnByaW1hcnkgc2VhcmNoIiBhbmRyb2lkInF1aWNrbHkgbWVldGluZ3Nlc3RpbWF0ZTtyZXR1cm4gO2NvbG9yOiMgaGVpZ2h0PWFwcHJvdmFsLCAmcXVvdDsgY2hlY2tlZC5taW4uanMibWFnbmV0aWM+PC9hPjwvaGZvcmVjYXN0LiBXaGlsZSB0aHVyc2RheWR2ZXJ0aXNlJmVhY3V0ZTtoYXNDbGFzc2V2YWx1YXRlb3JkZXJpbmdleGlzdGluZ3BhdGllbnRzIE9ubGluZSBjb2xvcmFkb09wdGlvbnMiY2FtcGJlbGw8IS0tIGVuZDwvc3Bhbj48PGJyIC8+DQpfcG9wdXBzfHNjaWVuY2VzLCZxdW90OyBxdWFsaXR5IFdpbmRvd3MgYXNzaWduZWRoZWlnaHQ6IDxiIGNsYXNzbGUmcXVvdDsgdmFsdWU9IiBDb21wYW55ZXhhbXBsZXM8aWZyYW1lIGJlbGlldmVzcHJlc2VudHNtYXJzaGFsbHBhcnQgb2YgcHJvcGVybHkpLgoKVGhlIHRheG9ub215bXVjaCBvZiA8L3NwYW4+CiIgZGF0YS1zcnR1Z3XDqnNzY3JvbGxUbyBwcm9qZWN0PGhlYWQ+DQphdHRvcm5leWVtcGhhc2lzc3BvbnNvcnNmYW5jeWJveHdvcmxkJ3Mgd2lsZGxpZmVjaGVja2VkPXNlc3Npb25zcHJvZ3JhbW1weDtmb250LSBQcm9qZWN0am91cm5hbHNiZWxpZXZlZHZhY2F0aW9udGhvbXBzb25saWdodGluZ2FuZCB0aGUgc3BlY2lhbCBib3JkZXI9MGNoZWNraW5nPC90Ym9keT48YnV0dG9uIENvbXBsZXRlY2xlYXJmaXgKPGhlYWQ+CmFydGljbGUgPHNlY3Rpb25maW5kaW5nc3JvbGUgaW4gcG9wdWxhciAgT2N0b2JlcndlYnNpdGUgZXhwb3N1cmV1c2VkIHRvICBjaGFuZ2Vzb3BlcmF0ZWRjbGlja2luZ2VudGVyaW5nY29tbWFuZHNpbmZvcm1lZCBudW1iZXJzICA8L2Rpdj5jcmVhdGluZ29uU3VibWl0bWFyeWxhbmRjb2xsZWdlc2FuYWx5dGljbGlzdGluZ3Njb250YWN0LmxvZ2dlZEluYWR2aXNvcnlzaWJsaW5nc2NvbnRlbnQicyZxdW90OylzLiBUaGlzIHBhY2thZ2VzY2hlY2tib3hzdWdnZXN0c3ByZWduYW50dG9tb3Jyb3dzcGFjaW5nPWljb24ucG5namFwYW5lc2Vjb2RlYmFzZWJ1dHRvbiI+Z2FtYmxpbmdzdWNoIGFzICwgd2hpbGUgPC9zcGFuPiBtaXNzb3VyaXNwb3J0aW5ndG9wOjFweCAuPC9zcGFuPnRlbnNpb25zd2lkdGg9IjJsYXp5bG9hZG5vdmVtYmVydXNlZCBpbiBoZWlnaHQ9ImNyaXB0Ij4KJm5ic3A7PC88dHI+PHRkIGhlaWdodDoyL3Byb2R1Y3Rjb3VudHJ5IGluY2x1ZGUgZm9vdGVyIiAmbHQ7IS0tIHRpdGxlIj48L2pxdWVyeS48L2Zvcm0+CijnroDkvZMpKOe5gemrlClocnZhdHNraWl0YWxpYW5vcm9tw6JuxIN0w7xya8OnZdin2LHYr9mIdGFtYmnDqW5ub3RpY2lhc21lbnNhamVzcGVyc29uYXNkZXJlY2hvc25hY2lvbmFsc2VydmljaW9jb250YWN0b3VzdWFyaW9zcHJvZ3JhbWFnb2JpZXJub2VtcHJlc2FzYW51bmNpb3N2YWxlbmNpYWNvbG9tYmlhZGVzcHXDqXNkZXBvcnRlc3Byb3llY3RvcHJvZHVjdG9ww7pibGljb25vc290cm9zaGlzdG9yaWFwcmVzZW50ZW1pbGxvbmVzbWVkaWFudGVwcmVndW50YWFudGVyaW9ycmVjdXJzb3Nwcm9ibGVtYXNhbnRpYWdvbnVlc3Ryb3NvcGluacOzbmltcHJpbWlybWllbnRyYXNhbcOpcmljYXZlbmRlZG9yc29jaWVkYWRyZXNwZWN0b3JlYWxpemFycmVnaXN0cm9wYWxhYnJhc2ludGVyw6lzZW50b25jZXNlc3BlY2lhbG1pZW1icm9zcmVhbGlkYWRjw7NyZG9iYXphcmFnb3phcMOhZ2luYXNzb2NpYWxlc2Jsb3F1ZWFyZ2VzdGnDs25hbHF1aWxlcnNpc3RlbWFzY2llbmNpYXNjb21wbGV0b3ZlcnNpw7NuY29tcGxldGFlc3R1ZGlvc3DDumJsaWNhb2JqZXRpdm9hbGljYW50ZWJ1c2NhZG9yY2FudGlkYWRlbnRyYWRhc2FjY2lvbmVzYXJjaGl2b3NzdXBlcmlvcm1heW9yw61hYWxlbWFuaWFmdW5jacOzbsO6bHRpbW9zaGFjaWVuZG9hcXVlbGxvc2VkaWNpw7NuZmVybmFuZG9hbWJpZW50ZWZhY2Vib29rbnVlc3RyYXNjbGllbnRlc3Byb2Nlc29zYmFzdGFudGVwcmVzZW50YXJlcG9ydGFyY29uZ3Jlc29wdWJsaWNhcmNvbWVyY2lvY29udHJhdG9qw7N2ZW5lc2Rpc3RyaXRvdMOpY25pY2Fjb25qdW50b2VuZXJnw61hdHJhYmFqYXJhc3R1cmlhc3JlY2llbnRldXRpbGl6YXJib2xldMOtbnNhbHZhZG9yY29ycmVjdGF0cmFiYWpvc3ByaW1lcm9zbmVnb2Npb3NsaWJlcnRhZGRldGFsbGVzcGFudGFsbGFwcsOzeGltb2FsbWVyw61hYW5pbWFsZXNxdWnDqW5lc2NvcmF6w7Nuc2VjY2nDs25idXNjYW5kb29wY2lvbmVzZXh0ZXJpb3Jjb25jZXB0b3RvZGF2w61hZ2FsZXLDrWFlc2NyaWJpcm1lZGljaW5hbGljZW5jaWFjb25zdWx0YWFzcGVjdG9zY3LDrXRpY2Fkw7NsYXJlc2p1c3RpY2lhZGViZXLDoW5wZXLDrW9kb25lY2VzaXRhbWFudGVuZXJwZXF1ZcOxb3JlY2liaWRhdHJpYnVuYWx0ZW5lcmlmZWNhbmNpw7NuY2FuYXJpYXNkZXNjYXJnYWRpdmVyc29zbWFsbG9yY2FyZXF1aWVyZXTDqWNuaWNvZGViZXLDrWF2aXZpZW5kYWZpbmFuemFzYWRlbGFudGVmdW5jaW9uYWNvbnNlam9zZGlmw61jaWxjaXVkYWRlc2FudGlndWFzYXZhbnphZGF0w6lybWlub3VuaWRhZGVzc8OhbmNoZXpjYW1wYcOxYXNvZnRvbmljcmV2aXN0YXNjb250aWVuZXNlY3RvcmVzbW9tZW50b3NmYWN1bHRhZGNyw6lkaXRvZGl2ZXJzYXNzdXB1ZXN0b2ZhY3RvcmVzc2VndW5kb3NwZXF1ZcOxYdCz0L7QtNCw0LXRgdC70LjQtdGB0YLRjNCx0YvQu9C+0LHRi9GC0YzRjdGC0L7QvNCV0YHQu9C40YLQvtCz0L7QvNC10L3Rj9Cy0YHQtdGF0Y3RgtC+0LnQtNCw0LbQtdCx0YvQu9C40LPQvtC00YPQtNC10L3RjNGN0YLQvtGC0LHRi9C70LDRgdC10LHRj9C+0LTQuNC90YHQtdCx0LXQvdCw0LTQvtGB0LDQudGC0YTQvtGC0L7QvdC10LPQvtGB0LLQvtC40YHQstC+0LnQuNCz0YDRi9GC0L7QttC10LLRgdC10LzRgdCy0L7RjtC70LjRiNGM0Y3RgtC40YXQv9C+0LrQsNC00L3QtdC50LTQvtC80LDQvNC40YDQsNC70LjQsdC+0YLQtdC80YPRhdC+0YLRj9C00LLRg9GF0YHQtdGC0LjQu9GO0LTQuNC00LXQu9C+0LzQuNGA0LXRgtC10LHRj9GB0LLQvtC10LLQuNC00LXRh9C10LPQvtGN0YLQuNC80YHRh9C10YLRgtC10LzRi9GG0LXQvdGL0YHRgtCw0LvQstC10LTRjNGC0LXQvNC10LLQvtC00YvRgtC10LHQtdCy0YvRiNC10L3QsNC80LjRgtC40L/QsNGC0L7QvNGD0L/RgNCw0LLQu9C40YbQsNC+0LTQvdCw0LPQvtC00YvQt9C90LDRjtC80L7Qs9GD0LTRgNGD0LPQstGB0LXQudC40LTQtdGC0LrQuNC90L7QvtC00L3QvtC00LXQu9Cw0LTQtdC70LXRgdGA0L7QutC40Y7QvdGP0LLQtdGB0YzQldGB0YLRjNGA0LDQt9Cw0L3QsNGI0LjYp9mE2YTZh9in2YTYqtmK2KzZhdmK2LnYrtin2LXYqdin2YTYsNmK2LnZhNmK2YfYrNiv2YrYr9in2YTYotmG2KfZhNix2K/Yqtit2YPZhdi12YHYrdip2YPYp9mG2KrYp9mE2YTZitmK2YPZiNmG2LTYqNmD2KnZgdmK2YfYp9io2YbYp9iq2K3ZiNin2KHYo9mD2KvYsdiu2YTYp9mE2KfZhNit2KjYr9mE2YrZhNiv2LHZiNiz2KfYtti62LfYqtmD2YjZhtmH2YbYp9mD2LPYp9it2KnZhtin2K/Zitin2YTYt9io2LnZhNmK2YPYtNmD2LHYp9mK2YXZg9mG2YXZhtmH2KfYtNix2YPYqdix2KbZitiz2YbYtNmK2LfZhdin2LDYp9in2YTZgdmG2LTYqNin2KjYqti52KjYsdix2K3Zhdip2YPYp9mB2KnZitmC2YjZhNmF2LHZg9iy2YPZhNmF2KnYo9it2YXYr9mC2YTYqNmK2YrYudmG2YrYtdmI2LHYqdi32LHZitmC2LTYp9ix2YPYrNmI2KfZhNij2K7YsdmJ2YXYudmG2KfYp9io2K3Yq9i52LHZiNi22KjYtNmD2YTZhdiz2KzZhNio2YbYp9mG2K7Yp9mE2K/Zg9iq2KfYqNmD2YTZitip2KjYr9mI2YbYo9mK2LbYp9mK2YjYrNiv2YHYsdmK2YLZg9iq2KjYqtij2YHYttmE2YXYt9io2K7Yp9mD2KvYsdio2KfYsdmD2KfZgdi22YTYp9it2YTZidmG2YHYs9mH2KPZitin2YXYsdiv2YjYr9ij2YbZh9in2K/ZitmG2KfYp9mE2KfZhtmF2LnYsdi22KrYudmE2YXYr9in2K7ZhNmF2YXZg9mGAEGIkgMLXAEAAQABAAEAAgACAAIAAgAEAAQABAAEAAABAgMEBQYHBwYFBAMCAQAICQoLDA0ODw8ODQwLCgkIEBESExQVFhcXFhUUExIREBgZGhscHR4fHx4dHBsaGRj/////AEHskgMLvOkE/////wEAAAACAAAAAgAAAAEAAAABAAAAAwAAAP//AAEAAAABAAD//wABAAAACAAIAAgACAAAAAEAAgADAAQABQAGAAdyZXNvdXJjZXNjb3VudHJpZXNxdWVzdGlvbnNlcXVpcG1lbnRjb21tdW5pdHlhdmFpbGFibGVoaWdobGlnaHREVEQveGh0bWxtYXJrZXRpbmdrbm93bGVkZ2Vzb21ldGhpbmdjb250YWluZXJkaXJlY3Rpb25zdWJzY3JpYmVhZHZlcnRpc2VjaGFyYWN0ZXIiIHZhbHVlPSI8L3NlbGVjdD5BdXN0cmFsaWEiIGNsYXNzPSJzaXR1YXRpb25hdXRob3JpdHlmb2xsb3dpbmdwcmltYXJpbHlvcGVyYXRpb25jaGFsbGVuZ2VkZXZlbG9wZWRhbm9ueW1vdXNmdW5jdGlvbiBmdW5jdGlvbnNjb21wYW5pZXNzdHJ1Y3R1cmVhZ3JlZW1lbnQiIHRpdGxlPSJwb3RlbnRpYWxlZHVjYXRpb25hcmd1bWVudHNzZWNvbmRhcnljb3B5cmlnaHRsYW5ndWFnZXNleGNsdXNpdmVjb25kaXRpb248L2Zvcm0+DQpzdGF0ZW1lbnRhdHRlbnRpb25CaW9ncmFwaHl9IGVsc2Ugewpzb2x1dGlvbnN3aGVuIHRoZSBBbmFseXRpY3N0ZW1wbGF0ZXNkYW5nZXJvdXNzYXRlbGxpdGVkb2N1bWVudHNwdWJsaXNoZXJpbXBvcnRhbnRwcm90b3R5cGVpbmZsdWVuY2UmcmFxdW87PC9lZmZlY3RpdmVnZW5lcmFsbHl0cmFuc2Zvcm1iZWF1dGlmdWx0cmFuc3BvcnRvcmdhbml6ZWRwdWJsaXNoZWRwcm9taW5lbnR1bnRpbCB0aGV0aHVtYm5haWxOYXRpb25hbCAuZm9jdXMoKTtvdmVyIHRoZSBtaWdyYXRpb25hbm5vdW5jZWRmb290ZXIiPgpleGNlcHRpb25sZXNzIHRoYW5leHBlbnNpdmVmb3JtYXRpb25mcmFtZXdvcmt0ZXJyaXRvcnluZGljYXRpb25jdXJyZW50bHljbGFzc05hbWVjcml0aWNpc210cmFkaXRpb25lbHNld2hlcmVBbGV4YW5kZXJhcHBvaW50ZWRtYXRlcmlhbHNicm9hZGNhc3RtZW50aW9uZWRhZmZpbGlhdGU8L29wdGlvbj50cmVhdG1lbnRkaWZmZXJlbnQvZGVmYXVsdC5QcmVzaWRlbnRvbmNsaWNrPSJiaW9ncmFwaHlvdGhlcndpc2VwZXJtYW5lbnRGcmFuw6dhaXNIb2xseXdvb2RleHBhbnNpb25zdGFuZGFyZHM8L3N0eWxlPgpyZWR1Y3Rpb25EZWNlbWJlciBwcmVmZXJyZWRDYW1icmlkZ2VvcHBvbmVudHNCdXNpbmVzcyBjb25mdXNpb24+Cjx0aXRsZT5wcmVzZW50ZWRleHBsYWluZWRkb2VzIG5vdCB3b3JsZHdpZGVpbnRlcmZhY2Vwb3NpdGlvbnNuZXdzcGFwZXI8L3RhYmxlPgptb3VudGFpbnNsaWtlIHRoZSBlc3NlbnRpYWxmaW5hbmNpYWxzZWxlY3Rpb25hY3Rpb249Ii9hYmFuZG9uZWRFZHVjYXRpb25wYXJzZUludChzdGFiaWxpdHl1bmFibGUgdG88L3RpdGxlPgpyZWxhdGlvbnNOb3RlIHRoYXRlZmZpY2llbnRwZXJmb3JtZWR0d28geWVhcnNTaW5jZSB0aGV0aGVyZWZvcmV3cmFwcGVyIj5hbHRlcm5hdGVpbmNyZWFzZWRCYXR0bGUgb2ZwZXJjZWl2ZWR0cnlpbmcgdG9uZWNlc3Nhcnlwb3J0cmF5ZWRlbGVjdGlvbnNFbGl6YWJldGg8L2lmcmFtZT5kaXNjb3ZlcnlpbnN1cmFuY2VzLmxlbmd0aDtsZWdlbmRhcnlHZW9ncmFwaHljYW5kaWRhdGVjb3Jwb3JhdGVzb21ldGltZXNzZXJ2aWNlcy5pbmhlcml0ZWQ8L3N0cm9uZz5Db21tdW5pdHlyZWxpZ2lvdXNsb2NhdGlvbnNDb21taXR0ZWVidWlsZGluZ3N0aGUgd29ybGRubyBsb25nZXJiZWdpbm5pbmdyZWZlcmVuY2VjYW5ub3QgYmVmcmVxdWVuY3l0eXBpY2FsbHlpbnRvIHRoZSByZWxhdGl2ZTtyZWNvcmRpbmdwcmVzaWRlbnRpbml0aWFsbHl0ZWNobmlxdWV0aGUgb3RoZXJpdCBjYW4gYmVleGlzdGVuY2V1bmRlcmxpbmV0aGlzIHRpbWV0ZWxlcGhvbmVpdGVtc2NvcGVwcmFjdGljZXNhZHZhbnRhZ2UpO3JldHVybiBGb3Igb3RoZXJwcm92aWRpbmdkZW1vY3JhY3lib3RoIHRoZSBleHRlbnNpdmVzdWZmZXJpbmdzdXBwb3J0ZWRjb21wdXRlcnMgZnVuY3Rpb25wcmFjdGljYWxzYWlkIHRoYXRpdCBtYXkgYmVFbmdsaXNoPC9mcm9tIHRoZSBzY2hlZHVsZWRkb3dubG9hZHM8L2xhYmVsPgpzdXNwZWN0ZWRtYXJnaW46IDBzcGlyaXR1YWw8L2hlYWQ+CgptaWNyb3NvZnRncmFkdWFsbHlkaXNjdXNzZWRoZSBiZWNhbWVleGVjdXRpdmVqcXVlcnkuanNob3VzZWhvbGRjb25maXJtZWRwdXJjaGFzZWRsaXRlcmFsbHlkZXN0cm95ZWR1cCB0byB0aGV2YXJpYXRpb25yZW1haW5pbmdpdCBpcyBub3RjZW50dXJpZXNKYXBhbmVzZSBhbW9uZyB0aGVjb21wbGV0ZWRhbGdvcml0aG1pbnRlcmVzdHNyZWJlbGxpb251bmRlZmluZWRlbmNvdXJhZ2VyZXNpemFibGVpbnZvbHZpbmdzZW5zaXRpdmV1bml2ZXJzYWxwcm92aXNpb24oYWx0aG91Z2hmZWF0dXJpbmdjb25kdWN0ZWQpLCB3aGljaCBjb250aW51ZWQtaGVhZGVyIj5GZWJydWFyeSBudW1lcm91cyBvdmVyZmxvdzpjb21wb25lbnRmcmFnbWVudHNleGNlbGxlbnRjb2xzcGFuPSJ0ZWNobmljYWxuZWFyIHRoZSBBZHZhbmNlZCBzb3VyY2Ugb2ZleHByZXNzZWRIb25nIEtvbmcgRmFjZWJvb2ttdWx0aXBsZSBtZWNoYW5pc21lbGV2YXRpb25vZmZlbnNpdmU8L2Zvcm0+CglzcG9uc29yZWRkb2N1bWVudC5vciAmcXVvdDt0aGVyZSBhcmV0aG9zZSB3aG9tb3ZlbWVudHNwcm9jZXNzZXNkaWZmaWN1bHRzdWJtaXR0ZWRyZWNvbW1lbmRjb252aW5jZWRwcm9tb3RpbmciIHdpZHRoPSIucmVwbGFjZShjbGFzc2ljYWxjb2FsaXRpb25oaXMgZmlyc3RkZWNpc2lvbnNhc3Npc3RhbnRpbmRpY2F0ZWRldm9sdXRpb24td3JhcHBlciJlbm91Z2ggdG9hbG9uZyB0aGVkZWxpdmVyZWQtLT4NCjwhLS1BbWVyaWNhbiBwcm90ZWN0ZWROb3ZlbWJlciA8L3N0eWxlPjxmdXJuaXR1cmVJbnRlcm5ldCAgb25ibHVyPSJzdXNwZW5kZWRyZWNpcGllbnRiYXNlZCBvbiBNb3Jlb3ZlcixhYm9saXNoZWRjb2xsZWN0ZWR3ZXJlIG1hZGVlbW90aW9uYWxlbWVyZ2VuY3luYXJyYXRpdmVhZHZvY2F0ZXNweDtib3JkZXJjb21taXR0ZWRkaXI9Imx0ciJlbXBsb3llZXNyZXNlYXJjaC4gc2VsZWN0ZWRzdWNjZXNzb3JjdXN0b21lcnNkaXNwbGF5ZWRTZXB0ZW1iZXJhZGRDbGFzcyhGYWNlYm9vayBzdWdnZXN0ZWRhbmQgbGF0ZXJvcGVyYXRpbmdlbGFib3JhdGVTb21ldGltZXNJbnN0aXR1dGVjZXJ0YWlubHlpbnN0YWxsZWRmb2xsb3dlcnNKZXJ1c2FsZW10aGV5IGhhdmVjb21wdXRpbmdnZW5lcmF0ZWRwcm92aW5jZXNndWFyYW50ZWVhcmJpdHJhcnlyZWNvZ25pemV3YW50ZWQgdG9weDt3aWR0aDp0aGVvcnkgb2ZiZWhhdmlvdXJXaGlsZSB0aGVlc3RpbWF0ZWRiZWdhbiB0byBpdCBiZWNhbWVtYWduaXR1ZGVtdXN0IGhhdmVtb3JlIHRoYW5EaXJlY3RvcnlleHRlbnNpb25zZWNyZXRhcnluYXR1cmFsbHlvY2N1cnJpbmd2YXJpYWJsZXNnaXZlbiB0aGVwbGF0Zm9ybS48L2xhYmVsPjxmYWlsZWQgdG9jb21wb3VuZHNraW5kcyBvZiBzb2NpZXRpZXNhbG9uZ3NpZGUgLS0mZ3Q7Cgpzb3V0aHdlc3R0aGUgcmlnaHRyYWRpYXRpb25tYXkgaGF2ZSB1bmVzY2FwZShzcG9rZW4gaW4iIGhyZWY9Ii9wcm9ncmFtbWVvbmx5IHRoZSBjb21lIGZyb21kaXJlY3RvcnlidXJpZWQgaW5hIHNpbWlsYXJ0aGV5IHdlcmU8L2ZvbnQ+PC9Ob3J3ZWdpYW5zcGVjaWZpZWRwcm9kdWNpbmdwYXNzZW5nZXIobmV3IERhdGV0ZW1wb3JhcnlmaWN0aW9uYWxBZnRlciB0aGVlcXVhdGlvbnNkb3dubG9hZC5yZWd1bGFybHlkZXZlbG9wZXJhYm92ZSB0aGVsaW5rZWQgdG9waGVub21lbmFwZXJpb2Qgb2Z0b29sdGlwIj5zdWJzdGFuY2VhdXRvbWF0aWNhc3BlY3Qgb2ZBbW9uZyB0aGVjb25uZWN0ZWRlc3RpbWF0ZXNBaXIgRm9yY2VzeXN0ZW0gb2ZvYmplY3RpdmVpbW1lZGlhdGVtYWtpbmcgaXRwYWludGluZ3Njb25xdWVyZWRhcmUgc3RpbGxwcm9jZWR1cmVncm93dGggb2ZoZWFkZWQgYnlFdXJvcGVhbiBkaXZpc2lvbnNtb2xlY3VsZXNmcmFuY2hpc2VpbnRlbnRpb25hdHRyYWN0ZWRjaGlsZGhvb2RhbHNvIHVzZWRkZWRpY2F0ZWRzaW5nYXBvcmVkZWdyZWUgb2ZmYXRoZXIgb2Zjb25mbGljdHM8L2E+PC9wPgpjYW1lIGZyb213ZXJlIHVzZWRub3RlIHRoYXRyZWNlaXZpbmdFeGVjdXRpdmVldmVuIG1vcmVhY2Nlc3MgdG9jb21tYW5kZXJQb2xpdGljYWxtdXNpY2lhbnNkZWxpY2lvdXNwcmlzb25lcnNhZHZlbnQgb2ZVVEYtOCIgLz48IVtDREFUQVsiPkNvbnRhY3RTb3V0aGVybiBiZ2NvbG9yPSJzZXJpZXMgb2YuIEl0IHdhcyBpbiBFdXJvcGVwZXJtaXR0ZWR2YWxpZGF0ZS5hcHBlYXJpbmdvZmZpY2lhbHNzZXJpb3VzbHktbGFuZ3VhZ2Vpbml0aWF0ZWRleHRlbmRpbmdsb25nLXRlcm1pbmZsYXRpb25zdWNoIHRoYXRnZXRDb29raWVtYXJrZWQgYnk8L2J1dHRvbj5pbXBsZW1lbnRidXQgaXQgaXNpbmNyZWFzZXNkb3duIHRoZSByZXF1aXJpbmdkZXBlbmRlbnQtLT4KPCEtLSBpbnRlcnZpZXdXaXRoIHRoZSBjb3BpZXMgb2Zjb25zZW5zdXN3YXMgYnVpbHRWZW5lenVlbGEoZm9ybWVybHl0aGUgc3RhdGVwZXJzb25uZWxzdHJhdGVnaWNmYXZvdXIgb2ZpbnZlbnRpb25XaWtpcGVkaWFjb250aW5lbnR2aXJ0dWFsbHl3aGljaCB3YXNwcmluY2lwbGVDb21wbGV0ZSBpZGVudGljYWxzaG93IHRoYXRwcmltaXRpdmVhd2F5IGZyb21tb2xlY3VsYXJwcmVjaXNlbHlkaXNzb2x2ZWRVbmRlciB0aGV2ZXJzaW9uPSI+Jm5ic3A7PC9JdCBpcyB0aGUgVGhpcyBpcyB3aWxsIGhhdmVvcmdhbmlzbXNzb21lIHRpbWVGcmllZHJpY2h3YXMgZmlyc3R0aGUgb25seSBmYWN0IHRoYXRmb3JtIGlkPSJwcmVjZWRpbmdUZWNobmljYWxwaHlzaWNpc3RvY2N1cnMgaW5uYXZpZ2F0b3JzZWN0aW9uIj5zcGFuIGlkPSJzb3VnaHQgdG9iZWxvdyB0aGVzdXJ2aXZpbmd9PC9zdHlsZT5oaXMgZGVhdGhhcyBpbiB0aGVjYXVzZWQgYnlwYXJ0aWFsbHlleGlzdGluZyB1c2luZyB0aGV3YXMgZ2l2ZW5hIGxpc3Qgb2ZsZXZlbHMgb2Zub3Rpb24gb2ZPZmZpY2lhbCBkaXNtaXNzZWRzY2llbnRpc3RyZXNlbWJsZXNkdXBsaWNhdGVleHBsb3NpdmVyZWNvdmVyZWRhbGwgb3RoZXJnYWxsZXJpZXN7cGFkZGluZzpwZW9wbGUgb2ZyZWdpb24gb2ZhZGRyZXNzZXNhc3NvY2lhdGVpbWcgYWx0PSJpbiBtb2Rlcm5zaG91bGQgYmVtZXRob2Qgb2ZyZXBvcnRpbmd0aW1lc3RhbXBuZWVkZWQgdG90aGUgR3JlYXRyZWdhcmRpbmdzZWVtZWQgdG92aWV3ZWQgYXNpbXBhY3Qgb25pZGVhIHRoYXR0aGUgV29ybGRoZWlnaHQgb2ZleHBhbmRpbmdUaGVzZSBhcmVjdXJyZW50Ij5jYXJlZnVsbHltYWludGFpbnNjaGFyZ2Ugb2ZDbGFzc2ljYWxhZGRyZXNzZWRwcmVkaWN0ZWRvd25lcnNoaXA8ZGl2IGlkPSJyaWdodCI+DQpyZXNpZGVuY2VsZWF2ZSB0aGVjb250ZW50Ij5hcmUgb2Z0ZW4gIH0pKCk7DQpwcm9iYWJseSBQcm9mZXNzb3ItYnV0dG9uIiByZXNwb25kZWRzYXlzIHRoYXRoYWQgdG8gYmVwbGFjZWQgaW5IdW5nYXJpYW5zdGF0dXMgb2ZzZXJ2ZXMgYXNVbml2ZXJzYWxleGVjdXRpb25hZ2dyZWdhdGVmb3Igd2hpY2hpbmZlY3Rpb25hZ3JlZWQgdG9ob3dldmVyLCBwb3B1bGFyIj5wbGFjZWQgb25jb25zdHJ1Y3RlbGVjdG9yYWxzeW1ib2wgb2ZpbmNsdWRpbmdyZXR1cm4gdG9hcmNoaXRlY3RDaHJpc3RpYW5wcmV2aW91cyBsaXZpbmcgaW5lYXNpZXIgdG9wcm9mZXNzb3IKJmx0OyEtLSBlZmZlY3Qgb2ZhbmFseXRpY3N3YXMgdGFrZW53aGVyZSB0aGV0b29rIG92ZXJiZWxpZWYgaW5BZnJpa2FhbnNhcyBmYXIgYXNwcmV2ZW50ZWR3b3JrIHdpdGhhIHNwZWNpYWw8ZmllbGRzZXRDaHJpc3RtYXNSZXRyaWV2ZWQKCkluIHRoZSBiYWNrIGludG9ub3J0aGVhc3RtYWdhemluZXM+PHN0cm9uZz5jb21taXR0ZWVnb3Zlcm5pbmdncm91cHMgb2ZzdG9yZWQgaW5lc3RhYmxpc2hhIGdlbmVyYWxpdHMgZmlyc3R0aGVpciBvd25wb3B1bGF0ZWRhbiBvYmplY3RDYXJpYmJlYW5hbGxvdyB0aGVkaXN0cmljdHN3aXNjb25zaW5sb2NhdGlvbi47IHdpZHRoOiBpbmhhYml0ZWRTb2NpYWxpc3RKYW51YXJ5IDE8L2Zvb3Rlcj5zaW1pbGFybHljaG9pY2Ugb2Z0aGUgc2FtZSBzcGVjaWZpYyBidXNpbmVzcyBUaGUgZmlyc3QubGVuZ3RoOyBkZXNpcmUgdG9kZWFsIHdpdGhzaW5jZSB0aGV1c2VyQWdlbnRjb25jZWl2ZWRpbmRleC5waHBhcyAmcXVvdDtlbmdhZ2UgaW5yZWNlbnRseSxmZXcgeWVhcnN3ZXJlIGFsc28KPGhlYWQ+CjxlZGl0ZWQgYnlhcmUga25vd25jaXRpZXMgaW5hY2Nlc3NrZXljb25kZW1uZWRhbHNvIGhhdmVzZXJ2aWNlcyxmYW1pbHkgb2ZTY2hvb2wgb2Zjb252ZXJ0ZWRuYXR1cmUgb2YgbGFuZ3VhZ2VtaW5pc3RlcnM8L29iamVjdD50aGVyZSBpcyBhIHBvcHVsYXJzZXF1ZW5jZXNhZHZvY2F0ZWRUaGV5IHdlcmVhbnkgb3RoZXJsb2NhdGlvbj1lbnRlciB0aGVtdWNoIG1vcmVyZWZsZWN0ZWR3YXMgbmFtZWRvcmlnaW5hbCBhIHR5cGljYWx3aGVuIHRoZXllbmdpbmVlcnNjb3VsZCBub3RyZXNpZGVudHN3ZWRuZXNkYXl0aGUgdGhpcmQgcHJvZHVjdHNKYW51YXJ5IDJ3aGF0IHRoZXlhIGNlcnRhaW5yZWFjdGlvbnNwcm9jZXNzb3JhZnRlciBoaXN0aGUgbGFzdCBjb250YWluZWQiPjwvZGl2Pgo8L2E+PC90ZD5kZXBlbmQgb25zZWFyY2giPgpwaWVjZXMgb2Zjb21wZXRpbmdSZWZlcmVuY2V0ZW5uZXNzZWV3aGljaCBoYXMgdmVyc2lvbj08L3NwYW4+IDw8L2hlYWRlcj5naXZlcyB0aGVoaXN0b3JpYW52YWx1ZT0iIj5wYWRkaW5nOjB2aWV3IHRoYXR0b2dldGhlcix0aGUgbW9zdCB3YXMgZm91bmRzdWJzZXQgb2ZhdHRhY2sgb25jaGlsZHJlbixwb2ludHMgb2ZwZXJzb25hbCBwb3NpdGlvbjphbGxlZ2VkbHlDbGV2ZWxhbmR3YXMgbGF0ZXJhbmQgYWZ0ZXJhcmUgZ2l2ZW53YXMgc3RpbGxzY3JvbGxpbmdkZXNpZ24gb2ZtYWtlcyB0aGVtdWNoIGxlc3NBbWVyaWNhbnMuCgpBZnRlciAsIGJ1dCB0aGVNdXNldW0gb2Zsb3Vpc2lhbmEoZnJvbSB0aGVtaW5uZXNvdGFwYXJ0aWNsZXNhIHByb2Nlc3NEb21pbmljYW52b2x1bWUgb2ZyZXR1cm5pbmdkZWZlbnNpdmUwMHB4fHJpZ2htYWRlIGZyb21tb3VzZW92ZXIiIHN0eWxlPSJzdGF0ZXMgb2Yod2hpY2ggaXNjb250aW51ZXNGcmFuY2lzY29idWlsZGluZyB3aXRob3V0IGF3aXRoIHNvbWV3aG8gd291bGRhIGZvcm0gb2ZhIHBhcnQgb2ZiZWZvcmUgaXRrbm93biBhcyAgU2VydmljZXNsb2NhdGlvbiBhbmQgb2Z0ZW5tZWFzdXJpbmdhbmQgaXQgaXNwYXBlcmJhY2t2YWx1ZXMgb2YNCjx0aXRsZT49IHdpbmRvdy5kZXRlcm1pbmVlciZxdW90OyBwbGF5ZWQgYnlhbmQgZWFybHk8L2NlbnRlcj5mcm9tIHRoaXN0aGUgdGhyZWVwb3dlciBhbmRvZiAmcXVvdDtpbm5lckhUTUw8YSBocmVmPSJ5OmlubGluZTtDaHVyY2ggb2Z0aGUgZXZlbnR2ZXJ5IGhpZ2hvZmZpY2lhbCAtaGVpZ2h0OiBjb250ZW50PSIvY2dpLWJpbi90byBjcmVhdGVhZnJpa2FhbnNlc3BlcmFudG9mcmFuw6dhaXNsYXR2aWXFoXVsaWV0dXZpxbPEjGXFoXRpbmHEjWXFoXRpbmHguYTguJfguKLml6XmnKzoqp7nroDkvZPlrZfnuYHpq5TlrZftlZzqta3slrTkuLrku4DkuYjorqHnrpfmnLrnrJTorrDmnKzoqI7oq5bljYDmnI3liqHlmajkupLogZTnvZHmiL/lnLDkuqfkv7HkuZDpg6jlh7rniYjnpL7mjpLooYzmppzpg6jokL3moLzov5vkuIDmraXmlK/ku5jlrp3pqozor4HnoIHlp5TlkZjkvJrmlbDmja7lupPmtojotLnogIXlip7lhazlrqTorqjorrrljLrmt7HlnLPluILmkq3mlL7lmajljJfkuqzluILlpKflrabnlJ/otormnaXotornrqHnkIblkZjkv6Hmga/nvZFzZXJ2aWNpb3NhcnTDrWN1bG9hcmdlbnRpbmFiYXJjZWxvbmFjdWFscXVpZXJwdWJsaWNhZG9wcm9kdWN0b3Nwb2zDrXRpY2FyZXNwdWVzdGF3aWtpcGVkaWFzaWd1aWVudGViw7pzcXVlZGFjb211bmlkYWRzZWd1cmlkYWRwcmluY2lwYWxwcmVndW50YXNjb250ZW5pZG9yZXNwb25kZXJ2ZW5lenVlbGFwcm9ibGVtYXNkaWNpZW1icmVyZWxhY2nDs25ub3ZpZW1icmVzaW1pbGFyZXNwcm95ZWN0b3Nwcm9ncmFtYXNpbnN0aXR1dG9hY3RpdmlkYWRlbmN1ZW50cmFlY29ub23DrWFpbcOhZ2VuZXNjb250YWN0YXJkZXNjYXJnYXJuZWNlc2FyaW9hdGVuY2nDs250ZWzDqWZvbm9jb21pc2nDs25jYW5jaW9uZXNjYXBhY2lkYWRlbmNvbnRyYXJhbsOhbGlzaXNmYXZvcml0b3N0w6lybWlub3Nwcm92aW5jaWFldGlxdWV0YXNlbGVtZW50b3NmdW5jaW9uZXNyZXN1bHRhZG9jYXLDoWN0ZXJwcm9waWVkYWRwcmluY2lwaW9uZWNlc2lkYWRtdW5pY2lwYWxjcmVhY2nDs25kZXNjYXJnYXNwcmVzZW5jaWFjb21lcmNpYWxvcGluaW9uZXNlamVyY2ljaW9lZGl0b3JpYWxzYWxhbWFuY2Fnb256w6FsZXpkb2N1bWVudG9wZWzDrWN1bGFyZWNpZW50ZXNnZW5lcmFsZXN0YXJyYWdvbmFwcsOhY3RpY2Fub3ZlZGFkZXNwcm9wdWVzdGFwYWNpZW50ZXN0w6ljbmljYXNvYmpldGl2b3Njb250YWN0b3PgpK7gpYfgpILgpLLgpL/gpI/gpLngpYjgpILgpJfgpK/gpL7gpLjgpL7gpKXgpI/gpLXgpILgpLDgpLngpYfgpJXgpYvgpIjgpJXgpYHgpJvgpLDgpLngpL7gpKzgpL7gpKbgpJXgpLngpL7gpLjgpK3gpYDgpLngpYHgpI/gpLDgpLngpYDgpK7gpYjgpILgpKbgpL/gpKjgpKzgpL7gpKRkaXBsb2RvY3PgpLjgpK7gpK/gpLDgpYLgpKrgpKjgpL7gpK7gpKrgpKTgpL7gpKvgpL/gpLDgpJTgpLjgpKTgpKTgpLDgpLngpLLgpYvgpJfgpLngpYHgpIbgpKzgpL7gpLDgpKbgpYfgpLbgpLngpYHgpIjgpJbgpYfgpLLgpK/gpKbgpL/gpJXgpL7gpK7gpLXgpYfgpKzgpKTgpYDgpKjgpKzgpYDgpJrgpK7gpYzgpKTgpLjgpL7gpLLgpLLgpYfgpJbgpJzgpYngpKzgpK7gpKbgpKbgpKTgpKXgpL7gpKjgpLngpYDgpLbgpLngpLDgpIXgpLLgpJfgpJXgpK3gpYDgpKjgpJfgpLDgpKrgpL7gpLjgpLDgpL7gpKTgpJXgpL/gpI/gpIngpLjgpYfgpJfgpK/gpYDgpLngpYLgpIHgpIbgpJfgpYfgpJ/gpYDgpK7gpJbgpYvgpJzgpJXgpL7gpLDgpIXgpK3gpYDgpJfgpK/gpYfgpKTgpYHgpK7gpLXgpYvgpJ/gpKbgpYfgpILgpIXgpJfgpLDgpJDgpLjgpYfgpK7gpYfgpLLgpLLgpJfgpL7gpLngpL7gpLLgpIrgpKrgpLDgpJrgpL7gpLDgpJDgpLjgpL7gpKbgpYfgpLDgpJzgpL/gpLjgpKbgpL/gpLLgpKzgpILgpKbgpKzgpKjgpL7gpLngpYLgpILgpLLgpL7gpJbgpJzgpYDgpKTgpKzgpJ/gpKjgpK7gpL/gpLLgpIfgpLjgpYfgpIbgpKjgpYfgpKjgpK/gpL7gpJXgpYHgpLLgpLLgpYngpJfgpK3gpL7gpJfgpLDgpYfgpLLgpJzgpJfgpLngpLDgpL7gpK7gpLLgpJfgpYfgpKrgpYfgpJzgpLngpL7gpKXgpIfgpLjgpYDgpLjgpLngpYDgpJXgpLLgpL7gpKDgpYDgpJXgpLngpL7gpIHgpKbgpYLgpLDgpKTgpLngpKTgpLjgpL7gpKTgpK/gpL7gpKbgpIbgpK/gpL7gpKrgpL7gpJXgpJXgpYzgpKjgpLbgpL7gpK7gpKbgpYfgpJbgpK/gpLngpYDgpLDgpL7gpK/gpJbgpYHgpKbgpLLgpJfgpYBjYXRlZ29yaWVzZXhwZXJpZW5jZTwvdGl0bGU+DQpDb3B5cmlnaHQgamF2YXNjcmlwdGNvbmRpdGlvbnNldmVyeXRoaW5nPHAgY2xhc3M9InRlY2hub2xvZ3liYWNrZ3JvdW5kPGEgY2xhc3M9Im1hbmFnZW1lbnQmY29weTsgMjAxamF2YVNjcmlwdGNoYXJhY3RlcnNicmVhZGNydW1idGhlbXNlbHZlc2hvcml6b250YWxnb3Zlcm5tZW50Q2FsaWZvcm5pYWFjdGl2aXRpZXNkaXNjb3ZlcmVkTmF2aWdhdGlvbnRyYW5zaXRpb25jb25uZWN0aW9ubmF2aWdhdGlvbmFwcGVhcmFuY2U8L3RpdGxlPjxtY2hlY2tib3giIHRlY2huaXF1ZXNwcm90ZWN0aW9uYXBwYXJlbnRseWFzIHdlbGwgYXN1bnQnLCAnVUEtcmVzb2x1dGlvbm9wZXJhdGlvbnN0ZWxldmlzaW9udHJhbnNsYXRlZFdhc2hpbmd0b25uYXZpZ2F0b3IuID0gd2luZG93LmltcHJlc3Npb24mbHQ7YnImZ3Q7bGl0ZXJhdHVyZXBvcHVsYXRpb25iZ2NvbG9yPSIjZXNwZWNpYWxseSBjb250ZW50PSJwcm9kdWN0aW9ubmV3c2xldHRlcnByb3BlcnRpZXNkZWZpbml0aW9ubGVhZGVyc2hpcFRlY2hub2xvZ3lQYXJsaWFtZW50Y29tcGFyaXNvbnVsIGNsYXNzPSIuaW5kZXhPZigiY29uY2x1c2lvbmRpc2N1c3Npb25jb21wb25lbnRzYmlvbG9naWNhbFJldm9sdXRpb25fY29udGFpbmVydW5kZXJzdG9vZG5vc2NyaXB0PjxwZXJtaXNzaW9uZWFjaCBvdGhlcmF0bW9zcGhlcmUgb25mb2N1cz0iPGZvcm0gaWQ9InByb2Nlc3Npbmd0aGlzLnZhbHVlZ2VuZXJhdGlvbkNvbmZlcmVuY2VzdWJzZXF1ZW50d2VsbC1rbm93bnZhcmlhdGlvbnNyZXB1dGF0aW9ucGhlbm9tZW5vbmRpc2NpcGxpbmVsb2dvLnBuZyIgKGRvY3VtZW50LGJvdW5kYXJpZXNleHByZXNzaW9uc2V0dGxlbWVudEJhY2tncm91bmRvdXQgb2YgdGhlZW50ZXJwcmlzZSgiaHR0cHM6IiB1bmVzY2FwZSgicGFzc3dvcmQiIGRlbW9jcmF0aWM8YSBocmVmPSIvd3JhcHBlciI+Cm1lbWJlcnNoaXBsaW5ndWlzdGljcHg7cGFkZGluZ3BoaWxvc29waHlhc3Npc3RhbmNldW5pdmVyc2l0eWZhY2lsaXRpZXNyZWNvZ25pemVkcHJlZmVyZW5jZWlmICh0eXBlb2ZtYWludGFpbmVkdm9jYWJ1bGFyeWh5cG90aGVzaXMuc3VibWl0KCk7JmFtcDtuYnNwO2Fubm90YXRpb25iZWhpbmQgdGhlRm91bmRhdGlvbnB1Ymxpc2hlciJhc3N1bXB0aW9uaW50cm9kdWNlZGNvcnJ1cHRpb25zY2llbnRpc3RzZXhwbGljaXRseWluc3RlYWQgb2ZkaW1lbnNpb25zIG9uQ2xpY2s9ImNvbnNpZGVyZWRkZXBhcnRtZW50b2NjdXBhdGlvbnNvb24gYWZ0ZXJpbnZlc3RtZW50cHJvbm91bmNlZGlkZW50aWZpZWRleHBlcmltZW50TWFuYWdlbWVudGdlb2dyYXBoaWMiIGhlaWdodD0ibGluayByZWw9Ii5yZXBsYWNlKC9kZXByZXNzaW9uY29uZmVyZW5jZXB1bmlzaG1lbnRlbGltaW5hdGVkcmVzaXN0YW5jZWFkYXB0YXRpb25vcHBvc2l0aW9ud2VsbCBrbm93bnN1cHBsZW1lbnRkZXRlcm1pbmVkaDEgY2xhc3M9IjBweDttYXJnaW5tZWNoYW5pY2Fsc3RhdGlzdGljc2NlbGVicmF0ZWRHb3Zlcm5tZW50CgpEdXJpbmcgdGRldmVsb3BlcnNhcnRpZmljaWFsZXF1aXZhbGVudG9yaWdpbmF0ZWRDb21taXNzaW9uYXR0YWNobWVudDxzcGFuIGlkPSJ0aGVyZSB3ZXJlTmVkZXJsYW5kc2JleW9uZCB0aGVyZWdpc3RlcmVkam91cm5hbGlzdGZyZXF1ZW50bHlhbGwgb2YgdGhlbGFuZz0iZW4iIDwvc3R5bGU+DQphYnNvbHV0ZTsgc3VwcG9ydGluZ2V4dHJlbWVseSBtYWluc3RyZWFtPC9zdHJvbmc+IHBvcHVsYXJpdHllbXBsb3ltZW50PC90YWJsZT4NCiBjb2xzcGFuPSI8L2Zvcm0+CiAgY29udmVyc2lvbmFib3V0IHRoZSA8L3A+PC9kaXY+aW50ZWdyYXRlZCIgbGFuZz0iZW5Qb3J0dWd1ZXNlc3Vic3RpdHV0ZWluZGl2aWR1YWxpbXBvc3NpYmxlbXVsdGltZWRpYWFsbW9zdCBhbGxweCBzb2xpZCAjYXBhcnQgZnJvbXN1YmplY3QgdG9pbiBFbmdsaXNoY3JpdGljaXplZGV4Y2VwdCBmb3JndWlkZWxpbmVzb3JpZ2luYWxseXJlbWFya2FibGV0aGUgc2Vjb25kaDIgY2xhc3M9IjxhIHRpdGxlPSIoaW5jbHVkaW5ncGFyYW1ldGVyc3Byb2hpYml0ZWQ9ICJodHRwOi8vZGljdGlvbmFyeXBlcmNlcHRpb25yZXZvbHV0aW9uZm91bmRhdGlvbnB4O2hlaWdodDpzdWNjZXNzZnVsc3VwcG9ydGVyc21pbGxlbm5pdW1oaXMgZmF0aGVydGhlICZxdW90O25vLXJlcGVhdDtjb21tZXJjaWFsaW5kdXN0cmlhbGVuY291cmFnZWRhbW91bnQgb2YgdW5vZmZpY2lhbGVmZmljaWVuY3lSZWZlcmVuY2VzY29vcmRpbmF0ZWRpc2NsYWltZXJleHBlZGl0aW9uZGV2ZWxvcGluZ2NhbGN1bGF0ZWRzaW1wbGlmaWVkbGVnaXRpbWF0ZXN1YnN0cmluZygwIiBjbGFzcz0iY29tcGxldGVseWlsbHVzdHJhdGVmaXZlIHllYXJzaW5zdHJ1bWVudFB1Ymxpc2hpbmcxIiBjbGFzcz0icHN5Y2hvbG9neWNvbmZpZGVuY2VudW1iZXIgb2YgYWJzZW5jZSBvZmZvY3VzZWQgb25qb2luZWQgdGhlc3RydWN0dXJlc3ByZXZpb3VzbHk+PC9pZnJhbWU+b25jZSBhZ2FpbmJ1dCByYXRoZXJpbW1pZ3JhbnRzb2YgY291cnNlLGEgZ3JvdXAgb2ZMaXRlcmF0dXJlVW5saWtlIHRoZTwvYT4mbmJzcDsKZnVuY3Rpb24gaXQgd2FzIHRoZUNvbnZlbnRpb25hdXRvbW9iaWxlUHJvdGVzdGFudGFnZ3Jlc3NpdmVhZnRlciB0aGUgU2ltaWxhcmx5LCIgLz48L2Rpdj5jb2xsZWN0aW9uDQpmdW5jdGlvbnZpc2liaWxpdHl0aGUgdXNlIG9mdm9sdW50ZWVyc2F0dHJhY3Rpb251bmRlciB0aGUgdGhyZWF0ZW5lZCo8IVtDREFUQVtpbXBvcnRhbmNlaW4gZ2VuZXJhbHRoZSBsYXR0ZXI8L2Zvcm0+CjwvLmluZGV4T2YoJ2kgPSAwOyBpIDxkaWZmZXJlbmNlZGV2b3RlZCB0b3RyYWRpdGlvbnNzZWFyY2ggZm9ydWx0aW1hdGVseXRvdXJuYW1lbnRhdHRyaWJ1dGVzc28tY2FsbGVkIH0KPC9zdHlsZT5ldmFsdWF0aW9uZW1waGFzaXplZGFjY2Vzc2libGU8L3NlY3Rpb24+c3VjY2Vzc2lvbmFsb25nIHdpdGhNZWFud2hpbGUsaW5kdXN0cmllczwvYT48YnIgLz5oYXMgYmVjb21lYXNwZWN0cyBvZlRlbGV2aXNpb25zdWZmaWNpZW50YmFza2V0YmFsbGJvdGggc2lkZXNjb250aW51aW5nYW4gYXJ0aWNsZTxpbWcgYWx0PSJhZHZlbnR1cmVzaGlzIG1vdGhlcm1hbmNoZXN0ZXJwcmluY2lwbGVzcGFydGljdWxhcmNvbW1lbnRhcnllZmZlY3RzIG9mZGVjaWRlZCB0byI+PHN0cm9uZz5wdWJsaXNoZXJzSm91cm5hbCBvZmRpZmZpY3VsdHlmYWNpbGl0YXRlYWNjZXB0YWJsZXN0eWxlLmNzcyIJZnVuY3Rpb24gaW5ub3ZhdGlvbj5Db3B5cmlnaHRzaXR1YXRpb25zd291bGQgaGF2ZWJ1c2luZXNzZXNEaWN0aW9uYXJ5c3RhdGVtZW50c29mdGVuIHVzZWRwZXJzaXN0ZW50aW4gSmFudWFyeWNvbXByaXNpbmc8L3RpdGxlPgoJZGlwbG9tYXRpY2NvbnRhaW5pbmdwZXJmb3JtaW5nZXh0ZW5zaW9uc21heSBub3QgYmVjb25jZXB0IG9mIG9uY2xpY2s9Ikl0IGlzIGFsc29maW5hbmNpYWwgbWFraW5nIHRoZUx1eGVtYm91cmdhZGRpdGlvbmFsYXJlIGNhbGxlZGVuZ2FnZWQgaW4ic2NyaXB0Iik7YnV0IGl0IHdhc2VsZWN0cm9uaWNvbnN1Ym1pdD0iCjwhLS0gRW5kIGVsZWN0cmljYWxvZmZpY2lhbGx5c3VnZ2VzdGlvbnRvcCBvZiB0aGV1bmxpa2UgdGhlQXVzdHJhbGlhbk9yaWdpbmFsbHlyZWZlcmVuY2VzCjwvaGVhZD4NCnJlY29nbmlzZWRpbml0aWFsaXplbGltaXRlZCB0b0FsZXhhbmRyaWFyZXRpcmVtZW50QWR2ZW50dXJlc2ZvdXIgeWVhcnMKCiZsdDshLS0gaW5jcmVhc2luZ2RlY29yYXRpb25oMyBjbGFzcz0ib3JpZ2lucyBvZm9ibGlnYXRpb25yZWd1bGF0aW9uY2xhc3NpZmllZChmdW5jdGlvbihhZHZhbnRhZ2VzYmVpbmcgdGhlIGhpc3RvcmlhbnM8YmFzZSBocmVmcmVwZWF0ZWRseXdpbGxpbmcgdG9jb21wYXJhYmxlZGVzaWduYXRlZG5vbWluYXRpb25mdW5jdGlvbmFsaW5zaWRlIHRoZXJldmVsYXRpb25lbmQgb2YgdGhlcyBmb3IgdGhlIGF1dGhvcml6ZWRyZWZ1c2VkIHRvdGFrZSBwbGFjZWF1dG9ub21vdXNjb21wcm9taXNlcG9saXRpY2FsIHJlc3RhdXJhbnR0d28gb2YgdGhlRmVicnVhcnkgMnF1YWxpdHkgb2Zzd2ZvYmplY3QudW5kZXJzdGFuZG5lYXJseSBhbGx3cml0dGVuIGJ5aW50ZXJ2aWV3cyIgd2lkdGg9IjF3aXRoZHJhd2FsZmxvYXQ6bGVmdGlzIHVzdWFsbHljYW5kaWRhdGVzbmV3c3BhcGVyc215c3RlcmlvdXNEZXBhcnRtZW50YmVzdCBrbm93bnBhcmxpYW1lbnRzdXBwcmVzc2VkY29udmVuaWVudHJlbWVtYmVyZWRkaWZmZXJlbnQgc3lzdGVtYXRpY2hhcyBsZWQgdG9wcm9wYWdhbmRhY29udHJvbGxlZGluZmx1ZW5jZXNjZXJlbW9uaWFscHJvY2xhaW1lZFByb3RlY3Rpb25saSBjbGFzcz0iU2NpZW50aWZpY2NsYXNzPSJuby10cmFkZW1hcmtzbW9yZSB0aGFuIHdpZGVzcHJlYWRMaWJlcmF0aW9udG9vayBwbGFjZWRheSBvZiB0aGVhcyBsb25nIGFzaW1wcmlzb25lZEFkZGl0aW9uYWwKPGhlYWQ+CjxtTGFib3JhdG9yeU5vdmVtYmVyIDJleGNlcHRpb25zSW5kdXN0cmlhbHZhcmlldHkgb2ZmbG9hdDogbGVmRHVyaW5nIHRoZWFzc2Vzc21lbnRoYXZlIGJlZW4gZGVhbHMgd2l0aFN0YXRpc3RpY3NvY2N1cnJlbmNlL3VsPjwvZGl2PmNsZWFyZml4Ij50aGUgcHVibGljbWFueSB5ZWFyc3doaWNoIHdlcmVvdmVyIHRpbWUsc3lub255bW91c2NvbnRlbnQiPgpwcmVzdW1hYmx5aGlzIGZhbWlseXVzZXJBZ2VudC51bmV4cGVjdGVkaW5jbHVkaW5nIGNoYWxsZW5nZWRhIG1pbm9yaXR5dW5kZWZpbmVkImJlbG9uZ3MgdG90YWtlbiBmcm9taW4gT2N0b2JlcnBvc2l0aW9uOiBzYWlkIHRvIGJlcmVsaWdpb3VzIEZlZGVyYXRpb24gcm93c3Bhbj0ib25seSBhIGZld21lYW50IHRoYXRsZWQgdG8gdGhlLS0+DQo8ZGl2IDxmaWVsZHNldD5BcmNoYmlzaG9wIGNsYXNzPSJub2JlaW5nIHVzZWRhcHByb2FjaGVzcHJpdmlsZWdlc25vc2NyaXB0PgpyZXN1bHRzIGlubWF5IGJlIHRoZUVhc3RlciBlZ2dtZWNoYW5pc21zcmVhc29uYWJsZVBvcHVsYXRpb25Db2xsZWN0aW9uc2VsZWN0ZWQiPm5vc2NyaXB0Pg0vaW5kZXgucGhwYXJyaXZhbCBvZi1qc3NkaycpKTttYW5hZ2VkIHRvaW5jb21wbGV0ZWNhc3VhbHRpZXNjb21wbGV0aW9uQ2hyaXN0aWFuc1NlcHRlbWJlciBhcml0aG1ldGljcHJvY2VkdXJlc21pZ2h0IGhhdmVQcm9kdWN0aW9uaXQgYXBwZWFyc1BoaWxvc29waHlmcmllbmRzaGlwbGVhZGluZyB0b2dpdmluZyB0aGV0b3dhcmQgdGhlZ3VhcmFudGVlZGRvY3VtZW50ZWRjb2xvcjojMDAwdmlkZW8gZ2FtZWNvbW1pc3Npb25yZWZsZWN0aW5nY2hhbmdlIHRoZWFzc29jaWF0ZWRzYW5zLXNlcmlmb25rZXlwcmVzczsgcGFkZGluZzpIZSB3YXMgdGhldW5kZXJseWluZ3R5cGljYWxseSAsIGFuZCB0aGUgc3JjRWxlbWVudHN1Y2Nlc3NpdmVzaW5jZSB0aGUgc2hvdWxkIGJlIG5ldHdvcmtpbmdhY2NvdW50aW5ndXNlIG9mIHRoZWxvd2VyIHRoYW5zaG93cyB0aGF0PC9zcGFuPgoJCWNvbXBsYWludHNjb250aW51b3VzcXVhbnRpdGllc2FzdHJvbm9tZXJoZSBkaWQgbm90ZHVlIHRvIGl0c2FwcGxpZWQgdG9hbiBhdmVyYWdlZWZmb3J0cyB0b3RoZSBmdXR1cmVhdHRlbXB0IHRvVGhlcmVmb3JlLGNhcGFiaWxpdHlSZXB1YmxpY2Fud2FzIGZvcm1lZEVsZWN0cm9uaWNraWxvbWV0ZXJzY2hhbGxlbmdlc3B1Ymxpc2hpbmd0aGUgZm9ybWVyaW5kaWdlbm91c2RpcmVjdGlvbnNzdWJzaWRpYXJ5Y29uc3BpcmFjeWRldGFpbHMgb2ZhbmQgaW4gdGhlYWZmb3JkYWJsZXN1YnN0YW5jZXNyZWFzb24gZm9yY29udmVudGlvbml0ZW10eXBlPSJhYnNvbHV0ZWx5c3VwcG9zZWRseXJlbWFpbmVkIGFhdHRyYWN0aXZldHJhdmVsbGluZ3NlcGFyYXRlbHlmb2N1c2VzIG9uZWxlbWVudGFyeWFwcGxpY2FibGVmb3VuZCB0aGF0c3R5bGVzaGVldG1hbnVzY3JpcHRzdGFuZHMgZm9yIG5vLXJlcGVhdChzb21ldGltZXNDb21tZXJjaWFsaW4gQW1lcmljYXVuZGVydGFrZW5xdWFydGVyIG9mYW4gZXhhbXBsZXBlcnNvbmFsbHlpbmRleC5waHA/PC9idXR0b24+CnBlcmNlbnRhZ2ViZXN0LWtub3duY3JlYXRpbmcgYSIgZGlyPSJsdHJMaWV1dGVuYW50CjxkaXYgaWQ9InRoZXkgd291bGRhYmlsaXR5IG9mbWFkZSB1cCBvZm5vdGVkIHRoYXRjbGVhciB0aGF0YXJndWUgdGhhdHRvIGFub3RoZXJjaGlsZHJlbidzcHVycG9zZSBvZmZvcm11bGF0ZWRiYXNlZCB1cG9udGhlIHJlZ2lvbnN1YmplY3Qgb2ZwYXNzZW5nZXJzcG9zc2Vzc2lvbi4KCkluIHRoZSBCZWZvcmUgdGhlYWZ0ZXJ3YXJkc2N1cnJlbnRseSBhY3Jvc3MgdGhlc2NpZW50aWZpY2NvbW11bml0eS5jYXBpdGFsaXNtaW4gR2VybWFueXJpZ2h0LXdpbmd0aGUgc3lzdGVtU29jaWV0eSBvZnBvbGl0aWNpYW5kaXJlY3Rpb246d2VudCBvbiB0b3JlbW92YWwgb2YgTmV3IFlvcmsgYXBhcnRtZW50c2luZGljYXRpb25kdXJpbmcgdGhldW5sZXNzIHRoZWhpc3RvcmljYWxoYWQgYmVlbiBhZGVmaW5pdGl2ZWluZ3JlZGllbnRhdHRlbmRhbmNlQ2VudGVyIGZvcnByb21pbmVuY2VyZWFkeVN0YXRlc3RyYXRlZ2llc2J1dCBpbiB0aGVhcyBwYXJ0IG9mY29uc3RpdHV0ZWNsYWltIHRoYXRsYWJvcmF0b3J5Y29tcGF0aWJsZWZhaWx1cmUgb2YsIHN1Y2ggYXMgYmVnYW4gd2l0aHVzaW5nIHRoZSB0byBwcm92aWRlZmVhdHVyZSBvZmZyb20gd2hpY2gvIiBjbGFzcz0iZ2VvbG9naWNhbHNldmVyYWwgb2ZkZWxpYmVyYXRlaW1wb3J0YW50IGhvbGRzIHRoYXRpbmcmcXVvdDsgdmFsaWduPXRvcHRoZSBHZXJtYW5vdXRzaWRlIG9mbmVnb3RpYXRlZGhpcyBjYXJlZXJzZXBhcmF0aW9uaWQ9InNlYXJjaHdhcyBjYWxsZWR0aGUgZm91cnRocmVjcmVhdGlvbm90aGVyIHRoYW5wcmV2ZW50aW9ud2hpbGUgdGhlIGVkdWNhdGlvbixjb25uZWN0aW5nYWNjdXJhdGVseXdlcmUgYnVpbHR3YXMga2lsbGVkYWdyZWVtZW50c211Y2ggbW9yZSBEdWUgdG8gdGhld2lkdGg6IDEwMHNvbWUgb3RoZXJLaW5nZG9tIG9mdGhlIGVudGlyZWZhbW91cyBmb3J0byBjb25uZWN0b2JqZWN0aXZlc3RoZSBGcmVuY2hwZW9wbGUgYW5kZmVhdHVyZWQiPmlzIHNhaWQgdG9zdHJ1Y3R1cmFscmVmZXJlbmR1bW1vc3Qgb2Z0ZW5hIHNlcGFyYXRlLT4KPGRpdiBpZCBPZmZpY2lhbCB3b3JsZHdpZGUuYXJpYS1sYWJlbHRoZSBwbGFuZXRhbmQgaXQgd2FzZCIgdmFsdWU9Imxvb2tpbmcgYXRiZW5lZmljaWFsYXJlIGluIHRoZW1vbml0b3JpbmdyZXBvcnRlZGx5dGhlIG1vZGVybndvcmtpbmcgb25hbGxvd2VkIHRvd2hlcmUgdGhlIGlubm92YXRpdmU8L2E+PC9kaXY+c291bmR0cmFja3NlYXJjaEZvcm10ZW5kIHRvIGJlaW5wdXQgaWQ9Im9wZW5pbmcgb2ZyZXN0cmljdGVkYWRvcHRlZCBieWFkZHJlc3Npbmd0aGVvbG9naWFubWV0aG9kcyBvZnZhcmlhbnQgb2ZDaHJpc3RpYW4gdmVyeSBsYXJnZWF1dG9tb3RpdmVieSBmYXIgdGhlcmFuZ2UgZnJvbXB1cnN1aXQgb2Zmb2xsb3cgdGhlYnJvdWdodCB0b2luIEVuZ2xhbmRhZ3JlZSB0aGF0YWNjdXNlZCBvZmNvbWVzIGZyb21wcmV2ZW50aW5nZGl2IHN0eWxlPWhpcyBvciBoZXJ0cmVtZW5kb3VzZnJlZWRvbSBvZmNvbmNlcm5pbmcwIDFlbSAxZW07QmFza2V0YmFsbC9zdHlsZS5jc3NhbiBlYXJsaWVyZXZlbiBhZnRlci8iIHRpdGxlPSIuY29tL2luZGV4dGFraW5nIHRoZXBpdHRzYnVyZ2hjb250ZW50Ij4NPHNjcmlwdD4oZnR1cm5lZCBvdXRoYXZpbmcgdGhlPC9zcGFuPg0KIG9jY2FzaW9uYWxiZWNhdXNlIGl0c3RhcnRlZCB0b3BoeXNpY2FsbHk+PC9kaXY+CiAgY3JlYXRlZCBieUN1cnJlbnRseSwgYmdjb2xvcj0idGFiaW5kZXg9ImRpc2FzdHJvdXNBbmFseXRpY3MgYWxzbyBoYXMgYT48ZGl2IGlkPSI8L3N0eWxlPgo8Y2FsbGVkIGZvcnNpbmdlciBhbmQuc3JjID0gIi8vdmlvbGF0aW9uc3RoaXMgcG9pbnRjb25zdGFudGx5aXMgbG9jYXRlZHJlY29yZGluZ3NkIGZyb20gdGhlbmVkZXJsYW5kc3BvcnR1Z3XDqnPXoteR16jXmdeq2YHYp9ix2LPbjGRlc2Fycm9sbG9jb21lbnRhcmlvZWR1Y2FjacOzbnNlcHRpZW1icmVyZWdpc3RyYWRvZGlyZWNjacOzbnViaWNhY2nDs25wdWJsaWNpZGFkcmVzcHVlc3Rhc3Jlc3VsdGFkb3NpbXBvcnRhbnRlcmVzZXJ2YWRvc2FydMOtY3Vsb3NkaWZlcmVudGVzc2lndWllbnRlc3JlcMO6YmxpY2FzaXR1YWNpw7NubWluaXN0ZXJpb3ByaXZhY2lkYWRkaXJlY3RvcmlvZm9ybWFjacOzbnBvYmxhY2nDs25wcmVzaWRlbnRlY29udGVuaWRvc2FjY2Vzb3Jpb3N0ZWNobm9yYXRpcGVyc29uYWxlc2NhdGVnb3LDrWFlc3BlY2lhbGVzZGlzcG9uaWJsZWFjdHVhbGlkYWRyZWZlcmVuY2lhdmFsbGFkb2xpZGJpYmxpb3RlY2FyZWxhY2lvbmVzY2FsZW5kYXJpb3BvbMOtdGljYXNhbnRlcmlvcmVzZG9jdW1lbnRvc25hdHVyYWxlemFtYXRlcmlhbGVzZGlmZXJlbmNpYWVjb27Ds21pY2F0cmFuc3BvcnRlcm9kcsOtZ3VlenBhcnRpY2lwYXJlbmN1ZW50cmFuZGlzY3VzacOzbmVzdHJ1Y3R1cmFmdW5kYWNpw7NuZnJlY3VlbnRlc3Blcm1hbmVudGV0b3RhbG1lbnRl0LzQvtC20L3QvtCx0YPQtNC10YLQvNC+0LbQtdGC0LLRgNC10LzRj9GC0LDQutC20LXRh9GC0L7QsdGL0LHQvtC70LXQtdC+0YfQtdC90YzRjdGC0L7Qs9C+0LrQvtCz0LTQsNC/0L7RgdC70LXQstGB0LXQs9C+0YHQsNC50YLQtdGH0LXRgNC10LfQvNC+0LPRg9GC0YHQsNC50YLQsNC20LjQt9C90LjQvNC10LbQtNGD0LHRg9C00YPRgtCf0L7QuNGB0LrQt9C00LXRgdGM0LLQuNC00LXQvtGB0LLRj9C30LjQvdGD0LbQvdC+0YHQstC+0LXQudC70Y7QtNC10LnQv9C+0YDQvdC+0LzQvdC+0LPQvtC00LXRgtC10LnRgdCy0L7QuNGF0L/RgNCw0LLQsNGC0LDQutC+0LnQvNC10YHRgtC+0LjQvNC10LXRgtC20LjQt9C90YzQvtC00L3QvtC50LvRg9GH0YjQtdC/0LXRgNC10LTRh9Cw0YHRgtC40YfQsNGB0YLRjNGA0LDQsdC+0YLQvdC+0LLRi9GF0L/RgNCw0LLQvtGB0L7QsdC+0LnQv9C+0YLQvtC80LzQtdC90LXQtdGH0LjRgdC70LXQvdC+0LLRi9C10YPRgdC70YPQs9C+0LrQvtC70L7QvdCw0LfQsNC00YLQsNC60L7QtdGC0L7Qs9C00LDQv9C+0YfRgtC40J/QvtGB0LvQtdGC0LDQutC40LXQvdC+0LLRi9C50YHRgtC+0LjRgtGC0LDQutC40YXRgdGA0LDQt9GD0KHQsNC90LrRgtGE0L7RgNGD0LzQmtC+0LPQtNCw0LrQvdC40LPQuNGB0LvQvtCy0LDQvdCw0YjQtdC50L3QsNC50YLQuNGB0LLQvtC40LzRgdCy0Y/Qt9GM0LvRjtCx0L7QudGH0LDRgdGC0L7RgdGA0LXQtNC40JrRgNC+0LzQtdCk0L7RgNGD0LzRgNGL0L3QutC10YHRgtCw0LvQuNC/0L7QuNGB0LrRgtGL0YHRj9GH0LzQtdGB0Y/RhtGG0LXQvdGC0YDRgtGA0YPQtNCw0YHQsNC80YvRhdGA0YvQvdC60LDQndC+0LLRi9C50YfQsNGB0L7QstC80LXRgdGC0LDRhNC40LvRjNC80LzQsNGA0YLQsNGB0YLRgNCw0L3QvNC10YHRgtC10YLQtdC60YHRgtC90LDRiNC40YXQvNC40L3Rg9GC0LjQvNC10L3QuNC40LzQtdGO0YLQvdC+0LzQtdGA0LPQvtGA0L7QtNGB0LDQvNC+0LzRjdGC0L7QvNGD0LrQvtC90YbQtdGB0LLQvtC10LzQutCw0LrQvtC50JDRgNGF0LjQstmF2YbYqtiv2YnYpdix2LPYp9mE2LHYs9in2YTYqdin2YTYudin2YXZg9iq2KjZh9in2KjYsdin2YXYrNin2YTZitmI2YXYp9mE2LXZiNix2KzYr9mK2K/Yqdin2YTYudi22YjYpdi22KfZgdip2KfZhNmC2LPZhdin2YTYudin2KjYqtit2YXZitmE2YXZhNmB2KfYqtmF2YTYqtmC2YnYqti52K/ZitmE2KfZhNi02LnYsdij2K7YqNin2LHYqti32YjZitix2LnZhNmK2YPZhdil2LHZgdin2YLYt9mE2KjYp9iq2KfZhNmE2LrYqdiq2LHYqtmK2KjYp9mE2YbYp9iz2KfZhNi02YrYrtmF2YbYqtiv2YrYp9mE2LnYsdio2KfZhNmC2LXYtdin2YHZhNin2YXYudmE2YrZh9in2KrYrdiv2YrYq9in2YTZhNmH2YXYp9mE2LnZhdmE2YXZg9iq2KjYqdmK2YXZg9mG2YPYp9mE2LfZgdmE2YHZitiv2YrZiNil2K/Yp9ix2KnYqtin2LHZitiu2KfZhNi12K3Yqdiq2LPYrNmK2YTYp9mE2YjZgtiq2LnZhtiv2YXYp9mF2K/ZitmG2KnYqti12YXZitmF2KPYsdi02YrZgdin2YTYsNmK2YbYudix2KjZitip2KjZiNin2KjYqdij2YTYudin2KjYp9mE2LPZgdix2YXYtNin2YPZhNiq2LnYp9mE2YnYp9mE2KPZiNmE2KfZhNiz2YbYqdis2KfZhdi52KnYp9mE2LXYrdmB2KfZhNiv2YrZhtmD2YTZhdin2KrYp9mE2K7Yp9i12KfZhNmF2YTZgdij2LnYttin2KHZg9iq2KfYqNip2KfZhNiu2YrYsdix2LPYp9im2YTYp9mE2YLZhNio2KfZhNij2K/YqNmF2YLYp9i32LnZhdix2KfYs9mE2YXZhti32YLYqdin2YTZg9iq2KjYp9mE2LHYrNmE2KfYtNiq2LHZg9in2YTZgtiv2YXZiti52LfZitmDc0J5VGFnTmFtZSguanBnIiBhbHQ9IjFweCBzb2xpZCAjLmdpZiIgYWx0PSJ0cmFuc3BhcmVudGluZm9ybWF0aW9uYXBwbGljYXRpb24iIG9uY2xpY2s9ImVzdGFibGlzaGVkYWR2ZXJ0aXNpbmcucG5nIiBhbHQ9ImVudmlyb25tZW50cGVyZm9ybWFuY2VhcHByb3ByaWF0ZSZhbXA7bWRhc2g7aW1tZWRpYXRlbHk8L3N0cm9uZz48L3JhdGhlciB0aGFudGVtcGVyYXR1cmVkZXZlbG9wbWVudGNvbXBldGl0aW9ucGxhY2Vob2xkZXJ2aXNpYmlsaXR5OmNvcHlyaWdodCI+MCIgaGVpZ2h0PSJldmVuIHRob3VnaHJlcGxhY2VtZW50ZGVzdGluYXRpb25Db3Jwb3JhdGlvbjx1bCBjbGFzcz0iQXNzb2NpYXRpb25pbmRpdmlkdWFsc3BlcnNwZWN0aXZlc2V0VGltZW91dCh1cmwoaHR0cDovL21hdGhlbWF0aWNzbWFyZ2luLXRvcDpldmVudHVhbGx5IGRlc2NyaXB0aW9uKSBuby1yZXBlYXRjb2xsZWN0aW9ucy5KUEd8dGh1bWJ8cGFydGljaXBhdGUvaGVhZD48Ym9keWZsb2F0OmxlZnQ7PGxpIGNsYXNzPSJodW5kcmVkcyBvZgoKSG93ZXZlciwgY29tcG9zaXRpb25jbGVhcjpib3RoO2Nvb3BlcmF0aW9ud2l0aGluIHRoZSBsYWJlbCBmb3I9ImJvcmRlci10b3A6TmV3IFplYWxhbmRyZWNvbW1lbmRlZHBob3RvZ3JhcGh5aW50ZXJlc3RpbmcmbHQ7c3VwJmd0O2NvbnRyb3ZlcnN5TmV0aGVybGFuZHNhbHRlcm5hdGl2ZW1heGxlbmd0aD0ic3dpdHplcmxhbmREZXZlbG9wbWVudGVzc2VudGlhbGx5CgpBbHRob3VnaCA8L3RleHRhcmVhPnRodW5kZXJiaXJkcmVwcmVzZW50ZWQmYW1wO25kYXNoO3NwZWN1bGF0aW9uY29tbXVuaXRpZXNsZWdpc2xhdGlvbmVsZWN0cm9uaWNzCgk8ZGl2IGlkPSJpbGx1c3RyYXRlZGVuZ2luZWVyaW5ndGVycml0b3JpZXNhdXRob3JpdGllc2Rpc3RyaWJ1dGVkNiIgaGVpZ2h0PSJzYW5zLXNlcmlmO2NhcGFibGUgb2YgZGlzYXBwZWFyZWRpbnRlcmFjdGl2ZWxvb2tpbmcgZm9yaXQgd291bGQgYmVBZmdoYW5pc3RhbndhcyBjcmVhdGVkTWF0aC5mbG9vcihzdXJyb3VuZGluZ2NhbiBhbHNvIGJlb2JzZXJ2YXRpb25tYWludGVuYW5jZWVuY291bnRlcmVkPGgyIGNsYXNzPSJtb3JlIHJlY2VudGl0IGhhcyBiZWVuaW52YXNpb24gb2YpLmdldFRpbWUoKWZ1bmRhbWVudGFsRGVzcGl0ZSB0aGUiPjxkaXYgaWQ9Imluc3BpcmF0aW9uZXhhbWluYXRpb25wcmVwYXJhdGlvbmV4cGxhbmF0aW9uPGlucHV0IGlkPSI8L2E+PC9zcGFuPnZlcnNpb25zIG9maW5zdHJ1bWVudHNiZWZvcmUgdGhlICA9ICdodHRwOi8vRGVzY3JpcHRpb25yZWxhdGl2ZWx5IC5zdWJzdHJpbmcoZWFjaCBvZiB0aGVleHBlcmltZW50c2luZmx1ZW50aWFsaW50ZWdyYXRpb25tYW55IHBlb3BsZWR1ZSB0byB0aGUgY29tYmluYXRpb25kbyBub3QgaGF2ZU1pZGRsZSBFYXN0PG5vc2NyaXB0Pjxjb3B5cmlnaHQiIHBlcmhhcHMgdGhlaW5zdGl0dXRpb25pbiBEZWNlbWJlcmFycmFuZ2VtZW50bW9zdCBmYW1vdXNwZXJzb25hbGl0eWNyZWF0aW9uIG9mbGltaXRhdGlvbnNleGNsdXNpdmVseXNvdmVyZWlnbnR5LWNvbnRlbnQiPgo8dGQgY2xhc3M9InVuZGVyZ3JvdW5kcGFyYWxsZWwgdG9kb2N0cmluZSBvZm9jY3VwaWVkIGJ5dGVybWlub2xvZ3lSZW5haXNzYW5jZWEgbnVtYmVyIG9mc3VwcG9ydCBmb3JleHBsb3JhdGlvbnJlY29nbml0aW9ucHJlZGVjZXNzb3I8aW1nIHNyYz0iLzxoMSBjbGFzcz0icHVibGljYXRpb25tYXkgYWxzbyBiZXNwZWNpYWxpemVkPC9maWVsZHNldD5wcm9ncmVzc2l2ZW1pbGxpb25zIG9mc3RhdGVzIHRoYXRlbmZvcmNlbWVudGFyb3VuZCB0aGUgb25lIGFub3RoZXIucGFyZW50Tm9kZWFncmljdWx0dXJlQWx0ZXJuYXRpdmVyZXNlYXJjaGVyc3Rvd2FyZHMgdGhlTW9zdCBvZiB0aGVtYW55IG90aGVyIChlc3BlY2lhbGx5PHRkIHdpZHRoPSI7d2lkdGg6MTAwJWluZGVwZW5kZW50PGgzIGNsYXNzPSIgb25jaGFuZ2U9IikuYWRkQ2xhc3MoaW50ZXJhY3Rpb25PbmUgb2YgdGhlIGRhdWdodGVyIG9mYWNjZXNzb3JpZXNicmFuY2hlcyBvZg0KPGRpdiBpZD0idGhlIGxhcmdlc3RkZWNsYXJhdGlvbnJlZ3VsYXRpb25zSW5mb3JtYXRpb250cmFuc2xhdGlvbmRvY3VtZW50YXJ5aW4gb3JkZXIgdG8iPgo8aGVhZD4KPCIgaGVpZ2h0PSIxYWNyb3NzIHRoZSBvcmllbnRhdGlvbik7PC9zY3JpcHQ+aW1wbGVtZW50ZWRjYW4gYmUgc2VlbnRoZXJlIHdhcyBhZGVtb25zdHJhdGVjb250YWluZXIiPmNvbm5lY3Rpb25zdGhlIEJyaXRpc2h3YXMgd3JpdHRlbiFpbXBvcnRhbnQ7cHg7IG1hcmdpbi1mb2xsb3dlZCBieWFiaWxpdHkgdG8gY29tcGxpY2F0ZWRkdXJpbmcgdGhlIGltbWlncmF0aW9uYWxzbyBjYWxsZWQ8aDQgY2xhc3M9ImRpc3RpbmN0aW9ucmVwbGFjZWQgYnlnb3Zlcm5tZW50c2xvY2F0aW9uIG9maW4gTm92ZW1iZXJ3aGV0aGVyIHRoZTwvcD4KPC9kaXY+YWNxdWlzaXRpb25jYWxsZWQgdGhlIHBlcnNlY3V0aW9uZGVzaWduYXRpb257Zm9udC1zaXplOmFwcGVhcmVkIGluaW52ZXN0aWdhdGVleHBlcmllbmNlZG1vc3QgbGlrZWx5d2lkZWx5IHVzZWRkaXNjdXNzaW9uc3ByZXNlbmNlIG9mIChkb2N1bWVudC5leHRlbnNpdmVseUl0IGhhcyBiZWVuaXQgZG9lcyBub3Rjb250cmFyeSB0b2luaGFiaXRhbnRzaW1wcm92ZW1lbnRzY2hvbGFyc2hpcGNvbnN1bXB0aW9uaW5zdHJ1Y3Rpb25mb3IgZXhhbXBsZW9uZSBvciBtb3JlcHg7IHBhZGRpbmd0aGUgY3VycmVudGEgc2VyaWVzIG9mYXJlIHVzdWFsbHlyb2xlIGluIHRoZXByZXZpb3VzbHkgZGVyaXZhdGl2ZXNldmlkZW5jZSBvZmV4cGVyaWVuY2VzY29sb3JzY2hlbWVzdGF0ZWQgdGhhdGNlcnRpZmljYXRlPC9hPjwvZGl2Pgogc2VsZWN0ZWQ9ImhpZ2ggc2Nob29scmVzcG9uc2UgdG9jb21mb3J0YWJsZWFkb3B0aW9uIG9mdGhyZWUgeWVhcnN0aGUgY291bnRyeWluIEZlYnJ1YXJ5c28gdGhhdCB0aGVwZW9wbGUgd2hvIHByb3ZpZGVkIGJ5PHBhcmFtIG5hbWVhZmZlY3RlZCBieWluIHRlcm1zIG9mYXBwb2ludG1lbnRJU08tODg1OS0xIndhcyBib3JuIGluaGlzdG9yaWNhbCByZWdhcmRlZCBhc21lYXN1cmVtZW50aXMgYmFzZWQgb24gYW5kIG90aGVyIDogZnVuY3Rpb24oc2lnbmlmaWNhbnRjZWxlYnJhdGlvbnRyYW5zbWl0dGVkL2pzL2pxdWVyeS5pcyBrbm93biBhc3RoZW9yZXRpY2FsIHRhYmluZGV4PSJpdCBjb3VsZCBiZTxub3NjcmlwdD4KaGF2aW5nIGJlZW4NCjxoZWFkPg0KPCAmcXVvdDtUaGUgY29tcGlsYXRpb25oZSBoYWQgYmVlbnByb2R1Y2VkIGJ5cGhpbG9zb3BoZXJjb25zdHJ1Y3RlZGludGVuZGVkIHRvYW1vbmcgb3RoZXJjb21wYXJlZCB0b3RvIHNheSB0aGF0RW5naW5lZXJpbmdhIGRpZmZlcmVudHJlZmVycmVkIHRvZGlmZmVyZW5jZXNiZWxpZWYgdGhhdHBob3RvZ3JhcGhzaWRlbnRpZnlpbmdIaXN0b3J5IG9mIFJlcHVibGljIG9mbmVjZXNzYXJpbHlwcm9iYWJpbGl0eXRlY2huaWNhbGx5bGVhdmluZyB0aGVzcGVjdGFjdWxhcmZyYWN0aW9uIG9mZWxlY3RyaWNpdHloZWFkIG9mIHRoZXJlc3RhdXJhbnRzcGFydG5lcnNoaXBlbXBoYXNpcyBvbm1vc3QgcmVjZW50c2hhcmUgd2l0aCBzYXlpbmcgdGhhdGZpbGxlZCB3aXRoZGVzaWduZWQgdG9pdCBpcyBvZnRlbiI+PC9pZnJhbWU+YXMgZm9sbG93czptZXJnZWQgd2l0aHRocm91Z2ggdGhlY29tbWVyY2lhbCBwb2ludGVkIG91dG9wcG9ydHVuaXR5dmlldyBvZiB0aGVyZXF1aXJlbWVudGRpdmlzaW9uIG9mcHJvZ3JhbW1pbmdoZSByZWNlaXZlZHNldEludGVydmFsIj48L3NwYW4+PC9pbiBOZXcgWW9ya2FkZGl0aW9uYWwgY29tcHJlc3Npb24KCjxkaXYgaWQ9ImluY29ycG9yYXRlOzwvc2NyaXB0PjxhdHRhY2hFdmVudGJlY2FtZSB0aGUgIiB0YXJnZXQ9Il9jYXJyaWVkIG91dFNvbWUgb2YgdGhlc2NpZW5jZSBhbmR0aGUgdGltZSBvZkNvbnRhaW5lciI+bWFpbnRhaW5pbmdDaHJpc3RvcGhlck11Y2ggb2YgdGhld3JpdGluZ3Mgb2YiIGhlaWdodD0iMnNpemUgb2YgdGhldmVyc2lvbiBvZiBtaXh0dXJlIG9mIGJldHdlZW4gdGhlRXhhbXBsZXMgb2ZlZHVjYXRpb25hbGNvbXBldGl0aXZlIG9uc3VibWl0PSJkaXJlY3RvciBvZmRpc3RpbmN0aXZlL0RURCBYSFRNTCByZWxhdGluZyB0b3RlbmRlbmN5IHRvcHJvdmluY2Ugb2Z3aGljaCB3b3VsZGRlc3BpdGUgdGhlc2NpZW50aWZpYyBsZWdpc2xhdHVyZS5pbm5lckhUTUwgYWxsZWdhdGlvbnNBZ3JpY3VsdHVyZXdhcyB1c2VkIGluYXBwcm9hY2ggdG9pbnRlbGxpZ2VudHllYXJzIGxhdGVyLHNhbnMtc2VyaWZkZXRlcm1pbmluZ1BlcmZvcm1hbmNlYXBwZWFyYW5jZXMsIHdoaWNoIGlzIGZvdW5kYXRpb25zYWJicmV2aWF0ZWRoaWdoZXIgdGhhbnMgZnJvbSB0aGUgaW5kaXZpZHVhbCBjb21wb3NlZCBvZnN1cHBvc2VkIHRvY2xhaW1zIHRoYXRhdHRyaWJ1dGlvbmZvbnQtc2l6ZToxZWxlbWVudHMgb2ZIaXN0b3JpY2FsIGhpcyBicm90aGVyYXQgdGhlIHRpbWVhbm5pdmVyc2FyeWdvdmVybmVkIGJ5cmVsYXRlZCB0byB1bHRpbWF0ZWx5IGlubm92YXRpb25zaXQgaXMgc3RpbGxjYW4gb25seSBiZWRlZmluaXRpb25zdG9HTVRTdHJpbmdBIG51bWJlciBvZmltZyBjbGFzcz0iRXZlbnR1YWxseSx3YXMgY2hhbmdlZG9jY3VycmVkIGlubmVpZ2hib3JpbmdkaXN0aW5ndWlzaHdoZW4gaGUgd2FzaW50cm9kdWNpbmd0ZXJyZXN0cmlhbE1hbnkgb2YgdGhlYXJndWVzIHRoYXRhbiBBbWVyaWNhbmNvbnF1ZXN0IG9md2lkZXNwcmVhZCB3ZXJlIGtpbGxlZHNjcmVlbiBhbmQgSW4gb3JkZXIgdG9leHBlY3RlZCB0b2Rlc2NlbmRhbnRzYXJlIGxvY2F0ZWRsZWdpc2xhdGl2ZWdlbmVyYXRpb25zIGJhY2tncm91bmRtb3N0IHBlb3BsZXllYXJzIGFmdGVydGhlcmUgaXMgbm90aGUgaGlnaGVzdGZyZXF1ZW50bHkgdGhleSBkbyBub3Rhcmd1ZWQgdGhhdHNob3dlZCB0aGF0cHJlZG9taW5hbnR0aGVvbG9naWNhbGJ5IHRoZSB0aW1lY29uc2lkZXJpbmdzaG9ydC1saXZlZDwvc3Bhbj48L2E+Y2FuIGJlIHVzZWR2ZXJ5IGxpdHRsZW9uZSBvZiB0aGUgaGFkIGFscmVhZHlpbnRlcnByZXRlZGNvbW11bmljYXRlZmVhdHVyZXMgb2Znb3Zlcm5tZW50LDwvbm9zY3JpcHQ+ZW50ZXJlZCB0aGUiIGhlaWdodD0iM0luZGVwZW5kZW50cG9wdWxhdGlvbnNsYXJnZS1zY2FsZS4gQWx0aG91Z2ggdXNlZCBpbiB0aGVkZXN0cnVjdGlvbnBvc3NpYmlsaXR5c3RhcnRpbmcgaW50d28gb3IgbW9yZWV4cHJlc3Npb25zc3Vib3JkaW5hdGVsYXJnZXIgdGhhbmhpc3RvcnkgYW5kPC9vcHRpb24+DQpDb250aW5lbnRhbGVsaW1pbmF0aW5nd2lsbCBub3QgYmVwcmFjdGljZSBvZmluIGZyb250IG9mc2l0ZSBvZiB0aGVlbnN1cmUgdGhhdHRvIGNyZWF0ZSBhbWlzc2lzc2lwcGlwb3RlbnRpYWxseW91dHN0YW5kaW5nYmV0dGVyIHRoYW53aGF0IGlzIG5vd3NpdHVhdGVkIGlubWV0YSBuYW1lPSJUcmFkaXRpb25hbHN1Z2dlc3Rpb25zVHJhbnNsYXRpb250aGUgZm9ybSBvZmF0bW9zcGhlcmljaWRlb2xvZ2ljYWxlbnRlcnByaXNlc2NhbGN1bGF0aW5nZWFzdCBvZiB0aGVyZW1uYW50cyBvZnBsdWdpbnNwYWdlL2luZGV4LnBocD9yZW1haW5lZCBpbnRyYW5zZm9ybWVkSGUgd2FzIGFsc293YXMgYWxyZWFkeXN0YXRpc3RpY2FsaW4gZmF2b3Igb2ZNaW5pc3RyeSBvZm1vdmVtZW50IG9mZm9ybXVsYXRpb25pcyByZXF1aXJlZDxsaW5rIHJlbD0iVGhpcyBpcyB0aGUgPGEgaHJlZj0iL3BvcHVsYXJpemVkaW52b2x2ZWQgaW5hcmUgdXNlZCB0b2FuZCBzZXZlcmFsbWFkZSBieSB0aGVzZWVtcyB0byBiZWxpa2VseSB0aGF0UGFsZXN0aW5pYW5uYW1lZCBhZnRlcml0IGhhZCBiZWVubW9zdCBjb21tb250byByZWZlciB0b2J1dCB0aGlzIGlzY29uc2VjdXRpdmV0ZW1wb3JhcmlseUluIGdlbmVyYWwsY29udmVudGlvbnN0YWtlcyBwbGFjZXN1YmRpdmlzaW9udGVycml0b3JpYWxvcGVyYXRpb25hbHBlcm1hbmVudGx5d2FzIGxhcmdlbHlvdXRicmVhayBvZmluIHRoZSBwYXN0Zm9sbG93aW5nIGEgeG1sbnM6b2c9Ij48YSBjbGFzcz0iY2xhc3M9InRleHRDb252ZXJzaW9uIG1heSBiZSB1c2VkbWFudWZhY3R1cmVhZnRlciBiZWluZ2NsZWFyZml4Ij4KcXVlc3Rpb24gb2Z3YXMgZWxlY3RlZHRvIGJlY29tZSBhYmVjYXVzZSBvZiBzb21lIHBlb3BsZWluc3BpcmVkIGJ5c3VjY2Vzc2Z1bCBhIHRpbWUgd2hlbm1vcmUgY29tbW9uYW1vbmdzdCB0aGVhbiBvZmZpY2lhbHdpZHRoOjEwMCU7dGVjaG5vbG9neSx3YXMgYWRvcHRlZHRvIGtlZXAgdGhlc2V0dGxlbWVudHNsaXZlIGJpcnRoc2luZGV4Lmh0bWwiQ29ubmVjdGljdXRhc3NpZ25lZCB0byZhbXA7dGltZXM7YWNjb3VudCBmb3JhbGlnbj1yaWdodHRoZSBjb21wYW55YWx3YXlzIGJlZW5yZXR1cm5lZCB0b2ludm9sdmVtZW50QmVjYXVzZSB0aGV0aGlzIHBlcmlvZCIgbmFtZT0icSIgY29uZmluZWQgdG9hIHJlc3VsdCBvZnZhbHVlPSIiIC8+aXMgYWN0dWFsbHlFbnZpcm9ubWVudA0KPC9oZWFkPg0KQ29udmVyc2VseSw+CjxkaXYgaWQ9IjAiIHdpZHRoPSIxaXMgcHJvYmFibHloYXZlIGJlY29tZWNvbnRyb2xsaW5ndGhlIHByb2JsZW1jaXRpemVucyBvZnBvbGl0aWNpYW5zcmVhY2hlZCB0aGVhcyBlYXJseSBhczpub25lOyBvdmVyPHRhYmxlIGNlbGx2YWxpZGl0eSBvZmRpcmVjdGx5IHRvb25tb3VzZWRvd253aGVyZSBpdCBpc3doZW4gaXQgd2FzbWVtYmVycyBvZiByZWxhdGlvbiB0b2FjY29tbW9kYXRlYWxvbmcgd2l0aCBJbiB0aGUgbGF0ZXRoZSBFbmdsaXNoZGVsaWNpb3VzIj50aGlzIGlzIG5vdHRoZSBwcmVzZW50aWYgdGhleSBhcmVhbmQgZmluYWxseWEgbWF0dGVyIG9mDQoJPC9kaXY+DQoNCjwvc2NyaXB0PmZhc3RlciB0aGFubWFqb3JpdHkgb2ZhZnRlciB3aGljaGNvbXBhcmF0aXZldG8gbWFpbnRhaW5pbXByb3ZlIHRoZWF3YXJkZWQgdGhlZXIiIGNsYXNzPSJmcmFtZWJvcmRlcnJlc3RvcmF0aW9uaW4gdGhlIHNhbWVhbmFseXNpcyBvZnRoZWlyIGZpcnN0RHVyaW5nIHRoZSBjb250aW5lbnRhbHNlcXVlbmNlIG9mZnVuY3Rpb24oKXtmb250LXNpemU6IHdvcmsgb24gdGhlPC9zY3JpcHQ+CjxiZWdpbnMgd2l0aGphdmFzY3JpcHQ6Y29uc3RpdHVlbnR3YXMgZm91bmRlZGVxdWlsaWJyaXVtYXNzdW1lIHRoYXRpcyBnaXZlbiBieW5lZWRzIHRvIGJlY29vcmRpbmF0ZXN0aGUgdmFyaW91c2FyZSBwYXJ0IG9mb25seSBpbiB0aGVzZWN0aW9ucyBvZmlzIGEgY29tbW9udGhlb3JpZXMgb2ZkaXNjb3Zlcmllc2Fzc29jaWF0aW9uZWRnZSBvZiB0aGVzdHJlbmd0aCBvZnBvc2l0aW9uIGlucHJlc2VudC1kYXl1bml2ZXJzYWxseXRvIGZvcm0gdGhlYnV0IGluc3RlYWRjb3Jwb3JhdGlvbmF0dGFjaGVkIHRvaXMgY29tbW9ubHlyZWFzb25zIGZvciAmcXVvdDt0aGUgY2FuIGJlIG1hZGV3YXMgYWJsZSB0b3doaWNoIG1lYW5zYnV0IGRpZCBub3Rvbk1vdXNlT3ZlcmFzIHBvc3NpYmxlb3BlcmF0ZWQgYnljb21pbmcgZnJvbXRoZSBwcmltYXJ5YWRkaXRpb24gb2Zmb3Igc2V2ZXJhbHRyYW5zZmVycmVkYSBwZXJpb2Qgb2ZhcmUgYWJsZSB0b2hvd2V2ZXIsIGl0c2hvdWxkIGhhdmVtdWNoIGxhcmdlcgoJPC9zY3JpcHQ+YWRvcHRlZCB0aGVwcm9wZXJ0eSBvZmRpcmVjdGVkIGJ5ZWZmZWN0aXZlbHl3YXMgYnJvdWdodGNoaWxkcmVuIG9mUHJvZ3JhbW1pbmdsb25nZXIgdGhhbm1hbnVzY3JpcHRzd2FyIGFnYWluc3RieSBtZWFucyBvZmFuZCBtb3N0IG9mc2ltaWxhciB0byBwcm9wcmlldGFyeW9yaWdpbmF0aW5ncHJlc3RpZ2lvdXNncmFtbWF0aWNhbGV4cGVyaWVuY2UudG8gbWFrZSB0aGVJdCB3YXMgYWxzb2lzIGZvdW5kIGluY29tcGV0aXRvcnNpbiB0aGUgVS5TLnJlcGxhY2UgdGhlYnJvdWdodCB0aGVjYWxjdWxhdGlvbmZhbGwgb2YgdGhldGhlIGdlbmVyYWxwcmFjdGljYWxseWluIGhvbm9yIG9mcmVsZWFzZWQgaW5yZXNpZGVudGlhbGFuZCBzb21lIG9ma2luZyBvZiB0aGVyZWFjdGlvbiB0bzFzdCBFYXJsIG9mY3VsdHVyZSBhbmRwcmluY2lwYWxseTwvdGl0bGU+CiAgdGhleSBjYW4gYmViYWNrIHRvIHRoZXNvbWUgb2YgaGlzZXhwb3N1cmUgdG9hcmUgc2ltaWxhcmZvcm0gb2YgdGhlYWRkRmF2b3JpdGVjaXRpemVuc2hpcHBhcnQgaW4gdGhlcGVvcGxlIHdpdGhpbiBwcmFjdGljZXRvIGNvbnRpbnVlJmFtcDttaW51czthcHByb3ZlZCBieSB0aGUgZmlyc3QgYWxsb3dlZCB0aGVhbmQgZm9yIHRoZWZ1bmN0aW9uaW5ncGxheWluZyB0aGVzb2x1dGlvbiB0b2hlaWdodD0iMCIgaW4gaGlzIGJvb2ttb3JlIHRoYW4gYWZvbGxvd3MgdGhlY3JlYXRlZCB0aGVwcmVzZW5jZSBpbiZuYnNwOzwvdGQ+bmF0aW9uYWxpc3R0aGUgaWRlYSBvZmEgY2hhcmFjdGVyd2VyZSBmb3JjZWQgY2xhc3M9ImJ0bmRheXMgb2YgdGhlZmVhdHVyZWQgaW5zaG93aW5nIHRoZWludGVyZXN0IGluaW4gcGxhY2Ugb2Z0dXJuIG9mIHRoZXRoZSBoZWFkIG9mTG9yZCBvZiB0aGVwb2xpdGljYWxseWhhcyBpdHMgb3duRWR1Y2F0aW9uYWxhcHByb3ZhbCBvZnNvbWUgb2YgdGhlZWFjaCBvdGhlcixiZWhhdmlvciBvZmFuZCBiZWNhdXNlYW5kIGFub3RoZXJhcHBlYXJlZCBvbnJlY29yZGVkIGluYmxhY2smcXVvdDttYXkgaW5jbHVkZXRoZSB3b3JsZCdzY2FuIGxlYWQgdG9yZWZlcnMgdG8gYWJvcmRlcj0iMCIgZ292ZXJubWVudCB3aW5uaW5nIHRoZXJlc3VsdGVkIGluIHdoaWxlIHRoZSBXYXNoaW5ndG9uLHRoZSBzdWJqZWN0Y2l0eSBpbiB0aGU+PC9kaXY+DQoJCXJlZmxlY3QgdGhldG8gY29tcGxldGViZWNhbWUgbW9yZXJhZGlvYWN0aXZlcmVqZWN0ZWQgYnl3aXRob3V0IGFueWhpcyBmYXRoZXIsd2hpY2ggY291bGRjb3B5IG9mIHRoZXRvIGluZGljYXRlYSBwb2xpdGljYWxhY2NvdW50cyBvZmNvbnN0aXR1dGVzd29ya2VkIHdpdGhlcjwvYT48L2xpPm9mIGhpcyBsaWZlYWNjb21wYW5pZWRjbGllbnRXaWR0aHByZXZlbnQgdGhlTGVnaXNsYXRpdmVkaWZmZXJlbnRseXRvZ2V0aGVyIGluaGFzIHNldmVyYWxmb3IgYW5vdGhlcnRleHQgb2YgdGhlZm91bmRlZCB0aGVlIHdpdGggdGhlIGlzIHVzZWQgZm9yY2hhbmdlZCB0aGV1c3VhbGx5IHRoZXBsYWNlIHdoZXJld2hlcmVhcyB0aGU+IDxhIGhyZWY9IiI+PGEgaHJlZj0idGhlbXNlbHZlcyxhbHRob3VnaCBoZXRoYXQgY2FuIGJldHJhZGl0aW9uYWxyb2xlIG9mIHRoZWFzIGEgcmVzdWx0cmVtb3ZlQ2hpbGRkZXNpZ25lZCBieXdlc3Qgb2YgdGhlU29tZSBwZW9wbGVwcm9kdWN0aW9uLHNpZGUgb2YgdGhlbmV3c2xldHRlcnN1c2VkIGJ5IHRoZWRvd24gdG8gdGhlYWNjZXB0ZWQgYnlsaXZlIGluIHRoZWF0dGVtcHRzIHRvb3V0c2lkZSB0aGVmcmVxdWVuY2llc0hvd2V2ZXIsIGlucHJvZ3JhbW1lcnNhdCBsZWFzdCBpbmFwcHJveGltYXRlYWx0aG91Z2ggaXR3YXMgcGFydCBvZmFuZCB2YXJpb3VzR292ZXJub3Igb2Z0aGUgYXJ0aWNsZXR1cm5lZCBpbnRvPjxhIGhyZWY9Ii90aGUgZWNvbm9teWlzIHRoZSBtb3N0bW9zdCB3aWRlbHl3b3VsZCBsYXRlcmFuZCBwZXJoYXBzcmlzZSB0byB0aGVvY2N1cnMgd2hlbnVuZGVyIHdoaWNoY29uZGl0aW9ucy50aGUgd2VzdGVybnRoZW9yeSB0aGF0aXMgcHJvZHVjZWR0aGUgY2l0eSBvZmluIHdoaWNoIGhlc2VlbiBpbiB0aGV0aGUgY2VudHJhbGJ1aWxkaW5nIG9mbWFueSBvZiBoaXNhcmVhIG9mIHRoZWlzIHRoZSBvbmx5bW9zdCBvZiB0aGVtYW55IG9mIHRoZXRoZSBXZXN0ZXJuVGhlcmUgaXMgbm9leHRlbmRlZCB0b1N0YXRpc3RpY2FsY29sc3Bhbj0yIHxzaG9ydCBzdG9yeXBvc3NpYmxlIHRvdG9wb2xvZ2ljYWxjcml0aWNhbCBvZnJlcG9ydGVkIHRvYSBDaHJpc3RpYW5kZWNpc2lvbiB0b2lzIGVxdWFsIHRvcHJvYmxlbXMgb2ZUaGlzIGNhbiBiZW1lcmNoYW5kaXNlZm9yIG1vc3Qgb2ZubyBldmlkZW5jZWVkaXRpb25zIG9mZWxlbWVudHMgaW4mcXVvdDsuIFRoZWNvbS9pbWFnZXMvd2hpY2ggbWFrZXN0aGUgcHJvY2Vzc3JlbWFpbnMgdGhlbGl0ZXJhdHVyZSxpcyBhIG1lbWJlcnRoZSBwb3B1bGFydGhlIGFuY2llbnRwcm9ibGVtcyBpbnRpbWUgb2YgdGhlZGVmZWF0ZWQgYnlib2R5IG9mIHRoZWEgZmV3IHllYXJzbXVjaCBvZiB0aGV0aGUgd29yayBvZkNhbGlmb3JuaWEsc2VydmVkIGFzIGFnb3Zlcm5tZW50LmNvbmNlcHRzIG9mbW92ZW1lbnQgaW4JCTxkaXYgaWQ9Iml0IiB2YWx1ZT0ibGFuZ3VhZ2Ugb2ZhcyB0aGV5IGFyZXByb2R1Y2VkIGluaXMgdGhhdCB0aGVleHBsYWluIHRoZWRpdj48L2Rpdj4KSG93ZXZlciB0aGVsZWFkIHRvIHRoZQk8YSBocmVmPSIvd2FzIGdyYW50ZWRwZW9wbGUgaGF2ZWNvbnRpbnVhbGx5d2FzIHNlZW4gYXNhbmQgcmVsYXRlZHRoZSByb2xlIG9mcHJvcG9zZWQgYnlvZiB0aGUgYmVzdGVhY2ggb3RoZXIuQ29uc3RhbnRpbmVwZW9wbGUgZnJvbWRpYWxlY3RzIG9mdG8gcmV2aXNpb253YXMgcmVuYW1lZGEgc291cmNlIG9mdGhlIGluaXRpYWxsYXVuY2hlZCBpbnByb3ZpZGUgdGhldG8gdGhlIHdlc3R3aGVyZSB0aGVyZWFuZCBzaW1pbGFyYmV0d2VlbiB0d29pcyBhbHNvIHRoZUVuZ2xpc2ggYW5kY29uZGl0aW9ucyx0aGF0IGl0IHdhc2VudGl0bGVkIHRvdGhlbXNlbHZlcy5xdWFudGl0eSBvZnJhbnNwYXJlbmN5dGhlIHNhbWUgYXN0byBqb2luIHRoZWNvdW50cnkgYW5kdGhpcyBpcyB0aGVUaGlzIGxlZCB0b2Egc3RhdGVtZW50Y29udHJhc3QgdG9sYXN0SW5kZXhPZnRocm91Z2ggaGlzaXMgZGVzaWduZWR0aGUgdGVybSBpc2lzIHByb3ZpZGVkcHJvdGVjdCB0aGVuZzwvYT48L2xpPlRoZSBjdXJyZW50dGhlIHNpdGUgb2ZzdWJzdGFudGlhbGV4cGVyaWVuY2UsaW4gdGhlIFdlc3R0aGV5IHNob3VsZHNsb3ZlbsSNaW5hY29tZW50YXJpb3N1bml2ZXJzaWRhZGNvbmRpY2lvbmVzYWN0aXZpZGFkZXNleHBlcmllbmNpYXRlY25vbG9nw61hcHJvZHVjY2nDs25wdW50dWFjacOzbmFwbGljYWNpw7NuY29udHJhc2XDsWFjYXRlZ29yw61hc3JlZ2lzdHJhcnNlcHJvZmVzaW9uYWx0cmF0YW1pZW50b3JlZ8Otc3RyYXRlc2VjcmV0YXLDrWFwcmluY2lwYWxlc3Byb3RlY2Npw7NuaW1wb3J0YW50ZXNpbXBvcnRhbmNpYXBvc2liaWxpZGFkaW50ZXJlc2FudGVjcmVjaW1pZW50b25lY2VzaWRhZGVzc3VzY3JpYmlyc2Vhc29jaWFjacOzbmRpc3BvbmlibGVzZXZhbHVhY2nDs25lc3R1ZGlhbnRlc3Jlc3BvbnNhYmxlcmVzb2x1Y2nDs25ndWFkYWxhamFyYXJlZ2lzdHJhZG9zb3BvcnR1bmlkYWRjb21lcmNpYWxlc2ZvdG9ncmFmw61hYXV0b3JpZGFkZXNpbmdlbmllcsOtYXRlbGV2aXNpw7NuY29tcGV0ZW5jaWFvcGVyYWNpb25lc2VzdGFibGVjaWRvc2ltcGxlbWVudGVhY3R1YWxtZW50ZW5hdmVnYWNpw7NuY29uZm9ybWlkYWRsaW5lLWhlaWdodDpmb250LWZhbWlseToiIDogImh0dHA6Ly9hcHBsaWNhdGlvbnNsaW5rIiBocmVmPSJzcGVjaWZpY2FsbHkvLzwhW0NEQVRBWwpPcmdhbml6YXRpb25kaXN0cmlidXRpb24wcHg7IGhlaWdodDpyZWxhdGlvbnNoaXBkZXZpY2Utd2lkdGg8ZGl2IGNsYXNzPSI8bGFiZWwgZm9yPSJyZWdpc3RyYXRpb248L25vc2NyaXB0PgovaW5kZXguaHRtbCJ3aW5kb3cub3BlbiggIWltcG9ydGFudDthcHBsaWNhdGlvbi9pbmRlcGVuZGVuY2UvL3d3dy5nb29nbGVvcmdhbml6YXRpb25hdXRvY29tcGxldGVyZXF1aXJlbWVudHNjb25zZXJ2YXRpdmU8Zm9ybSBuYW1lPSJpbnRlbGxlY3R1YWxtYXJnaW4tbGVmdDoxOHRoIGNlbnR1cnlhbiBpbXBvcnRhbnRpbnN0aXR1dGlvbnNhYmJyZXZpYXRpb248aW1nIGNsYXNzPSJvcmdhbmlzYXRpb25jaXZpbGl6YXRpb24xOXRoIGNlbnR1cnlhcmNoaXRlY3R1cmVpbmNvcnBvcmF0ZWQyMHRoIGNlbnR1cnktY29udGFpbmVyIj5tb3N0IG5vdGFibHkvPjwvYT48L2Rpdj5ub3RpZmljYXRpb24ndW5kZWZpbmVkJylGdXJ0aGVybW9yZSxiZWxpZXZlIHRoYXRpbm5lckhUTUwgPSBwcmlvciB0byB0aGVkcmFtYXRpY2FsbHlyZWZlcnJpbmcgdG9uZWdvdGlhdGlvbnNoZWFkcXVhcnRlcnNTb3V0aCBBZnJpY2F1bnN1Y2Nlc3NmdWxQZW5uc3lsdmFuaWFBcyBhIHJlc3VsdCw8aHRtbCBsYW5nPSImbHQ7L3N1cCZndDtkZWFsaW5nIHdpdGhwaGlsYWRlbHBoaWFoaXN0b3JpY2FsbHkpOzwvc2NyaXB0PgpwYWRkaW5nLXRvcDpleHBlcmltZW50YWxnZXRBdHRyaWJ1dGVpbnN0cnVjdGlvbnN0ZWNobm9sb2dpZXNwYXJ0IG9mIHRoZSA9ZnVuY3Rpb24oKXtzdWJzY3JpcHRpb25sLmR0ZCI+DQo8aHRnZW9ncmFwaGljYWxDb25zdGl0dXRpb24nLCBmdW5jdGlvbihzdXBwb3J0ZWQgYnlhZ3JpY3VsdHVyYWxjb25zdHJ1Y3Rpb25wdWJsaWNhdGlvbnNmb250LXNpemU6IDFhIHZhcmlldHkgb2Y8ZGl2IHN0eWxlPSJFbmN5Y2xvcGVkaWFpZnJhbWUgc3JjPSJkZW1vbnN0cmF0ZWRhY2NvbXBsaXNoZWR1bml2ZXJzaXRpZXNEZW1vZ3JhcGhpY3MpOzwvc2NyaXB0PjxkZWRpY2F0ZWQgdG9rbm93bGVkZ2Ugb2ZzYXRpc2ZhY3Rpb25wYXJ0aWN1bGFybHk8L2Rpdj48L2Rpdj5FbmdsaXNoIChVUylhcHBlbmRDaGlsZCh0cmFuc21pc3Npb25zLiBIb3dldmVyLCBpbnRlbGxpZ2VuY2UiIHRhYmluZGV4PSJmbG9hdDpyaWdodDtDb21tb253ZWFsdGhyYW5naW5nIGZyb21pbiB3aGljaCB0aGVhdCBsZWFzdCBvbmVyZXByb2R1Y3Rpb25lbmN5Y2xvcGVkaWE7Zm9udC1zaXplOjFqdXJpc2RpY3Rpb25hdCB0aGF0IHRpbWUiPjxhIGNsYXNzPSJJbiBhZGRpdGlvbixkZXNjcmlwdGlvbitjb252ZXJzYXRpb25jb250YWN0IHdpdGhpcyBnZW5lcmFsbHlyIiBjb250ZW50PSJyZXByZXNlbnRpbmcmbHQ7bWF0aCZndDtwcmVzZW50YXRpb25vY2Nhc2lvbmFsbHk8aW1nIHdpZHRoPSJuYXZpZ2F0aW9uIj5jb21wZW5zYXRpb25jaGFtcGlvbnNoaXBtZWRpYT0iYWxsIiB2aW9sYXRpb24gb2ZyZWZlcmVuY2UgdG9yZXR1cm4gdHJ1ZTtTdHJpY3QvL0VOIiB0cmFuc2FjdGlvbnNpbnRlcnZlbnRpb252ZXJpZmljYXRpb25JbmZvcm1hdGlvbiBkaWZmaWN1bHRpZXNDaGFtcGlvbnNoaXBjYXBhYmlsaXRpZXM8IVtlbmRpZl0tLT59Cjwvc2NyaXB0PgpDaHJpc3RpYW5pdHlmb3IgZXhhbXBsZSxQcm9mZXNzaW9uYWxyZXN0cmljdGlvbnNzdWdnZXN0IHRoYXR3YXMgcmVsZWFzZWQoc3VjaCBhcyB0aGVyZW1vdmVDbGFzcyh1bmVtcGxveW1lbnR0aGUgQW1lcmljYW5zdHJ1Y3R1cmUgb2YvaW5kZXguaHRtbCBwdWJsaXNoZWQgaW5zcGFuIGNsYXNzPSIiPjxhIGhyZWY9Ii9pbnRyb2R1Y3Rpb25iZWxvbmdpbmcgdG9jbGFpbWVkIHRoYXRjb25zZXF1ZW5jZXM8bWV0YSBuYW1lPSJHdWlkZSB0byB0aGVvdmVyd2hlbG1pbmdhZ2FpbnN0IHRoZSBjb25jZW50cmF0ZWQsCi5ub250b3VjaCBvYnNlcnZhdGlvbnM8L2E+CjwvZGl2PgpmIChkb2N1bWVudC5ib3JkZXI6IDFweCB7Zm9udC1zaXplOjF0cmVhdG1lbnQgb2YwIiBoZWlnaHQ9IjFtb2RpZmljYXRpb25JbmRlcGVuZGVuY2VkaXZpZGVkIGludG9ncmVhdGVyIHRoYW5hY2hpZXZlbWVudHNlc3RhYmxpc2hpbmdKYXZhU2NyaXB0IiBuZXZlcnRoZWxlc3NzaWduaWZpY2FuY2VCcm9hZGNhc3Rpbmc+Jm5ic3A7PC90ZD5jb250YWluZXIiPgpzdWNoIGFzIHRoZSBpbmZsdWVuY2Ugb2ZhIHBhcnRpY3VsYXJzcmM9J2h0dHA6Ly9uYXZpZ2F0aW9uIiBoYWxmIG9mIHRoZSBzdWJzdGFudGlhbCAmbmJzcDs8L2Rpdj5hZHZhbnRhZ2Ugb2ZkaXNjb3Zlcnkgb2ZmdW5kYW1lbnRhbCBtZXRyb3BvbGl0YW50aGUgb3Bwb3NpdGUiIHhtbDpsYW5nPSJkZWxpYmVyYXRlbHlhbGlnbj1jZW50ZXJldm9sdXRpb24gb2ZwcmVzZXJ2YXRpb25pbXByb3ZlbWVudHNiZWdpbm5pbmcgaW5KZXN1cyBDaHJpc3RQdWJsaWNhdGlvbnNkaXNhZ3JlZW1lbnR0ZXh0LWFsaWduOnIsIGZ1bmN0aW9uKClzaW1pbGFyaXRpZXNib2R5PjwvaHRtbD5pcyBjdXJyZW50bHlhbHBoYWJldGljYWxpcyBzb21ldGltZXN0eXBlPSJpbWFnZS9tYW55IG9mIHRoZSBmbG93OmhpZGRlbjthdmFpbGFibGUgaW5kZXNjcmliZSB0aGVleGlzdGVuY2Ugb2ZhbGwgb3ZlciB0aGV0aGUgSW50ZXJuZXQJPHVsIGNsYXNzPSJpbnN0YWxsYXRpb25uZWlnaGJvcmhvb2Rhcm1lZCBmb3JjZXNyZWR1Y2luZyB0aGVjb250aW51ZXMgdG9Ob25ldGhlbGVzcyx0ZW1wZXJhdHVyZXMKCQk8YSBocmVmPSJjbG9zZSB0byB0aGVleGFtcGxlcyBvZiBpcyBhYm91dCB0aGUoc2VlIGJlbG93KS4iIGlkPSJzZWFyY2hwcm9mZXNzaW9uYWxpcyBhdmFpbGFibGV0aGUgb2ZmaWNpYWwJCTwvc2NyaXB0PgoKCQk8ZGl2IGlkPSJhY2NlbGVyYXRpb250aHJvdWdoIHRoZSBIYWxsIG9mIEZhbWVkZXNjcmlwdGlvbnN0cmFuc2xhdGlvbnNpbnRlcmZlcmVuY2UgdHlwZT0ndGV4dC9yZWNlbnQgeWVhcnNpbiB0aGUgd29ybGR2ZXJ5IHBvcHVsYXJ7YmFja2dyb3VuZDp0cmFkaXRpb25hbCBzb21lIG9mIHRoZSBjb25uZWN0ZWQgdG9leHBsb2l0YXRpb25lbWVyZ2VuY2Ugb2Zjb25zdGl0dXRpb25BIEhpc3Rvcnkgb2ZzaWduaWZpY2FudCBtYW51ZmFjdHVyZWRleHBlY3RhdGlvbnM+PG5vc2NyaXB0PjxjYW4gYmUgZm91bmRiZWNhdXNlIHRoZSBoYXMgbm90IGJlZW5uZWlnaGJvdXJpbmd3aXRob3V0IHRoZSBhZGRlZCB0byB0aGUJPGxpIGNsYXNzPSJpbnN0cnVtZW50YWxTb3ZpZXQgVW5pb25hY2tub3dsZWRnZWR3aGljaCBjYW4gYmVuYW1lIGZvciB0aGVhdHRlbnRpb24gdG9hdHRlbXB0cyB0byBkZXZlbG9wbWVudHNJbiBmYWN0LCB0aGU8bGkgY2xhc3M9ImFpbXBsaWNhdGlvbnNzdWl0YWJsZSBmb3JtdWNoIG9mIHRoZSBjb2xvbml6YXRpb25wcmVzaWRlbnRpYWxjYW5jZWxCdWJibGUgSW5mb3JtYXRpb25tb3N0IG9mIHRoZSBpcyBkZXNjcmliZWRyZXN0IG9mIHRoZSBtb3JlIG9yIGxlc3NpbiBTZXB0ZW1iZXJJbnRlbGxpZ2VuY2VzcmM9Imh0dHA6Ly9weDsgaGVpZ2h0OiBhdmFpbGFibGUgdG9tYW51ZmFjdHVyZXJodW1hbiByaWdodHNsaW5rIGhyZWY9Ii9hdmFpbGFiaWxpdHlwcm9wb3J0aW9uYWxvdXRzaWRlIHRoZSBhc3Ryb25vbWljYWxodW1hbiBiZWluZ3NuYW1lIG9mIHRoZSBhcmUgZm91bmQgaW5hcmUgYmFzZWQgb25zbWFsbGVyIHRoYW5hIHBlcnNvbiB3aG9leHBhbnNpb24gb2Zhcmd1aW5nIHRoYXRub3cga25vd24gYXNJbiB0aGUgZWFybHlpbnRlcm1lZGlhdGVkZXJpdmVkIGZyb21TY2FuZGluYXZpYW48L2E+PC9kaXY+DQpjb25zaWRlciB0aGVhbiBlc3RpbWF0ZWR0aGUgTmF0aW9uYWw8ZGl2IGlkPSJwYWdyZXN1bHRpbmcgaW5jb21taXNzaW9uZWRhbmFsb2dvdXMgdG9hcmUgcmVxdWlyZWQvdWw+CjwvZGl2Pgp3YXMgYmFzZWQgb25hbmQgYmVjYW1lIGEmbmJzcDsmbmJzcDt0IiB2YWx1ZT0iIiB3YXMgY2FwdHVyZWRubyBtb3JlIHRoYW5yZXNwZWN0aXZlbHljb250aW51ZSB0byA+DQo8aGVhZD4NCjx3ZXJlIGNyZWF0ZWRtb3JlIGdlbmVyYWxpbmZvcm1hdGlvbiB1c2VkIGZvciB0aGVpbmRlcGVuZGVudCB0aGUgSW1wZXJpYWxjb21wb25lbnQgb2Z0byB0aGUgbm9ydGhpbmNsdWRlIHRoZSBDb25zdHJ1Y3Rpb25zaWRlIG9mIHRoZSB3b3VsZCBub3QgYmVmb3IgaW5zdGFuY2VpbnZlbnRpb24gb2Ztb3JlIGNvbXBsZXhjb2xsZWN0aXZlbHliYWNrZ3JvdW5kOiB0ZXh0LWFsaWduOiBpdHMgb3JpZ2luYWxpbnRvIGFjY291bnR0aGlzIHByb2Nlc3NhbiBleHRlbnNpdmVob3dldmVyLCB0aGV0aGV5IGFyZSBub3RyZWplY3RlZCB0aGVjcml0aWNpc20gb2ZkdXJpbmcgd2hpY2hwcm9iYWJseSB0aGV0aGlzIGFydGljbGUoZnVuY3Rpb24oKXtJdCBzaG91bGQgYmVhbiBhZ3JlZW1lbnRhY2NpZGVudGFsbHlkaWZmZXJzIGZyb21BcmNoaXRlY3R1cmViZXR0ZXIga25vd25hcnJhbmdlbWVudHNpbmZsdWVuY2Ugb25hdHRlbmRlZCB0aGVpZGVudGljYWwgdG9zb3V0aCBvZiB0aGVwYXNzIHRocm91Z2h4bWwiIHRpdGxlPSJ3ZWlnaHQ6Ym9sZDtjcmVhdGluZyB0aGVkaXNwbGF5Om5vbmVyZXBsYWNlZCB0aGU8aW1nIHNyYz0iL2lodHRwczovL3d3dy5Xb3JsZCBXYXIgSUl0ZXN0aW1vbmlhbHNmb3VuZCBpbiB0aGVyZXF1aXJlZCB0byBhbmQgdGhhdCB0aGViZXR3ZWVuIHRoZSB3YXMgZGVzaWduZWRjb25zaXN0cyBvZiBjb25zaWRlcmFibHlwdWJsaXNoZWQgYnl0aGUgbGFuZ3VhZ2VDb25zZXJ2YXRpb25jb25zaXN0ZWQgb2ZyZWZlciB0byB0aGViYWNrIHRvIHRoZSBjc3MiIG1lZGlhPSJQZW9wbGUgZnJvbSBhdmFpbGFibGUgb25wcm92ZWQgdG8gYmVzdWdnZXN0aW9ucyJ3YXMga25vd24gYXN2YXJpZXRpZXMgb2ZsaWtlbHkgdG8gYmVjb21wcmlzZWQgb2ZzdXBwb3J0IHRoZSBoYW5kcyBvZiB0aGVjb3VwbGVkIHdpdGhjb25uZWN0IGFuZCBib3JkZXI6bm9uZTtwZXJmb3JtYW5jZXNiZWZvcmUgYmVpbmdsYXRlciBiZWNhbWVjYWxjdWxhdGlvbnNvZnRlbiBjYWxsZWRyZXNpZGVudHMgb2ZtZWFuaW5nIHRoYXQ+PGxpIGNsYXNzPSJldmlkZW5jZSBmb3JleHBsYW5hdGlvbnNlbnZpcm9ubWVudHMiPjwvYT48L2Rpdj53aGljaCBhbGxvd3NJbnRyb2R1Y3Rpb25kZXZlbG9wZWQgYnlhIHdpZGUgcmFuZ2VvbiBiZWhhbGYgb2Z2YWxpZ249InRvcCJwcmluY2lwbGUgb2ZhdCB0aGUgdGltZSw8L25vc2NyaXB0Pg1zYWlkIHRvIGhhdmVpbiB0aGUgZmlyc3R3aGlsZSBvdGhlcnNoeXBvdGhldGljYWxwaGlsb3NvcGhlcnNwb3dlciBvZiB0aGVjb250YWluZWQgaW5wZXJmb3JtZWQgYnlpbmFiaWxpdHkgdG93ZXJlIHdyaXR0ZW5zcGFuIHN0eWxlPSJpbnB1dCBuYW1lPSJ0aGUgcXVlc3Rpb25pbnRlbmRlZCBmb3JyZWplY3Rpb24gb2ZpbXBsaWVzIHRoYXRpbnZlbnRlZCB0aGV0aGUgc3RhbmRhcmR3YXMgcHJvYmFibHlsaW5rIGJldHdlZW5wcm9mZXNzb3Igb2ZpbnRlcmFjdGlvbnNjaGFuZ2luZyB0aGVJbmRpYW4gT2NlYW4gY2xhc3M9Imxhc3R3b3JraW5nIHdpdGgnaHR0cDovL3d3dy55ZWFycyBiZWZvcmVUaGlzIHdhcyB0aGVyZWNyZWF0aW9uYWxlbnRlcmluZyB0aGVtZWFzdXJlbWVudHNhbiBleHRyZW1lbHl2YWx1ZSBvZiB0aGVzdGFydCBvZiB0aGUKPC9zY3JpcHQ+CgphbiBlZmZvcnQgdG9pbmNyZWFzZSB0aGV0byB0aGUgc291dGhzcGFjaW5nPSIwIj5zdWZmaWNpZW50bHl0aGUgRXVyb3BlYW5jb252ZXJ0ZWQgdG9jbGVhclRpbWVvdXRkaWQgbm90IGhhdmVjb25zZXF1ZW50bHlmb3IgdGhlIG5leHRleHRlbnNpb24gb2ZlY29ub21pYyBhbmRhbHRob3VnaCB0aGVhcmUgcHJvZHVjZWRhbmQgd2l0aCB0aGVpbnN1ZmZpY2llbnRnaXZlbiBieSB0aGVzdGF0aW5nIHRoYXRleHBlbmRpdHVyZXM8L3NwYW4+PC9hPgp0aG91Z2h0IHRoYXRvbiB0aGUgYmFzaXNjZWxscGFkZGluZz1pbWFnZSBvZiB0aGVyZXR1cm5pbmcgdG9pbmZvcm1hdGlvbixzZXBhcmF0ZWQgYnlhc3Nhc3NpbmF0ZWRzIiBjb250ZW50PSJhdXRob3JpdHkgb2Zub3J0aHdlc3Rlcm48L2Rpdj4KPGRpdiAiPjwvZGl2Pg0KICBjb25zdWx0YXRpb25jb21tdW5pdHkgb2Z0aGUgbmF0aW9uYWxpdCBzaG91bGQgYmVwYXJ0aWNpcGFudHMgYWxpZ249ImxlZnR0aGUgZ3JlYXRlc3RzZWxlY3Rpb24gb2ZzdXBlcm5hdHVyYWxkZXBlbmRlbnQgb25pcyBtZW50aW9uZWRhbGxvd2luZyB0aGV3YXMgaW52ZW50ZWRhY2NvbXBhbnlpbmdoaXMgcGVyc29uYWxhdmFpbGFibGUgYXRzdHVkeSBvZiB0aGVvbiB0aGUgb3RoZXJleGVjdXRpb24gb2ZIdW1hbiBSaWdodHN0ZXJtcyBvZiB0aGVhc3NvY2lhdGlvbnNyZXNlYXJjaCBhbmRzdWNjZWVkZWQgYnlkZWZlYXRlZCB0aGVhbmQgZnJvbSB0aGVidXQgdGhleSBhcmVjb21tYW5kZXIgb2ZzdGF0ZSBvZiB0aGV5ZWFycyBvZiBhZ2V0aGUgc3R1ZHkgb2Y8dWwgY2xhc3M9InNwbGFjZSBpbiB0aGV3aGVyZSBoZSB3YXM8bGkgY2xhc3M9ImZ0aGVyZSBhcmUgbm93aGljaCBiZWNhbWVoZSBwdWJsaXNoZWRleHByZXNzZWQgaW50byB3aGljaCB0aGVjb21taXNzaW9uZXJmb250LXdlaWdodDp0ZXJyaXRvcnkgb2ZleHRlbnNpb25zIj5Sb21hbiBFbXBpcmVlcXVhbCB0byB0aGVJbiBjb250cmFzdCxob3dldmVyLCBhbmRpcyB0eXBpY2FsbHlhbmQgaGlzIHdpZmUoYWxzbyBjYWxsZWQ+PHVsIGNsYXNzPSJlZmZlY3RpdmVseSBldm9sdmVkIGludG9zZWVtIHRvIGhhdmV3aGljaCBpcyB0aGV0aGVyZSB3YXMgbm9hbiBleGNlbGxlbnRhbGwgb2YgdGhlc2VkZXNjcmliZWQgYnlJbiBwcmFjdGljZSxicm9hZGNhc3RpbmdjaGFyZ2VkIHdpdGhyZWZsZWN0ZWQgaW5zdWJqZWN0ZWQgdG9taWxpdGFyeSBhbmR0byB0aGUgcG9pbnRlY29ub21pY2FsbHlzZXRUYXJnZXRpbmdhcmUgYWN0dWFsbHl2aWN0b3J5IG92ZXIoKTs8L3NjcmlwdD5jb250aW51b3VzbHlyZXF1aXJlZCBmb3Jldm9sdXRpb25hcnlhbiBlZmZlY3RpdmVub3J0aCBvZiB0aGUsIHdoaWNoIHdhcyBmcm9udCBvZiB0aGVvciBvdGhlcndpc2Vzb21lIGZvcm0gb2ZoYWQgbm90IGJlZW5nZW5lcmF0ZWQgYnlpbmZvcm1hdGlvbi5wZXJtaXR0ZWQgdG9pbmNsdWRlcyB0aGVkZXZlbG9wbWVudCxlbnRlcmVkIGludG90aGUgcHJldmlvdXNjb25zaXN0ZW50bHlhcmUga25vd24gYXN0aGUgZmllbGQgb2Z0aGlzIHR5cGUgb2ZnaXZlbiB0byB0aGV0aGUgdGl0bGUgb2Zjb250YWlucyB0aGVpbnN0YW5jZXMgb2ZpbiB0aGUgbm9ydGhkdWUgdG8gdGhlaXJhcmUgZGVzaWduZWRjb3Jwb3JhdGlvbnN3YXMgdGhhdCB0aGVvbmUgb2YgdGhlc2Vtb3JlIHBvcHVsYXJzdWNjZWVkZWQgaW5zdXBwb3J0IGZyb21pbiBkaWZmZXJlbnRkb21pbmF0ZWQgYnlkZXNpZ25lZCBmb3Jvd25lcnNoaXAgb2ZhbmQgcG9zc2libHlzdGFuZGFyZGl6ZWRyZXNwb25zZVRleHR3YXMgaW50ZW5kZWRyZWNlaXZlZCB0aGVhc3N1bWVkIHRoYXRhcmVhcyBvZiB0aGVwcmltYXJpbHkgaW50aGUgYmFzaXMgb2ZpbiB0aGUgc2Vuc2VhY2NvdW50cyBmb3JkZXN0cm95ZWQgYnlhdCBsZWFzdCB0d293YXMgZGVjbGFyZWRjb3VsZCBub3QgYmVTZWNyZXRhcnkgb2ZhcHBlYXIgdG8gYmVtYXJnaW4tdG9wOjEvXlxzK3xccyskL2dlKXt0aHJvdyBlfTt0aGUgc3RhcnQgb2Z0d28gc2VwYXJhdGVsYW5ndWFnZSBhbmR3aG8gaGFkIGJlZW5vcGVyYXRpb24gb2ZkZWF0aCBvZiB0aGVyZWFsIG51bWJlcnMJPGxpbmsgcmVsPSJwcm92aWRlZCB0aGV0aGUgc3Rvcnkgb2Zjb21wZXRpdGlvbnNlbmdsaXNoIChVSyllbmdsaXNoIChVUynQnNC+0L3Qs9C+0LvQodGA0L/RgdC60LjRgdGA0L/RgdC60LjRgdGA0L/RgdC60L7ZhNi52LHYqNmK2KnmraPpq5TkuK3mlofnroDkvZPkuK3mlofnuYHkvZPkuK3mlofmnInpmZDlhazlj7jkurrmsJHmlL/lupzpmL/ph4zlt7Tlt7TnpL7kvJrkuLvkuYnmk43kvZzns7vnu5/mlL/nrZbms5Xop4RpbmZvcm1hY2nDs25oZXJyYW1pZW50YXNlbGVjdHLDs25pY29kZXNjcmlwY2nDs25jbGFzaWZpY2Fkb3Njb25vY2ltaWVudG9wdWJsaWNhY2nDs25yZWxhY2lvbmFkYXNpbmZvcm3DoXRpY2FyZWxhY2lvbmFkb3NkZXBhcnRhbWVudG90cmFiYWphZG9yZXNkaXJlY3RhbWVudGVheXVudGFtaWVudG9tZXJjYWRvTGlicmVjb250w6FjdGVub3NoYWJpdGFjaW9uZXNjdW1wbGltaWVudG9yZXN0YXVyYW50ZXNkaXNwb3NpY2nDs25jb25zZWN1ZW5jaWFlbGVjdHLDs25pY2FhcGxpY2FjaW9uZXNkZXNjb25lY3RhZG9pbnN0YWxhY2nDs25yZWFsaXphY2nDs251dGlsaXphY2nDs25lbmNpY2xvcGVkaWFlbmZlcm1lZGFkZXNpbnN0cnVtZW50b3NleHBlcmllbmNpYXNpbnN0aXR1Y2nDs25wYXJ0aWN1bGFyZXNzdWJjYXRlZ29yaWHRgtC+0LvRjNC60L7QoNC+0YHRgdC40LjRgNCw0LHQvtGC0YvQsdC+0LvRjNGI0LXQv9GA0L7RgdGC0L7QvNC+0LbQtdGC0LXQtNGA0YPQs9C40YXRgdC70YPRh9Cw0LXRgdC10LnRh9Cw0YHQstGB0LXQs9C00LDQoNC+0YHRgdC40Y/QnNC+0YHQutCy0LXQtNGA0YPQs9C40LXQs9C+0YDQvtC00LDQstC+0L/RgNC+0YHQtNCw0L3QvdGL0YXQtNC+0LvQttC90YvQuNC80LXQvdC90L7QnNC+0YHQutCy0YvRgNGD0LHQu9C10LnQnNC+0YHQutCy0LDRgdGC0YDQsNC90YvQvdC40YfQtdCz0L7RgNCw0LHQvtGC0LXQtNC+0LvQttC10L3Rg9GB0LvRg9Cz0LjRgtC10L/QtdGA0YzQntC00L3QsNC60L7Qv9C+0YLQvtC80YPRgNCw0LHQvtGC0YPQsNC/0YDQtdC70Y/QstC+0L7QsdGJ0LXQvtC00L3QvtCz0L7RgdCy0L7QtdCz0L7RgdGC0LDRgtGM0LjQtNGA0YPQs9C+0LnRhNC+0YDRg9C80LXRhdC+0YDQvtGI0L7Qv9GA0L7RgtC40LLRgdGB0YvQu9C60LDQutCw0LbQtNGL0LnQstC70LDRgdGC0LjQs9GA0YPQv9C/0YvQstC80LXRgdGC0LXRgNCw0LHQvtGC0LDRgdC60LDQt9Cw0LvQv9C10YDQstGL0LnQtNC10LvQsNGC0YzQtNC10L3RjNCz0LjQv9C10YDQuNC+0LTQsdC40LfQvdC10YHQvtGB0L3QvtCy0LXQvNC+0LzQtdC90YLQutGD0L/QuNGC0YzQtNC+0LvQttC90LDRgNCw0LzQutCw0YXQvdCw0YfQsNC70L7QoNCw0LHQvtGC0LDQotC+0LvRjNC60L7RgdC+0LLRgdC10LzQstGC0L7RgNC+0LnQvdCw0YfQsNC70LDRgdC/0LjRgdC+0LrRgdC70YPQttCx0YvRgdC40YHRgtC10LzQv9C10YfQsNGC0LjQvdC+0LLQvtCz0L7Qv9C+0LzQvtGJ0LjRgdCw0LnRgtC+0LLQv9C+0YfQtdC80YPQv9C+0LzQvtGJ0YzQtNC+0LvQttC90L7RgdGB0YvQu9C60LjQsdGL0YHRgtGA0L7QtNCw0L3QvdGL0LXQvNC90L7Qs9C40LXQv9GA0L7QtdC60YLQodC10LnRh9Cw0YHQvNC+0LTQtdC70LjRgtCw0LrQvtCz0L7QvtC90LvQsNC50L3Qs9C+0YDQvtC00LXQstC10YDRgdC40Y/RgdGC0YDQsNC90LXRhNC40LvRjNC80YvRg9GA0L7QstC90Y/RgNCw0LfQvdGL0YXQuNGB0LrQsNGC0YzQvdC10LTQtdC70Y7Rj9C90LLQsNGA0Y/QvNC10L3RjNGI0LXQvNC90L7Qs9C40YXQtNCw0L3QvdC+0LnQt9C90LDRh9C40YLQvdC10LvRjNC30Y/RhNC+0YDRg9C80LDQotC10L/QtdGA0YzQvNC10YHRj9GG0LDQt9Cw0YnQuNGC0YvQm9GD0YfRiNC40LXgpKjgpLngpYDgpILgpJXgpLDgpKjgpYfgpIXgpKrgpKjgpYfgpJXgpL/gpK/gpL7gpJXgpLDgpYfgpILgpIXgpKjgpY3gpK/gpJXgpY3gpK/gpL7gpJfgpL7gpIfgpKHgpKzgpL7gpLDgpYfgpJXgpL/gpLjgpYDgpKbgpL/gpK/gpL7gpKrgpLngpLLgpYfgpLjgpL/gpILgpLngpK3gpL7gpLDgpKTgpIXgpKrgpKjgpYDgpLXgpL7gpLLgpYfgpLjgpYfgpLXgpL7gpJXgpLDgpKTgpYfgpK7gpYfgpLDgpYfgpLngpYvgpKjgpYfgpLjgpJXgpKTgpYfgpKzgpLngpYHgpKTgpLjgpL7gpIfgpJ/gpLngpYvgpJfgpL7gpJzgpL7gpKjgpYfgpK7gpL/gpKjgpJ/gpJXgpLDgpKTgpL7gpJXgpLDgpKjgpL7gpIngpKjgpJXgpYfgpK/gpLngpL7gpIHgpLjgpKzgpLjgpYfgpK3gpL7gpLfgpL7gpIbgpKrgpJXgpYfgpLLgpL/gpK/gpYfgpLbgpYHgpLDgpYLgpIfgpLjgpJXgpYfgpJjgpILgpJ/gpYfgpK7gpYfgpLDgpYDgpLjgpJXgpKTgpL7gpK7gpYfgpLDgpL7gpLLgpYfgpJXgpLDgpIXgpKfgpL/gpJXgpIXgpKrgpKjgpL7gpLjgpK7gpL7gpJzgpK7gpYHgpJ3gpYfgpJXgpL7gpLDgpKPgpLngpYvgpKTgpL7gpJXgpKHgpLzgpYDgpK/gpLngpL7gpILgpLngpYvgpJ/gpLLgpLbgpKzgpY3gpKbgpLLgpL/gpK/gpL7gpJzgpYDgpLXgpKjgpJzgpL7gpKTgpL7gpJXgpYjgpLjgpYfgpIbgpKrgpJXgpL7gpLXgpL7gpLLgpYDgpKbgpYfgpKjgpYfgpKrgpYLgpLDgpYDgpKrgpL7gpKjgpYDgpIngpLjgpJXgpYfgpLngpYvgpJfgpYDgpKzgpYjgpKDgpJXgpIbgpKrgpJXgpYDgpLXgpLDgpY3gpLfgpJfgpL7gpILgpLXgpIbgpKrgpJXgpYvgpJzgpL/gpLLgpL7gpJzgpL7gpKjgpL7gpLjgpLngpK7gpKTgpLngpK7gpYfgpILgpIngpKjgpJXgpYDgpK/gpL7gpLngpYLgpKbgpLDgpY3gpJzgpLjgpYLgpJrgpYDgpKrgpLjgpILgpKbgpLjgpLXgpL7gpLLgpLngpYvgpKjgpL7gpLngpYvgpKTgpYDgpJzgpYjgpLjgpYfgpLXgpL7gpKrgpLjgpJzgpKjgpKTgpL7gpKjgpYfgpKTgpL7gpJzgpL7gpLDgpYDgpJjgpL7gpK/gpLLgpJzgpL/gpLLgpYfgpKjgpYDgpJrgpYfgpJzgpL7gpILgpJrgpKrgpKTgpY3gpLDgpJfgpYLgpJfgpLLgpJzgpL7gpKTgpYfgpKzgpL7gpLngpLDgpIbgpKrgpKjgpYfgpLXgpL7gpLngpKjgpIfgpLjgpJXgpL7gpLjgpYHgpKzgpLngpLDgpLngpKjgpYfgpIfgpLjgpLjgpYfgpLjgpLngpL/gpKTgpKzgpKHgpLzgpYfgpJjgpJ/gpKjgpL7gpKTgpLLgpL7gpLbgpKrgpL7gpILgpJrgpLbgpY3gpLDgpYDgpKzgpKHgpLzgpYDgpLngpYvgpKTgpYfgpLjgpL7gpIjgpJ/gpLbgpL7gpK/gpKbgpLjgpJXgpKTgpYDgpJzgpL7gpKTgpYDgpLXgpL7gpLLgpL7gpLngpJzgpL7gpLDgpKrgpJ/gpKjgpL7gpLDgpJbgpKjgpYfgpLjgpKHgpLzgpJXgpK7gpL/gpLLgpL7gpIngpLjgpJXgpYDgpJXgpYfgpLXgpLLgpLLgpJfgpKTgpL7gpJbgpL7gpKjgpL7gpIXgpLDgpY3gpKXgpJzgpLngpL7gpILgpKbgpYfgpJbgpL7gpKrgpLngpLLgpYDgpKjgpL/gpK/gpK7gpKzgpL/gpKjgpL7gpKzgpYjgpILgpJXgpJXgpLngpYDgpILgpJXgpLngpKjgpL7gpKbgpYfgpKTgpL7gpLngpK7gpLLgpYfgpJXgpL7gpKvgpYDgpJzgpKzgpJXgpL/gpKTgpYHgpLDgpKTgpK7gpL7gpILgpJfgpLXgpLngpYDgpILgpLDgpYvgpJzgpLzgpK7gpL/gpLLgpYDgpIbgpLDgpYvgpKrgpLjgpYfgpKjgpL7gpK/gpL7gpKbgpLXgpLLgpYfgpKjgpYfgpJbgpL7gpKTgpL7gpJXgpLDgpYDgpKzgpIngpKjgpJXgpL7gpJzgpLXgpL7gpKzgpKrgpYLgpLDgpL7gpKzgpKHgpLzgpL7gpLjgpYzgpKbgpL7gpLbgpYfgpK/gpLDgpJXgpL/gpK/gpYfgpJXgpLngpL7gpILgpIXgpJXgpLjgpLDgpKzgpKjgpL7gpI/gpLXgpLngpL7gpILgpLjgpY3gpKXgpLLgpK7gpL/gpLLgpYfgpLLgpYfgpJbgpJXgpLXgpL/gpLfgpK/gpJXgpY3gpLDgpILgpLjgpK7gpYLgpLngpKXgpL7gpKjgpL7Yqtiz2KrYt9mK2LnZhdi02KfYsdmD2KnYqNmI2KfYs9i32KnYp9mE2LXZgdit2KnZhdmI2KfYttmK2LnYp9mE2K7Yp9i12KnYp9mE2YXYstmK2K/Yp9mE2LnYp9mF2KnYp9mE2YPYp9iq2KjYp9mE2LHYr9mI2K/YqNix2YbYp9mF2KzYp9mE2K/ZiNmE2KnYp9mE2LnYp9mE2YXYp9mE2YXZiNmC2LnYp9mE2LnYsdio2YrYp9mE2LPYsdmK2LnYp9mE2KzZiNin2YTYp9mE2LDZh9in2KjYp9mE2K3Zitin2KnYp9mE2K3ZgtmI2YLYp9mE2YPYsdmK2YXYp9mE2LnYsdin2YLZhdit2YHZiNi42KnYp9mE2KvYp9mG2YrZhdi02KfZh9iv2KnYp9mE2YXYsdij2KnYp9mE2YLYsdii2YbYp9mE2LTYqNin2KjYp9mE2K3ZiNin2LHYp9mE2KzYr9mK2K/Yp9mE2KPYs9ix2KnYp9mE2LnZhNmI2YXZhdis2YXZiNi52KnYp9mE2LHYrdmF2YbYp9mE2YbZgtin2LfZgdmE2LPYt9mK2YbYp9mE2YPZiNmK2KrYp9mE2K/ZhtmK2KfYqNix2YPYp9iq2YfYp9mE2LHZitin2LbYqtit2YrYp9iq2YrYqNiq2YjZgtmK2KrYp9mE2KPZiNmE2YnYp9mE2KjYsdmK2K/Yp9mE2YPZhNin2YXYp9mE2LHYp9io2LfYp9mE2LTYrti12YrYs9mK2KfYsdin2KrYp9mE2KvYp9mE2KvYp9mE2LXZhNin2KnYp9mE2K3Yr9mK2KvYp9mE2LLZiNin2LHYp9mE2K7ZhNmK2KzYp9mE2KzZhdmK2LnYp9mE2LnYp9mF2YfYp9mE2KzZhdin2YTYp9mE2LPYp9i52KnZhdi02KfZh9iv2YfYp9mE2LHYptmK2LPYp9mE2K/YrtmI2YTYp9mE2YHZhtmK2KnYp9mE2YPYqtin2KjYp9mE2K/ZiNix2YrYp9mE2K/YsdmI2LPYp9iz2KrYutix2YLYqti12KfZhdmK2YXYp9mE2KjZhtin2KrYp9mE2LnYuNmK2YVlbnRlcnRhaW5tZW50dW5kZXJzdGFuZGluZyA9IGZ1bmN0aW9uKCkuanBnIiB3aWR0aD0iY29uZmlndXJhdGlvbi5wbmciIHdpZHRoPSI8Ym9keSBjbGFzcz0iTWF0aC5yYW5kb20oKWNvbnRlbXBvcmFyeSBVbml0ZWQgU3RhdGVzY2lyY3Vtc3RhbmNlcy5hcHBlbmRDaGlsZChvcmdhbml6YXRpb25zPHNwYW4gY2xhc3M9IiI+PGltZyBzcmM9Ii9kaXN0aW5ndWlzaGVkdGhvdXNhbmRzIG9mIGNvbW11bmljYXRpb25jbGVhciI+PC9kaXY+aW52ZXN0aWdhdGlvbmZhdmljb24uaWNvIiBtYXJnaW4tcmlnaHQ6YmFzZWQgb24gdGhlIE1hc3NhY2h1c2V0dHN0YWJsZSBib3JkZXI9aW50ZXJuYXRpb25hbGFsc28ga25vd24gYXNwcm9udW5jaWF0aW9uYmFja2dyb3VuZDojZnBhZGRpbmctbGVmdDpGb3IgZXhhbXBsZSwgbWlzY2VsbGFuZW91cyZsdDsvbWF0aCZndDtwc3ljaG9sb2dpY2FsaW4gcGFydGljdWxhcmVhcmNoIiB0eXBlPSJmb3JtIG1ldGhvZD0iYXMgb3Bwb3NlZCB0b1N1cHJlbWUgQ291cnRvY2Nhc2lvbmFsbHkgQWRkaXRpb25hbGx5LE5vcnRoIEFtZXJpY2FweDtiYWNrZ3JvdW5kb3Bwb3J0dW5pdGllc0VudGVydGFpbm1lbnQudG9Mb3dlckNhc2UobWFudWZhY3R1cmluZ3Byb2Zlc3Npb25hbCBjb21iaW5lZCB3aXRoRm9yIGluc3RhbmNlLGNvbnNpc3Rpbmcgb2YiIG1heGxlbmd0aD0icmV0dXJuIGZhbHNlO2NvbnNjaW91c25lc3NNZWRpdGVycmFuZWFuZXh0cmFvcmRpbmFyeWFzc2Fzc2luYXRpb25zdWJzZXF1ZW50bHkgYnV0dG9uIHR5cGU9InRoZSBudW1iZXIgb2Z0aGUgb3JpZ2luYWwgY29tcHJlaGVuc2l2ZXJlZmVycyB0byB0aGU8L3VsPgo8L2Rpdj4KcGhpbG9zb3BoaWNhbGxvY2F0aW9uLmhyZWZ3YXMgcHVibGlzaGVkU2FuIEZyYW5jaXNjbyhmdW5jdGlvbigpewo8ZGl2IGlkPSJtYWluc29waGlzdGljYXRlZG1hdGhlbWF0aWNhbCAvaGVhZD4NCjxib2R5c3VnZ2VzdHMgdGhhdGRvY3VtZW50YXRpb25jb25jZW50cmF0aW9ucmVsYXRpb25zaGlwc21heSBoYXZlIGJlZW4oZm9yIGV4YW1wbGUsVGhpcyBhcnRpY2xlIGluIHNvbWUgY2FzZXNwYXJ0cyBvZiB0aGUgZGVmaW5pdGlvbiBvZkdyZWF0IEJyaXRhaW4gY2VsbHBhZGRpbmc9ZXF1aXZhbGVudCB0b3BsYWNlaG9sZGVyPSI7IGZvbnQtc2l6ZToganVzdGlmaWNhdGlvbmJlbGlldmVkIHRoYXRzdWZmZXJlZCBmcm9tYXR0ZW1wdGVkIHRvIGxlYWRlciBvZiB0aGVjcmlwdCIgc3JjPSIvKGZ1bmN0aW9uKCkge2FyZSBhdmFpbGFibGUKCTxsaW5rIHJlbD0iIHNyYz0naHR0cDovL2ludGVyZXN0ZWQgaW5jb252ZW50aW9uYWwgIiBhbHQ9IiIgLz48L2FyZSBnZW5lcmFsbHloYXMgYWxzbyBiZWVubW9zdCBwb3B1bGFyIGNvcnJlc3BvbmRpbmdjcmVkaXRlZCB3aXRodHlsZT0iYm9yZGVyOjwvYT48L3NwYW4+PC8uZ2lmIiB3aWR0aD0iPGlmcmFtZSBzcmM9InRhYmxlIGNsYXNzPSJpbmxpbmUtYmxvY2s7YWNjb3JkaW5nIHRvIHRvZ2V0aGVyIHdpdGhhcHByb3hpbWF0ZWx5cGFybGlhbWVudGFyeW1vcmUgYW5kIG1vcmVkaXNwbGF5Om5vbmU7dHJhZGl0aW9uYWxseXByZWRvbWluYW50bHkmbmJzcDt8Jm5ic3A7Jm5ic3A7PC9zcGFuPiBjZWxsc3BhY2luZz08aW5wdXQgbmFtZT0ib3IiIGNvbnRlbnQ9ImNvbnRyb3ZlcnNpYWxwcm9wZXJ0eT0ib2c6L3gtc2hvY2t3YXZlLWRlbW9uc3RyYXRpb25zdXJyb3VuZGVkIGJ5TmV2ZXJ0aGVsZXNzLHdhcyB0aGUgZmlyc3Rjb25zaWRlcmFibGUgQWx0aG91Z2ggdGhlIGNvbGxhYm9yYXRpb25zaG91bGQgbm90IGJlcHJvcG9ydGlvbiBvZjxzcGFuIHN0eWxlPSJrbm93biBhcyB0aGUgc2hvcnRseSBhZnRlcmZvciBpbnN0YW5jZSxkZXNjcmliZWQgYXMgL2hlYWQ+Cjxib2R5IHN0YXJ0aW5nIHdpdGhpbmNyZWFzaW5nbHkgdGhlIGZhY3QgdGhhdGRpc2N1c3Npb24gb2ZtaWRkbGUgb2YgdGhlYW4gaW5kaXZpZHVhbGRpZmZpY3VsdCB0byBwb2ludCBvZiB2aWV3aG9tb3NleHVhbGl0eWFjY2VwdGFuY2Ugb2Y8L3NwYW4+PC9kaXY+bWFudWZhY3R1cmVyc29yaWdpbiBvZiB0aGVjb21tb25seSB1c2VkaW1wb3J0YW5jZSBvZmRlbm9taW5hdGlvbnNiYWNrZ3JvdW5kOiAjbGVuZ3RoIG9mIHRoZWRldGVybWluYXRpb25hIHNpZ25pZmljYW50IiBib3JkZXI9IjAiPnJldm9sdXRpb25hcnlwcmluY2lwbGVzIG9maXMgY29uc2lkZXJlZHdhcyBkZXZlbG9wZWRJbmRvLUV1cm9wZWFudnVsbmVyYWJsZSB0b3Byb3BvbmVudHMgb2ZhcmUgc29tZXRpbWVzY2xvc2VyIHRvIHRoZU5ldyBZb3JrIENpdHkgbmFtZT0ic2VhcmNoYXR0cmlidXRlZCB0b2NvdXJzZSBvZiB0aGVtYXRoZW1hdGljaWFuYnkgdGhlIGVuZCBvZmF0IHRoZSBlbmQgb2YiIGJvcmRlcj0iMCIgdGVjaG5vbG9naWNhbC5yZW1vdmVDbGFzcyhicmFuY2ggb2YgdGhlZXZpZGVuY2UgdGhhdCFbZW5kaWZdLS0+DQpJbnN0aXR1dGUgb2YgaW50byBhIHNpbmdsZXJlc3BlY3RpdmVseS5hbmQgdGhlcmVmb3JlcHJvcGVydGllcyBvZmlzIGxvY2F0ZWQgaW5zb21lIG9mIHdoaWNoVGhlcmUgaXMgYWxzb2NvbnRpbnVlZCB0byBhcHBlYXJhbmNlIG9mICZhbXA7bmRhc2g7IGRlc2NyaWJlcyB0aGVjb25zaWRlcmF0aW9uYXV0aG9yIG9mIHRoZWluZGVwZW5kZW50bHllcXVpcHBlZCB3aXRoZG9lcyBub3QgaGF2ZTwvYT48YSBocmVmPSJjb25mdXNlZCB3aXRoPGxpbmsgaHJlZj0iL2F0IHRoZSBhZ2Ugb2ZhcHBlYXIgaW4gdGhlVGhlc2UgaW5jbHVkZXJlZ2FyZGxlc3Mgb2Zjb3VsZCBiZSB1c2VkIHN0eWxlPSZxdW90O3NldmVyYWwgdGltZXNyZXByZXNlbnQgdGhlYm9keT4KPC9odG1sPnRob3VnaHQgdG8gYmVwb3B1bGF0aW9uIG9mcG9zc2liaWxpdGllc3BlcmNlbnRhZ2Ugb2ZhY2Nlc3MgdG8gdGhlYW4gYXR0ZW1wdCB0b3Byb2R1Y3Rpb24gb2ZqcXVlcnkvanF1ZXJ5dHdvIGRpZmZlcmVudGJlbG9uZyB0byB0aGVlc3RhYmxpc2htZW50cmVwbGFjaW5nIHRoZWRlc2NyaXB0aW9uIiBkZXRlcm1pbmUgdGhlYXZhaWxhYmxlIGZvckFjY29yZGluZyB0byB3aWRlIHJhbmdlIG9mCTxkaXYgY2xhc3M9Im1vcmUgY29tbW9ubHlvcmdhbmlzYXRpb25zZnVuY3Rpb25hbGl0eXdhcyBjb21wbGV0ZWQgJmFtcDttZGFzaDsgcGFydGljaXBhdGlvbnRoZSBjaGFyYWN0ZXJhbiBhZGRpdGlvbmFsYXBwZWFycyB0byBiZWZhY3QgdGhhdCB0aGVhbiBleGFtcGxlIG9mc2lnbmlmaWNhbnRseW9ubW91c2VvdmVyPSJiZWNhdXNlIHRoZXkgYXN5bmMgPSB0cnVlO3Byb2JsZW1zIHdpdGhzZWVtcyB0byBoYXZldGhlIHJlc3VsdCBvZiBzcmM9Imh0dHA6Ly9mYW1pbGlhciB3aXRocG9zc2Vzc2lvbiBvZmZ1bmN0aW9uICgpIHt0b29rIHBsYWNlIGluYW5kIHNvbWV0aW1lc3N1YnN0YW50aWFsbHk8c3Bhbj48L3NwYW4+aXMgb2Z0ZW4gdXNlZGluIGFuIGF0dGVtcHRncmVhdCBkZWFsIG9mRW52aXJvbm1lbnRhbHN1Y2Nlc3NmdWxseSB2aXJ0dWFsbHkgYWxsMjB0aCBjZW50dXJ5LHByb2Zlc3Npb25hbHNuZWNlc3NhcnkgdG8gZGV0ZXJtaW5lZCBieWNvbXBhdGliaWxpdHliZWNhdXNlIGl0IGlzRGljdGlvbmFyeSBvZm1vZGlmaWNhdGlvbnNUaGUgZm9sbG93aW5nbWF5IHJlZmVyIHRvOkNvbnNlcXVlbnRseSxJbnRlcm5hdGlvbmFsYWx0aG91Z2ggc29tZXRoYXQgd291bGQgYmV3b3JsZCdzIGZpcnN0Y2xhc3NpZmllZCBhc2JvdHRvbSBvZiB0aGUocGFydGljdWxhcmx5YWxpZ249ImxlZnQiIG1vc3QgY29tbW9ubHliYXNpcyBmb3IgdGhlZm91bmRhdGlvbiBvZmNvbnRyaWJ1dGlvbnNwb3B1bGFyaXR5IG9mY2VudGVyIG9mIHRoZXRvIHJlZHVjZSB0aGVqdXJpc2RpY3Rpb25zYXBwcm94aW1hdGlvbiBvbm1vdXNlb3V0PSJOZXcgVGVzdGFtZW50Y29sbGVjdGlvbiBvZjwvc3Bhbj48L2E+PC9pbiB0aGUgVW5pdGVkZmlsbSBkaXJlY3Rvci1zdHJpY3QuZHRkIj5oYXMgYmVlbiB1c2VkcmV0dXJuIHRvIHRoZWFsdGhvdWdoIHRoaXNjaGFuZ2UgaW4gdGhlc2V2ZXJhbCBvdGhlcmJ1dCB0aGVyZSBhcmV1bnByZWNlZGVudGVkaXMgc2ltaWxhciB0b2VzcGVjaWFsbHkgaW53ZWlnaHQ6IGJvbGQ7aXMgY2FsbGVkIHRoZWNvbXB1dGF0aW9uYWxpbmRpY2F0ZSB0aGF0cmVzdHJpY3RlZCB0bwk8bWV0YSBuYW1lPSJhcmUgdHlwaWNhbGx5Y29uZmxpY3Qgd2l0aEhvd2V2ZXIsIHRoZSBBbiBleGFtcGxlIG9mY29tcGFyZWQgd2l0aHF1YW50aXRpZXMgb2ZyYXRoZXIgdGhhbiBhY29uc3RlbGxhdGlvbm5lY2Vzc2FyeSBmb3JyZXBvcnRlZCB0aGF0c3BlY2lmaWNhdGlvbnBvbGl0aWNhbCBhbmQmbmJzcDsmbmJzcDs8cmVmZXJlbmNlcyB0b3RoZSBzYW1lIHllYXJHb3Zlcm5tZW50IG9mZ2VuZXJhdGlvbiBvZmhhdmUgbm90IGJlZW5zZXZlcmFsIHllYXJzY29tbWl0bWVudCB0bwkJPHVsIGNsYXNzPSJ2aXN1YWxpemF0aW9uMTl0aCBjZW50dXJ5LHByYWN0aXRpb25lcnN0aGF0IGhlIHdvdWxkYW5kIGNvbnRpbnVlZG9jY3VwYXRpb24gb2ZpcyBkZWZpbmVkIGFzY2VudHJlIG9mIHRoZXRoZSBhbW91bnQgb2Y+PGRpdiBzdHlsZT0iZXF1aXZhbGVudCBvZmRpZmZlcmVudGlhdGVicm91Z2h0IGFib3V0bWFyZ2luLWxlZnQ6IGF1dG9tYXRpY2FsbHl0aG91Z2h0IG9mIGFzU29tZSBvZiB0aGVzZQo8ZGl2IGNsYXNzPSJpbnB1dCBjbGFzcz0icmVwbGFjZWQgd2l0aGlzIG9uZSBvZiB0aGVlZHVjYXRpb24gYW5kaW5mbHVlbmNlZCBieXJlcHV0YXRpb24gYXMKPG1ldGEgbmFtZT0iYWNjb21tb2RhdGlvbjwvZGl2Pgo8L2Rpdj5sYXJnZSBwYXJ0IG9mSW5zdGl0dXRlIGZvcnRoZSBzby1jYWxsZWQgYWdhaW5zdCB0aGUgSW4gdGhpcyBjYXNlLHdhcyBhcHBvaW50ZWRjbGFpbWVkIHRvIGJlSG93ZXZlciwgdGhpc0RlcGFydG1lbnQgb2Z0aGUgcmVtYWluaW5nZWZmZWN0IG9uIHRoZXBhcnRpY3VsYXJseSBkZWFsIHdpdGggdGhlCjxkaXYgc3R5bGU9ImFsbW9zdCBhbHdheXNhcmUgY3VycmVudGx5ZXhwcmVzc2lvbiBvZnBoaWxvc29waHkgb2Zmb3IgbW9yZSB0aGFuY2l2aWxpemF0aW9uc29uIHRoZSBpc2xhbmRzZWxlY3RlZEluZGV4Y2FuIHJlc3VsdCBpbiIgdmFsdWU9IiIgLz50aGUgc3RydWN0dXJlIC8+PC9hPjwvZGl2Pk1hbnkgb2YgdGhlc2VjYXVzZWQgYnkgdGhlb2YgdGhlIFVuaXRlZHNwYW4gY2xhc3M9Im1jYW4gYmUgdHJhY2VkaXMgcmVsYXRlZCB0b2JlY2FtZSBvbmUgb2ZpcyBmcmVxdWVudGx5bGl2aW5nIGluIHRoZXRoZW9yZXRpY2FsbHlGb2xsb3dpbmcgdGhlUmV2b2x1dGlvbmFyeWdvdmVybm1lbnQgaW5pcyBkZXRlcm1pbmVkdGhlIHBvbGl0aWNhbGludHJvZHVjZWQgaW5zdWZmaWNpZW50IHRvZGVzY3JpcHRpb24iPnNob3J0IHN0b3JpZXNzZXBhcmF0aW9uIG9mYXMgdG8gd2hldGhlcmtub3duIGZvciBpdHN3YXMgaW5pdGlhbGx5ZGlzcGxheTpibG9ja2lzIGFuIGV4YW1wbGV0aGUgcHJpbmNpcGFsY29uc2lzdHMgb2YgYXJlY29nbml6ZWQgYXMvYm9keT48L2h0bWw+YSBzdWJzdGFudGlhbHJlY29uc3RydWN0ZWRoZWFkIG9mIHN0YXRlcmVzaXN0YW5jZSB0b3VuZGVyZ3JhZHVhdGVUaGVyZSBhcmUgdHdvZ3Jhdml0YXRpb25hbGFyZSBkZXNjcmliZWRpbnRlbnRpb25hbGx5c2VydmVkIGFzIHRoZWNsYXNzPSJoZWFkZXJvcHBvc2l0aW9uIHRvZnVuZGFtZW50YWxseWRvbWluYXRlZCB0aGVhbmQgdGhlIG90aGVyYWxsaWFuY2Ugd2l0aHdhcyBmb3JjZWQgdG9yZXNwZWN0aXZlbHksYW5kIHBvbGl0aWNhbGluIHN1cHBvcnQgb2ZwZW9wbGUgaW4gdGhlMjB0aCBjZW50dXJ5LmFuZCBwdWJsaXNoZWRsb2FkQ2hhcnRiZWF0dG8gdW5kZXJzdGFuZG1lbWJlciBzdGF0ZXNlbnZpcm9ubWVudGFsZmlyc3QgaGFsZiBvZmNvdW50cmllcyBhbmRhcmNoaXRlY3R1cmFsYmUgY29uc2lkZXJlZGNoYXJhY3Rlcml6ZWRjbGVhckludGVydmFsYXV0aG9yaXRhdGl2ZUZlZGVyYXRpb24gb2Z3YXMgc3VjY2VlZGVkYW5kIHRoZXJlIGFyZWEgY29uc2VxdWVuY2V0aGUgUHJlc2lkZW50YWxzbyBpbmNsdWRlZGZyZWUgc29mdHdhcmVzdWNjZXNzaW9uIG9mZGV2ZWxvcGVkIHRoZXdhcyBkZXN0cm95ZWRhd2F5IGZyb20gdGhlOwo8L3NjcmlwdD4KPGFsdGhvdWdoIHRoZXlmb2xsb3dlZCBieSBhbW9yZSBwb3dlcmZ1bHJlc3VsdGVkIGluIGFVbml2ZXJzaXR5IG9mSG93ZXZlciwgbWFueXRoZSBwcmVzaWRlbnRIb3dldmVyLCBzb21laXMgdGhvdWdodCB0b3VudGlsIHRoZSBlbmR3YXMgYW5ub3VuY2VkYXJlIGltcG9ydGFudGFsc28gaW5jbHVkZXM+PGlucHV0IHR5cGU9dGhlIGNlbnRlciBvZiBETyBOT1QgQUxURVJ1c2VkIHRvIHJlZmVydGhlbWVzLz9zb3J0PXRoYXQgaGFkIGJlZW50aGUgYmFzaXMgZm9yaGFzIGRldmVsb3BlZGluIHRoZSBzdW1tZXJjb21wYXJhdGl2ZWx5ZGVzY3JpYmVkIHRoZXN1Y2ggYXMgdGhvc2V0aGUgcmVzdWx0aW5naXMgaW1wb3NzaWJsZXZhcmlvdXMgb3RoZXJTb3V0aCBBZnJpY2FuaGF2ZSB0aGUgc2FtZWVmZmVjdGl2ZW5lc3NpbiB3aGljaCBjYXNlOyB0ZXh0LWFsaWduOnN0cnVjdHVyZSBhbmQ7IGJhY2tncm91bmQ6cmVnYXJkaW5nIHRoZXN1cHBvcnRlZCB0aGVpcyBhbHNvIGtub3duc3R5bGU9Im1hcmdpbmluY2x1ZGluZyB0aGViYWhhc2EgTWVsYXl1bm9yc2sgYm9rbcOlbG5vcnNrIG55bm9yc2tzbG92ZW7FocSNaW5haW50ZXJuYWNpb25hbGNhbGlmaWNhY2nDs25jb211bmljYWNpw7NuY29uc3RydWNjacOzbiI+PGRpdiBjbGFzcz0iZGlzYW1iaWd1YXRpb25Eb21haW5OYW1lJywgJ2FkbWluaXN0cmF0aW9uc2ltdWx0YW5lb3VzbHl0cmFuc3BvcnRhdGlvbkludGVybmF0aW9uYWwgbWFyZ2luLWJvdHRvbTpyZXNwb25zaWJpbGl0eTwhW2VuZGlmXS0tPgo8Lz48bWV0YSBuYW1lPSJpbXBsZW1lbnRhdGlvbmluZnJhc3RydWN0dXJlcmVwcmVzZW50YXRpb25ib3JkZXItYm90dG9tOjwvaGVhZD4KPGJvZHk+PWh0dHAlM0ElMkYlMkY8Zm9ybSBtZXRob2Q9Im1ldGhvZD0icG9zdCIgL2Zhdmljb24uaWNvIiB9KTsKPC9zY3JpcHQ+Ci5zZXRBdHRyaWJ1dGUoQWRtaW5pc3RyYXRpb249IG5ldyBBcnJheSgpOzwhW2VuZGlmXS0tPg0KZGlzcGxheTpibG9jaztVbmZvcnR1bmF0ZWx5LCI+Jm5ic3A7PC9kaXY+L2Zhdmljb24uaWNvIj49J3N0eWxlc2hlZXQnIGlkZW50aWZpY2F0aW9uLCBmb3IgZXhhbXBsZSw8bGk+PGEgaHJlZj0iL2FuIGFsdGVybmF0aXZlYXMgYSByZXN1bHQgb2ZwdCI+PC9zY3JpcHQ+CnR5cGU9InN1Ym1pdCIgCihmdW5jdGlvbigpIHtyZWNvbW1lbmRhdGlvbmZvcm0gYWN0aW9uPSIvdHJhbnNmb3JtYXRpb25yZWNvbnN0cnVjdGlvbi5zdHlsZS5kaXNwbGF5IEFjY29yZGluZyB0byBoaWRkZW4iIG5hbWU9ImFsb25nIHdpdGggdGhlZG9jdW1lbnQuYm9keS5hcHByb3hpbWF0ZWx5IENvbW11bmljYXRpb25zcG9zdCIgYWN0aW9uPSJtZWFuaW5nICZxdW90Oy0tPCFbZW5kaWZdLS0+UHJpbWUgTWluaXN0ZXJjaGFyYWN0ZXJpc3RpYzwvYT4gPGEgY2xhc3M9dGhlIGhpc3Rvcnkgb2Ygb25tb3VzZW92ZXI9InRoZSBnb3Zlcm5tZW50aHJlZj0iaHR0cHM6Ly93YXMgb3JpZ2luYWxseXdhcyBpbnRyb2R1Y2VkY2xhc3NpZmljYXRpb25yZXByZXNlbnRhdGl2ZWFyZSBjb25zaWRlcmVkPCFbZW5kaWZdLS0+CgpkZXBlbmRzIG9uIHRoZVVuaXZlcnNpdHkgb2YgaW4gY29udHJhc3QgdG8gcGxhY2Vob2xkZXI9ImluIHRoZSBjYXNlIG9maW50ZXJuYXRpb25hbCBjb25zdGl0dXRpb25hbHN0eWxlPSJib3JkZXItOiBmdW5jdGlvbigpIHtCZWNhdXNlIG9mIHRoZS1zdHJpY3QuZHRkIj4KPHRhYmxlIGNsYXNzPSJhY2NvbXBhbmllZCBieWFjY291bnQgb2YgdGhlPHNjcmlwdCBzcmM9Ii9uYXR1cmUgb2YgdGhlIHRoZSBwZW9wbGUgaW4gaW4gYWRkaXRpb24gdG9zKTsganMuaWQgPSBpZCIgd2lkdGg9IjEwMCUicmVnYXJkaW5nIHRoZSBSb21hbiBDYXRob2xpY2FuIGluZGVwZW5kZW50Zm9sbG93aW5nIHRoZSAuZ2lmIiB3aWR0aD0iMXRoZSBmb2xsb3dpbmcgZGlzY3JpbWluYXRpb25hcmNoYWVvbG9naWNhbHByaW1lIG1pbmlzdGVyLmpzIj48L3NjcmlwdD5jb21iaW5hdGlvbiBvZiBtYXJnaW53aWR0aD0iY3JlYXRlRWxlbWVudCh3LmF0dGFjaEV2ZW50KDwvYT48L3RkPjwvdHI+c3JjPSJodHRwczovL2FJbiBwYXJ0aWN1bGFyLCBhbGlnbj0ibGVmdCIgQ3plY2ggUmVwdWJsaWNVbml0ZWQgS2luZ2RvbWNvcnJlc3BvbmRlbmNlY29uY2x1ZGVkIHRoYXQuaHRtbCIgdGl0bGU9IihmdW5jdGlvbiAoKSB7Y29tZXMgZnJvbSB0aGVhcHBsaWNhdGlvbiBvZjxzcGFuIGNsYXNzPSJzYmVsaWV2ZWQgdG8gYmVlbWVudCgnc2NyaXB0JzwvYT4KPC9saT4KPGxpdmVyeSBkaWZmZXJlbnQ+PHNwYW4gY2xhc3M9Im9wdGlvbiB2YWx1ZT0iKGFsc28ga25vd24gYXMJPGxpPjxhIGhyZWY9Ij48aW5wdXQgbmFtZT0ic2VwYXJhdGVkIGZyb21yZWZlcnJlZCB0byBhcyB2YWxpZ249InRvcCI+Zm91bmRlciBvZiB0aGVhdHRlbXB0aW5nIHRvIGNhcmJvbiBkaW94aWRlCgo8ZGl2IGNsYXNzPSJjbGFzcz0ic2VhcmNoLS9ib2R5Pgo8L2h0bWw+b3Bwb3J0dW5pdHkgdG9jb21tdW5pY2F0aW9uczwvaGVhZD4NCjxib2R5IHN0eWxlPSJ3aWR0aDpUaeG6v25nIFZp4buHdGNoYW5nZXMgaW4gdGhlYm9yZGVyLWNvbG9yOiMwIiBib3JkZXI9IjAiIDwvc3Bhbj48L2Rpdj48d2FzIGRpc2NvdmVyZWQiIHR5cGU9InRleHQiICk7Cjwvc2NyaXB0PgoKRGVwYXJ0bWVudCBvZiBlY2NsZXNpYXN0aWNhbHRoZXJlIGhhcyBiZWVucmVzdWx0aW5nIGZyb208L2JvZHk+PC9odG1sPmhhcyBuZXZlciBiZWVudGhlIGZpcnN0IHRpbWVpbiByZXNwb25zZSB0b2F1dG9tYXRpY2FsbHkgPC9kaXY+Cgo8ZGl2IGl3YXMgY29uc2lkZXJlZHBlcmNlbnQgb2YgdGhlIiAvPjwvYT48L2Rpdj5jb2xsZWN0aW9uIG9mIGRlc2NlbmRlZCBmcm9tc2VjdGlvbiBvZiB0aGVhY2NlcHQtY2hhcnNldHRvIGJlIGNvbmZ1c2VkbWVtYmVyIG9mIHRoZSBwYWRkaW5nLXJpZ2h0OnRyYW5zbGF0aW9uIG9maW50ZXJwcmV0YXRpb24gaHJlZj0naHR0cDovL3doZXRoZXIgb3Igbm90VGhlcmUgYXJlIGFsc290aGVyZSBhcmUgbWFueWEgc21hbGwgbnVtYmVyb3RoZXIgcGFydHMgb2ZpbXBvc3NpYmxlIHRvICBjbGFzcz0iYnV0dG9ubG9jYXRlZCBpbiB0aGUuIEhvd2V2ZXIsIHRoZWFuZCBldmVudHVhbGx5QXQgdGhlIGVuZCBvZiBiZWNhdXNlIG9mIGl0c3JlcHJlc2VudHMgdGhlPGZvcm0gYWN0aW9uPSIgbWV0aG9kPSJwb3N0Iml0IGlzIHBvc3NpYmxlbW9yZSBsaWtlbHkgdG9hbiBpbmNyZWFzZSBpbmhhdmUgYWxzbyBiZWVuY29ycmVzcG9uZHMgdG9hbm5vdW5jZWQgdGhhdGFsaWduPSJyaWdodCI+bWFueSBjb3VudHJpZXNmb3IgbWFueSB5ZWFyc2VhcmxpZXN0IGtub3duYmVjYXVzZSBpdCB3YXNwdCI+PC9zY3JpcHQ+DSB2YWxpZ249InRvcCIgaW5oYWJpdGFudHMgb2Zmb2xsb3dpbmcgeWVhcg0KPGRpdiBjbGFzcz0ibWlsbGlvbiBwZW9wbGVjb250cm92ZXJzaWFsIGNvbmNlcm5pbmcgdGhlYXJndWUgdGhhdCB0aGVnb3Zlcm5tZW50IGFuZGEgcmVmZXJlbmNlIHRvdHJhbnNmZXJyZWQgdG9kZXNjcmliaW5nIHRoZSBzdHlsZT0iY29sb3I6YWx0aG91Z2ggdGhlcmViZXN0IGtub3duIGZvcnN1Ym1pdCIgbmFtZT0ibXVsdGlwbGljYXRpb25tb3JlIHRoYW4gb25lIHJlY29nbml0aW9uIG9mQ291bmNpbCBvZiB0aGVlZGl0aW9uIG9mIHRoZSAgPG1ldGEgbmFtZT0iRW50ZXJ0YWlubWVudCBhd2F5IGZyb20gdGhlIDttYXJnaW4tcmlnaHQ6YXQgdGhlIHRpbWUgb2ZpbnZlc3RpZ2F0aW9uc2Nvbm5lY3RlZCB3aXRoYW5kIG1hbnkgb3RoZXJhbHRob3VnaCBpdCBpc2JlZ2lubmluZyB3aXRoIDxzcGFuIGNsYXNzPSJkZXNjZW5kYW50cyBvZjxzcGFuIGNsYXNzPSJpIGFsaWduPSJyaWdodCI8L2hlYWQ+Cjxib2R5IGFzcGVjdHMgb2YgdGhlaGFzIHNpbmNlIGJlZW5FdXJvcGVhbiBVbmlvbnJlbWluaXNjZW50IG9mbW9yZSBkaWZmaWN1bHRWaWNlIFByZXNpZGVudGNvbXBvc2l0aW9uIG9mcGFzc2VkIHRocm91Z2htb3JlIGltcG9ydGFudGZvbnQtc2l6ZToxMXB4ZXhwbGFuYXRpb24gb2Z0aGUgY29uY2VwdCBvZndyaXR0ZW4gaW4gdGhlCTxzcGFuIGNsYXNzPSJpcyBvbmUgb2YgdGhlIHJlc2VtYmxhbmNlIHRvb24gdGhlIGdyb3VuZHN3aGljaCBjb250YWluc2luY2x1ZGluZyB0aGUgZGVmaW5lZCBieSB0aGVwdWJsaWNhdGlvbiBvZm1lYW5zIHRoYXQgdGhlb3V0c2lkZSBvZiB0aGVzdXBwb3J0IG9mIHRoZTxpbnB1dCBjbGFzcz0iPHNwYW4gY2xhc3M9InQoTWF0aC5yYW5kb20oKW1vc3QgcHJvbWluZW50ZGVzY3JpcHRpb24gb2ZDb25zdGFudGlub3BsZXdlcmUgcHVibGlzaGVkPGRpdiBjbGFzcz0ic2VhcHBlYXJzIGluIHRoZTEiIGhlaWdodD0iMSIgbW9zdCBpbXBvcnRhbnR3aGljaCBpbmNsdWRlc3doaWNoIGhhZCBiZWVuZGVzdHJ1Y3Rpb24gb2Z0aGUgcG9wdWxhdGlvbgoJPGRpdiBjbGFzcz0icG9zc2liaWxpdHkgb2Zzb21ldGltZXMgdXNlZGFwcGVhciB0byBoYXZlc3VjY2VzcyBvZiB0aGVpbnRlbmRlZCB0byBiZXByZXNlbnQgaW4gdGhlc3R5bGU9ImNsZWFyOmINCjwvc2NyaXB0Pg0KPHdhcyBmb3VuZGVkIGluaW50ZXJ2aWV3IHdpdGhfaWQiIGNvbnRlbnQ9ImNhcGl0YWwgb2YgdGhlDQo8bGluayByZWw9InNyZWxlYXNlIG9mIHRoZXBvaW50IG91dCB0aGF0eE1MSHR0cFJlcXVlc3RhbmQgc3Vic2VxdWVudHNlY29uZCBsYXJnZXN0dmVyeSBpbXBvcnRhbnRzcGVjaWZpY2F0aW9uc3N1cmZhY2Ugb2YgdGhlYXBwbGllZCB0byB0aGVmb3JlaWduIHBvbGljeV9zZXREb21haW5OYW1lZXN0YWJsaXNoZWQgaW5pcyBiZWxpZXZlZCB0b0luIGFkZGl0aW9uIHRvbWVhbmluZyBvZiB0aGVpcyBuYW1lZCBhZnRlcnRvIHByb3RlY3QgdGhlaXMgcmVwcmVzZW50ZWREZWNsYXJhdGlvbiBvZm1vcmUgZWZmaWNpZW50Q2xhc3NpZmljYXRpb25vdGhlciBmb3JtcyBvZmhlIHJldHVybmVkIHRvPHNwYW4gY2xhc3M9ImNwZXJmb3JtYW5jZSBvZihmdW5jdGlvbigpIHsNaWYgYW5kIG9ubHkgaWZyZWdpb25zIG9mIHRoZWxlYWRpbmcgdG8gdGhlcmVsYXRpb25zIHdpdGhVbml0ZWQgTmF0aW9uc3N0eWxlPSJoZWlnaHQ6b3RoZXIgdGhhbiB0aGV5cGUiIGNvbnRlbnQ9IkFzc29jaWF0aW9uIG9mCjwvaGVhZD4KPGJvZHlsb2NhdGVkIG9uIHRoZWlzIHJlZmVycmVkIHRvKGluY2x1ZGluZyB0aGVjb25jZW50cmF0aW9uc3RoZSBpbmRpdmlkdWFsYW1vbmcgdGhlIG1vc3R0aGFuIGFueSBvdGhlci8+CjxsaW5rIHJlbD0iIHJldHVybiBmYWxzZTt0aGUgcHVycG9zZSBvZnRoZSBhYmlsaXR5IHRvO2NvbG9yOiNmZmZ9Ci4KPHNwYW4gY2xhc3M9InRoZSBzdWJqZWN0IG9mZGVmaW5pdGlvbnMgb2Y+DQo8bGluayByZWw9ImNsYWltIHRoYXQgdGhlaGF2ZSBkZXZlbG9wZWQ8dGFibGUgd2lkdGg9ImNlbGVicmF0aW9uIG9mRm9sbG93aW5nIHRoZSB0byBkaXN0aW5ndWlzaDxzcGFuIGNsYXNzPSJidGFrZXMgcGxhY2UgaW51bmRlciB0aGUgbmFtZW5vdGVkIHRoYXQgdGhlPjwhW2VuZGlmXS0tPgpzdHlsZT0ibWFyZ2luLWluc3RlYWQgb2YgdGhlaW50cm9kdWNlZCB0aGV0aGUgcHJvY2VzcyBvZmluY3JlYXNpbmcgdGhlZGlmZmVyZW5jZXMgaW5lc3RpbWF0ZWQgdGhhdGVzcGVjaWFsbHkgdGhlL2Rpdj48ZGl2IGlkPSJ3YXMgZXZlbnR1YWxseXRocm91Z2hvdXQgaGlzdGhlIGRpZmZlcmVuY2Vzb21ldGhpbmcgdGhhdHNwYW4+PC9zcGFuPjwvc2lnbmlmaWNhbnRseSA+PC9zY3JpcHQ+DQoNCmVudmlyb25tZW50YWwgdG8gcHJldmVudCB0aGVoYXZlIGJlZW4gdXNlZGVzcGVjaWFsbHkgZm9ydW5kZXJzdGFuZCB0aGVpcyBlc3NlbnRpYWxseXdlcmUgdGhlIGZpcnN0aXMgdGhlIGxhcmdlc3RoYXZlIGJlZW4gbWFkZSIgc3JjPSJodHRwOi8vaW50ZXJwcmV0ZWQgYXNzZWNvbmQgaGFsZiBvZmNyb2xsaW5nPSJubyIgaXMgY29tcG9zZWQgb2ZJSSwgSG9seSBSb21hbmlzIGV4cGVjdGVkIHRvaGF2ZSB0aGVpciBvd25kZWZpbmVkIGFzIHRoZXRyYWRpdGlvbmFsbHkgaGF2ZSBkaWZmZXJlbnRhcmUgb2Z0ZW4gdXNlZHRvIGVuc3VyZSB0aGF0YWdyZWVtZW50IHdpdGhjb250YWluaW5nIHRoZWFyZSBmcmVxdWVudGx5aW5mb3JtYXRpb24gb25leGFtcGxlIGlzIHRoZXJlc3VsdGluZyBpbiBhPC9hPjwvbGk+PC91bD4gY2xhc3M9ImZvb3RlcmFuZCBlc3BlY2lhbGx5dHlwZT0iYnV0dG9uIiA8L3NwYW4+PC9zcGFuPndoaWNoIGluY2x1ZGVkPgo8bWV0YSBuYW1lPSJjb25zaWRlcmVkIHRoZWNhcnJpZWQgb3V0IGJ5SG93ZXZlciwgaXQgaXNiZWNhbWUgcGFydCBvZmluIHJlbGF0aW9uIHRvcG9wdWxhciBpbiB0aGV0aGUgY2FwaXRhbCBvZndhcyBvZmZpY2lhbGx5d2hpY2ggaGFzIGJlZW50aGUgSGlzdG9yeSBvZmFsdGVybmF0aXZlIHRvZGlmZmVyZW50IGZyb210byBzdXBwb3J0IHRoZXN1Z2dlc3RlZCB0aGF0aW4gdGhlIHByb2Nlc3MgIDxkaXYgY2xhc3M9InRoZSBmb3VuZGF0aW9uYmVjYXVzZSBvZiBoaXNjb25jZXJuZWQgd2l0aHRoZSB1bml2ZXJzaXR5b3Bwb3NlZCB0byB0aGV0aGUgY29udGV4dCBvZjxzcGFuIGNsYXNzPSJwdGV4dCIgbmFtZT0icSIJCTxkaXYgY2xhc3M9InRoZSBzY2llbnRpZmljcmVwcmVzZW50ZWQgYnltYXRoZW1hdGljaWFuc2VsZWN0ZWQgYnkgdGhldGhhdCBoYXZlIGJlZW4+PGRpdiBjbGFzcz0iY2RpdiBpZD0iaGVhZGVyaW4gcGFydGljdWxhcixjb252ZXJ0ZWQgaW50byk7Cjwvc2NyaXB0Pgo8cGhpbG9zb3BoaWNhbCBzcnBza29ocnZhdHNraXRp4bq/bmcgVmnhu4d00KDRg9GB0YHQutC40LnRgNGD0YHRgdC60LjQuWludmVzdGlnYWNpw7NucGFydGljaXBhY2nDs27QutC+0YLQvtGA0YvQtdC+0LHQu9Cw0YHRgtC40LrQvtGC0L7RgNGL0LnRh9C10LvQvtCy0LXQutGB0LjRgdGC0LXQvNGL0J3QvtCy0L7RgdGC0LjQutC+0YLQvtGA0YvRhdC+0LHQu9Cw0YHRgtGM0LLRgNC10LzQtdC90LjQutC+0YLQvtGA0LDRj9GB0LXQs9C+0LTQvdGP0YHQutCw0YfQsNGC0YzQvdC+0LLQvtGB0YLQuNCj0LrRgNCw0LjQvdGL0LLQvtC/0YDQvtGB0YvQutC+0YLQvtGA0L7QudGB0LTQtdC70LDRgtGM0L/QvtC80L7RidGM0Y7RgdGA0LXQtNGB0YLQstC+0LHRgNCw0LfQvtC80YHRgtC+0YDQvtC90YvRg9GH0LDRgdGC0LjQtdGC0LXRh9C10L3QuNC10JPQu9Cw0LLQvdCw0Y/QuNGB0YLQvtGA0LjQuNGB0LjRgdGC0LXQvNCw0YDQtdGI0LXQvdC40Y/QodC60LDRh9Cw0YLRjNC/0L7RjdGC0L7QvNGD0YHQu9C10LTRg9C10YLRgdC60LDQt9Cw0YLRjNGC0L7QstCw0YDQvtCy0LrQvtC90LXRh9C90L7RgNC10YjQtdC90LjQtdC60L7RgtC+0YDQvtC10L7RgNCz0LDQvdC+0LLQutC+0YLQvtGA0L7QvNCg0LXQutC70LDQvNCw2KfZhNmF2YbYqtiv2YnZhdmG2KrYr9mK2KfYqtin2YTZhdmI2LbZiNi52KfZhNio2LHYp9mF2KzYp9mE2YXZiNin2YLYudin2YTYsdiz2KfYptmE2YXYtNin2LHZg9in2KrYp9mE2KPYudi22KfYodin2YTYsdmK2KfYttip2KfZhNiq2LXZhdmK2YXYp9mE2KfYudi22KfYodin2YTZhtiq2KfYptis2KfZhNij2YTYudin2KjYp9mE2KrYs9is2YrZhNin2YTYo9mC2LPYp9mF2KfZhNi22LrYt9in2KrYp9mE2YHZitiv2YrZiNin2YTYqtix2K3Zitio2KfZhNis2K/Zitiv2KnYp9mE2KrYudmE2YrZhdin2YTYo9iu2KjYp9ix2KfZhNin2YHZhNin2YXYp9mE2KPZgdmE2KfZhdin2YTYqtin2LHZitiu2KfZhNiq2YLZhtmK2KnYp9mE2KfZhNi52KfYqNin2YTYrtmI2KfYt9ix2KfZhNmF2KzYqtmF2LnYp9mE2K/ZitmD2YjYsdin2YTYs9mK2KfYrdip2LnYqNiv2KfZhNmE2YfYp9mE2KrYsdio2YrYqdin2YTYsdmI2KfYqNi32KfZhNij2K/YqNmK2KnYp9mE2KfYrtio2KfYsdin2YTZhdiq2K3Yr9ip2KfZhNin2LrYp9mG2YpjdXJzb3I6cG9pbnRlcjs8L3RpdGxlPgo8bWV0YSAiIGhyZWY9Imh0dHA6Ly8iPjxzcGFuIGNsYXNzPSJtZW1iZXJzIG9mIHRoZSB3aW5kb3cubG9jYXRpb252ZXJ0aWNhbC1hbGlnbjovYT4gfCA8YSBocmVmPSI8IWRvY3R5cGUgaHRtbD5tZWRpYT0ic2NyZWVuIiA8b3B0aW9uIHZhbHVlPSJmYXZpY29uLmljbyIgLz4KCQk8ZGl2IGNsYXNzPSJjaGFyYWN0ZXJpc3RpY3MiIG1ldGhvZD0iZ2V0IiAvYm9keT4KPC9odG1sPgpzaG9ydGN1dCBpY29uIiBkb2N1bWVudC53cml0ZShwYWRkaW5nLWJvdHRvbTpyZXByZXNlbnRhdGl2ZXNzdWJtaXQiIHZhbHVlPSJhbGlnbj0iY2VudGVyIiB0aHJvdWdob3V0IHRoZSBzY2llbmNlIGZpY3Rpb24KICA8ZGl2IGNsYXNzPSJzdWJtaXQiIGNsYXNzPSJvbmUgb2YgdGhlIG1vc3QgdmFsaWduPSJ0b3AiPjx3YXMgZXN0YWJsaXNoZWQpOw0KPC9zY3JpcHQ+DQpyZXR1cm4gZmFsc2U7Ij4pLnN0eWxlLmRpc3BsYXliZWNhdXNlIG9mIHRoZSBkb2N1bWVudC5jb29raWU8Zm9ybSBhY3Rpb249Ii99Ym9keXttYXJnaW46MDtFbmN5Y2xvcGVkaWEgb2Z2ZXJzaW9uIG9mIHRoZSAuY3JlYXRlRWxlbWVudChuYW1lIiBjb250ZW50PSI8L2Rpdj4KPC9kaXY+CgphZG1pbmlzdHJhdGl2ZSA8L2JvZHk+CjwvaHRtbD5oaXN0b3J5IG9mIHRoZSAiPjxpbnB1dCB0eXBlPSJwb3J0aW9uIG9mIHRoZSBhcyBwYXJ0IG9mIHRoZSAmbmJzcDs8YSBocmVmPSJvdGhlciBjb3VudHJpZXMiPgo8ZGl2IGNsYXNzPSI8L3NwYW4+PC9zcGFuPjxJbiBvdGhlciB3b3JkcyxkaXNwbGF5OiBibG9jaztjb250cm9sIG9mIHRoZSBpbnRyb2R1Y3Rpb24gb2YvPgo8bWV0YSBuYW1lPSJhcyB3ZWxsIGFzIHRoZSBpbiByZWNlbnQgeWVhcnMNCgk8ZGl2IGNsYXNzPSI8L2Rpdj4KCTwvZGl2PgppbnNwaXJlZCBieSB0aGV0aGUgZW5kIG9mIHRoZSBjb21wYXRpYmxlIHdpdGhiZWNhbWUga25vd24gYXMgc3R5bGU9Im1hcmdpbjouanMiPjwvc2NyaXB0PjwgSW50ZXJuYXRpb25hbCB0aGVyZSBoYXZlIGJlZW5HZXJtYW4gbGFuZ3VhZ2Ugc3R5bGU9ImNvbG9yOiNDb21tdW5pc3QgUGFydHljb25zaXN0ZW50IHdpdGhib3JkZXI9IjAiIGNlbGwgbWFyZ2luaGVpZ2h0PSJ0aGUgbWFqb3JpdHkgb2YiIGFsaWduPSJjZW50ZXJyZWxhdGVkIHRvIHRoZSBtYW55IGRpZmZlcmVudCBPcnRob2RveCBDaHVyY2hzaW1pbGFyIHRvIHRoZSAvPgo8bGluayByZWw9InN3YXMgb25lIG9mIHRoZSB1bnRpbCBoaXMgZGVhdGh9KSgpOwo8L3NjcmlwdD5vdGhlciBsYW5ndWFnZXNjb21wYXJlZCB0byB0aGVwb3J0aW9ucyBvZiB0aGV0aGUgTmV0aGVybGFuZHN0aGUgbW9zdCBjb21tb25iYWNrZ3JvdW5kOnVybChhcmd1ZWQgdGhhdCB0aGVzY3JvbGxpbmc9Im5vIiBpbmNsdWRlZCBpbiB0aGVOb3J0aCBBbWVyaWNhbiB0aGUgbmFtZSBvZiB0aGVpbnRlcnByZXRhdGlvbnN0aGUgdHJhZGl0aW9uYWxkZXZlbG9wbWVudCBvZiBmcmVxdWVudGx5IHVzZWRhIGNvbGxlY3Rpb24gb2Z2ZXJ5IHNpbWlsYXIgdG9zdXJyb3VuZGluZyB0aGVleGFtcGxlIG9mIHRoaXNhbGlnbj0iY2VudGVyIj53b3VsZCBoYXZlIGJlZW5pbWFnZV9jYXB0aW9uID1hdHRhY2hlZCB0byB0aGVzdWdnZXN0aW5nIHRoYXRpbiB0aGUgZm9ybSBvZiBpbnZvbHZlZCBpbiB0aGVpcyBkZXJpdmVkIGZyb21uYW1lZCBhZnRlciB0aGVJbnRyb2R1Y3Rpb24gdG9yZXN0cmljdGlvbnMgb24gc3R5bGU9IndpZHRoOiBjYW4gYmUgdXNlZCB0byB0aGUgY3JlYXRpb24gb2Ztb3N0IGltcG9ydGFudCBpbmZvcm1hdGlvbiBhbmRyZXN1bHRlZCBpbiB0aGVjb2xsYXBzZSBvZiB0aGVUaGlzIG1lYW5zIHRoYXRlbGVtZW50cyBvZiB0aGV3YXMgcmVwbGFjZWQgYnlhbmFseXNpcyBvZiB0aGVpbnNwaXJhdGlvbiBmb3JyZWdhcmRlZCBhcyB0aGVtb3N0IHN1Y2Nlc3NmdWxrbm93biBhcyAmcXVvdDthIGNvbXByZWhlbnNpdmVIaXN0b3J5IG9mIHRoZSB3ZXJlIGNvbnNpZGVyZWRyZXR1cm5lZCB0byB0aGVhcmUgcmVmZXJyZWQgdG9VbnNvdXJjZWQgaW1hZ2U+Cgk8ZGl2IGNsYXNzPSJjb25zaXN0cyBvZiB0aGVzdG9wUHJvcGFnYXRpb25pbnRlcmVzdCBpbiB0aGVhdmFpbGFiaWxpdHkgb2ZhcHBlYXJzIHRvIGhhdmVlbGVjdHJvbWFnbmV0aWNlbmFibGVTZXJ2aWNlcyhmdW5jdGlvbiBvZiB0aGVJdCBpcyBpbXBvcnRhbnQ8L3NjcmlwdD48L2Rpdj5mdW5jdGlvbigpe3ZhciByZWxhdGl2ZSB0byB0aGVhcyBhIHJlc3VsdCBvZiB0aGUgcG9zaXRpb24gb2ZGb3IgZXhhbXBsZSwgaW4gbWV0aG9kPSJwb3N0IiB3YXMgZm9sbG93ZWQgYnkmYW1wO21kYXNoOyB0aGV0aGUgYXBwbGljYXRpb25qcyI+PC9zY3JpcHQ+DQp1bD48L2Rpdj48L2Rpdj5hZnRlciB0aGUgZGVhdGh3aXRoIHJlc3BlY3QgdG9zdHlsZT0icGFkZGluZzppcyBwYXJ0aWN1bGFybHlkaXNwbGF5OmlubGluZTsgdHlwZT0ic3VibWl0IiBpcyBkaXZpZGVkIGludG/kuK3mlocgKOeugOS9kylyZXNwb25zYWJpbGlkYWRhZG1pbmlzdHJhY2nDs25pbnRlcm5hY2lvbmFsZXNjb3JyZXNwb25kaWVudGXgpIngpKrgpK/gpYvgpJfgpKrgpYLgpLDgpY3gpLXgpLngpK7gpL7gpLDgpYfgpLLgpYvgpJfgpYvgpILgpJrgpYHgpKjgpL7gpLXgpLLgpYfgpJXgpL/gpKjgpLjgpLDgpJXgpL7gpLDgpKrgpYHgpLLgpL/gpLjgpJbgpYvgpJzgpYfgpILgpJrgpL7gpLngpL/gpI/gpK3gpYfgpJzgpYfgpILgpLbgpL7gpK7gpL/gpLLgpLngpK7gpL7gpLDgpYDgpJzgpL7gpJfgpLDgpKPgpKzgpKjgpL7gpKjgpYfgpJXgpYHgpK7gpL7gpLDgpKzgpY3gpLLgpYngpJfgpK7gpL7gpLLgpL/gpJXgpK7gpLngpL/gpLLgpL7gpKrgpYPgpLfgpY3gpKDgpKzgpKLgpLzgpKTgpYfgpK3gpL7gpJzgpKrgpL7gpJXgpY3gpLLgpL/gpJXgpJ/gpY3gpLDgpYfgpKjgpJbgpL/gpLLgpL7gpKvgpKbgpYzgpLDgpL7gpKjgpK7gpL7gpK7gpLLgpYfgpK7gpKTgpKbgpL7gpKjgpKzgpL7gpJzgpL7gpLDgpLXgpL/gpJXgpL7gpLjgpJXgpY3gpK/gpYvgpILgpJrgpL7gpLngpKTgpYfgpKrgpLngpYHgpIHgpJrgpKzgpKTgpL7gpK/gpL7gpLjgpILgpLXgpL7gpKbgpKbgpYfgpJbgpKjgpYfgpKrgpL/gpJvgpLLgpYfgpLXgpL/gpLbgpYfgpLfgpLDgpL7gpJzgpY3gpK/gpIngpKTgpY3gpKTgpLDgpK7gpYHgpILgpKzgpIjgpKbgpYvgpKjgpYvgpILgpIngpKrgpJXgpLDgpKPgpKrgpKLgpLzgpYfgpILgpLjgpY3gpKXgpL/gpKTgpKvgpL/gpLLgpY3gpK7gpK7gpYHgpJbgpY3gpK/gpIXgpJrgpY3gpJvgpL7gpJvgpYLgpJ/gpKTgpYDgpLjgpILgpJfgpYDgpKTgpJzgpL7gpI/gpJfgpL7gpLXgpL/gpK3gpL7gpJfgpJjgpKPgpY3gpJ/gpYfgpKbgpYLgpLjgpLDgpYfgpKbgpL/gpKjgpYvgpILgpLngpKTgpY3gpK/gpL7gpLjgpYfgpJXgpY3gpLjgpJfgpL7gpILgpKfgpYDgpLXgpL/gpLbgpY3gpLXgpLDgpL7gpKTgpYfgpILgpKbgpYjgpJ/gpY3gpLjgpKjgpJXgpY3gpLbgpL7gpLjgpL7gpK7gpKjgpYfgpIXgpKbgpL7gpLLgpKTgpKzgpL/gpJzgpLLgpYDgpKrgpYHgpLDgpYLgpLfgpLngpL/gpILgpKbgpYDgpK7gpL/gpKTgpY3gpLDgpJXgpLXgpL/gpKTgpL7gpLDgpYHgpKrgpK/gpYfgpLjgpY3gpKXgpL7gpKjgpJXgpLDgpYvgpKHgpLzgpK7gpYHgpJXgpY3gpKTgpK/gpYvgpJzgpKjgpL7gpJXgpYPgpKrgpK/gpL7gpKrgpYvgpLjgpY3gpJ/gpJjgpLDgpYfgpLLgpYLgpJXgpL7gpLDgpY3gpK/gpLXgpL/gpJrgpL7gpLDgpLjgpYLgpJrgpKjgpL7gpK7gpYLgpLLgpY3gpK/gpKbgpYfgpJbgpYfgpILgpLngpK7gpYfgpLbgpL7gpLjgpY3gpJXgpYLgpLLgpK7gpYjgpILgpKjgpYfgpKTgpYjgpK/gpL7gpLDgpJzgpL/gpLjgpJXgpYdyc3MreG1sIiB0aXRsZT0iLXR5cGUiIGNvbnRlbnQ9InRpdGxlIiBjb250ZW50PSJhdCB0aGUgc2FtZSB0aW1lLmpzIj48L3NjcmlwdD4KPCIgbWV0aG9kPSJwb3N0IiA8L3NwYW4+PC9hPjwvbGk+dmVydGljYWwtYWxpZ246dC9qcXVlcnkubWluLmpzIj4uY2xpY2soZnVuY3Rpb24oIHN0eWxlPSJwYWRkaW5nLX0pKCk7Cjwvc2NyaXB0Pgo8L3NwYW4+PGEgaHJlZj0iPGEgaHJlZj0iaHR0cDovLyk7IHJldHVybiBmYWxzZTt0ZXh0LWRlY29yYXRpb246IHNjcm9sbGluZz0ibm8iIGJvcmRlci1jb2xsYXBzZTphc3NvY2lhdGVkIHdpdGggQmFoYXNhIEluZG9uZXNpYUVuZ2xpc2ggbGFuZ3VhZ2U8dGV4dCB4bWw6c3BhY2U9LmdpZiIgYm9yZGVyPSIwIjwvYm9keT4KPC9odG1sPgpvdmVyZmxvdzpoaWRkZW47aW1nIHNyYz0iaHR0cDovL2FkZEV2ZW50TGlzdGVuZXJyZXNwb25zaWJsZSBmb3Igcy5qcyI+PC9zY3JpcHQ+Ci9mYXZpY29uLmljbyIgLz5vcGVyYXRpbmcgc3lzdGVtIiBzdHlsZT0id2lkdGg6MXRhcmdldD0iX2JsYW5rIj5TdGF0ZSBVbml2ZXJzaXR5dGV4dC1hbGlnbjpsZWZ0Owpkb2N1bWVudC53cml0ZSgsIGluY2x1ZGluZyB0aGUgYXJvdW5kIHRoZSB3b3JsZCk7DQo8L3NjcmlwdD4NCjwiIHN0eWxlPSJoZWlnaHQ6O292ZXJmbG93OmhpZGRlbm1vcmUgaW5mb3JtYXRpb25hbiBpbnRlcm5hdGlvbmFsYSBtZW1iZXIgb2YgdGhlIG9uZSBvZiB0aGUgZmlyc3RjYW4gYmUgZm91bmQgaW4gPC9kaXY+CgkJPC9kaXY+CmRpc3BsYXk6IG5vbmU7Ij4iIC8+CjxsaW5rIHJlbD0iCiAgKGZ1bmN0aW9uKCkge3RoZSAxNXRoIGNlbnR1cnkucHJldmVudERlZmF1bHQobGFyZ2UgbnVtYmVyIG9mIEJ5emFudGluZSBFbXBpcmUuanBnfHRodW1ifGxlZnR8dmFzdCBtYWpvcml0eSBvZm1ham9yaXR5IG9mIHRoZSAgYWxpZ249ImNlbnRlciI+VW5pdmVyc2l0eSBQcmVzc2RvbWluYXRlZCBieSB0aGVTZWNvbmQgV29ybGQgV2FyZGlzdHJpYnV0aW9uIG9mIHN0eWxlPSJwb3NpdGlvbjp0aGUgcmVzdCBvZiB0aGUgY2hhcmFjdGVyaXplZCBieSByZWw9Im5vZm9sbG93Ij5kZXJpdmVzIGZyb20gdGhlcmF0aGVyIHRoYW4gdGhlIGEgY29tYmluYXRpb24gb2ZzdHlsZT0id2lkdGg6MTAwRW5nbGlzaC1zcGVha2luZ2NvbXB1dGVyIHNjaWVuY2Vib3JkZXI9IjAiIGFsdD0idGhlIGV4aXN0ZW5jZSBvZkRlbW9jcmF0aWMgUGFydHkiIHN0eWxlPSJtYXJnaW4tRm9yIHRoaXMgcmVhc29uLC5qcyI+PC9zY3JpcHQ+CglzQnlUYWdOYW1lKHMpWzBdanMiPjwvc2NyaXB0Pg0KPC5qcyI+PC9zY3JpcHQ+DQpsaW5rIHJlbD0iaWNvbiIgJyBhbHQ9JycgY2xhc3M9J2Zvcm1hdGlvbiBvZiB0aGV2ZXJzaW9ucyBvZiB0aGUgPC9hPjwvZGl2PjwvZGl2Pi9wYWdlPgogIDxwYWdlPgo8ZGl2IGNsYXNzPSJjb250YmVjYW1lIHRoZSBmaXJzdGJhaGFzYSBJbmRvbmVzaWFlbmdsaXNoIChzaW1wbGUpzpXOu867zrfOvc65zrrOrNGF0YDQstCw0YLRgdC60LjQutC+0LzQv9Cw0L3QuNC40Y/QstC70Y/QtdGC0YHRj9CU0L7QsdCw0LLQuNGC0YzRh9C10LvQvtCy0LXQutCw0YDQsNC30LLQuNGC0LjRj9CY0L3RgtC10YDQvdC10YLQntGC0LLQtdGC0LjRgtGM0L3QsNC/0YDQuNC80LXRgNC40L3RgtC10YDQvdC10YLQutC+0YLQvtGA0L7Qs9C+0YHRgtGA0LDQvdC40YbRi9C60LDRh9C10YHRgtCy0LXRg9GB0LvQvtCy0LjRj9GF0L/RgNC+0LHQu9C10LzRi9C/0L7Qu9GD0YfQuNGC0YzRj9Cy0LvRj9GO0YLRgdGP0L3QsNC40LHQvtC70LXQtdC60L7QvNC/0LDQvdC40Y/QstC90LjQvNCw0L3QuNC10YHRgNC10LTRgdGC0LLQsNin2YTZhdmI2KfYttmK2LnYp9mE2LHYptmK2LPZitip2KfZhNin2YbYqtmC2KfZhNmF2LTYp9ix2YPYp9iq2YPYp9mE2LPZitin2LHYp9iq2KfZhNmF2YPYqtmI2KjYqdin2YTYs9i52YjYr9mK2KnYp9it2LXYp9im2YrYp9iq2KfZhNi52KfZhNmF2YrYqdin2YTYtdmI2KrZitin2KrYp9mE2KfZhtiq2LHZhtiq2KfZhNiq2LXYp9mF2YrZhdin2YTYpdiz2YTYp9mF2YrYp9mE2YXYtNin2LHZg9ip2KfZhNmF2LHYptmK2KfYqnJvYm90cyIgY29udGVudD0iPGRpdiBpZD0iZm9vdGVyIj50aGUgVW5pdGVkIFN0YXRlczxpbWcgc3JjPSJodHRwOi8vLmpwZ3xyaWdodHx0aHVtYnwuanMiPjwvc2NyaXB0Pg0KPGxvY2F0aW9uLnByb3RvY29sZnJhbWVib3JkZXI9IjAiIHMiIC8+CjxtZXRhIG5hbWU9IjwvYT48L2Rpdj48L2Rpdj48Zm9udC13ZWlnaHQ6Ym9sZDsmcXVvdDsgYW5kICZxdW90O2RlcGVuZGluZyBvbiB0aGUgbWFyZ2luOjA7cGFkZGluZzoiIHJlbD0ibm9mb2xsb3ciIFByZXNpZGVudCBvZiB0aGUgdHdlbnRpZXRoIGNlbnR1cnlldmlzaW9uPgogIDwvcGFnZUludGVybmV0IEV4cGxvcmVyYS5hc3luYyA9IHRydWU7DQppbmZvcm1hdGlvbiBhYm91dDxkaXYgaWQ9ImhlYWRlciI+IiBhY3Rpb249Imh0dHA6Ly88YSBocmVmPSJodHRwczovLzxkaXYgaWQ9ImNvbnRlbnQiPC9kaXY+DQo8L2Rpdj4NCjxkZXJpdmVkIGZyb20gdGhlIDxpbWcgc3JjPSdodHRwOi8vYWNjb3JkaW5nIHRvIHRoZSAKPC9ib2R5Pgo8L2h0bWw+CnN0eWxlPSJmb250LXNpemU6c2NyaXB0IGxhbmd1YWdlPSJBcmlhbCwgSGVsdmV0aWNhLDwvYT48c3BhbiBjbGFzcz0iPC9zY3JpcHQ+PHNjcmlwdCBwb2xpdGljYWwgcGFydGllc3RkPjwvdHI+PC90YWJsZT48aHJlZj0iaHR0cDovL3d3dy5pbnRlcnByZXRhdGlvbiBvZnJlbD0ic3R5bGVzaGVldCIgZG9jdW1lbnQud3JpdGUoJzxjaGFyc2V0PSJ1dGYtOCI+CmJlZ2lubmluZyBvZiB0aGUgcmV2ZWFsZWQgdGhhdCB0aGV0ZWxldmlzaW9uIHNlcmllcyIgcmVsPSJub2ZvbGxvdyI+IHRhcmdldD0iX2JsYW5rIj5jbGFpbWluZyB0aGF0IHRoZWh0dHAlM0ElMkYlMkZ3d3cubWFuaWZlc3RhdGlvbnMgb2ZQcmltZSBNaW5pc3RlciBvZmluZmx1ZW5jZWQgYnkgdGhlY2xhc3M9ImNsZWFyZml4Ij4vZGl2Pg0KPC9kaXY+DQoNCnRocmVlLWRpbWVuc2lvbmFsQ2h1cmNoIG9mIEVuZ2xhbmRvZiBOb3J0aCBDYXJvbGluYXNxdWFyZSBraWxvbWV0cmVzLmFkZEV2ZW50TGlzdGVuZXJkaXN0aW5jdCBmcm9tIHRoZWNvbW1vbmx5IGtub3duIGFzUGhvbmV0aWMgQWxwaGFiZXRkZWNsYXJlZCB0aGF0IHRoZWNvbnRyb2xsZWQgYnkgdGhlQmVuamFtaW4gRnJhbmtsaW5yb2xlLXBsYXlpbmcgZ2FtZXRoZSBVbml2ZXJzaXR5IG9maW4gV2VzdGVybiBFdXJvcGVwZXJzb25hbCBjb21wdXRlclByb2plY3QgR3V0ZW5iZXJncmVnYXJkbGVzcyBvZiB0aGVoYXMgYmVlbiBwcm9wb3NlZHRvZ2V0aGVyIHdpdGggdGhlPjwvbGk+PGxpIGNsYXNzPSJpbiBzb21lIGNvdW50cmllc21pbi5qcyI+PC9zY3JpcHQ+b2YgdGhlIHBvcHVsYXRpb25vZmZpY2lhbCBsYW5ndWFnZTxpbWcgc3JjPSJpbWFnZXMvaWRlbnRpZmllZCBieSB0aGVuYXR1cmFsIHJlc291cmNlc2NsYXNzaWZpY2F0aW9uIG9mY2FuIGJlIGNvbnNpZGVyZWRxdWFudHVtIG1lY2hhbmljc05ldmVydGhlbGVzcywgdGhlbWlsbGlvbiB5ZWFycyBhZ288L2JvZHk+DQo8L2h0bWw+Dc6VzrvOu863zr3Ouc66zqwKdGFrZSBhZHZhbnRhZ2Ugb2ZhbmQsIGFjY29yZGluZyB0b2F0dHJpYnV0ZWQgdG8gdGhlTWljcm9zb2Z0IFdpbmRvd3N0aGUgZmlyc3QgY2VudHVyeXVuZGVyIHRoZSBjb250cm9sZGl2IGNsYXNzPSJoZWFkZXJzaG9ydGx5IGFmdGVyIHRoZW5vdGFibGUgZXhjZXB0aW9udGVucyBvZiB0aG91c2FuZHNzZXZlcmFsIGRpZmZlcmVudGFyb3VuZCB0aGUgd29ybGQucmVhY2hpbmcgbWlsaXRhcnlpc29sYXRlZCBmcm9tIHRoZW9wcG9zaXRpb24gdG8gdGhldGhlIE9sZCBUZXN0YW1lbnRBZnJpY2FuIEFtZXJpY2Fuc2luc2VydGVkIGludG8gdGhlc2VwYXJhdGUgZnJvbSB0aGVtZXRyb3BvbGl0YW4gYXJlYW1ha2VzIGl0IHBvc3NpYmxlYWNrbm93bGVkZ2VkIHRoYXRhcmd1YWJseSB0aGUgbW9zdHR5cGU9InRleHQvY3NzIj4KdGhlIEludGVybmF0aW9uYWxBY2NvcmRpbmcgdG8gdGhlIHBlPSJ0ZXh0L2NzcyIgLz4KY29pbmNpZGUgd2l0aCB0aGV0d28tdGhpcmRzIG9mIHRoZUR1cmluZyB0aGlzIHRpbWUsZHVyaW5nIHRoZSBwZXJpb2Rhbm5vdW5jZWQgdGhhdCBoZXRoZSBpbnRlcm5hdGlvbmFsYW5kIG1vcmUgcmVjZW50bHliZWxpZXZlZCB0aGF0IHRoZWNvbnNjaW91c25lc3MgYW5kZm9ybWVybHkga25vd24gYXNzdXJyb3VuZGVkIGJ5IHRoZWZpcnN0IGFwcGVhcmVkIGlub2NjYXNpb25hbGx5IHVzZWRwb3NpdGlvbjphYnNvbHV0ZTsiIHRhcmdldD0iX2JsYW5rIiBwb3NpdGlvbjpyZWxhdGl2ZTt0ZXh0LWFsaWduOmNlbnRlcjtqYXgvbGlicy9qcXVlcnkvMS5iYWNrZ3JvdW5kLWNvbG9yOiN0eXBlPSJhcHBsaWNhdGlvbi9hbmd1YWdlIiBjb250ZW50PSI8bWV0YSBodHRwLWVxdWl2PSJQcml2YWN5IFBvbGljeTwvYT5lKCIlM0NzY3JpcHQgc3JjPSciIHRhcmdldD0iX2JsYW5rIj5PbiB0aGUgb3RoZXIgaGFuZCwuanBnfHRodW1ifHJpZ2h0fDI8L2Rpdj48ZGl2IGNsYXNzPSI8ZGl2IHN0eWxlPSJmbG9hdDpuaW5ldGVlbnRoIGNlbnR1cnk8L2JvZHk+DQo8L2h0bWw+DQo8aW1nIHNyYz0iaHR0cDovL3M7dGV4dC1hbGlnbjpjZW50ZXJmb250LXdlaWdodDogYm9sZDsgQWNjb3JkaW5nIHRvIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4iIGZyYW1lYm9yZGVyPSIwIiAiIHN0eWxlPSJwb3NpdGlvbjpsaW5rIGhyZWY9Imh0dHA6Ly9odG1sNC9sb29zZS5kdGQiPgpkdXJpbmcgdGhpcyBwZXJpb2Q8L3RkPjwvdHI+PC90YWJsZT5jbG9zZWx5IHJlbGF0ZWQgdG9mb3IgdGhlIGZpcnN0IHRpbWU7Zm9udC13ZWlnaHQ6Ym9sZDtpbnB1dCB0eXBlPSJ0ZXh0IiA8c3BhbiBzdHlsZT0iZm9udC1vbnJlYWR5c3RhdGVjaGFuZ2UJPGRpdiBjbGFzcz0iY2xlYXJkb2N1bWVudC5sb2NhdGlvbi4gRm9yIGV4YW1wbGUsIHRoZSBhIHdpZGUgdmFyaWV0eSBvZiA8IURPQ1RZUEUgaHRtbD4NCjwmbmJzcDsmbmJzcDsmbmJzcDsiPjxhIGhyZWY9Imh0dHA6Ly9zdHlsZT0iZmxvYXQ6bGVmdDtjb25jZXJuZWQgd2l0aCB0aGU9aHR0cCUzQSUyRiUyRnd3dy5pbiBwb3B1bGFyIGN1bHR1cmV0eXBlPSJ0ZXh0L2NzcyIgLz5pdCBpcyBwb3NzaWJsZSB0byBIYXJ2YXJkIFVuaXZlcnNpdHl0eWxlc2hlZXQiIGhyZWY9Ii90aGUgbWFpbiBjaGFyYWN0ZXJPeGZvcmQgVW5pdmVyc2l0eSAgbmFtZT0ia2V5d29yZHMiIGNzdHlsZT0idGV4dC1hbGlnbjp0aGUgVW5pdGVkIEtpbmdkb21mZWRlcmFsIGdvdmVybm1lbnQ8ZGl2IHN0eWxlPSJtYXJnaW4gZGVwZW5kaW5nIG9uIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGU8ZGl2IGNsYXNzPSJoZWFkZXIubWluLmpzIj48L3NjcmlwdD5kZXN0cnVjdGlvbiBvZiB0aGVzbGlnaHRseSBkaWZmZXJlbnRpbiBhY2NvcmRhbmNlIHdpdGh0ZWxlY29tbXVuaWNhdGlvbnNpbmRpY2F0ZXMgdGhhdCB0aGVzaG9ydGx5IHRoZXJlYWZ0ZXJlc3BlY2lhbGx5IGluIHRoZSBFdXJvcGVhbiBjb3VudHJpZXNIb3dldmVyLCB0aGVyZSBhcmVzcmM9Imh0dHA6Ly9zdGF0aWNzdWdnZXN0ZWQgdGhhdCB0aGUiIHNyYz0iaHR0cDovL3d3dy5hIGxhcmdlIG51bWJlciBvZiBUZWxlY29tbXVuaWNhdGlvbnMiIHJlbD0ibm9mb2xsb3ciIHRIb2x5IFJvbWFuIEVtcGVyb3JhbG1vc3QgZXhjbHVzaXZlbHkiIGJvcmRlcj0iMCIgYWx0PSJTZWNyZXRhcnkgb2YgU3RhdGVjdWxtaW5hdGluZyBpbiB0aGVDSUEgV29ybGQgRmFjdGJvb2t0aGUgbW9zdCBpbXBvcnRhbnRhbm5pdmVyc2FyeSBvZiB0aGVzdHlsZT0iYmFja2dyb3VuZC08bGk+PGVtPjxhIGhyZWY9Ii90aGUgQXRsYW50aWMgT2NlYW5zdHJpY3RseSBzcGVha2luZyxzaG9ydGx5IGJlZm9yZSB0aGVkaWZmZXJlbnQgdHlwZXMgb2Z0aGUgT3R0b21hbiBFbXBpcmU+PGltZyBzcmM9Imh0dHA6Ly9BbiBJbnRyb2R1Y3Rpb24gdG9jb25zZXF1ZW5jZSBvZiB0aGVkZXBhcnR1cmUgZnJvbSB0aGVDb25mZWRlcmF0ZSBTdGF0ZXNpbmRpZ2Vub3VzIHBlb3BsZXNQcm9jZWVkaW5ncyBvZiB0aGVpbmZvcm1hdGlvbiBvbiB0aGV0aGVvcmllcyBoYXZlIGJlZW5pbnZvbHZlbWVudCBpbiB0aGVkaXZpZGVkIGludG8gdGhyZWVhZGphY2VudCBjb3VudHJpZXNpcyByZXNwb25zaWJsZSBmb3JkaXNzb2x1dGlvbiBvZiB0aGVjb2xsYWJvcmF0aW9uIHdpdGh3aWRlbHkgcmVnYXJkZWQgYXNoaXMgY29udGVtcG9yYXJpZXNmb3VuZGluZyBtZW1iZXIgb2ZEb21pbmljYW4gUmVwdWJsaWNnZW5lcmFsbHkgYWNjZXB0ZWR0aGUgcG9zc2liaWxpdHkgb2ZhcmUgYWxzbyBhdmFpbGFibGV1bmRlciBjb25zdHJ1Y3Rpb25yZXN0b3JhdGlvbiBvZiB0aGV0aGUgZ2VuZXJhbCBwdWJsaWNpcyBhbG1vc3QgZW50aXJlbHlwYXNzZXMgdGhyb3VnaCB0aGVoYXMgYmVlbiBzdWdnZXN0ZWRjb21wdXRlciBhbmQgdmlkZW9HZXJtYW5pYyBsYW5ndWFnZXMgYWNjb3JkaW5nIHRvIHRoZSBkaWZmZXJlbnQgZnJvbSB0aGVzaG9ydGx5IGFmdGVyd2FyZHNocmVmPSJodHRwczovL3d3dy5yZWNlbnQgZGV2ZWxvcG1lbnRCb2FyZCBvZiBEaXJlY3RvcnM8ZGl2IGNsYXNzPSJzZWFyY2h8IDxhIGhyZWY9Imh0dHA6Ly9JbiBwYXJ0aWN1bGFyLCB0aGVNdWx0aXBsZSBmb290bm90ZXNvciBvdGhlciBzdWJzdGFuY2V0aG91c2FuZHMgb2YgeWVhcnN0cmFuc2xhdGlvbiBvZiB0aGU8L2Rpdj4NCjwvZGl2Pg0KDQo8YSBocmVmPSJpbmRleC5waHB3YXMgZXN0YWJsaXNoZWQgaW5taW4uanMiPjwvc2NyaXB0PgpwYXJ0aWNpcGF0ZSBpbiB0aGVhIHN0cm9uZyBpbmZsdWVuY2VzdHlsZT0ibWFyZ2luLXRvcDpyZXByZXNlbnRlZCBieSB0aGVncmFkdWF0ZWQgZnJvbSB0aGVUcmFkaXRpb25hbGx5LCB0aGVFbGVtZW50KCJzY3JpcHQiKTtIb3dldmVyLCBzaW5jZSB0aGUvZGl2Pgo8L2Rpdj4KPGRpdiBsZWZ0OyBtYXJnaW4tbGVmdDpwcm90ZWN0aW9uIGFnYWluc3QwOyB2ZXJ0aWNhbC1hbGlnbjpVbmZvcnR1bmF0ZWx5LCB0aGV0eXBlPSJpbWFnZS94LWljb24vZGl2Pgo8ZGl2IGNsYXNzPSIgY2xhc3M9ImNsZWFyZml4Ij48ZGl2IGNsYXNzPSJmb290ZXIJCTwvZGl2PgoJCTwvZGl2Pgp0aGUgbW90aW9uIHBpY3R1cmXQkdGK0LvQs9Cw0YDRgdC60LjQsdGK0LvQs9Cw0YDRgdC60LjQpNC10LTQtdGA0LDRhtC40LjQvdC10YHQutC+0LvRjNC60L7RgdC+0L7QsdGJ0LXQvdC40LXRgdC+0L7QsdGJ0LXQvdC40Y/Qv9GA0L7Qs9GA0LDQvNC80YvQntGC0L/RgNCw0LLQuNGC0YzQsdC10YHQv9C70LDRgtC90L7QvNCw0YLQtdGA0LjQsNC70YvQv9C+0LfQstC+0LvRj9C10YLQv9C+0YHQu9C10LTQvdC40LXRgNCw0LfQu9C40YfQvdGL0YXQv9GA0L7QtNGD0LrRhtC40LjQv9GA0L7Qs9GA0LDQvNC80LDQv9C+0LvQvdC+0YHRgtGM0Y7QvdCw0YXQvtC00LjRgtGB0Y/QuNC30LHRgNCw0L3QvdC+0LXQvdCw0YHQtdC70LXQvdC40Y/QuNC30LzQtdC90LXQvdC40Y/QutCw0YLQtdCz0L7RgNC40LjQkNC70LXQutGB0LDQvdC00YDgpKbgpY3gpLXgpL7gpLDgpL7gpK7gpYjgpKjgpYHgpIXgpLLgpKrgpY3gpLDgpKbgpL7gpKjgpK3gpL7gpLDgpKTgpYDgpK/gpIXgpKjgpYHgpKbgpYfgpLbgpLngpL/gpKjgpY3gpKbgpYDgpIfgpILgpKHgpL/gpK/gpL7gpKbgpL/gpLLgpY3gpLLgpYDgpIXgpKfgpL/gpJXgpL7gpLDgpLXgpYDgpKHgpL/gpK/gpYvgpJrgpL/gpJ/gpY3gpKDgpYfgpLjgpK7gpL7gpJrgpL7gpLDgpJzgpILgpJXgpY3gpLbgpKjgpKbgpYHgpKjgpL/gpK/gpL7gpKrgpY3gpLDgpK/gpYvgpJfgpIXgpKjgpYHgpLjgpL7gpLDgpJHgpKjgpLLgpL7gpIfgpKjgpKrgpL7gpLDgpY3gpJ/gpYDgpLbgpLDgpY3gpKTgpYvgpILgpLLgpYvgpJXgpLjgpK3gpL7gpKvgpLzgpY3gpLLgpYjgpLbgpLbgpLDgpY3gpKTgpYfgpILgpKrgpY3gpLDgpKbgpYfgpLbgpKrgpY3gpLLgpYfgpK/gpLDgpJXgpYfgpILgpKbgpY3gpLDgpLjgpY3gpKXgpL/gpKTgpL/gpIngpKTgpY3gpKrgpL7gpKbgpIngpKjgpY3gpLngpYfgpILgpJrgpL/gpJ/gpY3gpKDgpL7gpK/gpL7gpKTgpY3gpLDgpL7gpJzgpY3gpK/gpL7gpKbgpL7gpKrgpYHgpLDgpL7gpKjgpYfgpJzgpYvgpKHgpLzgpYfgpILgpIXgpKjgpYHgpLXgpL7gpKbgpLbgpY3gpLDgpYfgpKPgpYDgpLbgpL/gpJXgpY3gpLfgpL7gpLjgpLDgpJXgpL7gpLDgpYDgpLjgpILgpJfgpY3gpLDgpLngpKrgpLDgpL/gpKPgpL7gpK7gpKzgpY3gpLDgpL7gpILgpKHgpKzgpJrgpY3gpJrgpYvgpILgpIngpKrgpLLgpKzgpY3gpKfgpK7gpILgpKTgpY3gpLDgpYDgpLjgpILgpKrgpLDgpY3gpJXgpIngpK7gpY3gpK7gpYDgpKbgpK7gpL7gpKfgpY3gpK/gpK7gpLjgpLngpL7gpK/gpKTgpL7gpLbgpKzgpY3gpKbgpYvgpILgpK7gpYDgpKHgpL/gpK/gpL7gpIbgpIjgpKrgpYDgpI/gpLLgpK7gpYvgpKzgpL7gpIfgpLLgpLjgpILgpJbgpY3gpK/gpL7gpIbgpKrgpLDgpYfgpLbgpKjgpIXgpKjgpYHgpKzgpILgpKfgpKzgpL7gpJzgpLzgpL7gpLDgpKjgpLXgpYDgpKjgpKTgpK7gpKrgpY3gpLDgpK7gpYHgpJbgpKrgpY3gpLDgpLbgpY3gpKjgpKrgpLDgpL/gpLXgpL7gpLDgpKjgpYHgpJXgpLjgpL7gpKjgpLjgpK7gpLDgpY3gpKXgpKjgpIbgpK/gpYvgpJzgpL/gpKTgpLjgpYvgpK7gpLXgpL7gpLDYp9mE2YXYtNin2LHZg9in2KrYp9mE2YXZhtiq2K/Zitin2KrYp9mE2YPZhdio2YrZiNiq2LHYp9mE2YXYtNin2YfYr9in2KrYudiv2K/Yp9mE2LLZiNin2LHYudiv2K/Yp9mE2LHYr9mI2K/Yp9mE2KXYs9mE2KfZhdmK2KnYp9mE2YHZiNiq2YjYtNmI2KjYp9mE2YXYs9in2KjZgtin2KrYp9mE2YXYudmE2YjZhdin2KrYp9mE2YXYs9mE2LPZhNin2KrYp9mE2KzYsdin2YHZitmD2LPYp9mE2KfYs9mE2KfZhdmK2KnYp9mE2KfYqti12KfZhNin2KprZXl3b3JkcyIgY29udGVudD0idzMub3JnLzE5OTkveGh0bWwiPjxhIHRhcmdldD0iX2JsYW5rIiB0ZXh0L2h0bWw7IGNoYXJzZXQ9IiB0YXJnZXQ9Il9ibGFuayI+PHRhYmxlIGNlbGxwYWRkaW5nPSJhdXRvY29tcGxldGU9Im9mZiIgdGV4dC1hbGlnbjogY2VudGVyO3RvIGxhc3QgdmVyc2lvbiBieSBiYWNrZ3JvdW5kLWNvbG9yOiAjIiBocmVmPSJodHRwOi8vd3d3Li9kaXY+PC9kaXY+PGRpdiBpZD08YSBocmVmPSIjIiBjbGFzcz0iIj48aW1nIHNyYz0iaHR0cDovL2NyaXB0IiBzcmM9Imh0dHA6Ly8KPHNjcmlwdCBsYW5ndWFnZT0iLy9FTiIgImh0dHA6Ly93d3cud2VuY29kZVVSSUNvbXBvbmVudCgiIGhyZWY9ImphdmFzY3JpcHQ6PGRpdiBjbGFzcz0iY29udGVudGRvY3VtZW50LndyaXRlKCc8c2Nwb3NpdGlvbjogYWJzb2x1dGU7c2NyaXB0IHNyYz0iaHR0cDovLyBzdHlsZT0ibWFyZ2luLXRvcDoubWluLmpzIj48L3NjcmlwdD4KPC9kaXY+CjxkaXYgY2xhc3M9InczLm9yZy8xOTk5L3hodG1sIiAKDQo8L2JvZHk+DQo8L2h0bWw+ZGlzdGluY3Rpb24gYmV0d2Vlbi8iIHRhcmdldD0iX2JsYW5rIj48bGluayBocmVmPSJodHRwOi8vZW5jb2Rpbmc9InV0Zi04Ij8+CncuYWRkRXZlbnRMaXN0ZW5lcj9hY3Rpb249Imh0dHA6Ly93d3cuaWNvbiIgaHJlZj0iaHR0cDovLyBzdHlsZT0iYmFja2dyb3VuZDp0eXBlPSJ0ZXh0L2NzcyIgLz4KbWV0YSBwcm9wZXJ0eT0ib2c6dDxpbnB1dCB0eXBlPSJ0ZXh0IiAgc3R5bGU9InRleHQtYWxpZ246dGhlIGRldmVsb3BtZW50IG9mIHR5bGVzaGVldCIgdHlwZT0idGVodG1sOyBjaGFyc2V0PXV0Zi04aXMgY29uc2lkZXJlZCB0byBiZXRhYmxlIHdpZHRoPSIxMDAlIiBJbiBhZGRpdGlvbiB0byB0aGUgY29udHJpYnV0ZWQgdG8gdGhlIGRpZmZlcmVuY2VzIGJldHdlZW5kZXZlbG9wbWVudCBvZiB0aGUgSXQgaXMgaW1wb3J0YW50IHRvIDwvc2NyaXB0PgoKPHNjcmlwdCAgc3R5bGU9ImZvbnQtc2l6ZToxPjwvc3Bhbj48c3BhbiBpZD1nYkxpYnJhcnkgb2YgQ29uZ3Jlc3M8aW1nIHNyYz0iaHR0cDovL2ltRW5nbGlzaCB0cmFuc2xhdGlvbkFjYWRlbXkgb2YgU2NpZW5jZXNkaXYgc3R5bGU9ImRpc3BsYXk6Y29uc3RydWN0aW9uIG9mIHRoZS5nZXRFbGVtZW50QnlJZChpZClpbiBjb25qdW5jdGlvbiB3aXRoRWxlbWVudCgnc2NyaXB0Jyk7IDxtZXRhIHByb3BlcnR5PSJvZzrQkdGK0LvQs9Cw0YDRgdC60LgKIHR5cGU9InRleHQiIG5hbWU9Ij5Qcml2YWN5IFBvbGljeTwvYT5hZG1pbmlzdGVyZWQgYnkgdGhlZW5hYmxlU2luZ2xlUmVxdWVzdHN0eWxlPSZxdW90O21hcmdpbjo8L2Rpdj48L2Rpdj48L2Rpdj48PjxpbWcgc3JjPSJodHRwOi8vaSBzdHlsZT0mcXVvdDtmbG9hdDpyZWZlcnJlZCB0byBhcyB0aGUgdG90YWwgcG9wdWxhdGlvbiBvZmluIFdhc2hpbmd0b24sIEQuQy4gc3R5bGU9ImJhY2tncm91bmQtYW1vbmcgb3RoZXIgdGhpbmdzLG9yZ2FuaXphdGlvbiBvZiB0aGVwYXJ0aWNpcGF0ZWQgaW4gdGhldGhlIGludHJvZHVjdGlvbiBvZmlkZW50aWZpZWQgd2l0aCB0aGVmaWN0aW9uYWwgY2hhcmFjdGVyIE94Zm9yZCBVbml2ZXJzaXR5IG1pc3VuZGVyc3RhbmRpbmcgb2ZUaGVyZSBhcmUsIGhvd2V2ZXIsc3R5bGVzaGVldCIgaHJlZj0iL0NvbHVtYmlhIFVuaXZlcnNpdHlleHBhbmRlZCB0byBpbmNsdWRldXN1YWxseSByZWZlcnJlZCB0b2luZGljYXRpbmcgdGhhdCB0aGVoYXZlIHN1Z2dlc3RlZCB0aGF0YWZmaWxpYXRlZCB3aXRoIHRoZWNvcnJlbGF0aW9uIGJldHdlZW5udW1iZXIgb2YgZGlmZmVyZW50PjwvdGQ+PC90cj48L3RhYmxlPlJlcHVibGljIG9mIElyZWxhbmQKPC9zY3JpcHQ+CjxzY3JpcHQgdW5kZXIgdGhlIGluZmx1ZW5jZWNvbnRyaWJ1dGlvbiB0byB0aGVPZmZpY2lhbCB3ZWJzaXRlIG9maGVhZHF1YXJ0ZXJzIG9mIHRoZWNlbnRlcmVkIGFyb3VuZCB0aGVpbXBsaWNhdGlvbnMgb2YgdGhlaGF2ZSBiZWVuIGRldmVsb3BlZEZlZGVyYWwgUmVwdWJsaWMgb2ZiZWNhbWUgaW5jcmVhc2luZ2x5Y29udGludWF0aW9uIG9mIHRoZU5vdGUsIGhvd2V2ZXIsIHRoYXRzaW1pbGFyIHRvIHRoYXQgb2YgY2FwYWJpbGl0aWVzIG9mIHRoZWFjY29yZGFuY2Ugd2l0aCB0aGVwYXJ0aWNpcGFudHMgaW4gdGhlZnVydGhlciBkZXZlbG9wbWVudHVuZGVyIHRoZSBkaXJlY3Rpb25pcyBvZnRlbiBjb25zaWRlcmVkaGlzIHlvdW5nZXIgYnJvdGhlcjwvdGQ+PC90cj48L3RhYmxlPjxhIGh0dHAtZXF1aXY9IlgtVUEtcGh5c2ljYWwgcHJvcGVydGllc29mIEJyaXRpc2ggQ29sdW1iaWFoYXMgYmVlbiBjcml0aWNpemVkKHdpdGggdGhlIGV4Y2VwdGlvbnF1ZXN0aW9ucyBhYm91dCB0aGVwYXNzaW5nIHRocm91Z2ggdGhlMCIgY2VsbHBhZGRpbmc9IjAiIHRob3VzYW5kcyBvZiBwZW9wbGVyZWRpcmVjdHMgaGVyZS4gRm9yaGF2ZSBjaGlsZHJlbiB1bmRlciUzRSUzQy9zY3JpcHQlM0UiKSk7PGEgaHJlZj0iaHR0cDovL3d3dy48bGk+PGEgaHJlZj0iaHR0cDovL3NpdGVfbmFtZSIgY29udGVudD0idGV4dC1kZWNvcmF0aW9uOm5vbmVzdHlsZT0iZGlzcGxheTogbm9uZTxtZXRhIGh0dHAtZXF1aXY9IlgtbmV3IERhdGUoKS5nZXRUaW1lKCkgdHlwZT0iaW1hZ2UveC1pY29uIjwvc3Bhbj48c3BhbiBjbGFzcz0ibGFuZ3VhZ2U9ImphdmFzY3JpcHR3aW5kb3cubG9jYXRpb24uaHJlZjxhIGhyZWY9ImphdmFzY3JpcHQ6LS0+DQo8c2NyaXB0IHR5cGU9InQ8YSBocmVmPSdodHRwOi8vd3d3LmhvcnRjdXQgaWNvbiIgaHJlZj0iPC9kaXY+DQo8ZGl2IGNsYXNzPSI8c2NyaXB0IHNyYz0iaHR0cDovLyIgcmVsPSJzdHlsZXNoZWV0IiB0PC9kaXY+CjxzY3JpcHQgdHlwZT0vYT4gPGEgaHJlZj0iaHR0cDovLyBhbGxvd1RyYW5zcGFyZW5jeT0iWC1VQS1Db21wYXRpYmxlIiBjb25yZWxhdGlvbnNoaXAgYmV0d2Vlbgo8L3NjcmlwdD4NCjxzY3JpcHQgPC9hPjwvbGk+PC91bD48L2Rpdj5hc3NvY2lhdGVkIHdpdGggdGhlIHByb2dyYW1taW5nIGxhbmd1YWdlPC9hPjxhIGhyZWY9Imh0dHA6Ly88L2E+PC9saT48bGkgY2xhc3M9ImZvcm0gYWN0aW9uPSJodHRwOi8vPGRpdiBzdHlsZT0iZGlzcGxheTp0eXBlPSJ0ZXh0IiBuYW1lPSJxIjx0YWJsZSB3aWR0aD0iMTAwJSIgYmFja2dyb3VuZC1wb3NpdGlvbjoiIGJvcmRlcj0iMCIgd2lkdGg9InJlbD0ic2hvcnRjdXQgaWNvbiIgaDY+PHVsPjxsaT48YSBocmVmPSIgIDxtZXRhIGh0dHAtZXF1aXY9ImNzcyIgbWVkaWE9InNjcmVlbiIgcmVzcG9uc2libGUgZm9yIHRoZSAiIHR5cGU9ImFwcGxpY2F0aW9uLyIgc3R5bGU9ImJhY2tncm91bmQtaHRtbDsgY2hhcnNldD11dGYtOCIgYWxsb3d0cmFuc3BhcmVuY3k9InN0eWxlc2hlZXQiIHR5cGU9InRlDQo8bWV0YSBodHRwLWVxdWl2PSI+PC9zcGFuPjxzcGFuIGNsYXNzPSIwIiBjZWxsc3BhY2luZz0iMCI+Owo8L3NjcmlwdD4KPHNjcmlwdCBzb21ldGltZXMgY2FsbGVkIHRoZWRvZXMgbm90IG5lY2Vzc2FyaWx5Rm9yIG1vcmUgaW5mb3JtYXRpb25hdCB0aGUgYmVnaW5uaW5nIG9mIDwhRE9DVFlQRSBodG1sPjxodG1scGFydGljdWxhcmx5IGluIHRoZSB0eXBlPSJoaWRkZW4iIG5hbWU9ImphdmFzY3JpcHQ6dm9pZCgwKTsiZWZmZWN0aXZlbmVzcyBvZiB0aGUgYXV0b2NvbXBsZXRlPSJvZmYiIGdlbmVyYWxseSBjb25zaWRlcmVkPjxpbnB1dCB0eXBlPSJ0ZXh0IiAiPjwvc2NyaXB0Pg0KPHNjcmlwdHRocm91Z2hvdXQgdGhlIHdvcmxkY29tbW9uIG1pc2NvbmNlcHRpb25hc3NvY2lhdGlvbiB3aXRoIHRoZTwvZGl2Pgo8L2Rpdj4KPGRpdiBjZHVyaW5nIGhpcyBsaWZldGltZSxjb3JyZXNwb25kaW5nIHRvIHRoZXR5cGU9ImltYWdlL3gtaWNvbiIgYW4gaW5jcmVhc2luZyBudW1iZXJkaXBsb21hdGljIHJlbGF0aW9uc2FyZSBvZnRlbiBjb25zaWRlcmVkbWV0YSBjaGFyc2V0PSJ1dGYtOCIgPGlucHV0IHR5cGU9InRleHQiIGV4YW1wbGVzIGluY2x1ZGUgdGhlIj48aW1nIHNyYz0iaHR0cDovL2lwYXJ0aWNpcGF0aW9uIGluIHRoZXRoZSBlc3RhYmxpc2htZW50IG9mCjwvZGl2Pgo8ZGl2IGNsYXNzPSImYW1wO25ic3A7JmFtcDtuYnNwO3RvIGRldGVybWluZSB3aGV0aGVycXVpdGUgZGlmZmVyZW50IGZyb21tYXJrZWQgdGhlIGJlZ2lubmluZ2Rpc3RhbmNlIGJldHdlZW4gdGhlY29udHJpYnV0aW9ucyB0byB0aGVjb25mbGljdCBiZXR3ZWVuIHRoZXdpZGVseSBjb25zaWRlcmVkIHRvd2FzIG9uZSBvZiB0aGUgZmlyc3R3aXRoIHZhcnlpbmcgZGVncmVlc2hhdmUgc3BlY3VsYXRlZCB0aGF0KGRvY3VtZW50LmdldEVsZW1lbnRwYXJ0aWNpcGF0aW5nIGluIHRoZW9yaWdpbmFsbHkgZGV2ZWxvcGVkZXRhIGNoYXJzZXQ9InV0Zi04Ij4gdHlwZT0idGV4dC9jc3MiIC8+CmludGVyY2hhbmdlYWJseSB3aXRobW9yZSBjbG9zZWx5IHJlbGF0ZWRzb2NpYWwgYW5kIHBvbGl0aWNhbHRoYXQgd291bGQgb3RoZXJ3aXNlcGVycGVuZGljdWxhciB0byB0aGVzdHlsZSB0eXBlPSJ0ZXh0L2Nzc3R5cGU9InN1Ym1pdCIgbmFtZT0iZmFtaWxpZXMgcmVzaWRpbmcgaW5kZXZlbG9waW5nIGNvdW50cmllc2NvbXB1dGVyIHByb2dyYW1taW5nZWNvbm9taWMgZGV2ZWxvcG1lbnRkZXRlcm1pbmF0aW9uIG9mIHRoZWZvciBtb3JlIGluZm9ybWF0aW9ub24gc2V2ZXJhbCBvY2Nhc2lvbnNwb3J0dWd1w6pzIChFdXJvcGV1KdCj0LrRgNCw0ZfQvdGB0YzQutCw0YPQutGA0LDRl9C90YHRjNC60LDQoNC+0YHRgdC40LnRgdC60L7QudC80LDRgtC10YDQuNCw0LvQvtCy0LjQvdGE0L7RgNC80LDRhtC40LjRg9C/0YDQsNCy0LvQtdC90LjRj9C90LXQvtCx0YXQvtC00LjQvNC+0LjQvdGE0L7RgNC80LDRhtC40Y/QmNC90YTQvtGA0LzQsNGG0LjRj9Cg0LXRgdC/0YPQsdC70LjQutC40LrQvtC70LjRh9C10YHRgtCy0L7QuNC90YTQvtGA0LzQsNGG0LjRjtGC0LXRgNGA0LjRgtC+0YDQuNC40LTQvtGB0YLQsNGC0L7Rh9C90L7Yp9mE2YXYqtmI2KfYrNiv2YjZhtin2YTYp9i02KrYsdin2YPYp9iq2KfZhNin2YLYqtix2KfYrdin2KpodG1sOyBjaGFyc2V0PVVURi04IiBzZXRUaW1lb3V0KGZ1bmN0aW9uKClkaXNwbGF5OmlubGluZS1ibG9jazs8aW5wdXQgdHlwZT0ic3VibWl0IiB0eXBlID0gJ3RleHQvamF2YXNjcmk8aW1nIHNyYz0iaHR0cDovL3d3dy4iICJodHRwOi8vd3d3LnczLm9yZy9zaG9ydGN1dCBpY29uIiBocmVmPSIiIGF1dG9jb21wbGV0ZT0ib2ZmIiA8L2E+PC9kaXY+PGRpdiBjbGFzcz08L2E+PC9saT4KPGxpIGNsYXNzPSJjc3MiIHR5cGU9InRleHQvY3NzIiA8Zm9ybSBhY3Rpb249Imh0dHA6Ly94dC9jc3MiIGhyZWY9Imh0dHA6Ly9saW5rIHJlbD0iYWx0ZXJuYXRlIiANCjxzY3JpcHQgdHlwZT0idGV4dC8gb25jbGljaz0iamF2YXNjcmlwdDoobmV3IERhdGUpLmdldFRpbWUoKX1oZWlnaHQ9IjEiIHdpZHRoPSIxIiBQZW9wbGUncyBSZXB1YmxpYyBvZiAgPGEgaHJlZj0iaHR0cDovL3d3dy50ZXh0LWRlY29yYXRpb246dW5kZXJ0aGUgYmVnaW5uaW5nIG9mIHRoZSA8L2Rpdj4KPC9kaXY+CjwvZGl2Pgplc3RhYmxpc2htZW50IG9mIHRoZSA8L2Rpdj48L2Rpdj48L2Rpdj48L2Qjdmlld3BvcnR7bWluLWhlaWdodDoKPHNjcmlwdCBzcmM9Imh0dHA6Ly9vcHRpb24+PG9wdGlvbiB2YWx1ZT1vZnRlbiByZWZlcnJlZCB0byBhcyAvb3B0aW9uPgo8b3B0aW9uIHZhbHU8IURPQ1RZUEUgaHRtbD4KPCEtLVtJbnRlcm5hdGlvbmFsIEFpcnBvcnQ+CjxhIGhyZWY9Imh0dHA6Ly93d3c8L2E+PGEgaHJlZj0iaHR0cDovL3fguKDguLLguKnguLLguYTguJfguKLhg6Xhg5Dhg6Dhg5fhg6Phg5rhg5jmraPpq5TkuK3mlocgKOe5gemrlCngpKjgpL/gpLDgpY3gpKbgpYfgpLbgpKHgpL7gpIngpKjgpLLgpYvgpKHgpJXgpY3gpLfgpYfgpKTgpY3gpLDgpJzgpL7gpKjgpJXgpL7gpLDgpYDgpLjgpILgpKzgpILgpKfgpL/gpKTgpLjgpY3gpKXgpL7gpKrgpKjgpL7gpLjgpY3gpLXgpYDgpJXgpL7gpLDgpLjgpILgpLjgpY3gpJXgpLDgpKPgpLjgpL7gpK7gpJfgpY3gpLDgpYDgpJrgpL/gpJ/gpY3gpKDgpYvgpILgpLXgpL/gpJzgpY3gpJ7gpL7gpKjgpIXgpK7gpYfgpLDgpL/gpJXgpL7gpLXgpL/gpK3gpL/gpKjgpY3gpKjgpJfgpL7gpKHgpL/gpK/gpL7gpIHgpJXgpY3gpK/gpYvgpILgpJXgpL/gpLjgpYHgpLDgpJXgpY3gpLfgpL7gpKrgpLngpYHgpIHgpJrgpKTgpYDgpKrgpY3gpLDgpKzgpILgpKfgpKjgpJ/gpL/gpKrgpY3gpKrgpKPgpYDgpJXgpY3gpLDgpL/gpJXgpYfgpJ/gpKrgpY3gpLDgpL7gpLDgpILgpK3gpKrgpY3gpLDgpL7gpKrgpY3gpKTgpK7gpL7gpLLgpL/gpJXgpYvgpILgpLDgpKvgpLzgpY3gpKTgpL7gpLDgpKjgpL/gpLDgpY3gpK7gpL7gpKPgpLLgpL/gpK7gpL/gpJ/gpYfgpKFkZXNjcmlwdGlvbiIgY29udGVudD0iZG9jdW1lbnQubG9jYXRpb24ucHJvdC5nZXRFbGVtZW50c0J5VGFnTmFtZSg8IURPQ1RZUEUgaHRtbD4KPGh0bWwgPG1ldGEgY2hhcnNldD0idXRmLTgiPjp1cmwiIGNvbnRlbnQ9Imh0dHA6Ly8uY3NzIiByZWw9InN0eWxlc2hlZXQic3R5bGUgdHlwZT0idGV4dC9jc3MiPnR5cGU9InRleHQvY3NzIiBocmVmPSJ3My5vcmcvMTk5OS94aHRtbCIgeG1sdHlwZT0idGV4dC9qYXZhc2NyaXB0IiBtZXRob2Q9ImdldCIgYWN0aW9uPSJsaW5rIHJlbD0ic3R5bGVzaGVldCIgID0gZG9jdW1lbnQuZ2V0RWxlbWVudHR5cGU9ImltYWdlL3gtaWNvbiIgLz5jZWxscGFkZGluZz0iMCIgY2VsbHNwLmNzcyIgdHlwZT0idGV4dC9jc3MiIDwvYT48L2xpPjxsaT48YSBocmVmPSIiIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIj48YSBocmVmPSJodHRwOi8vd3d3LnN0eWxlPSJkaXNwbGF5Om5vbmU7Ij5hbHRlcm5hdGUiIHR5cGU9ImFwcGxpLS8vVzNDLy9EVEQgWEhUTUwgMS4wIGVsbHNwYWNpbmc9IjAiIGNlbGxwYWQgdHlwZT0iaGlkZGVuIiB2YWx1ZT0iL2E+Jm5ic3A7PHNwYW4gcm9sZT0icwo8aW5wdXQgdHlwZT0iaGlkZGVuIiBsYW5ndWFnZT0iSmF2YVNjcmlwdCIgIGRvY3VtZW50LmdldEVsZW1lbnRzQmc9IjAiIGNlbGxzcGFjaW5nPSIwIiB5cGU9InRleHQvY3NzIiBtZWRpYT0idHlwZT0ndGV4dC9qYXZhc2NyaXB0J3dpdGggdGhlIGV4Y2VwdGlvbiBvZiB5cGU9InRleHQvY3NzIiByZWw9InN0IGhlaWdodD0iMSIgd2lkdGg9IjEiID0nK2VuY29kZVVSSUNvbXBvbmVudCg8bGluayByZWw9ImFsdGVybmF0ZSIgCmJvZHksIHRyLCBpbnB1dCwgdGV4dG1ldGEgbmFtZT0icm9ib3RzIiBjb25tZXRob2Q9InBvc3QiIGFjdGlvbj0iPgo8YSBocmVmPSJodHRwOi8vd3d3LmNzcyIgcmVsPSJzdHlsZXNoZWV0IiA8L2Rpdj48L2Rpdj48ZGl2IGNsYXNzbGFuZ3VhZ2U9ImphdmFzY3JpcHQiPmFyaWEtaGlkZGVuPSJ0cnVlIj7CtzxyaXB0IiB0eXBlPSJ0ZXh0L2phdmFzbD0wO30pKCk7CihmdW5jdGlvbigpe2JhY2tncm91bmQtaW1hZ2U6IHVybCgvYT48L2xpPjxsaT48YSBocmVmPSJoCQk8bGk+PGEgaHJlZj0iaHR0cDovL2F0b3IiIGFyaWEtaGlkZGVuPSJ0cnU+IDxhIGhyZWY9Imh0dHA6Ly93d3cubGFuZ3VhZ2U9ImphdmFzY3JpcHQiIC9vcHRpb24+CjxvcHRpb24gdmFsdWUvZGl2PjwvZGl2PjxkaXYgY2xhc3M9cmF0b3IiIGFyaWEtaGlkZGVuPSJ0cmU9KG5ldyBEYXRlKS5nZXRUaW1lKClwb3J0dWd1w6pzIChkbyBCcmFzaWwp0L7RgNCz0LDQvdC40LfQsNGG0LjQuNCy0L7Qt9C80L7QttC90L7RgdGC0YzQvtCx0YDQsNC30L7QstCw0L3QuNGP0YDQtdCz0LjRgdGC0YDQsNGG0LjQuNCy0L7Qt9C80L7QttC90L7RgdGC0LjQvtCx0Y/Qt9Cw0YLQtdC70YzQvdCwPCFET0NUWVBFIGh0bWwgUFVCTElDICJudC1UeXBlIiBjb250ZW50PSJ0ZXh0LzxtZXRhIGh0dHAtZXF1aXY9IkNvbnRlcmFuc2l0aW9uYWwvL0VOIiAiaHR0cDo8aHRtbCB4bWxucz0iaHR0cDovL3d3dy0vL1czQy8vRFREIFhIVE1MIDEuMCBURFREL3hodG1sMS10cmFuc2l0aW9uYWwvL3d3dy53My5vcmcvVFIveGh0bWwxL3BlID0gJ3RleHQvamF2YXNjcmlwdCc7PG1ldGEgbmFtZT0iZGVzY3JpcHRpb25wYXJlbnROb2RlLmluc2VydEJlZm9yZTxpbnB1dCB0eXBlPSJoaWRkZW4iIG5hanMiIHR5cGU9InRleHQvamF2YXNjcmkoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aXNjcmlwdCB0eXBlPSJ0ZXh0L2phdmFzaW1hZ2UiIGNvbnRlbnQ9Imh0dHA6Ly9VQS1Db21wYXRpYmxlIiBjb250ZW50PXRtbDsgY2hhcnNldD11dGYtOCIgLz4KbGluayByZWw9InNob3J0Y3V0IGljb248bGluayByZWw9InN0eWxlc2hlZXQiIDwvc2NyaXB0Pgo8c2NyaXB0IHR5cGU9PSBkb2N1bWVudC5jcmVhdGVFbGVtZW48YSB0YXJnZXQ9Il9ibGFuayIgaHJlZj0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCaW5wdXQgdHlwZT0idGV4dCIgbmFtZT1hLnR5cGUgPSAndGV4dC9qYXZhc2NyaW5wdXQgdHlwZT0iaGlkZGVuIiBuYW1laHRtbDsgY2hhcnNldD11dGYtOCIgLz5kdGQiPgo8aHRtbCB4bWxucz0iaHR0cC0vL1czQy8vRFREIEhUTUwgNC4wMSBUZW50c0J5VGFnTmFtZSgnc2NyaXB0JylpbnB1dCB0eXBlPSJoaWRkZW4iIG5hbTxzY3JpcHQgdHlwZT0idGV4dC9qYXZhcyIgc3R5bGU9ImRpc3BsYXk6bm9uZTsiPmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCcgdHlwZT0ndGV4dC9qYXZhc2NyaXB0J2lucHV0IHR5cGU9InRleHQiIG5hbWU9ImQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoc25pY2FsIiBocmVmPSJodHRwOi8vd3d3LkMvL0RURCBIVE1MIDQuMDEgVHJhbnNpdDxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPmlvbmFsLmR0ZCI+CjxodG1sIHhtbG5zPWh0dHAtZXF1aXY9IkNvbnRlbnQtVHlwZWRpbmc9IjAiIGNlbGxzcGFjaW5nPSIwImh0bWw7IGNoYXJzZXQ9dXRmLTgiIC8+CiBzdHlsZT0iZGlzcGxheTpub25lOyI+PDxsaT48YSBocmVmPSJodHRwOi8vd3d3LiB0eXBlPSd0ZXh0L2phdmFzY3JpcHQnPtC00LXRj9GC0LXQu9GM0L3QvtGB0YLQuNGB0L7QvtGC0LLQtdGC0YHRgtCy0LjQuNC/0YDQvtC40LfQstC+0LTRgdGC0LLQsNCx0LXQt9C+0L/QsNGB0L3QvtGB0YLQuOCkquClgeCkuOCljeCkpOCkv+CkleCkvuCkleCkvuCkguCkl+CljeCksOClh+CkuOCkieCkqOCljeCkueCli+CkguCkqOClh+CkteCkv+Ckp+CkvuCkqOCkuOCkreCkvuCkq+Ckv+CkleCljeCkuOCkv+CkguCkl+CkuOClgeCksOCkleCljeCkt+Ckv+CkpOCkleClieCkquClgOCksOCkvuCkh+Ckn+CkteCkv+CknOCljeCknuCkvuCkquCkqOCkleCkvuCksOCljeCksOCkteCkvuCkiOCkuOCkleCljeCksOCkv+Ckr+CkpOCkvgEgAiwgCCBvZiB0aGUgBCBvZiACcyABLgUgYW5kIAQgaW4gASIEIHRvIAIiPgEKAi4gAV0FIGZvciADIGEgBiB0aGF0IAEnBiB3aXRoIAYgZnJvbSAEIGJ5IAEoBi4gVGhlIAQgb24gBCBhcyAEIGlzIARpbmcgAgoJAToDZWQgAj0iBCBhdCADbHkgASwCPScFLmNvbS8HLiBUaGlzIAUgbm90IANlciADYWwgBGZ1bCAEaXZlIAVsZXNzIARlc3QgBGl6ZSACwqAEb3VzIAUgdGhlIAJlIABBsvwHC2ECAAUADgATABYAGAAeACMAJQAqAC0ALwAyADQAOgA+AEUARwBOAFUAWgBcAGMAaABtAHIAdwB6AHwAgACDAIgAjACOAJEAlwCfAKUAqQCtALIAtwC9AMIAxwDKAM8A1QDYAEGg/QcL8gIxADExAAAAAAAxDDExCgAxAC8AADEEAAAxAAMxCjExAAYxDTExATEBAAAxAAEACgAxAAcxAAkwAAAxAAgxAAUxAAoxAAsxAzExAA0xAA4xDjExAjExAA8xABAACjExAAwFADEAAAExDzExABIxABExABMxABQxEDExETEvADExBDExABYxCzExABcxABgxABkxBzExARoxABsxABwAAAwxAB0xFDExEjExBjExABUxCgExCDExAB8xACAvAAMxBTExCTEACgExCggFABUxCwAxCgoxAB4AAAUjADEvAAIxChExACQxACEFAAAxChUxCgUxACUAAB4xACYACwAxACcACzExACIxCwgxCgwAABUxACgACgwxACkxACoxCxExACsACgUxCwoAACIxCiExACwxCwUtADEAACExCh4xCx4xAC4xCwExCiIACiEACx4ACwExCyExCxUxCwwACwUxCyIACwwACh4ACyIACiIAAAAAAEh9AEGigAgLAmRVAEGygAgLAiaeAEG+gAgLAuayAEHMgAgLAgwFAEHWgAgLCmQTFgGlXAAABE4AQfiACAsMTgjmPgAAAAAAAGU4AEGSgQgLCmdozQgAAAAAZEMAQa6BCAsCJg4AQbiBCAsCyFkAQcaBCAsGB0EAAMeFAEHWgQgLAma9AEH0gQgLAs8JAEG4gggLEExMAAAAAMRdAAAAAAAAZCYAQeaCCAsChXgAQaqDCAsC5nwAQbyDCAsQqlBkCQAAJVGNBkcjAAAEGQBB8oMICwKnygBBkIQICxZpGiYcAAAAAOhVx1kAAAAAyQ0AAEgHAEGyhAgLGiYrAAAAAKklAAAAAAAAaxkAAAAARpBIVKfzAEHehAgLAmYgAEHuhAgLDGefAAAA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//8CAAAA/f///wMAAAD/////AQAAAP7///8CAAAA/f///wMAAAABAgMEAAURBhAHCAkKCwwNDg8AQfCFDAsVhAAAADkAAAAXAAAACgAAAAQAAAABAEGUhgwL+RUEAAAACAAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAACwAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAAA4AAAAOAAAADgAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAFQAAABUAAAAVAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAA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AAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAB4AAAAeAAAAHgAAAAsAAAAAAAAAGwAAAAAAAAArAAAAAAAAADsAAAAAAAAAywIAAAAAAADLBgAAAAAAAMsKAAAAAAAAyw4AAAAAAADbAgAAAAAAANsGAAAAAAAA2woAAAAAAADbDgAAAAAAAOsCAAAAAAAA6wYAAAAAAADrCgAAAAAAAOsOAAAAAAAA+wIAAAAAAAD7BgAAAAAAAPsKAAAAAAAA+w4AAAAAAADLsgAAAAAAAMuyAQAAAAAAy7ICAAAAAADLsgMAAAAAAMu2AAAAAAAAy7YBAAAAAADLtgIAAAAAAMu2AwAAAAAAy7oAAAAAAADLugEAAAAAAMu6AgAAAAAAy7oDAAAAAADLvgAAAAAAAMu+AQAAAAAAy74CAAAAAADLvgMAAAAAANuyAAAAAAAA27IBAAAAAADbsgIAAAAAANuyAwAAAAAA27YAAAAAAADbtgEAAAAAANu2AgAAAAAA27YDAAAAAADbugAAAAAAANu6AQAAAAAA27oCAAAAAADbugMAAAAAANu+AAAAAAAA274BAAAAAADbvgIAAAAAANu+AwAAAAAA67IAAAAAAADrsgEAAAAAAOuyAgAAAAAA67IDAAAAAADrtgAAAAAAAOu2AQAAAAAA67YCAAAAAADrtgMAAAAAAOu6AAAAAAAA67oBAAAAAADrugIAAAAAAOu6AwAAAAAA674AAAAAAADrvgEAAAAAAOu+AgAAAAAA674DAAAAAAD7sgAAAAAAAPuyAQAAAAAA+7ICAAAAAAD7sgMAAAAAAPu2AAAAAAAA+7YBAAAAAAD7tgIAAAAAAPu2AwAAAAAA+7oAAAAAAAD7ugEAAAAAAPu6AgAAAAAA+7oDAAAAAAD7vgAAAAAAAPu+AQAAAAAA+74CAAAAAAD7vgMAAAAAAMuyLAAAAAAAy7JsAAAAAADLsqwAAAAAAMuy7AAAAAAAy7ItAAAAAADLsm0AAAAAAMuyrQAAAAAAy7LtAAAAAADLsi4AAAAAAMuybgAAAAAAy7KuAAAAAADLsu4AAAAAAMuyLwAAAAAAy7JvAAAAAADLsq8AAAAAAMuy7wAAAAAAy7YsAAAAAADLtmwAAAAAAMu2rAAAAAAAy7bsAAAAAADLti0AAAAAAMu2bQAAAAAAy7atAAAAAADLtu0AAAAAAMu2LgAAAAAAy7ZuAAAAAADLtq4AAAAAAMu27gAAAAAAy7YvAAAAAADLtm8AAAAAAMu2rwAAAAAAy7bvAAAAAADLuiwAAAAAAMu6bAAAAAAAy7qsAAAAAADLuuwAAAAAAMu6LQAAAAAAy7ptAAAAAADLuq0AAAAAAMu67QAAAAAAy7ouAAAAAADLum4AAAAAAMu6rgAAAAAAy7ruAAAAAADLui8AAAAAAMu6bwAAAAAAy7qvAAAAAADLuu8AAAAAAMu+LAAAAAAAy75sAAAAAADLvqwAAAAAAMu+7AAAAAAAy74tAAAAAADLvm0AAAAAAMu+rQAAAAAAy77tAAAAAADLvi4AAAAAAMu+bgAAAAAAy76uAAAAAADLvu4AAAAAAMu+LwAAAAAAy75vAAAAAADLvq8AAAAAAMu+7wAAAAAA27IsAAAAAADbsmwAAAAAANuyrAAAAAAA27LsAAAAAADbsi0AAAAAANuybQAAAAAA27KtAAAAAADbsu0AAAAAANuyLgAAAAAA27JuAAAAAADbsq4AAAAAANuy7gAAAAAA27IvAAAAAADbsm8AAAAAANuyrwAAAAAA27LvAAAAAADbtiwAAAAAANu2bAAAAAAA27asAAAAAADbtuwAAAAAANu2LQAAAAAA27ZtAAAAAADbtq0AAAAAANu27QAAAAAA27YuAAAAAADbtm4AAAAAANu2rgAAAAAA27buAAAAAADbti8AAAAAANu2bwAAAAAA27avAAAAAADbtu8AAAAAANu6LAAAAAAA27psAAAAAADbuqwAAAAAANu67AAAAAAA27otAAAAAADbum0AAAAAANu6rQAAAAAA27rtAAAAAADbui4AAAAAANu6bgAAAAAA27quAAAAAADbuu4AAAAAANu6LwAAAAAA27pvAAAAAADbuq8AAAAAANu67wAAAAAA274sAAAAAADbvmwAAAAAANu+rAAAAAAA277sAAAAAADbvi0AAAAAANu+bQAAAAAA276tAAAAAADbvu0AAAAAANu+LgAAAAAA275uAAAAAADbvq4AAAAAANu+7gAAAAAA274vAAAAAADbvm8AAAAAANu+rwAAAAAA277vAAAAAADrsiwAAAAAAOuybAAAAAAA67KsAAAAAADrsuwAAAAAAOuyLQAAAAAA67JtAAAAAADrsq0AAAAAAOuy7QAAAAAA67IuAAAAAADrsm4AAAAAAOuyrgAAAAAA67LuAAAAAADrsi8AAAAAAOuybwAAAAAA67KvAAAAAADrsu8AAAAAAOu2LAAAAAAA67ZsAAAAAADrtqwAAAAAAOu27AAAAAAA67YtAAAAAADrtm0AAAAAAOu2rQAAAAAA67btAAAAAADrti4AAAAAAOu2bgAAAAAA67auAAAAAADrtu4AAAAAAOu2LwAAAAAA67ZvAAAAAADrtq8AAAAAAOu27wAAAAAA67osAAAAAADrumwAAAAAAOu6rAAAAAAA67rsAAAAAADrui0AAAAAAOu6bQAAAAAA67qtAAAAAADruu0AAAAAAOu6LgAAAAAA67puAAAAAADruq4AAAAAAOu67gAAAAAA67ovAAAAAADrum8AAAAAAOu6rwAA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AAAAy7otCwAAAADLui0bAAAAAMu6LSsAAAAAy7otOwAAAADLum0LAAAAAMu6bRsAAAAAy7ptKwAAAADLum07AAAAAMu6rQsAAAAAy7qtGwAAAADLuq0rAAAAAMu6rTsAAAAAy7rtCwAAAADLuu0bAAAAAMu67SsAAAAAy7rtOwAAAADLui4LAAAAAMu6LhsAAAAAy7ouKwAAAADLui47AAAAAMu6bgsAAAAAy7puGwAAAADLum4rAAAAAMu6bjsAAAAAy7quCwAAAADLuq4bAAAAAMu6risAAAAAy7quOwAAAADLuu4LAAAAAMu67hsAAAAAy7ruKwAAAADLuu47AAAAAMu6LwsAAAAAy7ovGwAAAADLui8rAAAAAMu6LzsAAAAAy7pvCwAAAADLum8bAAAAAMu6bysAAAAAy7pvOwAAAADLuq8LAAAAAMu6rxsAAAAAy7qvKwAAAADLuq87AAAAAMu67wsAAAAAy7rvGwAAAADLuu8rAAAAAMu67zsAAAAAy74sCwAAAADLviwbAAAAAMu+LCsAAAAAy74sOwAAAADLvmwLAAAAAMu+bBsAAAAAy75sKwAAAADLvmw7AAAAAMu+rAsAAAAAy76sGwAAAADLvqwrAAAAAMu+rDsAAAAAy77sCwAAAADLvuwbAAAAAMu+7CsAAAAAy77sOwAAAADLvi0LAAAAAMu+LRsAAAAAy74tKwAAAADLvi07AAAAAMu+bQsAAAAAy75tGwAAAADLvm0rAAAAAMu+bTsAAAAAy76tCwAAAADLvq0bAAAAAMu+rSsAAAAAy76tOwAAAADLvu0LAAAAAMu+7RsAAAAAy77tKwAAAADLvu07AAAAAMu+LgsAAAAAy74uGwAAAADLvi4rAAAAAMu+LjsAAAAAy75uCwAAAADLvm4bAAAAAMu+bisAAAAAy75uOwAAAADLvq4LAAAAAMu+rhsAAAAAy76uKwAAAADLvq47AAAAAMu+7gsAAAAAy77uGwAAAADLvu4rAAAAAMu+7jsAAAAAy74vCwAAAADLvi8bAAAAAMu+LysAAAAAy74vOwAAAADLvm8LAAAAAMu+bxsAAAAAy75vKwAAAADLvm87AAAAAMu+rwsAAAAAy76vGwAAAADLvq8rAAAAAMu+rzsAAAAAy77vCwAAAADLvu8bAAAAAMu+7ysAAAAAy77vOwAAAADbsiwLAAAAANuyLBsAAAAA27IsKwAAAADbsiw7AAAAANuybAsAAAAA27JsGwAAAADbsmwrAAAAANuybDsAAAAA27KsCwAAAADbsqwbAAAAANuyrCsAAAAA27KsOwAAAADbsuwLAAAAANuy7BsAAAAA27LsKwAAAADbsuw7AAAAANuyLQsAAAAA27ItGwAAAADbsi0rAAAAANuyLTsAAAAA27JtCwAAAADbsm0bAAAAANuybSsAAAAA27JtOwAAAADbsq0LAAAAANuyrRsAAAAA27KtKwAAAADbsq07AAAAANuy7QsAAAAA27LtGwAAAADbsu0rAAAAANuy7TsAAAAA27IuCwAAAADbsi4bAAAAANuyLisAAAAA27IuOwAAAADbsm4LAAAAANuybhsAAAAA27JuKwAAAADbsm47AAAAANuyrgsAAAAA27KuGwAAAADbsq4rAAAAANuyrjsAAAAA27LuCwAAAADbsu4bAAAAANuy7isAAAAA27LuOwAAAADbsi8LAAAAANuyLxsAAAAA27IvKwAAAADbsi87AAAAANuybwsAAAAA27JvGwAAAADbsm8rAAAAANuybzsAAAAA27KvCwAAAADbsq8bAAAAANuyrysAAAAA27KvOwAAAADbsu8LAAAAANuy7xsAAAAA27LvKwAAAADbsu87AAAAANu2LAsAAAAA27YsGwAAAADbtiwrAAAAANu2LDsAAAAA27ZsCwAAAADbtmwbAAAAANu2bCsAAAAA27ZsOwAAAADbtqwLAAAAANu2rBsAAAAA27asKwAAAADbtqw7AAAAANu27AsAAAAA27bsGwAAAADbtuwrAAAAANu27DsAAAAA27YtCwAAAADbti0bAAAAANu2LSsAAAAA27YtOwAAAADbtm0LAAAAANu2bRsAAAAA27ZtKwAAAADbtm07AAAAANu2rQsAAAAA27atGwAAAADbtq0rAAAAANu2rTsAAAAA27btCwAAAADbtu0bAAAAANu27SsAAAAA27btOwAAAADbti4LAAAAANu2LhsAAAAA27YuKwAAAADbti47AAAAANu2bgsAAAAA27ZuGwAAAADbtm4rAAAAANu2bjsAAAAA27auCwAAAADbtq4bAAAAANu2risAAAAA27auOwAAAAAAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+PwABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj8AAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/AEGEjw0L/AEBAQEBAgICAgMDAwMEBAQEBQUFBQYGBgYHBwcHCAgICAkJCQkKCgoKCwsLCwwMDAwNDQ0NDg4ODg8PDw8QEBAQERERERISEhITExMTFBQUFBUVFRUWFhYWFxcXFxgYGBgZGRkZGhoaGhsbGxscHBwcHR0dHR4eHh4fHx8fICAgICEhISEiIiIiIyMjIyQkJCQlJSUlJiYmJicnJycoKCgoKSkpKSoqKiorKysrLCwsLC0tLS0uLi4uLy8vLzAwMDAxMTExMjIyMjMzMzM0NDQ0NTU1NTY2NjY3Nzc3ODg4ODk5OTk6Ojo6Ozs7Ozw8PDw9PT09Pj4+Pj8/Pz8AQYmTDQsFBAQAAAQAQaCTDQvgAQgMEAwMFAwQGBwMDCAMJAwsLCwsLCwsLCwsICAYKBwMDDA0NDQwNDQ0MDQ0NDQ0MDQ0NDQ0MDQ0NDQ0GAwcDAwMODw8PDg8PDw4PDw8PDw4PDw8PDw4PDw8PDwYDBwMAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAECAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAEGhlQ0LXgEBAQEBAQEBAQEBAQEBAQICAgICAgICAgIBAQEBAQEBAgICAgICAgICAgICAgICAgICAgICAgICAgIBAQEBAQEDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwEBAQEAQeCWDQugBAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAgICAgICAgICAgICAgICBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoMDAwMDAwMDAwMDAwMDAwOAABAQEBAQEBAQEBAQEBAQECAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQYGBgYGBgYGBgYGBgYGBgcAQZibDQuGAgEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAwAAAAOAAAAGAAAAAAAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAIAAAACgAAAA4AAAASAAAAGgAAACIAAAAyAAAAQgAAAGIAAACCAAAAwgAAAEIBAABCAgAAQgQAAEIIAABCGAAAQlgAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAwAAAAOAAAAEgAAABYAAAAeAAAAJgAAADYAAABGAAAAZgAAAIYAAADGAAAARgEAAEYCAABGBAAARggAQcCdDQvNFAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAABgAAAABAAAAAgAAAAUAAAACAAAACQAAAAIAAAANAAAAAgAAABEAAAADAAAAGQAAAAMAAAAhAAAAAwAAACkAAAADAAAAMQAAAAQAAABBAAAABAAAAFEAAAAEAAAAYQAAAAQAAABxAAAABQAAAJEAAAAFAAAAsQAAAAUAAADRAAAABQAAAPEAAAAGAAAAMQEAAAYAAABxAQAABwAAAPEBAAAIAAAA8QIAAAkAAADxBAAACgAAAPEIAAALAAAA8RAAAAwAAADxIAAADQAAAPFAAAAYAAAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsAAAABgACAAUAAQAHAAMABIAAgAaAAoAFgAGAB4ADgARAAEAGQAJABUABQAdAA0AEwADABsACwAXAAcAHwAPABCAAIAYgAiAFIAEgByADIASgAKAGoAKgBaABoAegA6AEYABgBmACYAVgAWAHYANgBOAA4AbgAuAF4AHgB+AD4AQQABAGEAIQBRABEAcQAxAEkACQBpACkAWQAZAHkAOQBFAAUAZQAlAFUAFQB1ADUATQANAG0ALQBdAB0AfQA9AEMAAwBjACMAUwATAHMAMwBLAAsAawArAFsAGwB7ADsARwAHAGcAJwBXABcAdwA3AE8ADwBvAC8AXwAfAH8APwBAgACAYIAggFCAEIBwgDCASIAIgGiAKIBYgBiAeIA4gESABIBkgCSAVIAUgHSANIBMgAyAbIAsgFyAHIB8gDyAQoACgGKAIoBSgBKAcoAygEqACoBqgCqAWoAagHqAOoBGgAaAZoAmgFaAFoB2gDaAToAOgG6ALoBegB6AfoA+gEGAAYBhgCGAUYARgHGAMYBJgAmAaYApgFmAGYB5gDmARYAFgGWAJYBVgBWAdYA1gE2ADYBtgC2AXYAdgH2APYBDgAOAY4AjgFOAE4BzgDOAS4ALgGuAK4BbgBuAe4A7gEeAB4BngCeAV4AXgHeAN4BPgA+Ab4AvgF+AH4B/gD+AQEAAQGBAIEBQQBBAcEAwQEhACEBoQChAWEAYQHhAOEBEQARAZEAkQFRAFEB0QDRATEAMQGxALEBcQBxAfEA8QEJAAkBiQCJAUkASQHJAMkBKQApAakAqQFpAGkB6QDpARkAGQGZAJkBWQBZAdkA2QE5ADkBuQC5AXkAeQH5APkBBQAFAYUAhQFFAEUBxQDFASUAJQGlAKUBZQBlAeUA5QEVABUBlQCVAVUAVQHVANUBNQA1AbUAtQF1AHUB9QD1AQ0ADQGNAI0BTQBNAc0AzQEtAC0BrQCtAW0AbQHtAO0BHQAdAZ0AnQFdAF0B3QDdAT0APQG9AL0BfQB9Af0A/QEDAAMBgwCDAUMAQwHDAMMBIwAjAaMAowFjAGMB4wDjARMAEwGTAJMBUwBTAdMA0wEzADMBswCzAXMAcwHzAPMBCwALAYsAiwFLAEsBywDLASsAKwGrAKsBawBrAesA6wEbABsBmwCbAVsAWwHbANsBOwA7AbsAuwF7AHsB+wD7AQcABwQHAgcGBwEHBQcDBweHAIcEhwKHBocBhwWHA4cHRwBHBEcCRwZHAUcFRwNHB8cAxwTHAscGxwHHBccDxwcnACcEJwInBicB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Cwu6A40L4QGEAGoDCQDlAAUKhQGICnwCBwvVBogL3QGGALQDBQs0AYcLQAQEAOwCiwDxA4gKFQAGACsChwDlAQULfgAICykBCQtuAQkLvQEMCzUADAt2AY0L7AEHCw8GiwtpAYgAwQCIANgBCACNAg0AXQCTAA4AhADYA4QLrwAFAKwABgCzB4QLrQKVCwgAhQsdAw0AUwAFCr0ABwq6AQcKuwEIChkBDAquAI0KBQGGACAGhQs1AosAgAGFAAQBBwD2AgcAcAMHAE8FCQCkAAkApwAKAJwACgBMAgwAZQAOADAADwBGAAYKAgAHCu4EBwrJBggKFgAICg4BCApkAgkKOAEJCrQBCgo3AQoKbwILCkgACwpKAQsKxwEMCkEBDAr4AQwKEgIMCh8CDQoRAA0KnAANCk4BEQo8AJQKQAAEC/wABwssBAoLsgELC+QACwuqAQ0L5wASC2oAlAtXAAcKYgEKCpoBiwovAwYAbwEHCp4CBwovBQgKmwEICrMBCQqNAgkK5AIKCoEBCwreAAsKRAELCj0DjApjAgcAlgQGCqYAhwp2AZIAeQCEADwDBQvnAIoL/QEHC1kCCQsVAQkLogIKC7IACgsBAQoLogELCxMCCwsgAgsLSQIMC3EADAvbAQ0LYwCOC6wBhgAFBocL8wYFAFcBhgqOAYcKMgCHC5MGBAC4AQcAOQAIAKcACAB3AQkAUgAJADECCQDoAgoAbAKJC+gChgCeAwYKBQIHCocECgptAosKwACJADsDCADCAIgA9AIKCt8AiwqFAgcKQACICvUABAuPAQULdwAFC+4BBwvvAokLLAKEACgDhwAWAAcK4waMCjYBBQB/AgcA4QQLAIADhgtIAoYATgaHAFwDhwthBAUKgQAGCj0AhwqzAwQAZgAHAC8DBwCjBosAxAMNCvkBjQr6AYsK6AOEC6cChACDA4QAOQIFC7YCiQvKAogAGwMGAP0HiwsHAAYANAAJAGgACQAvAgwANAGTAFcABAAtAYQAXAKFCn0CiAALAwULjwAFCwEDBgvgBgcLqgIHC8gHiAvgAokKTgKTACAAiQsPAgUKGAGHCsoEhgDuAQYApQIGAKoChgAUBIUKGQGHCigEBwD8AYULXAMGC6YBBwsAAAcLCAYJC0ECCwveAwwLjQAMC8UBDQsvAI0LCgGGAPYDBQsDAokLgwCGAL0D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Bwp7BwkKuQAJCusACgpAAAoKDgEKCpMBCgrVAQoKEQIKCk4CCwqMAAsKXAMNCgEADQqmAQ4KVQEOCmwBEQpdABIKcQATCmEAkwpxAIUKtwKHAGEEBQoGAAYKtwAHCqgCBwrSAwcK9QMHCh8EDArmAA0KrACSCh0ABAsIAAcLgAQHC4EEBwuzBgkLdgEKC94BiwuIAocLSwQGCh0Aiwo/AAQAMQIKAPkAiwDRAIQA+AIHCx8Digv/AYgLVwAJAJoAjADlAYgA/wCEAEMBjACjAYQKNwGGCswGBABwAYcAgQIHCqoACApaAAgKsQAICp8BCwrKAo4KGQEEC0UABQt6AAkLkAKKC9ABBQtRA4YLYQYIAAoCjgBIAQsKWwANCoEADwplAJEKfQAHADICCAAnAgQK7gEGCkoABwosAAsL8wEMChEADwoFAJQKCwAEChQBhQooAQkAXACTAFsABAoHAAUKWgAFCp4ABgoeAgcK3QAHCiYGCQrqAQoKHAILCrsBiwr1AgYADQIGALgHCAAmAwkAbAOMABwBBQtbAwcKTAIHC4gECAtrAAkKrwAJCyMBCQu3AQoKEgIKC5cCCwthAowLxQAHC6gADQvEAI0L7QCLAL4DhQBSAocKRAIHClgAiApzAgYA3wEGADICBwAkBA0ABgAFCmgDBgo5AAcK1wEJCr8BiQrGAYgLnQGRCxMABAt1AAYLdAEHC3EHjgtDAQQL0gKLC9cBEQA9AAUKHwCGCmYCCApKAYwK3QEHCrAEigrMAQYKqAGHCkoHBgBpBogANAMGABQGhgBSBgkLBQAMC9gADAsmAQwLKgEMC5ABDAsGAg0L5QCPC4sADwubAJALTwAEAC4BhwDmBgUKDQCGCo4ABgCUAAcAIQUHCnQACApCAQgK8wIJCiQCCgrKAgsKdAONCkQBiQCkAgkLWACLCw4BBQsMAAcLdwGJC7YBhgCKBgcKwAWHChIGCwCyAAcKLwQHCgUGBwrnBgcKDgcLCqIACwryAAwKXQIPChoAkAosAAYAhQEHAJUACQCOAIoAXgCMC0cAkQpzAAYACAAHAFkHCABbAAsLxgMMCx8BDQtWAQ0LkgEPC24AjwujAAQLAgGIC38CBgsWAAcLhwOKC0EChQupAocKVwSHCwYFCQBwAAgKAQCKCkYBBQroAQYKDwIHCukBBwpkBggKeQAICpAA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Cgu5AgsLyAGLC/QCCQuLAYoLTwCJC2wAkwBeAIgA7gGHC3cChwpuAgcA5gWHCtYGBArLAIcKkAcHC5YBBwvLAQgLXgKLC9YCBwAaBQgA+QEJAOIBCgB+AAsA4QAMAFsBDADBAQ0AEwAOANoAjgCzAQUADAEKAPwCDAB4AA0AJwCRAH8AjgtEAAsKpgKMCjMBDAsMAQwLgAKOC3cAhwr8B4ULZAIEC3QBBwviAQgLngAJC1oCCQtnAgoL9QAKC6YCCgvoAgsL+ACLCyYDBwo3AQkKNAGMCv8ABACAAYcA/gMFC1YDhwvHB4cK8gQECpABBQoLAYcK6ACHAKcGCQCfAAsAlQKMAFsCBADEAw4AtgEOALwBDgDIARYAPAAWAD8ACQtqAAkLowAJCygBCgunAAoLrAAKCwkDiwsQAIgARwKEAAMCCAB4AggAuQKJAFYDBQvDAIcLlQYGAGMEhgBVBYYLSAEHC80HCAvaAosL7gMEAIgAhQAnAoYA9gYHAAcFCQAsAAoAKAIKAIICCwBHAwwAEgEMABMBDAB0AQ0AWwCOAH0ABQvvAgsLHQOMC8sAhQDcAgcApwIIADkBBApkAIcLNQMKAGkBjgA8AYYAUwIGAJMABwB2AwkA8QKKAAwBBQpqAQUKuwEGCj4BBwr7A4sKbwIFCs8BiAooAQQKxgEFC7YDBQviA4YLXwGKAIkABQowAAUKlAEGCi0CBwrKAQgKVQIKCscBCgpeAgsKMQALCiQCDArcAQ0KEgCNCsIBhQCeAYcA4gYFC6UBhwsvAAUKugGHCsAHhgBXAoYA1QaGAFsGBADoAYQLXgGJC+8ChABTAIwApAKFC8cDBwBnBgUKNwCMCqEABAvZAQcLbwIICygDCQtnAwkLfQMLCyYACwuvAQwLcAAMC9kADAvzAAwLMgIMC6sCDQuNAA0LxQANC+MADQuWAQ0L5wEOC5wADgvLAA4L4AAOCwABEgs6AJYLAACFCsIBBwvgAosLCAGGABYBBAveAAcLHgGIC3UChwplA4wAYQCQAA4AhgA9BAQK1QAHCt8AiApQAAcAhAEHAIQCiwANA4QAUQMHAOUACAA7AAkAvgAKAHoBjAC/AAcKfQEHCiYDBwo0AwgKYgEICrUBCAoTAwkKkQIKCjoACgpTAQoK7QILCpIDDAqiAA0KSwAOCmoADgrGAA4KQAEOCp0B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hApzAQQKEAGHCkQDBQo5A4YKaAYFC/sABQu8AwgLDAEJC9YAkguOAIoANAEGAEcHjQslAIkKbwMHCj0Bhwo5AoQLJgGGABYDBQDqA4gA6QIFC1oBBQvHAogLhgGHACEBBQD4AQsARACJCjMBBADvAAYA3QEHAEcGiwBpApUADQCFAGEChQtwAgULDwMHC84Hhwv/B4UKDQKEAG8BhAtSAgYAEAKFCu0BBAquAIcKjwMICqEBiQoOA4QAtgIHACQCiQA6AAQKIAAFCtcABgoNAQcK9gYHCmQHCgoQAAsKNgMLCroDjQrhAYwArwIHANUGiArdAYQLOQKFCjQBhwpABAQAlQKKAOwDBQslAAYLJwAGC8MBBwvaAAcLmwIHC44EBwuXBggLlgKQCwIACQC9AQwANQANAOwBBQp+AAgKKQEJCm4BjAp2AQcKDwaLCmkBlABKAIYL/AGHANUAhAqvAIQKrQIGAPgCBgBCA4YA4AQHC8UBBwt7AgcLHAMIC0sBCQtIAQkLSgEJC2EDCgt3AAoL6wALC28ACwuBAAsL8AAMCx8ADAtCAAwL3gAMCw0BDAtXAgwLsQINC7oADQtsAY4LWQEHAIgGiwC9AIUKHQOFCjUCBgAMBgYLYgAHC0kChwu+AgkAyAMPAMAAlQA4AAQK/AAGCyUABwsrAQcKLAQHC4IGCAvDAAgLPAEJC7IACQsUAQkLUwEJCxgCCgtmAAoLagEKCrIBCgsRAwsLNwALC5UACwrkAAsKqgELCwUDDQrnAA0LoAENC6MBDgsmAA4LKQAOC9IAEgpqAJQKVwAEAO8CCwCGAYwAIAAEAJkBhQBOAAsLygEMCw8AjAuwAQcAQgYKAAEBCgC6AgsAIAILAEkCDADUAA0AMwEFCucABwpZAgkKFQEJCqICCgqyAAoKogEKCv0BCwoTAgwKcQAMCtsBDQpjAI4KrAEGANkBkQBpAAYAnQcPAJwAhQuFAgcKNwaQCisAhwDzBocKkwYECyIBhwtMBYYA+wIGC0YABwsMBQoL+gKLCyABjgAdAIwLrAEHAHMDBwuDAAcLpgEIC9IAjAs9AoYA6AEECo8BBQp3AAUK7gEHCu8CiQosAoUAaQKEC6gDiwAyAAcA7gWLALYCiQARAwQAIgKHAPoHBwvMAg0LYQCNC/sAhAuNApEAFgCGAPgDBAA5AYUAQQKIC5EC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CAsGAwoLngKMCzMAhQoQA4sKcgMEAFIABQBNAQUAiAMGAM8ABwBFAQcAvgYIAGUACgAKA4sA3ACHC3MBhAC+A4UAhwMEC38ABQteAQYLZAEIC6oBCQs8AgoL9wCLCzgBjACTAAYLOwAHC3UDCQtbAo0LjQEKAG8BCQoOAAkKuQGLCgkACwrGAwwKHwENClYBDQqSAQ8KbgCPCqMAhgCyAoQAwQIJAIsCCwDLAw0AEQEHCpQFBwpoBgcKSwcJCqkACQq2AAkKbwEJCt4BCQr6AQkKJwIJCi0CCQqIAgkKuQIJCsECCQrVAgkKEwMJChoDCgrGAAoK1gAKCgsBCgoTAQoKyAEKCicCCgoxAgoKZQIKCnMCCgqcAgoKowIKCrMCCgq3AgoKwwIKCssCCwq3AAsKyQALCgYBCwpgAQsKtwELCu0BCwo8AgsKTwILCmACCwpjAgsKhgILCqICCwrHAgsK7wILCvkCCwoIAwsKEQMLClIDCwpVAwsKXgMLCmEDCwpkAwsKawMLCoIDCwqGAwsKhwMLCo4DCwqkAwsKrgMLCr0DCwrHAwsKzAMMCpQADArDAAwK3AAMCu0ADAo+AQwKUwEMCokBDAq9AQwKwgEMCtoBDAr5AQwK/QEMChUCDApPAgwKUgIMClUCDAptAgwKeQIMCoICDQo7AA0KPAANCpEADQrvAA0K+gANCkkBDQpYAQ0KbQENCnQBDQqDAQ0KkwENCp4BDQrIAQ0K1gENCt4BDQrjAQ0K6QEOCjcADgo5AA4KUQAOCloADgqUAA4K7wAOCgoBDgpBAQ4KRgEOCkcBDgpKAQ4KWwEOCmMBDgqRAQ4KlAEOCpsBDgqeAQ4KoAEOCqQBDwo9AA8KSgAPClcADwpYAA8KXgAPCmAADwp0AA8KlQAPCpoAEAoyABAKPwAQCkkAEQoCABEKQgARClwAEQpnABEKcAARCngAEgoyABIKNgASClIAEgpWABIKWgASCm8AEgpzABIKnAATCigAEwpPABQKTgCVChYABwB3AwUKoQCHCkcDjgtiAIYAWgCKC2QBhwu5AQYLbwAHCwQACAujAAgLCAOKCzYChgCMA4YA7QQHAC0DDADxAY0AOACGANMEhwCtAYcLygeKAIgDBgB9AAcA/QSJAAQDlwAMAAQASQMFAIIBhQuCAQULKQGHCw4EBgBcAwYALQSHCzUB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CwsiAgsLtAIMCwMBDAsnAQ0LLgCNC5oAhgCkAoQLTAIEC+cABQs9AAYLaAAHC9kCBwvEAwcLegaMC54BBgsHAYoL9QILAFEBjgAvAYcLUwWEC0ABjAD6AYYKvwEFAE0ABwCvBQoASwOTAEkABwpBAgcKmAUJCtsBCQr5AQkKDgIJCmECCQqxAgkK1gIJCt8CCQriAgoKLAIKCqICCgqsAgsKWQALCsoACwoQAQsKfAELCp8BCwr5AQsKGQILCiYCCwoyAgsKgAILCpsCCwqwAgsKTwMLCp8DCwqiAwsKrAMMCpAADApFAQwKSQEMCoUBDAqTAQwKwwEMCgMCDApcAgwKaAIMCnICDQpCAA0KgwANCqcADQrsAA0KcAENCpsBDQqyAQ0KxQENCs0BDQraAQ4KOwAOCjwADgqLAA4KmAAOChQBDgphAQ4KkgEPChwADwpRAA8KewAPCpgAEgqIAJQKWACEAMoBhwCMBQYAbQAKAH4BBAuVAQQKYQIHCvQCBwsxAwkKIAILCp0BDgs6AA4KMwEQChkAEQslAJILfAAGAEoBBwA8BAsAjgCFC84DBAqiA4UKswMFCqsDjguKARAAWwCRAFcABQvrAAUKwgMHC9cECwuDAIwLcgELAOwBBQqLAggKqgAJCj0ACQo/AAoKFwAKCiUACgpCAwsKBAALChkBCwr3AQsKpQIMCmAADAqCAAwK9AAOCgUADgooAA4KogAOCsoAkgqFAAQKlgEFCkMCDArsAZYKDwAJC4kAigvdAIYA1wQLANMAjACRAAcLhgGKC4wAhwuKBYcLeASGABkEBwBBAQYKEQAHCukDBwq+BwkKdgMKCukBCgogAwsKDgMMCkABDQrTAQ4KkQAOCoMBjwp3AJEKEQAFC5cBCwvpARMLJQAUC0kAlgsmAIUKygGHAMEHBwq/BwgKAAAICqsACQp4AAkK3AIKCtkBCwqQAgsK5gMSCgAAEgoCAJMKFQAFC0UBBwvLBQgLBQAIC+MACQtpAAoLSQKMC2YCiAB6AIQA6gCHC6wEBgDQAwYASgSGAKEFBwD9AIgAJQIGC20CDQv4AZALEwCECgcCBQCuAQUApAMGAIMABwChAQkACgILADoBjQCGAQ4AlQAOAI8BjwA5AAUKiwMGCh8ABgvaAAcK6wEHChICCApQAgsKNQALCgsDDAqnAAwKmwEOCg4ADgqIAA8KSAAQChEAkApIAIwLSgEHC8YBBwsOA4gLAAOEAPsBCgukAowLzgEGAHYCCQArAwQK0AAFCmoABgoTAggKmAEJCrwAigo8AgQAVwEFAP8BhgqdBoYLpACEAMABBwDHAYoATwKHAGUFDAq5AZYLMgAJCsEBCgrAAIoK5AIGAD8ChArxAIYAlwSGAI0ChgDhBoYArgSECgMBBgtXAQcLwwAJC+IACgvFAAoLPwILC/YBiwuDAwcAZwQHACQGCgApAQoApgELAPwCCwAqAwwACAENAGYADQAsAQ0A5AEOAJMADgDlABEARwASAHYAkwB4AIcLmgKEAKYCBAqtAAUKOAEFCgAChwoFBQcKQwYHCpsGCQrQAQsKwwAMChcBDArAAQ4KCwCTCmYAEABjAJIApAAHC2UECQuPAAsLPQAOC5UBlgsVAIkLBAEECsQBBQpHAgUKMQMGCrEBBwpRAgcK0AIHCmIFCAqhAAkKHAEKCjkBiwp2A4QKIwKICtICDgAjAI4AvwCNAC0AigB5AIQAfQCGAFYGhQu/AwgKpAGLCsEAhADRAocKmQGIAJEABwAYAwgAkwAKADUDCwDKAwsA/QOIC60AhgsKAYQAywIHAM8Higo0AYUAEwIFAKgABQCiAwgASgAJAG8CDAD0AYwAQwKQAEEAigv2AAYA3AAHAE0EDQBpAI4LOgEFCuoDiArpAoYAwAMUAAAAlAsAAAQA7QMECu8ABgrdAQcKRwYLCkQAiwppAgYAEwAHAIUFiwCsAZUKDQAHAGAACACRAQgAvwIJAIADiAssAYYAOwaRAHQAiAD9AwcAqQcHAK0HBwDuBwgAlgAIAL4CCADhAggA7gKMAG4BCwtLAI4LCwGECm8BCAAgAwkAlAAJAGgDCQB6AwsANQELAOkDDQALAQ0AQwEFC6sBBQveAgcL3gGICzQABwvvAAsL2QCOC6UAhAtDAYwLowENACsBjgBLAAYLVwAGC8YGBwsUAAcLIAQIC9wCCQuWAQkLjwOKC7YChgBnBYQKtgKFC2UCiQALAwQAVgKMCq8CBgDKA4cAqAGFACMCBwsgAAcL2AMIC1UACAvFAgkLQwIJC08DCQtYAwoLHwMLCwIBCwvvAwwLSwEMC2cCDQu8AA0LswEOCwgADwulABALGwCUCygABgDGBIYAaQWEAGwDiguXAIcK1QAEC6cAhwtSAIUAhQAGCxgABwtKAAcLpgKJCwIBBQs+AAYLFgIHC6wCBwsTBAcLMAQICxgBCAsdAggLrgIKCwcCCwv8AIwLGgGIALsACAAIAAoAAAAKADIDiwDcA4QLZwELAK0BDwAzAIcKiAaIAK0CBQvTAAcLWACIC3MChgDYAYgAhAAGC5EAjQtQAQQK7wILCoYBjAogAAYAqgMGACQEBAsHAQQKmQGFCk4AiQBqAwgABgMKAJ4CDAAzAAQLlAMGCtkBBwpCBgoKugIMCtQADQozAZEKaQCSAFwAjwqcAIQAPgOJAL0CBAtXAgYLYgYHCwUABws3AAcLQwAHC2EABwuzAgcL0wMHC6EGCAvPAAgL1gAIC+cACAsmAQgLUAEIC6wBCAvDAQgLzAEIC9cBCAtuAggLcgIIC6cCCAv3AggLPQMJCwsACQv2AAkL5AEJCz0CCQvCAgkL+gIJCx4DCQtXAwkLZgMJC5ADCgsvAQoLTwEKC6gBCgvNAQoLHwIKC/cCCgsuAwsLOwALC8cACwvrAAsL2wELC04CCwuhAwsLwwMMC3IADAu2AAwL4gAMC0wBDAu3AQwLPwIMC1YCDQsIAA0LfQANC8IADQsfAQ4LxQAOC38BDws1ABELPwATCy4AEwtiABMLagCUC1UABAB/AAUAXgEGAGQBCACqAQkAPAIKAPcAiwA4AYYAvwQGADsACQBbAg0AjQEHCz0Higu1AYYA4gaTC34AhwpzAw0AJQGOADgAhQppAosKMgAFC7sABwruBYsKtgKHALkBBgBvAAcABAAIAKMACAAIA4oANgKEACYDBAvXAAkLJgAKCwMACwsXAAsLfwCLCxwDDgDpAAQKIgKHCvoHhwDKB4YAywaHC/oFiACJAQUAKQEHAA4EDgBnARMANACUAC8AhwA1AQQKOQGFCkECCAq4AI0KsQGHCqcDDAq6AAwKJAEOCmQAkgpGAIgAawEOAK8ACwqSAQwKbQAMCq8BDQqzAA0KzgAOCtkAEAoDAJQKNQAFCnYDBgouAAYK/gYHCg4ABwrcAgcKdgYICl8ACApHAQgKaAIJCnwDCgpWAgoKAQMLCoYACwrrAgwKegGOCmEAiACaAocAiwYGAI8ChgBABocAKAOFCv0DBAscAAULuAEHC/gACwtBA4wLWAGGC3YGhAAYAYwANgAEAKUBhQAkAoQKmQAGC1MB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hQoxAYQL9wAHAHMFCADmAQkA7AAJAG4DCgDaAAsAXwATABEAkwAfAAcA+wcIAKACjQDAAQQLuAAFC4YBBgtRAQcLFwAHC+4BBwtqAgcLsAUICxsACAtXAgoLmQCLC8YChwDSAYcK1AQGAKcABwC6AAcAkAIKAIMCBArgAQYKLgEGCmoGBwpFAwcKCwYHCnkGCAqtAQkK5AANCiEBDQpXAZMKZQCGAJQFhgCgBQUAnAEHChYBCgrjAgsKxAKNClwBhgBeBIgAMgKUCy4ACQA8AYsAAAGGAOsGhwCmBIkAhAAKC+MACwvxAQsLxQKMC58BjwBCAAYLaAEHC4AGiAveAZAKHAAEAD0BhwD/BAUAPwCFAP0BiAu7ApEKJACGAMMFCwtXAY4LfwCEC+MChAAgAYcL3QYIAFkACABsAgkAYAILAHQCDABCAY8AfACGAMkEBwClBAQLQwAFC6YBBgprAQcLDQQHCwkFBwsTBgcKowcICtUCCQvlApELbACGALwFBgCxAoYAqwWKAHgAlwABAIkKJQOOAEkBBQotA4cK/geHAOIAigtgAAcAPwcFCsgCCwoRAA0KQQGQCkMACQDNAQYKQAEHCg0DBwqBBwkKNwAKCroACgoRAQoKmAIKCiEDCwrkAwsK5QMNCp0AjgqqAAgLywAICg8BCws3AwsLTgMMC+IBDQuFAA0LFQENCy4BDQvQAQ4LzQCOC90AhwBCBQQLwQGFC84ChgBVAA4AKwEHCmcABwpfAwsKuACRCj4ABAtjAQYLNwEJCwABiguUAYkKkwKKC/YChQs7AwULQACMC0UChgCTBAQLugEHCxcEBwtIBYcLawaEANQDBQvRAwYLIAEHCxAChwspBAUAFwEGAOsABwDUAQgAvgEJAH0CCgDNAgsA4gKMAAIChAAlAQsKUQGOCi8BiAsdAQUAEQAGAHMBCQAQAgwAbAGEC/4ABQpNAAcKrwUKCksDkwpJAJYABQCECsoBBgsMAAcLwwSRC0kAhwqMBQYKbQCKCn4Bhwt9AAYKSgEHCjwEiwqOAAYLcQEGC/YBBwsMBAgLXAEJC8QBCgsaAAsL4AALC4MBCwsEAwwLXwAMC3UCDQvDAA0LzwANC/EADgsEAQ4LDgGPC4wAhAsNAQUL4AEHCxQCBwutBAcLTgUICyMBCwtdAY4LjAGWADAACgBZAg0AYQGNAHgBBQALAwUAJwMGAHcGhgCMBo4L3wAEAMQABQAuAoUAtQOUCw8AhwvkBoYAKgWEAPACiwDhAocLkQKICxUChwCcAQQA4wAFAJ8ABQCZAQcAUAAIACwCCgDfAQwAogEOADIADgB7AA4AwAAOAPkADgAnAY8AGwAHAL4FCABCAAgAiQAIAPkCCQB+AgsAUAALANQACwBwAQsAogEMAAgADQAPABAAPQARADsAEwAcAJQAVACHCsEHBAvTAAQLTAEFC08BBgvuAAcLDQEHCysDBwsFBwgKegAIC0QDCQv7AY0L8gAGAKsChgDkBAQAaQOECuoAhgBDAwYAJgAHAMQECAC5AAgAAAEJABYACQBLAQoA4gILAM0ACwAcAgsA6gINANEBDgBYAI4AwgCKANoDBQvxAwwLRgKSC4MABACfAAYAcwAHAPwABwABAQcAiAcIAEUACQCAAQoAWwAKAGcCDAB3AQ4A6wASAHUAkwB7AIUAjwOIABYBBQquAQUKpAMGCoMABwqhAQkKCgILCjoBjQqGAQ4KlQAOCo8Bjwo5AAQAlwAHAB8GiADtAgUL5AAGC8sABwucAAgLWwGJCwkBhAr7AQoA3QOMALwDhQDeAwUAwgAGAJ8DBwB+BgkAWgCMADQCBApXAYUK/wGFAKkBBwrHAYoKTwIEAAYDBwvcAQcLOAaKC1cABQDLA4cKZQUFCz4Bkwt5AAULIwEHC/0CCQuFAYwLJAKGCj8CBAA7AwwAhgIMAMECDADIAowAygKLAPACiQCWAgUASAAGAAgBBwAVAAcALgAHAN0HCADXAAgAAQIKAAoBiwAWAIsLCgIGAO8ABwB2AAoAXwALAFsCDQC7AQ4AoACPAAQABgCvAYYAnQIHCmcEBwokBgoKKQEKCqYBCwr8AgsKKgMMCggBDQpmAA0KLAENCuQBDgqTAA4K5QARCkcAEgp2AJMKeAAFAGoDBgCNBg8AAAAKCw0CiwtSAAYAQQAHAKsDBwCUBAcAhwYJABwCCgC4AgsACQELANwCCwCgAwsAqQONALYBhgBGBYgLIwKEC6YBBQtjAZELAACJC4kDBQCqAocAXweEACkDBAC4AoULYQMGADIEBgDABQ4KIwCOCr8ABQuSA4YLWQaFC+oAhwtnBYkLDAOECn0ABADWAoUAdgIIACIDiABGA4QK0QIGADkFBwAIAxMAOACICpEAhADKAwcKGAMICpMACgo1A4sK/QOLCsoDCACsA4kAHQOHCyAFCQD4AAoAkAEHCzADBwvZBAcKzwcJCxsBCQsIAgoL1QAKCzMBCgvPAQoLnwIKC+oCCwuRAQsLGgMMCwUCEgtrAJMLcwAGAJ8HhgD4B4cLUwENACkADwBdAAUKqAAFCqIDCApKAAkKbwIMCvQBjApDAgYAdgAHANcABwDxBYwACwAGCtwABwpNBI0KaQAGC6UBBws9AAcLBAYKCwsAigv1AQcAZwKKAPsAjAt3AocAFAQGChMABwqFBYsKrAGFAOEABwpgAAgKkQEICr8CiQqAA5EKdAAGC2YABwtIAA8LjgCTC0MABwqpBwcKrQcICr4CiAruAgcK7gcICpYACArhAgwKbgGXCx4ABAByAQUA9AIHAC4Fhws3AwgKIAMJCpQACQpoAwkKegMLCjUBCwrpAw0KCwGNCkMBBgB+BgcAMAAIAAMDCgB0AA0AaAAOAGkADgC4AA8AqAATAFwAlABEAAoA0QCHC04HBwtEAAgLMAAIC1gACAtGAggLqQIJC3UBCQtgAwsLnQALC1ABCwtLA5QLGwCGAKIDBAtYAAULiQAFC64ABQsJAwYLgAYGC70GBwtNAAcLqgEHCyUFBwtLBQgLfgAICzMCCQsLAgkL7gIKCzYBCgtEAwsLKgALCz4BCwvbAgwLRAAMC1wADAv7AQwLtAINC1EADQvuAA0LdgESC4oAEwtOABMLbwAUCzcAFAtNAJQLXAAEC6oDhwsnBwUKIwIHCqgBCAtpAooLXwEGAAYFBguEBgcL2wUIC3UACQs6AYoLrgAGAPcCBgB+AwcLwwKLCzMCBAB4AIcAZgcJAIEBlQARAIoArQGFC5MBBQA0A4cAowMKAMcAhQqFAAYAlwAGAIsGBwB/AZcACgAGAPkCiAq7AAgAbQEKCgAACgoyA4sK3AMECywABQs3AQYLnAAHC38CBwv6AgcLIwcJCwgACQvOAZQLUwAEC1oBBwtzAAkLtAAJC8gBigtrAYgKrQIHAD4EkQAuAAYAWAYLAAsADACmAQ0AvAGOAGgBBgD8AwYA7ASGADUGBAArAAUAWAEFAGUBDgDYAZYAOgAGAEgHBgBKBwYATAcGAE0HBgBSBwYAVQcGAG8HBgB3BwkAmAMJAJkDCQCcAwkAsgMJAL8DCQDDAwkAygMJAOUDCQDwAwkA+QMMABsDDAAdAwwAHgMMACADDAAjAwwAKwMMADQDDAA1AwwARwMMAEkDDABQAwwAjwMMAJkDDACaAwwAnQMMAKkDDACwAwwAsQMMALkDDwC4AA8AvwAPAMcADwDtAA8A8AAPAPMADwD2ABIAywAVACgAFQA0ABUAOQAYABcAGAAcAJgAHgCGANUCkQs6AIUAeAOJCmoDBADHAggKBgMKCp4CjAozAJALKAAGC7kABwtrB4sLoQKJCr0CiQC4AQQLRwEFC94BBws0BQgL8QKMC+MABAp/AAUKXgEGCmQBCAqqAQkKPAIKCvcAiwo4AQUL/AOFC/4DBAtnAIULkQEGAHkHBgCGBwYApwcJAJIDCQCrAwkAuAMJANMDCQDeAwkA5gMJAOsDCQD/AwwAOwMMAEIDDABNAwwAkAMMAKcDDAC3Aw8ArAAPAK4AEgDGAJUAPwAFAL4DBQDbAwQL8wGHC40FBwB1AwYKOwAGCuIGCQpbAo0KjQEKCz4AjQukAAQATwOHAEYBCwAUAY4AJQEEAEEABQDfAQUA7AMHAHkHCAA9AQkALgEKAGQCDQAWAIQLYAAEAAUBhwD+AYcA6gUGCm8ABwoEAAgKowAICggDigo2AgQAIwEJAAMCDACYAAwAuwENAIgBjgBlAQcLjwGHC9QFBABNAosAGgEGCzMChwrKBwUKKQGHCg4EBACCAAcASwOHABoGBQAqAAUAbwMHAPUABwBEAQcA/AULAM8BCwDYAQ0AawGQADQABACGAIUAdAGFAKgCiAprAQYAzQcIAKcDiADRAwQAKgOHAGIGhwqLBgcAbgUEC44DhQtAAwcKKAMICwoBiwtCAoQAhAIEANYDigBjA4QKGAGHABwCjAo2AIcAewCGALoHBAqlAYUKJAIGAG8CiAAVAwQAjAMFAGcBBQD8AQYAuwYHAFcBBwDMB4cA6geGAMQEBABVAYcA4AEGCv4ACQptAIoKZwCGAHgDCAsQAokLXAEHAMsHCAArAQsAegMMAKICBAsUAIULaAKHC0YEhgpeBgQA7gAFAPcBBgCzAAcA0wcIAH0BCADZAQkAlQAKABQDDwAtAA8AVgAUAG4AlgA5AIUKnwIECxoABQutAQYL9QAHC8ACBwtjBYcLwgUEAHkABQCcAAUAXQEJAK8BCgBdAo4AVgEHC68DiwtmAoQKeQOEC20CBwpmBQcLZgWHCnYHhApzAoUKBwOFCx4ChQtkA4gLsQEGAF0FBwDzAwsKagELCrQDjAqEAQYAUAAHAK0ACQAjAgoA2gIOABIAFgAnAIcL1wUGAJ4GhwC2B4wAxAAEAJsDBgD7AQYArwYHCsMBCAqFAQwK6gENChAADQrXAA0KXwESCoQAkwp9AAYAhgKGABcEhwpJA4gKNgIGAEsGhwC+BIsAngOECw0ChABTAgUA8AAGAMsBBwAMAAcAcgAHALUDBwDZBgcADQcIAJICCQABAAsAvwONAL4BBQqQA4YKnwaEAL4BBws+AAwLLQCTC3AABQrsAAYKPAIICuwBCwpqApAKOAAFCr4AiAo+AYcKYAUEC98ABgtnAQsLAwANC2wADgtZAJALFgCEC4cChgDqAYYA6wGGADAGhwutAooL3AAHAPoAiAD7AYQAngAEAIwABwBqAQgA0QAJAAoACQCgAAkA9wEJAGYCCgCxAgsARwELACkCCwDVAgsA/wIMAPwADABHAg0AwAAOAA0BDgBkAZQAMgATAAEAEwAaAJYACQCEC20ABgDkAAcAPQUJAJgBigBXAQQAdQEFABsBBgDgAQcAYQIKAFwDigBuAwYACwOGALkEBAAtAgcLBwEHC3QCiAtdAYQAJAIHAMUACACOAAgARQEJAJYACQBUAgoAXgEKAGEBCwBKAAsAOwEMAJYCDACpAg4ApwGPAI0ABAsoAAoLQwALC3UACwsAA4sLpwMHC+ADCAstAQkL0gIMCz8ADQsdAA4LoQCPCxIABgDSBYoLFAIFAEQCBwB6AQcAogIHAJAFDwBTABAACwAPC1MAkAsLAAYAIQQGADcFCgA8AQcKVQAHCvcACApJAooKowAEAKkABQBTAAYAjwEGAEMCBgDpBQcAtAIHAE4DBwD3AwcABwcIAJMBCQCKAQoAhQAMAAQADAApAQwAxAEQAFEAEgAZABUADgAWAAwAlwASAIYAUgQHAAoGCwArAY4AlwGGAKgEhACxAAUAmwGHAI0CBwC3AQoA1wILAAQBiwCsAooKkQCTClMABQDQAAcA8QKHAPgFiQtpAocKggeHCzkDCwCmAQ0AhQEECnwACgrJAQsKeQALCqkACwpmAwwK1gAOCrsAjwpNAAsAZwIPADoACwtnAo8LOgAJAGoCigDiAQYAoAcGALIHjgD5AQcKqQSHCy4HhQDyAIcKNQUGCmsABwp+AgcKYAaJCowBhQC5AwUKcgGGCtwGBQscAAYLzAAKC0ABCgtHAg0L9gEOC0gADgsSAQ4LOAEOC1gBDwufABALPgAQC0UAEQseABILKgASCzUAEgtUABILjAATC0QAEwtVABQLBQAUCy0AFAtlABYLBwCWCxQABAsuAgYLhgEHC6IABwuxAgkLaAGKC40CCwAiA40AQwCFCswAhQAiAQUKygOGCqoGhAB8AQUANAAHABUBCQBwAYsAFwMFC1gDBguIBgYL3QYGC/UGBwt+BAcLkQUHC60FjAsBAgULXAAHCgMACgvgAowLZgAEAHAABQCNAgUK4wEFCq0CBgrpAQcKtASICooBhAqZAwYABASFCu8DBQtOAgkL1QCRC1sAhwqgBgoAigCLANwBBQDVAgUA1wKHABMHBADTAwYAHQcGAC4HCABsAwgAcwMIAHkDCAB9AwgAfwMKAKYDDADQAg4AywGUAHsAhwsnAgQAJgAGALMBBwAzAQcA5wMHAMkFBwDEBgcAygYIAHMBCQCeAQsAPAEMADQADQCkAZMAZACHABAFhArIAoYKXQaFANMChgCLAogLvwAJCxcDCgtdAAsLLQEQCw0AEQsXABILhwATCwwAFAsBABQLDACUCw4AiAv3AQYL0gGHC58CBgCwBIYAMgWHAOcEhgDaAwUAbQAGAPgGBwBnBwwAKAGMAC4BhwvXA4UK5QGGAJQChgAgAwUA2AAFACYBBgBPAgcAVwcJAI0ACQAOAQkApwIKAJ8ACwDFAAsAtgEMABoCDAAvAg4AkAAOAKcADwBDAAQKHQEFCj0BBgotAQcKBwAICpkACgr+AgsK1AEMCtMBjQqPAIgAsQOGAEIEiQBRAAwL1AETC2AAlAsYAIYAhwGKC/EABwBCAYgA+QCGAIQFhwsbAwUAeAKKAA4CiAozAwYAkAAHALQDBwASBAgA6wAIAM0BCQDFAQkAHAMKAGIBEQBNAIcLugOLCpUDBgCsA4YAzAQEAGoBBwA0AIcALwEGCyUCCAsiAAgLGwEJC6UAigvbAQcLcgEHC+8DBwuZBIcLHQYFC4wCBQu9AocLwQEFAMQABgDmAQcA1AAIADUBiABaAQYKtwYGCscGBwrgBwcK5AcICkUDiQpUAwYLnwAGC2wBBwsEAgcLnwWJCwYChwB4B4cACgWEAK4CjQuXAIoAcQKIAMICigo4AosAnAEEAB4AhQArAAgKQwCKCqMBBwDHA40ACwAMAPYCDgC5AY4AzgEKCpECDgopAY4KaQGLCtkCBADcAIcA/wUHC/UBCQtvAAoLjQALC0wBDQsrAA0LrQEOC4IADgufAZELZgAEALYDBgBDBwcACwAIAGkDDADGAgwAzgIMAOwCDAD9ApQAfAAFC5UABQunA4gL6QCOCyMBhgArBgcAegMICjMACQpkAwoKQQMMCuEBDAo6ApQKagCNAAIAhAq9AYgLIQOHAO4GBwC9BooAiQEFAAcBhgCeAYQLQgGFCu8ABwDIAQcKxgcICoIAiwrQAokAMgMFCnsABgoSAgcKXAGHCosFhwroBwYAsgAGANYGCAD7AAkAsgIKAJsACgDEAAoAdQELALoCDQCbAJQAXQAFAGEAiQCJAYYAogILAN8AjACoAIQK0gCLC9ABBgBnBpIAnwCLCwIABwCmAwgAhwIRAGEAEwA7AJYAAgCEAL8ABQClAAkAWgEKAI8CCwB1AwQKrgGHC2UBhQBtAwUK1QCFC5YBCACAAIsAswAGC0UAhwt1AIcAEQULCysADQtIAI0LjgCHCyYHjgCkAAUAOQAGAGUABgBKAgYAfwYHAIQABwCCBAcAhwUHAOMFDADtAQ8AaQCXAA8ABQDLAQcAMQQIAPEAiABOAYULOgOFCmwABQrbAAoLhAALC78ACwtmAYsLzAEGAEQBBgAIAgcAUgEHAMEGCADkAIsA7gIVAB4AFgA1AAQKwQAFCpQDBwpsAQoKjgEKCtYCCwo9AQsKcgIMCo4ADAogAQwKpgINCjkBDwpxAJIKcgAGC24AhwuRBocAjgMGCvEABwqLAwgKQAMJClYBCgrZAgsKHAELCr0BCwqLAgsKXwMNCo4BkgpjAAcAwQIJAN4CBQvoAwcL3QKJC0cCBABJAAYAZAIHAJ8DBwAeBwgA2QAJAP0CCQD+AgoAmAELADMACwAZAwwACgEPAJ4AFABZAJYAIAAHADIFBAspAQYLEQIHC5gABwvJAgcLNQcIC8YCCAvNAowLfwIFAIUBiAB8AoYAgQUECjICCQr+AIsKbwOGAH0DhAoSAwQLCAKHCz8CiAAVAIwA0QKIAL8DBwuUBQcLaAYJC6kACQu2AAkLbwEJC94BCQv6AQkLJwIJC4gCCQuLAgkLuQIJC8ECCQvVAgkLEwMJCxoDCgvGAAoL1gAKCwsBCgsTAQoLyAEKCycCCgsxAgoLZQIKC3MCCgucAgoLowIKC7MCCgu3AgoLwwIKC8sCCwu3AAsLyQALC/QACwsGAQsLYAELC7cBCwvtAQsLPAILC08CCwtgAgsLYwILC4YCCwuiAgsLxwILC+8CCwv5AgsLCAMLCxEDCwtSAwsLVQMLC14DCwthAwsLZAMLC4IDCwuGAwsLhwMLC44DCwukAwsLrgMLC70DCwvHAwsLzAMMC5QADAvDAAwL3AAMC+0ADAs+AQwLUwEMC4kBDAu9AQwLwgEMC9oBDAv9AQwLFQIMC08CDAtSAgwLVQIMC20CDAt5AgwLggINCzsADQs8AA0LkQANC+8ADQv6AA0LEQENC0kBDQtYAQ0LbQENC3QBDQuDAQ0LkwENC54BDQvIAQ0L3gENC+MBDQvpAQ4LNwAOCzkADgtRAA4LWgAOC5QADgvvAA4LCgEOC0EBDgtGAQ4LRwEOC0oBDgtbAQ4LYwEOC5EBDgubAQ4LngEOC6ABDgukAQ8LPQAPC0oADwtXAA8LWAAPC14ADwtgAA8LdAAPC5UADwuaABALMgAQCz8AEAtJABELAgARC0IAEQtcABELZwARC3AAEgsyABILNgASC1IAEgtWABILWgASC28AEgtzABILnAATCygAEwtPABQLTgCVCxYAiQuqAIYAmQWHCxsFiwubAQUAvQAHALoBBwC7AQgAGQEMAK4AjQAFAQYK2AAHCoUDBwo/BYgK7QEFC40BBguaAAcKVQEHC6QCCAu7AQgLYQIJCxgACQtFAQoLIwALCtsACwsXAgsLoAILC/oDDAt9ApALHgAGAAIABwC/AAcAvgEHAO4EBwDJBggAFgAIAA4BCABkAgkABAAJADgBCQC0AQkAcgIKANgACgA3AQoACQIKAG8CCwBIAAsASgELAMcBDABBAQwA+AEMABICDAAfAg0AEQANAJwADQBOAQ4AgwARADwAlABAAAcAYgEKAJoBiwAvA4sKggAHCsYGiQt3AgwAqQEPAHAACgpzAAsKpAENCpQBDgpaAY8KNgAGADwABgCmAAcAdgEHAJ4CBwAvBQgAmwEIALMBCQCNAgkA5AIKAIEBCwDeAAsARAELAD0DjABjAgcASwYNAA4ADwAsABMADQCUAEwAhQvVAwQLOAAHC/8GCAtfAggLiwILC9EBCwtDAwwLUQGNC+ABBgDGBQUK8wOICr0CiwBUAgUAzgCGAI4BBAo2AAUKmgIHCg8EBwpqBAkKwwCKCi4BBwAyAAkLngCKC5sBhwtgBAYABQIHAIcECgBtAgsAwACGCoUGBABQAgYAWAKHAHUGCgDfAIsAhQKIC4sABwBAAIgA9QCOABYBBgtuAocLBgSIAFwChgDeBYoACQGNC6gABwDjBowANgEHCh4DiwvPAgcLoAAKC3ACjgsXAYQLawEHCnoACQoDAQoKVAALCtYBDAodAo0KewEFAIEABgA9AIcAswOGAEwFhwunBA0A+QGNAPoBCwDoAwUKUgAFCoMABwrbBggKHwAJCqgACQr8AosKZQOGAMYDhgpdAoYLJAEFC7EABgtoAgcLOwMJCw0CiguQAocLzgWKCx8ABQoWAYkKRAAECqMABQrJAAUKMwEFCjYBBgpPAQcKHAGICqUABgBHA4cKfAaICg0DBgohAIcK3ASFAH0CBAuhAIULdwKJAE4CBwqhB4gK0AIFABgBBwDKBIoKywCGAGoFBQAZAQYAAgQGCkYBBwqlAokKqQEHCxUGhwuUBocAKAQJC9UBCQvFAgwLAAIOC0EAkQsMAIYAlQMKC+UACwtJAAsLeAGLC7EBBwArAgkAwAANAB4ADQAxAA8AlgAQAEwAFAA0AAcKJAUHCoQFBwovBwkKTQILCvEACwqkAgsKKwMLCnsDDAqMAAwKWgEMCt8BDQp9AQ4KvACSCh4AlQAPAAYAWgcGAFsHBgBpBwkAsQMJAPYDCQD8AwwANwMMAEoDDABiAwwApgMPAPIAkgDQAAYAxQOGANsFBwAhAAcAeAAIAOkBCQA/AQoANAMLAOwDDAB7AQwApwINAHUADQCcAQ4AGQAPADQADwChABAALwCVAAIABgsuAgcLiwIIC6UBCQsAAIoLIgAEAKkDBQAhAwcA2QEFCmYBBwqgBAoKlgINCtQADQowAQ0KTQGRCmIAhABtAwYAtQKGADgDhABtAQcLKAeKC3YBBQAHAIsABgMEAN4CBQCWAoYArgEEAOoChwBCBAUAaAEIAO0ACgDnAJMAfACKC1wBBgsGAAcLUQAHCwMDBwvDBgkLlQGKC6UBBgDkAokANgOFCrIDBwDNBYgAoQMHCpsBCAp3AgkKQwEKCmMBCwrrAQwKjwAMCpIBDQpJAA4KmAEPCmsAkgpHAIcKTgIFC3EDhQt1A5YLGQAEAFQDBQuOAIYLIgIHCrsFCApIAQoKIAILCrsDDQpAAZEKUwAJABEACgAjAQsK/wENCooBDgoqAQ4KPgGSCmcABQvSAQsLOwIMC8YADQsbAQ4LugAPCxUAjwtnAIYA6QMEC7kABQsBAQULRwMFC6gDBwurAAkLjwEKCwIBCguLAQoL3gILC/YDDAsXAA0LXgEOC5YAkwsGAI8AIwCEAD8DBQpDA4YK4wEEABUBBQBgAgYA7QEHAMkBDACAAQcLlAEHC2EFBwuWBQcL4QcIC5UACAvvAAgLAAIICxkDCAsyAwkL2gEJC1MCCgt6AAoLNQIKC4kCCgsPAwsL7wALCycBCwu/AQsLEAILC38CCwsgAwsLqAMMCxkADAtJAAwLTQAMC50ADAs8AQwLhgEMC4cBDAuKAQwLiwEMC94BDAv3AQwLUAIMC6gCDQsyAA0LNQANC4QADQvGAA0LEwENC0IBDQufAQ4LRwAOCwEBDguLAQ8LRwAPC4gAEQt7ABILXQCTCzoAhgBHBQcAGwCHADwBiAvIAogA2AOFACgCiQAIAYQAkQEGAMYCBgBXBIYAPwWGALsECQAfAgoADAILAGwACwCNAgwADAINAHsADgD8ABAAEgATACYAFAAaABQAQQAVAAMAlwALAAQAzQAFAG8CBwBoAAgABwKJAMwChAqlAgQLeQGYCw0AhwuJBgcAQwIJACkACQD0AAkAnQIKAAUACwBdAwsAtwOLANQDhADNAogA8wOEACUDBAu0AIcLcgeECgkDhApLAYQA6QEGAAAEBAvrAYUK6wKHC54EBAurAIoL6gAEC0oCBwuiBIoLdwKHAHwDhwtQAQkLowMKC04BlAtHAIkA2QEGAGADDACTAosLngMHADMDCQAaAAkAiAEKAJgACgDiAAsAEwAMABQBDACqAQwATQINAMwBDwBhABMAMACUAGgAhwAzAIUKRgEECrMCkgoQAAkAggALAP0CCgqoAgoKGQONCmUBhQv9AggA5QAGCiAABwqBAQcK9QIHCnwHCApeAAgKxwIJCh0CCgqiAAoKGwMLCt0DCwryAwwKDgCOCjQBBwvaAYkLQgKEAKIChAACAwUATwAHAAMEBwDFBYsANACFC6gBhgCCBgYAmQEGCl0BBgqSBgcK5AQICnAACAvKAgkKswEJCpwCCgoiAQoKPwEKCi8DCwq0AAsKRQMMCvAADQqYAA0K2wCOCp4ABQAVA4YAwwAEAPsABACwAgcAAQKHAAQFhApFAgkLpAEKCw0BCgsdAQoLQAILC40BDQuvAJELWgAGCn4ABwo9AggKjQGOCiwAhAutAYUAeQMEAKAABQBKAQcAmgWIAK4ABwsSAAcLuwIHC64HCAvwAgkLEQEJC5wBCQu/AgoLRwAKC6sBCgv8AZILYQAGAGgDhgCDA4UKngOGAGYEhgCWAwQLNQAFC7oAhwvwAgcADAGIADkChgDIBAYAUQUHCtAEiQoTAggLPwIKCyEBiws/AYUKngKEC6MChQB2AYcKpQeFANsCCwC+AA8AMQALC74AjwsxAAQAcgIFAPoBBQCCAgYAqQEKAMoAiwCNAIkAvAEHCvIAhwqWBwYL0QAIC9QBCQvSAAsLJAAMCxwADAt2Ag0LFQANC10BDgsHAJELDQAEC1YBhwubBAUKQgMHCrIECAoOAAkK4QGJCnADBAugA4ULjgMECz4BBAvwAQcLWAOLC44CiABDAwcA9gWKCtEBlwARAIcA3QEECmUBBgqsAAcKjwCJCp0BBgBeBYoA4gMSAEwAhApOAgcAHwEIAGMBCQAlAYkA5wKGAG0FBwuTAwgL9wCTCwAABAvKAAULfgEGC8YBBwuoAwcLCwcIC/YCCQt3AQkLfwMKC+cCCgsYAwsL0gMLC/QDjgttAAUAgAEIAMcBjAAwAIQLhgEFCqkABwpNAYgKLQAFAAgBhgC4AIoLFwOFC80ChArGAAYLvQEHC0wBiQuNA4gA6QMEChgABQqMAAUKuQAHCtwFCwo1AosKRgOGC0ICBQB5AgYAHACHACsFhABTA4gLCwEHAGcBCADzAIwArwAECk4BhQpRAo0LVwCIC/4CCgAfAQwAigAKCx8BjAuKAAQAaQCEAOQCjAp0AIYAWQOHCzEHBgB6BYkAMwOEC0gChArFAoUKgQMFAOAADQCuAJIANACHCjAHBApgAoUK8QGLCzwABAD2AocAcQYEC+IABAtGAYcL6gYFC6oBCAseAAkLAgALCyUCkwt6AIcK9wcGChwCiAqIAAQAPQIIAI8CBAqBA4UKEgMHAF8BiwCAAIUK5wMECisBhwrsA4UAlgOEC1kBBAuBAQcLCQGHC0sChQrIAYgKtAAGAK8ChgABBgQLWwEFC6cBBQvkA4cLMQWECvMCBwvrBAkLfQALC0EAjAsdAQULiAAGC4gAiAuEAoYA9QUEAPEDhwBzBIsKUgGEAFQBhwq4BQgATwMKAF0DCgBsAwoAeQMKAJoDCgChAwoApQMMABADjAAXA4sAsAAJC4YACgsCAAoLGwAKC00BCwvSAo8LAQAEC7EBhQvPAgUA2QMHAP0BBwARApEAYACEAGcCBAp6AwUKJQMFCjMDBQrBAwYKjAEGCl8GBgqOBgcKrwcHCvkHCQp2AgsKCAALCvsDDAqwAA0K4QAOCiQBlQoYAIcAfweGAGsEkAsVAJALMwCHChcHBAD3AAcK4QUKCr4ACgp6AgsKGAMMCmYBjAq/AQUKAAAGChgCBwpcAg0KvQGRCn4ABAC4AAUAhgEGAFEBBwAXAAcA7gEHAGoCBwCwBQgAGwAIAFcCCgCZAIsAxgIGCugABgqcAQcKMgQICgkACAqdAAgKEgMJCsQACQpgAQkKyQEKClEBCwroAAsKbQMMCuABjAoiAg0AJgCHCr4DBAp+AYgKQwIECtQAhwq2BAQLKwIICxgCigsgAQsLiwCLC6sACQtyAYoLWgCEAPcDhgBABAUKjwKHC9EDhgAxBhEKQwCTCkoACgDjAAsA8QELAMUCjACfAQYAaAEHAIAGiADeAQcAXwAGCucAiAqnAYwLQQAECwEBhwvvB4cL6AaFCiwBiwvTAIgAuwIGCu0ABwpjAggKZAAJCqABCwpPAQwKrQCSCmUADgAaAJIAlgAGAEUChwBfBIcKuASEAOMCBgtTAAYLxQaHC20FiQBlAwQAQwAFAKYBBwANBAcACQUHABMGCQDlApEAbACFCscADAqrAZIKJgCIANABjgAqAAoAYAAIC/UBiQu4AoYLUAIEAAACBADGAwUAVgEGAD8HCABlAwgAawMIAIUDkAAaAAgAywALADcDCwBOAwwA4gENABUBDQAuAQ0A0AEOAM0AjgDdAAQAwQGFAM4CBwu2BgkLXwAJCxIBCgsXAQoLPQEKC6QBCwsvAQsLKAMMC4YADAtvAQ0LlQANC1sBDgtdAQ4LlgESCxYAEgtZABILegCTCy8AhQsaAAQAYwEGADcBCQAAAYoAlAGECyYCCgD2AgYKOAEGCrMGCgpIAgsKIgILCrQCDAoDAQwKJwENCi4AjQqaAIgLNgMFADsDBAuGAwULKQMGC3oAhwuAAwUAQACMAEUCBAC6AQYA4wIHABcEBwBIBQcAawYHC3cHCQvBAQoLwACKC+QChwsGAYQKTAKFC2wCBQDRAwYAIAEHABACBAsiAAULPgIHCxcBBwtYBogLWQIGAF8FBArnAAUKPQAGCmgABwrZAgcKxAMHCnoGjAqeAQYKBwGKCvUChApAAQQA/gAHAB0FBQtMAYcLHQUGCwUBCAu2AIsLrwOECuEABgAMAIcAwwQEABMBDAB4AQYLuQaNC+oBBAulA4ULcAMGALcDBgBVBAYAnQQHAJoABAqVAQcKMQMOCjoAEQolAJIKfAAGAPAFhQrOA4YA2QYGAHEBBgD2AQcADAQIAFwBCQDEAQoAGgALAOAACwCDAQsABAMMAF8ADAB1Ag0AwwANAM8ADQDxAA4ABAEOAA4BjwCMAIQADQEFAOABBwAUAgcArQQHAE4FCAAjAQsAXQGOAIwBBQrrAAcK1wQLCoMAjApyAQcKvAMHCoUEBwriBQcKRgYHCk8GBwpTBgcKyAYHCu8GCApOAgkKRAEJCuACCQoGAwkKCAMJChADCgo3AgoKxAILCgYCCwplAgsKtwILCswCCwrjAgsKAgMLCgMDCwpQAwsKWQMLCqMDCwqzAwwKRgEMCoMBDArkAQwKEAIMCigCDAplAg0KvQANCgABDQpUAQ0KsAENCrQBDQq4AQ0KxgEOCq4ADgrcAA4KHAEOCoYBkQp5AAgLVgIJC5gCigu5AQkKiQCKCt0AhQssA5QADwCGAD0FBgD5AwQLiQAHC5oEhwvwBQcKhgGKCowABwvsBIcL/gaJC78Ahwp4BAYAEgcHAJECCAB2AwoAWQMOALgBkABgAAgAFQIGC30GBwu3BwcL2QeHC9sHBgCtBYYK0AGEC8sCBQqXAQsKzAALCvMACwrpAQwKJQETCiUAFApJAJYKJgCFC78CBADTAAcAywUFCkUBCAoFAAgK4wAJCmkACgpJAowKZgIEAEwBBQBPAQYA7gAHAA0BBwArAwcABQcIAEQDCQD7AY0A8gAFC1kABwt7BwkLuQAJC+sACQvwAQoLQAAKCw4BCguTAQoL1QEKCxECCgtOAgsLjAALC1wDDQsBAA0LpgEOC1UBDgtsARELXQASC3EAEwthAJMLcQCFC7cCEAATAAULBgAGC7cABgptAgcLqAIHC9IDBwv1AwcLHwQMC+YADQusAA0K+AGSCx0AiACcAIUA8QMGCx0Aiws/AIYANAOGCtoABwrGAQcKDgMICgADjAquAgUA5AAGAMsABwCcAAgAWwEJAAkBEgAnABQANgAVAB8AFgADABcAAAAPCwgAEgsnABQLNgAVCx8AFgsDAJcLAAAHAGsEhwC8BZAKAACGAPwECgqkAowKzgGECzcBhgvMBgcLqgAIC1oACAuxAAgLnwELC8oCjgsZAYYKpAAGAAAHigBRA5YKMgAFACMBBQA+AQcA/QIJAIUBDAAkAggLCgKOC0gBCwtbAA0LgQAPC2UAkQt9AAQL7gEGC0oABwssAAcLlwEICycCDAsRAA8LBQCUCwsABAsUAYULKAEGClcBBwrDAAcL8QYJCuIACgrFAAoKPwILCvYBiwqDAwoADQKLAFIADgDFAQQLBwAFC1oABQueAAYLHgIHC90ABwsmBgkL6gEKCxwCCwu7AYsL9QKHAJoCFgodAJYLHQAEAKYBkwoIAAUAYwGRAAAABgBRBwkAlgMHC0wCCQuvAIoLEgKPCx8ACwClAAcKZQQJCo8ADgqVAZYKFQAJAAQBiQCJAwULaAMGCzkABgvfAQYLMgIHC9cBBwskBAkLvwEJC8YBjQsGAIoLwAKFAGEDBQCSA4YAWQaFAOoABwBnBQULHwAGC2YCkQs9AAcLsASKC8wBBguoAYcLSgeIADIBBQq/AwwLHgANC5QADgtXAA4LtgAQCyoAEgtcAJQLRgAGAH8HBgCBBwkAmwMJAKIDCQCtAwkAtQMJANsDCQDcAwkA4AMMACIDDAAvAwwAWAMMAHUDDAB9AwwAggMMAJcDDACYAwwArQMMALMDDwC3AA8AuQAPAL0ADwDFAA8AygAPAOkAEgDaABIA2wASAOkAjwucAIcK3waICq0ADQCjAA0AtAASAE4AFAAjAAULDQCGC44AhgoKAQYLYQAHC3QACAtCAQgL8wIJCyQCCgvKAgsLdAONC0QBhwAgBQkALgOJC6QChQDDAocA1QUGAKUBBwA9AAcABAYKAAsAigD1AQwA3QIMAP4CBwtiA4cLiwSJAFUBjgBiAJELcwCHC1cEiAosAYgA9gMICwEACQtwAIoLRgGEC9oCBQvoAQYLDwIHC+kBBwtkBggLeQAIC5AACAtnAQkLwQAJC/EACQtQAQkLcgMLCwoBCwt0AQsLsAMMC5EBjAuBAgYAywOGAGEEBgBmAAcASAAPAI4AkwBDAJcAHgCHADcDhgAVBAUKqwEFCt4CBwreAYgKNAAHAIoHCwrZAI4KpQAGAOgFhwBOBwkLHwAKC/QACgu7AgwLlQCNC/EBhQt5AZELZQAKC54ADQsNAA0LiQANCwIBDgtvAA4L4QAOC/0ADgswAQ4LUwEOC6EBkgshAAYAVwAGCsYGBwoUAAcKIAQICtwCCQqWAQkKjwOKCrYChgDbBIkA9QAHAEQACAAwAAgAWAAIAEYCCACpAgkAdQEJAGADCwCdAAsAUAELAEsDlAAbAAgLlwKQCwgAhQplAgQAWAAFAIkABQCuAAUACQMGAIAGBgC9BgcATQAHAKoBBwAlBQcASwUIAH4ACAAzAgkACwIJAO4CCgA2AQoARAMLACoACwA+AQsA2wIMAEQADABcAAwA+wEMALQCDQBRAA0A7gANAHYBDgC0ARIAigATAE4AEwBvABQANwAUAE0AlABcAI0AogEEAKoDiQBxAooAXwEFC0sDBwogAAcK2AMIClUACArFAgkKQwIJCk8DCQpYAwoKHwMLCgIBCwrvAwwKSwEMCmcCDQq8AA0KswEOCggADwqlABAKGwCUCigABgCEBgcA2wUIAHUACQA6AYoArgCHAMMChAsqAoULGAIFAJMBBQvPAAkLTwALC3ECkQsHAIQLqAGICxEDBAqnAIcKUgAJAAcAFwAGAAkLBwCXCwYABgAaAQUKPgAGChYCBwpKAAcKpgIHCqwCBwoTBAcKMAQIChgBCAodAggKrgIJCgIBCgoHAgsK/ACMChoBigohAIQKZwEEACwABQA3AQYAnAAHAH8CBwD6AgcAIwcJAAgACQDOAZQAUwAHCwEDCQsSAIoLZgEEAFoBBwBzAAkAtAAJAMgBCgBrAQQLgAOGC/EGhQrTAAcA+QIHABsEiQAhAgYKkQCNClABBwvuAgkL3wALCxsACwvSAQwLcAIOCwkBkgs9AAYA8AIGAAADBgCrBAYA5gQGAFMGiQBDAwYAkAcIAKIDiADAA4QKBwGEC/kADACNAoQKlAMEC1sChQuVAggAWAEECwsABguAAAcL5wAHC/0FigvVAoYAywWGAGsDBgC5AAcAawcJAGsDiwChAg8KmwCQCk8ABwBdAAcA0gAHAMcECADDAQgAzAELAGEBCwDbAQQKVwIGCmIGBwpDAAcKswIHCtMDBwqhBggKzwAICtYACArnAAgKJgEIClABCAqsAQgK1wEICm4CCApyAggKpwIICvcCCAo9AwkKCwAJCvYACQrkAQkKPQIJCsICCQr6AgkKHgMJClcDCQpmAwkKkAMKCi8BCgpPAQoKqAEKCs0BCgofAgoK9wIKCi4DCwo7AAsK6wALCk4CCwqhAwsKwwMLCtsDDApyAAwKtgAMCuIADApMAQwKtwEMCj8CDApWAgwKowINCggADQp9AA0KwgANCh8BDgrFAA4KfwEPCjUAEQo/ABMKLgATCmIAEwpqAJQKVQCEC9wBBABHAQUA3gEHADQFiADxAgUA/AOFAP4DhwsPBwQAZwCFAJEBBADzAYcAjQUKAM8ADQCkAJMKfgAJCxQACgtEAYsL6AGEAGAACQsYAYoLhgCHAMgDhQq7AIcKBgUFC3AABgtnAIYLlgAIAJIDCgADAAQK1wAJCiYACwoXAAsKfwCLChwDhwCPAQYAMwKJAOAABgDAAoYAvgQEC8QCCAsPAAkLMgAJC4IBCwsSAAsLEQKMC+QABAszAgcLbQAHC1ACBwt9AgcLAgMHC6UGCAu0AQgLzwEJCzwACQtPAQkLiAMKC0kACwuyAQwLSQINC0sBEgtuAJQLPACGABcGhAv2AQYLWwGKC6EABAshAAULZgAFC/QBBgscAQcLNwQHC48FBwumBggL1gEJCyoCCQvTAosLTQEHC/YAhwtIAwYLCgAICzsCCQvjAo8LWwAIAF0DCgCJAwwA2gIMABUDhQtyAoYAsgMFAOoCDABNAQ4ATAEMC00BjgtMAQULEgAGCw4CDQsYAA0LbgATCwUAkwssAAQAjgMFAEADhwrSBwoLAAOLCxMDBAs1AQULzgEHC8oDhwtJBAQKHAAFCrgBBwr4AAsKQQOMClgBhgp2BgYAeAIGAIwCBgD4BAYAaAWGABgGhguoBgYAcQWFClUDBgr5AAcK0gSLCj0CBQtWAAcL5wIJC1UACgsZAQoLsAELC+oBDAv7AA0LdgAOC3oBkguPAAULDAKFC+gChgDqBQoAyQCOAD8BBwDNAgoA/gEHCogBCAoUAAgKrAAICrICCQp/AQkKTQMLCiUBCwpAAwsKmAMLCtgDjQrdAIYAZQUFCloDhQrgAwgAEAKJAFwBCgtrAIwLtAEEABQAhQBoAoYA4wSEC58DCgt7AAwLngINC3MBDguOAJILXgCGAIsEBwt9BIkLnACGADMBhQsKAwcAQwSHAOUGBQv2AQYKDAGJCj4ACAvEAAoLGwGLC5YBBAAaAAUArQEGAPUABwDAAgcAYwWHAMIFhQtXA4QAcQMEAG0Chws8BgcLeAUJC74BigstAAYA4AKKCmoAhQAeAoYAXAGFAGQDiACxAYcA1wWKAAMDBgplAogK3wCKANcAjQB8AIgLhwGHC6wAhAqeAowANwAJCigAiwqIAAcAPgCTAHAAhABYA4QLOAIMAA4BiwoDAQgAPAKJALoCBAvcAgkKNgGJCqoCjgooAYYAqwOIC90ChwubBQcKeQWHCsQFBgBgAQQKKAEHCpEBBwqCBQcKOgYHCooGCAo/AAgKlAKJCkoABAusAYULnAIECosABAqEAYwKvAAHC98HjAuZAoQAhwKSAAoAigDcAI4A0AGEAG0AhgDSBgYAAwIECusCBgtXBgYLkQYHCokCBwrHBYcKLwaFCugAhwA2AokKdwMEACgACgBDAAsAdQALAAADiwCnA4QAIQMHAOADCAAtAQkA0gIMAD8ADQAdAA4AoQCPABIAiwCbAwYL1AYIC8sCCQsiAwoLLgAKCzMDDQs0AQ4LXwEOC2sBkgtDAIkL6QIHAHkEBAoOAAcKCQcKCuwCjQrKAQQLPwAFC1sBhgvaAYcAOAIECqkBBwtBAgcLmAUJC9sBCQv5AQkLDgIJC2ECCQuxAgkL1gIJC98CCQviAgoLLAIKC6ICCgusAgsLWQALC8oACwsQAQsLfAELC58BCwv5AQsLGQILCyYCCwsyAgsLgAILC5sCCwuwAgsLTwMLC58DCwuiAwsLrAMMC5AADAtFAQwLSQEMC4UBDAuTAQwLwwEMCwMCDAtcAgwLaAIMC3ICDQtCAA0LgwANC6cADQvsAA0LcAENC5sBDQuyAQ0LxQENC80BDQvaAQ4LOwAOCzwADguLAA4LmAAOCxQBDgthAQ4LkgEPCxwADwtRAA8LewAPC5gAEguIAJQLWACJAPcAhwtWBgkLIAILC50BkAsZAAQAhQIHADkDBgroBocLWQCMAEgBBQqvA4YK8waGAFMFBQr1AAYKQAIHCkYCiArhAIYAAAUFCzgDhQutAwcLuAEIC+YAiwtqAAUAHAAGAMwACgBAAQoARwINAPYBDgBIAA4AEgEOADgBDgBYAQ8AnwAQAD4AEABFABEAHgASACoAEgA1ABIAVAASAIwAEwBEABMAVQAUAAUAFAAtABQAZQAWAAcAlgAUAAQALgIGAIYBBwCiAAcAsQIJAGgBigCNAoYA/AIGAF4DiQBBAwUAWAMGAIgGBgDdBoYA9QYFAFwACgDgAowAZgAGAIcHBgCYBwgAnAMIALQDCgDHA4oA0gOGAMcFBQBOAggAaAEJANUAigA/AIYA8QUGAMUChgB7A4QKuwENAN0BDgB4AJQAPQAEC5IDBQsgA4ULVAMKCzYAjQtzAAQLlgOFC2wDiwuYAAQLXACFCxIBhwttBwkLIAMKC7UCCwviAQsL3gKLCxUDCQDjAYQKKgEGAL0EjQvyAYcLqwWFC+cCBAD+AwoA6AMMAL0DDADUAwwA9QMOAOEBkAB0AAgA9wERAB0ABAsxAAcLGAGHC2EGhwCwBoYA0gGICy8ABQqkAAcKeQCOCr0ABwosAwcK7QQHClAFCQp4AowKYAGLCiwChADbAgULEAEFC4wDBQuuAwcL8AMHCxgGCAvFAAkLLwALCxoCiwvmAgQKrAAJCmMCCgq0AQwKoQKNCv8AhQpMAwoA5AELAPICDADJAQ4AqwAOAIUBkgCZAAkKBwEKCpMAigrsAYkLewOKAPEAhQoZAgYA1QeIAMQDiQpKA5cLCAAEC5cBhAswAocLXAcGAEwEhgDaBIcAugMFCuYABQqIAQYKpAEJCjgCjApkAgQL2wELCyMACwtaAA0LBwANC0cADQuxAI4LpgGIC0wBhwCmBwYAJQIIACIACAAbAQkApQCKANsBCgC4AwwAxgOMAOIDBQCMAgUAvQKHAMEBBACPAgcAUgMRAEsAkgCJAAQAkgAHAFIGCACeAgUKKQAHCrMFBwq9BQcKQwcJCiUCiwqJA4UKuAIGAJ8ABgBsAQcABAKJAAYChwCfBQYL3gAHC3wCBwtUBggLmQEJC7UCiwtNAA0AlwCNCy0ABgADBAQLUAGECgMDiwuIAQoLeQALC68AlQsQAAgAtgOKANcDhQqZA4cA4QMGCrQABwpxBAgK7wKLCiUDBwD1AQkAbwAKAI0ACwBMAQ0AKwANAK0BDgCCAA4AnwGRAGYABAq3AAULcgMHCg8BCwo4AwsKuAMNChYBDQpTAQ0K4gEOCqgBlApjAAQKEwAFCt0BBQpUAgYK+QEHCsUECwqLAwwK0QCNCtYAhwq/BIUAxAGEC6oBBQCVAIgA6QCFAKcDBgs6AAcLjgIHC+kCBwuxBwgL8AAIC6MCCQvfAQkL2wIKC0oBCgtRAgoLMQMLCyAACwuFAAsL3QCRC0QADABGAhIAgwAHC2YAiQsaAogAIQOGCm0GhABGAAYKXAAGCrwABwr1BAcK9AUHClQHCgrkAIsK/AMECssBhQrGA4oAcQEQACQAjApKAY0LbgEHANECCgDsAAwAzAAGChIABwqkAwgK9QIJCjYACQpBAAkKTAMKCnEACgo7AQoKHgMLCpkADAqXAAwKiAEMCpoCjgr4AAcA8QAKAK4BCAokAgkKFAIKCnUACwpfAQsKdwGPChcAhgrOBoUKxQOFCzYCBgswAIcLPwCGCrYACgpBAAoK6AGKCvEBBgtyAAcLyAQHCxQGiAsDAIYAGQcIC0ACiQsLAQYANgSQABAACQpMAooKBAGKAP0DBQCWAYYA5geFC6UDBgBFAIcAdQAHACYHiAurAQQAsAGHADgDhgr6BoUAOgOLC0MAhQv3AocKNAGJADADhQDoAwQAKQEGABECBwCYAAcAyQIHADUHCADGAggAzQIMAH8CjACtAgcApwGICkwCiAofAYgA/gGGABgEBgBqAgcLOAAHC8UHCAtRAQgL4gIJC1gCCgvjAQwLJQANC78BjgtcAAQACAKHAD8CCADeA4oA0QOHCwYDCQtbAQsLGACMC6oAiAt7AYwKIgGEC0gBBABBAYYAOQIEC2UAhwuTBAcA0wIHAG8EBQtBA4gL6AIHCs8CCAopA4gKQgMIAJkDiAocAwUK0gAGCtUABwo8AAoKbAGLCocABQCNAQYAmgAHAKQCCAC7AQgAYQIJABgACQBFAQoAIwALABcCCwCgAgsA+gMMAH0CEAAeAAUKXwIICkYBiArqAQQKvQIFCtgBBgsJAAYLjQEHCzUABwvOBgkK9gIKC3gCCws8A4wLkgCHCnwBhwqbB5QLbQAKChYBigsWAYYAWAMHAIsABAqCAQgKlQEICtgCCQrxAQsKbgALCmgBDwolAJAKVACNABoBhQDVAwUAIAEHCqwFBwrIBQgKegKMCtgBBwBiBwgLbwEKC/gCDgtPABQLEQCYCwAABAoMAogKKgMEADgABwD/BggAXwIIAIsCCwDRAQsAQwMMAFEBjQDgAQoK7gCNCiEACwuhAQwL3wCMCwkBCQCeAAoAmwGMAAUBhQoUAoUK5QMMC7oADAskAQ4LZACSC0YABgB7BYgAaQKGALUEiwAzAgQA8gCGAE0BBAu6AAULnQAIC6gAigsGAIQAcQGFC2sDBQoOAwUKPQOGCsoGhgBuAocL+AQGAH8FBwtvAIgLRQIHCh8Hiwq1AgcAoAAKAHACjgAXAYQAawEKC00CDAtvAA0LBAEOC1IAEgs/AJMLLQAHC1QFBwtzB40LngAEC5QBBAuTAocLowINC9MADguFAA4LzAAPC0AADwtFAA8LcgAQCwoAEwsXABMLIwATCycAEwszABMLRwATC0sAmAsPAAQKTgAFCmAABQq2AAcKvAYHCiEHCgqKAQoK1wELChQCDgpUAZEKWACHCqwHhQuHAQsLdwMOC20Bjgt3AQULHAIGC6EGBwveAIgLVQGGC04ACQBZAgkAawIKAPkBCgDcAgsAYwGMAIsAhgAkAYsArgAFALEABgBoAgcAOwMJAA0CigCQAgoAHwAGCtcABwoEBAcKwQUHCrkGCQqoAYoKCwOHCkgCiAslAYYArQKHC0wHhQvMAQcAhwIGCkMABwpeBgkKYgEJCqMCCgo+Aw4KUACRClAABAChAIUAdwIGCo0ABwrhAAkKOwAJCl8CCgo4AQsKrwIMCisCDQp1AQ0K7gGUCjoABwvFAwcLtAWHC0QGiAoPA4YLhAEGANICBgDzBAQL/wEJC00BCQt7AQoLWgILC7kBCwvTAgsL0AOMC2UBhgAFB4cAlAYJANUBCQDFAgwAAAIOAEEAEQAMAAULqgOIC8MCBwDOBIgAEwIKAOUACwBJAAsAeAGLALEBDAAMAQwAgAKOAHcABwquAYsKLgAGAC4CBwCLAggApQEJAAAACgAiAIsA8AMGAGoABwD6BgcAHQcJAGYACQD7AgUKWgIHCuIHiQqiAQUAQQAGAKABBwC4BgcAhAcKAG0ACwAOAAsARgALADkCCwDfAg8AmQAUAFAAiAqlAocLWQaJCwQDiABTAgYL1QEHC60GigsDAgcAKAeKAHYBCQBqAAkAowAJACgBCgCnAAoArAAKAAkDiwAQAAYABgAHAFEABwADAwcAwwYJAJUBigClAQQL9AGHC6oDBQtEAIYLfwEFAHEDhQB1AwYAVgMGAGwEBgDXBQYA9gUGAP0FhgApBgQLUQEGC2EBBwuOBwgL6AGJC60BBwvsAAcLAwcICwMBCQuHAAkLsQAKCzkDCwtzAAsLcgELC5UBCwtcAgwLCgAMC5sCDAudAg0LTAAOCzYBDwtMAA8LkwCUCxcABQCOAIYAIgIECw8ABQsWAAYL9AAHCygABwvIAAcLigMHC68ECQtoAgoLzAILC3sCCwshA4wLygEFANIBCwA7AgwAxgANABsBDgC6AA8AFQAPAGcAhwpJAQQAuQAFAAEBBQBHAwUAqAMJAI8BCgACAQoAiwEKAN4CCwD2AwwAFwANAF4BDgCWABMABgCHC8cGDAskAI0LUQEFC1YCBwsXAwgLbACJC3sAhArVAQcAlAEHAGEFBwCWBQcA4QcIAJUACADvAAgAAAIIABkDCAAyAwkA2gEJAFMCCgB6AAoANQIKAIkCCgAPAwsA7wALACcBCwC/AQsAEAILAH8CCwAgAwwAGQAMAE0ADACdAAwAAAEMADwBDACGAQwAhwEMAIsBDADeAQwA9wEMAFACDACoAg0AMgANADUADQCEAA0AxgANAEIBDQCfAQ0A/wEOAEcADgCLAQ8ARwAPAIgAEQB7ABIAXQCTADoAiADIAoYKzwYFCqEDBgpUAQgKeAGICicDBgA4BwgAXAMKAFgDCgBbAwoAnQMKAK0DjAD6AgYAdQIGAIoDCQAqA4wAjAIFCtoABwpKBooKUwAHCugFhwoCBwQAeQEYAA0ABAubAAcLmQYLCgAAkApOAAQLpAAFC5cABQvaAgUL5QIHC/IBBwtmAwcLBgYMC9UADgskAA4LhwERC28AEgsGABILLgASC5cAEwskABQLIAAUCzgAFAtFABQLZgAVCwQAFgsIABYLCgAWCw4AlgsfAAcAMgeFCjsCBArHAQQLcAKHC9gGhgDdBQQL7AEFC8MBBgqhAAcKdAGJClUChApdAQQAtACHAHIHhwtDA40LRgCEAOsBiQrvAgYKsAGLCkIBBACrAIoA6gAGC3EAhwu0AQQASgIHAKIEigB3AgUK1AEKCkUBCwpYAwwKWQGPCmgABQrfAAoLUAIKC/ECDAs9AQwLYwEMC9EBDAvVAQwLMAIMC0ICjQvzAIQKNgKHCwgCBAo7AIcKcgUGCrQBiwrhAQkAowMKAE4BFABHAAQKMAAFCg8BBwq5A4cLVgcLAKoABQpiAogKyQGFCvMCBgAzBocKwQQECsUAlQsaAIULSQKJCwkChQD9AoUK2QCLC0oChQCoAQkL8AIMC2ICDQuvARALOwCSC20AiADKAgcArQKECzMBCQCkAQoADQEKAB0BCgBAAgsAjQENAK8AkQBaAIQArQGFC8QDCQvPAYoLUwIHABIABwC7AgcArgcIAPACCQARAQkAnAEJAL8CCgBHAAoAqwGKAPwBBAqlAAcKdgWHCiUHBAA1AAUAugAHAPACBwA8A44AdAAIAD8CCgAhAYsAPwGEAKMChgCQBQQLSwAFC7QABgv0AQcLOgAHC8YCiguFAoULiQIGCxQBBwsaAQcLbwMHC5wDCAvLAQkLVwIJC/ICCws+AgwLgAAMC+4BDQs0AA0LLQEPCx4AjwuEAAYAhwKGAEcEBQoJAAcKKQEHCsYDjAoyAYQLyACGADYFBQqSAAYKmwGKCtECBgDRAAYAdQQGAAgFCADUAQkA0gALACQADAAcAAwAdgINABUADQBdAQ4ABwCRAA0ABgqxAIcK0wEEAFYBhwCbBAoLxgGMC0QBBACgA4UAjgMHAC4HBgvhAIkL0wAQAGUAFABzABQAdgCUAHoABADwAYcAWAMEAD4BCwCOAgcLzgKLC2YACAs6AAkL1AILCykDDQtxAJELSAAFCsgABgtZAYcL3wQIC/8CCAsjAwkLLQGJC4cDBwCTAwgA9wATAAAABwudB4gLogIEAMoABQB+AQYAxgEHAKgDBwALBwgA9gIJAHcBCQB/AwoA5wIKABgDCwDSAwsA9AOOAG0ABwB+BAcAkQUHAK0FjAABAoYLAwGKABcDCwA1AwwAbgAMAJkAEgApAJYAEwCGCuEBhAAcAwYAvQEJAI0DiAv+AAoACAMNAFkBjgCpAQQKVAAHCsoFCgpMAIoKjgCHC+YCBgBCAoUK9wMGAGsFBAo7AQUK+wGHCloFBAC2AYUAKwKIAP4ChQv4AIYKugYEC3QABQtfAAULvQEHC5gGCAsdAAkLEAELC/0BiwuTA4cAHQKFCx8CCAreAAgK3AEJCu4ACwoEAgsKPwIPCm0AkgpkAAYAcAOGAKcEBQu1AIgLKQCGAOIFhAupAgcLGQAIC8oAigsYAosA1wOJAAADhABIAgkLpwGMC1kACAtxAAkLbQMKCyoCCwtTAAwLiACTC20ABwrCAgcKIgSKChoChQvQAwQLzgCHC+oCiAsOAowA4QILClwACwrEAAsKmQELCsIBCwqaAgsKCQMMCgYBDQqBAQ0KiQEPCnMAEAotAJEKUgAEAOIABABGAQcA6gYECz8BBQu7AooLoQIGCigAhwr1BgUAqgEIAB4ACQACAAsAJQKTAHoABgCJBIYAMQWKCmEABgqnAQcKmQKHCroEBwsNAAgL4gAKCxkCCws6AgsLXQILCx8DCwskAwwLVQAMCwQCDAtvAg0LcAANC2kBDgtNAA4LTgARCxwAkwtuAIQLAQOECycChAvYApMAdQAJCzkACQvLAQoLqQELC3cADAu4AAwLcwENC2YBkQszAAULvAAFCy4DCAsKAAkLpQEJC9kCCgthAosLsQKGC3AChwsqAYcAzgEEAFkBiwpwAogKPgIEAIEBBwAJAYcASwIGACgDhAsQAoUAjgGECmIBBABbAQUApwEFAOQDhwAxBYcKFgYHAOsECQB9AIsAQQAFAIgABgCIAIgAhAIFC2gABgutAIcLXwaHANUBhQo+AwQAFgEFANEBhwBXBQcLKgMIC4oACAtWAQkLVAAKC8EACwtzA4wLZwEFCvABhwrLAAQAsQGFAM8CBgtfAIYKIwIFClgAiQrvAAYLlgEKC5kBCgu/AQsLLACMC2QAhgCPBQcKigKHCh4FhgDtAocL2wSHAFMFBgB9AQcAhQIHALYCCAAiAgcKNAQJClAACwpOAAsKpQELChYCjAohAoYLZAaHC0AFDAAVAQcKEgELCt8Biwr7AQYAwQIGAA8DBgD7BAYAyQUECxoBBwsKBAsLjgELC3oCDAsBAAwLTwAMCyACDgvtABELCgCSCxQAhgDFAQQAKwIIABgCCgAgAQsA7QMECvEBhwowBgULdgAFC/MBBgvcAQcLWAIHC3gDhwtIBIoA2wMHAFMEBwoFAQcKWwQHCkoFBwo0BgcKqQYHCm4HCQrRAQoK+AAKCl0BCgqHAgsKDwILCpQCCwqdAgwKEQKNCjEBBwsoAQcLVAIICzACCAtKAgkLZAILC2QACwswAQwLLgANC1kADgtwAJELegAJAHIBigBaAIgKDQCEAFwDBwqCAggK+gALCnsACwqJAA0KMACOCl8AhwqVBYkLQQGEAAEBhwDvBwcA6AYHCz8GBwu7BggLTwAIC2oACAu+AAgLLgEIC38BCQt3AAkL6QAJCyoBCQujAQkL1wEKC7UA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Cwu1AwwL6AAMC+wADQudAQ0L9QGSC3QACQCMAAUK3gCKChYCBgAgBIkKigOGAKgGigr3AYYADAQFCpoABwrTBQoKewGKCuUBBAt/AYUKzAKGACMFBQBWAAcA5wIJAFUACgAZAQoAsAELADkDDAD7AA0AdgCOAHoBCAAIAQQKWwAFCoQBBQpNAwYKzgAGCvwABgptAQcKiAAHChMCiAptAgUADAKFAOgCBQsVAY0L9wCEC7MBCgBrAIwAtAGEAJ8DCgB7AAwAngKSAF4ABwB9BAkAnACKAL0DBQsJAQYL1ACHCxwAhQAKA4UA9gEIAMQACgAbAYsAlgGHCkACiAsXAoYAIAUFCgMDBQpfAwUKggMGCmAGBgpsBoYK9AYFAFcDBQpLAYcLzwWEC74CBQsoA4cL/QcHAHgFCQC+AYoALQCMCngChADrAwULpgAIC+MCjAv/AQUKawAHCskAiAoGAgYKvgGHChkHhgD8BYYASQQEC3cABQuqAAULvwEHC6wGBwthBwkLZQEJC88CDAvmAYwLVAIJClMDjQr+AQcAZAIIACECCAA4AggAggIJAM0CCgAdAgoA+wILAMEBDADpAQ0AmQANACgBDgCKAA4AiAEPADIAEAAGABAADAAUAAkAhAr4AQQLwgGHC4YECwA2AA0ArQANACYBBQpzAwUKzwMICogBlAoHAA0AxwEPAGMADwCBAJAARACHAKwAhAvyAgUKmgOGCqsGhgAFBBELJwCUCyQABAA4AgUK4QMHCgMCiQpbAIQA3AIKAGkCigtpAoYAzgMHAN0DCgB5AQwAawENAEQADQBeAA4AbACOADIBiADdAoQArAEHAP0GhwsmBAcA3weMAJkChwqZBQUAHwEHCpkDCApEAggKUQIICnYCigocAIoAJgMECo8DBQpjAwUK9QMHCvIHCAoeA4gKLQOGAAMGCAsLApYLIgCHC+QCBwvuAAcL8QcIC3gACAu8AAgLkwIJC1YCCgvSAQwLVgEMC0wCDQv3AQ4L9gCPC1wABwAbBo0AtgAFCocABgoHAgcKugYKCg8BCwoFAZEKNgAOClIBlApRAAcA5AEECiwBhQq0AZELcgAGAFcGhgCRBoULgAIEC8kABwvQBggLWgILC/cACws6A5ELQQAIC6QAkgs+AAYAKQcGAEUHiABuA4YAIQYICmUBCgrpAg4KqgERCl4A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AAIAAAAFAAAACQAAAAwAAAAAAAAAsF8GAAEAAAACAAAAAwAAAAQAAAAGAAAAAgAAAAMAAAAJAAAADQAAAAAAAADAXwYABQAAAAIAAAADAAAABAAAAAcAAAAIAAAAAwAAAAkAAAAOAAAAAAAAANBfBgAGAAAAAgAAAAMAAAAEAAAACQAAAAoAAAADAAAACQAAAA8AAAAAAAAA4F8GAAEAAAACAAAAAwAAAAQAAAALAAAAAgAAAAwAAAAJAAAAEAAAAAAAAADwXwYAAQAAAAIAAAADAAAABAAAAA0AAAACAAAAAwAAAAkAAAARAEHB0hkLuAVgBgAHAAAACAAAAAkAAAAKAAAADgAAAA8AAAADAAAACQAAABIAAAAAAAAAEGAGAAEAAAACAAAAAwAAAAQAAAAQAAAAAgAAAAMAAAAJAAAAEwAAAAAAAAAgYAYAAQAAAAIAAAADAAAABAAAABEAAAACAAAAAwAAAAkAAAAUAAAAAAAAADBgBgABAAAAAgAAAAMAAAAEAAAAEgAAAAIAAAADAAAACQAAABUAAAAAAAAAQGAGAAEAAAACAAAAAwAAAAQAAAATAAAAAgAAAAMAAAAJAAAAFgAAAAAAAABQYAYAAQAAAAIAAAADAAAABAAAABQAAAACAAAAAwAAAAkAAAAXAAAAAAAAAGBgBgABAAAAAgAAAAMAAAAEAAAAFQAAAAIAAAADAAAACQAAABgAAAAAAAAAcGAGAAEAAAACAAAAAwAAAAQAAAAWAAAAAgAAAAMAAAAJAAAAGQAAAAAAAACAYAYAAQAAAAIAAAADAAAABAAAABcAAAACAAAAAwAAAAkAAAAaAAAAAAAAAJBgBgABAAAAAgAAAAMAAAAEAAAAGAAAAAIAAAADAAAACQAAABsAAAAAAAAAoGAGAAEAAAACAAAAAwAAAAQAAAAZAAAAAgAAAAMAAAAJAAAAHAAAAAAAAACwYAYAAQAAAAIAAAADAAAABAAAABoAAAACAAAAAwAAAAkAAAAdAAAAAAAAAMBgBgABAAAAAgAAAAMAAAAEAAAAGwAAAAIAAAADAAAACQAAAB4AAAAAAAAA0GAGAAEAAAACAAAAAwAAAAQAAAAcAAAAAgAAAAMAAAAJAAAAHwAAAAAAAADgYAYAAQAAAAIAAAADAAAABAAAAB0AAAACAAAAAwAAAAkAAAAgAAAAAAAAAPBgBgABAAAAAgAAAAMAAAAEAAAAHgAAAAIAAAADAAAACQAAACEAQYHYGQu4BWEGAAEAAAACAAAAAwAAAAQAAAAfAAAAAgAAAAMAAAAJAAAAIgAAAAAAAAAQYQYAAQAAAAIAAAADAAAABAAAACAAAAACAAAAAwAAAAkAAAAjAAAAAAAAACBhBgABAAAAAgAAAAMAAAAEAAAAIQAAAAIAAAADAAAACQAAACQAAAAAAAAAMGEGAAEAAAACAAAAAwAAAAQAAAAiAAAAAgAAAAMAAAAJAAAAJQAAAAAAAABAYQYAAQAAAAIAAAADAAAABAAAACMAAAACAAAAJAAAAAkAAAAmAAAAAAAAAFBhBgABAAAAAgAAAAMAAAAEAAAAJQAAAAIAAAADAAAACQAAACcAAAAAAAAAYGEGAAEAAAACAAAAAwAAAAQAAAAmAAAAAgAAAAMAAAAJAAAAKAAAAAAAAABwYQYAAQAAAAIAAAADAAAABAAAACcAAAACAAAAKAAAAAkAAAApAAAAAAAAAIBhBgABAAAAAgAAAAMAAAAEAAAAKQAAAAIAAAADAAAACQAAACoAAAAAAAAAkGEGAAEAAAACAAAAAwAAAAQAAAAqAAAAAgAAAAMAAAAJAAAAKwAAAAAAAACgYQYAAQAAAAIAAAADAAAABAAAACsAAAACAAAAAwAAAAkAAAAsAAAAAAAAALBhBgABAAAAAgAAAAMAAAAEAAAALAAAAAIAAAAtAAAACQAAAC0AAAAAAAAAwGEGAAEAAAACAAAAAwAAAAQAAAAuAAAAAgAAAAMAAAAJAAAALgAAAAAAAADQYQYAAQAAAAIAAAADAAAABAAAAC8AAAACAAAAAwAAAAkAAAAvAAAAAAAAAOBhBgABAAAAAgAAAAMAAAAEAAAAMAAAAAIAAAADAAAACQAAADAAAAAAAAAA8GEGAAEAAAACAAAAAwAAAAQAAAAxAAAAAgAAAAMAAAAJAAAAMQBBwd0ZC7gFYgYAAQAAAAIAAAADAAAABAAAADIAAAACAAAAAwAAAAkAAAAyAAAAAAAAABBiBgABAAAAAgAAAAMAAAAEAAAAMwAAAAIAAAADAAAACQAAADMAAAAAAAAAIGIGAAEAAAACAAAAAwAAAAQAAAA0AAAAAgAAAAMAAAAJAAAANAAAAAAAAAAwYgYACwAAAAwAAAANAAAADgAAADUAAAA2AAAAAwAAAAkAAAA1AAAAAAAAAEBiBgABAAAAAgAAAAMAAAAEAAAANwAAAAIAAAADAAAACQAAADYAAAAAAAAAUGIGAAEAAAACAAAAAwAAAAQAAAA4AAAAAgAAADkAAAAJAAAANwAAAAAAAABgYgYAAQAAAAIAAAADAAAABAAAADoAAAACAAAAAwAAAAkAAAA4AAAAAAAAAHBiBgABAAAAAgAAAAMAAAAEAAAAOwAAAAIAAAADAAAACQAAADkAAAAAAAAAgGIGAAEAAAACAAAAAwAAAAQAAAA8AAAAAgAAAAMAAAAJAAAAOgAAAAAAAACQYgYAAQAAAAIAAAADAAAABAAAAD0AAAACAAAAAwAAAAkAAAA7AAAAAAAAAKBiBgABAAAAAgAAAAMAAAAEAAAAPgAAAAIAAAADAAAACQAAADwAAAAAAAAAsGIGAAEAAAACAAAAAwAAAAQAAAA/AAAAAgAAAEAAAAAJAAAAPQAAAAAAAADAYgYAAQAAAAIAAAADAAAABAAAAEEAAAACAAAAQgAAAAkAAAA+AAAAAAAAANBiBgAPAAAAAgAAAAMAAAAEAAAAQwAAAEQAAAADAAAACQAAAD8AAAAAAAAA4GIGABAAAAARAAAAAwAAAAQAAABFAAAARgAAAAMAAAAJAAAAQAAAAAAAAADwYgYAAQAAAAIAAAADAAAABAAAAEcAAAACAAAAAwAAAAkAAABBAEGB4xkL4ARjBgABAAAAAgAAAAMAAAAEAAAASAAAAAIAAAADAAAACQAAAEIAAAAAAAAAEGMGABIAAAATAAAAFAAAAAQAAABJAAAASgAAAAMAAAAJAAAAQwAAAAAAAAAgYwYAAQAAAAIAAAADAAAABAAAAEsAAAACAAAAAwAAAAkAAABEAAAAAAAAADBjBgABAAAAAgAAAAMAAAAEAAAATAAAAAIAAAADAAAACQAAAEUAAAAAAAAAQGMGABUAAAACAAAAFgAAAAQAAABNAAAATgAAAAMAAAAJAAAARgAAAAAAAABQYwYAAQAAAAIAAAADAAAABAAAAE8AAAACAAAAAwAAAAkAAABHAAAAAAAAAGBjBgABAAAAAgAAAAMAAAAEAAAAUAAAAAIAAAADAAAACQAAAEgAAAAAAAAAcGMGAAEAAAACAAAAAwAAAAQAAABRAAAAAgAAAAMAAAAJAAAASQAAAAAAAACAYwYAAQAAAAIAAAADAAAABAAAAFIAAAACAAAAAwAAAAkAAABKAAAAAAAAAJBjBgAXAAAAAgAAABgAAAAEAAAAUwAAAFQAAAADAAAACQAAAEsAAAAAAAAAoGMGAAEAAAACAAAAAwAAAAQAAABVAAAAAgAAAAMAAAAJAAAATAAAAAAAAACwYwYAAQAAAAIAAAADAAAABAAAAFYAAAACAAAAAwAAAAkAAABNAAAAAAAAAMBjBgBOAAAATwAAAAQAAAAAAAAA0GMGAE4AAABQAAAABAAAAAAAAADgYwYATgAAAFEAAAAEAAAAAAAAADBkBgAEAAAAUgAAAAYAAAAHAAAABQBB6ecZC5BEZAYABAAAAFMAAAAGAAAABwAAAAYAAAAAAAAAsGQGAAQAAABUAAAABgAAAAcAAAAEAAAAAwAAAAMAAAADAAAAdmVjdG9yPHVpbnQ4X3Q+AHdvZmYyRGVjAHdvZmYyRW5jAHB1c2hfYmFjawByZXNpemUAc2l6ZQBnZXQAc2V0AE5TdDNfXzI2dmVjdG9ySWhOU185YWxsb2NhdG9ySWhFRUVFAE5TdDNfXzIxM19fdmVjdG9yX2Jhc2VJaE5TXzlhbGxvY2F0b3JJaEVFRUUATlN0M19fMjIwX192ZWN0b3JfYmFzZV9jb21tb25JTGIxRUVFAFBOU3QzX18yNnZlY3RvckloTlNfOWFsbG9jYXRvckloRUVFRQBQS05TdDNfXzI2dmVjdG9ySWhOU185YWxsb2NhdG9ySWhFRUVFAGlpAHYAdmkAdmlpaQB2aWlpaQBpaWkATjEwZW1zY3JpcHRlbjN2YWxFAGlpaWkAaWlpaWkATlN0M19fMjEyYmFzaWNfc3RyaW5nSWNOU18xMWNoYXJfdHJhaXRzSWNFRU5TXzlhbGxvY2F0b3JJY0VFRUUATlN0M19fMjIxX19iYXNpY19zdHJpbmdfY29tbW9uSUxiMUVFRQB4X21pbnMuc2l6ZSgpID09IG51bV9nbHlwaHMAd29mZjIvc3JjL3dvZmYyX2RlYy5jYwBSZWNvbnN0cnVjdFRyYW5zZm9ybWVkSG10eABONXdvZmYyMTRXT0ZGMlN0cmluZ091dEUATjV3b2ZmMjhXT0ZGMk91dEUAZ2x5Zi9sb2NhIHRyYW5zZm9ybWF0aW9uIGZhaWxlZC4KAFBhcnNpbmcgb2YgdGhlIGlucHV0IGZvbnQgZmFpbGVkLgoAQ29tcHJlc3Npb24gb2YgY29tYmluZWQgdGFibGUgZmFpbGVkLgoAQ29tcHJlc3NlZCAlenUgdG8gJXUuCgBDb21wcmVzc2lvbiBvZiBleHRlbmRlZCBtZXRhZGF0YSBmYWlsZWQuCgBSZXN1bHQgYWxsb2NhdGlvbiB3YXMgdG9vIHNtYWxsICglemQgdnMgJXpkIGJ5dGVzKS4KAE1pc3NpbmcgdGFibGUgaW5kZXggZm9yIG9mZnNldCAweCUwOHgKAE1pc21hdGNoIGJldHdlZW4gY29tcHV0ZWQgYW5kIGFjdHVhbCBsZW5ndGggKCV6ZCB2cyAlemQpCgBtYXA6OmF0OiAga2V5IG5vdCBmb3VuZABhbGxvY2F0b3I8VD46OmFsbG9jYXRlKHNpemVfdCBuKSAnbicgZXhjZWVkcyBtYXhpbXVtIHN1cHBvcnRlZCBzaXplAAAMGxcqPzgwO0ACBAMCAgQABwMCAQ8tKyAgIDBYMHgAKG51bGwpAC0wWCswWCAwWC0weCsweCAweABpbmYASU5GAG5hbgBOQU4AdGVybWluYXRpbmcgd2l0aCAlcyBleGNlcHRpb24gb2YgdHlwZSAlczogJXMAdGVybWluYXRpbmcgd2l0aCAlcyBleGNlcHRpb24gb2YgdHlwZSAlcwB0ZXJtaW5hdGluZyB3aXRoICVzIGZvcmVpZ24gZXhjZXB0aW9uAHRlcm1pbmF0aW5nAHVuY2F1Z2h0AFN0OWV4Y2VwdGlvbgBOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQBTdDl0eXBlX2luZm8ATjEwX19jeHhhYml2MTIwX19zaV9jbGFzc190eXBlX2luZm9FAE4xMF9fY3h4YWJpdjExN19fY2xhc3NfdHlwZV9pbmZvRQB0ZXJtaW5hdGVfaGFuZGxlciB1bmV4cGVjdGVkbHkgcmV0dXJuZWQAX1oAX19fWgBfYmxvY2tfaW52b2tlAGludm9jYXRpb24gZnVuY3Rpb24gZm9yIGJsb2NrIGluIABsb25nIGxvbmcAX19pbnQxMjgAdW5zaWduZWQgX19pbnQxMjgAbG9uZyBkb3VibGUAX19mbG9hdDEyOAAuLi4AZGVjaW1hbDY0AGRlY2ltYWwxMjgAZGVjaW1hbDMyAGRlY2ltYWwxNgBjaGFyMzJfdABjaGFyMTZfdABhdXRvAGRlY2x0eXBlKGF1dG8pAHN0ZDo6bnVsbHB0cl90AFthYmk6AF0ATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTBBYmlUYWdBdHRyRQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU0Tm9kZUUAUHVyZSB2aXJ0dWFsIGZ1bmN0aW9uIGNhbGxlZCEAYWxsb2NhdG9yAGJhc2ljX3N0cmluZwBzdHJpbmcAaXN0cmVhbQBvc3RyZWFtAGlvc3RyZWFtAHN0ZDo6YWxsb2NhdG9yAHN0ZDo6YmFzaWNfc3RyaW5nAHN0ZDo6aXN0cmVhbQBzdGQ6Om9zdHJlYW0Ac3RkOjppb3N0cmVhbQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxOVNwZWNpYWxTdWJzdGl0dXRpb25FACBpbWFnaW5hcnkATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjBQb3N0Zml4UXVhbGlmaWVkVHlwZUUAIGNvbXBsZXgAKQAgACgAJgAmJgBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxM1JlZmVyZW5jZVR5cGVFAG9iamNfb2JqZWN0ACoAaWQ8AD4ATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTFQb2ludGVyVHlwZUUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjBOYW1lV2l0aFRlbXBsYXRlQXJnc0UAPAAsIABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMlRlbXBsYXRlQXJnc0UATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTNQYXJhbWV0ZXJQYWNrRQB3Y2hhcl90AGIwRQBiMUUAdQBsAHVsAGxsAHVsbABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNUludGVnZXJDYXN0RXhwckUAJUxhTABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNkZsb2F0TGl0ZXJhbEltcGxJZUVFACVhAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE2RmxvYXRMaXRlcmFsSW1wbElkRUUAJWFmAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE2RmxvYXRMaXRlcmFsSW1wbElmRUUAdHJ1ZQBmYWxzZQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU4Qm9vbEV4cHJFAC0ATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTRJbnRlZ2VyTGl0ZXJhbEUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjBUZW1wbGF0ZUFyZ3VtZW50UGFja0UAZ3MAJj0APQBhbGlnbm9mICgALAB+AC4qAC8ALz0AXgBePQA9PQA+PQA8PQA8PAA8PD0ALT0AKj0ALS0AIT0AIQB8fAB8AHw9AC0+KgArACs9ACsrAC0+ACUAJT0APj4APj49AHNpemVvZiAoAHR5cGVpZCAoAHRocm93AHRocm93IABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU5VGhyb3dFeHByRQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMkluaXRMaXN0RXhwckUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTNOb2RlQXJyYXlOb2RlRQBzaXplb2YuLi4gKABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxM0VuY2xvc2luZ0V4cHJFAHNpemVvZi4uLigATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjJQYXJhbWV0ZXJQYWNrRXhwYW5zaW9uRQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxOVNpemVvZlBhcmFtUGFja0V4cHJFAHN0YXRpY19jYXN0AD4oAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZThDYXN0RXhwckUAcmVpbnRlcnByZXRfY2FzdAApID8gKAApIDogKABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNUNvbmRpdGlvbmFsRXhwckUAbm9leGNlcHQgKABudwBuYQBwaQA6Om9wZXJhdG9yIABuZXcAW10ATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlN05ld0V4cHJFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTExUG9zdGZpeEV4cHJFACAuLi4gACA9IABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNUJyYWNlZFJhbmdlRXhwckUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTBCcmFjZWRFeHByRQBfR0xPQkFMX19OAChhbm9ueW1vdXMgbmFtZXNwYWNlKQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU4TmFtZVR5cGVFAClbAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE4QXJyYXlTdWJzY3JpcHRFeHByRQAuAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwTWVtYmVyRXhwckUAc3JOAHNyADo6AE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE5R2xvYmFsUXVhbGlmaWVkTmFtZUUAZG4Ab24Ab3BlcmF0b3ImJgBvcGVyYXRvciYAb3BlcmF0b3ImPQBvcGVyYXRvcj0Ab3BlcmF0b3IoKQBvcGVyYXRvciwAb3BlcmF0b3J+AG9wZXJhdG9yIGRlbGV0ZVtdAG9wZXJhdG9yKgBvcGVyYXRvci8Ab3BlcmF0b3IvPQBvcGVyYXRvcl4Ab3BlcmF0b3JePQBvcGVyYXRvcj09AG9wZXJhdG9yPj0Ab3BlcmF0b3I+AG9wZXJhdG9yW10Ab3BlcmF0b3I8PQBvcGVyYXRvcjw8AG9wZXJhdG9yPDw9AG9wZXJhdG9yPABvcGVyYXRvci0Ab3BlcmF0b3ItPQBvcGVyYXRvcio9AG9wZXJhdG9yLS0Ab3BlcmF0b3IgbmV3W10Ab3BlcmF0b3IhPQBvcGVyYXRvciEAb3BlcmF0b3IgbmV3AG9wZXJhdG9yfHwAb3BlcmF0b3J8AG9wZXJhdG9yfD0Ab3BlcmF0b3ItPioAb3BlcmF0b3IrAG9wZXJhdG9yKz0Ab3BlcmF0b3IrKwBvcGVyYXRvci0+AG9wZXJhdG9yPwBvcGVyYXRvciUAb3BlcmF0b3IlPQBvcGVyYXRvcj4+AG9wZXJhdG9yPj49AG9wZXJhdG9yPD0+AG9wZXJhdG9yIiIgAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE1TGl0ZXJhbE9wZXJhdG9yRQBvcGVyYXRvciBkZWxldGUAb3BlcmF0b3IgAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTIyQ29udmVyc2lvbk9wZXJhdG9yVHlwZUUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlOER0b3JOYW1lRQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxM1F1YWxpZmllZE5hbWVFAGR5bmFtaWNfY2FzdABkZWxldGUAW10gAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwRGVsZXRlRXhwckUAY3YAKSgATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTRDb252ZXJzaW9uRXhwckUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlOENhbGxFeHByRQBjb25zdF9jYXN0AE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwUHJlZml4RXhwckUAKSAAICgATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTBCaW5hcnlFeHByRQBhYQBhbgBhTgBhUwBjbQBkcwBkdgBkVgBlbwBlTwBlcQBnZQBndABsZQBscwBsUwBsdABtaQBtSQBtbABtTABuZQBvbwBvcgBvUgBwbABwTABybQByTQBycwByUwAuLi4gACAuLi4ATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlOEZvbGRFeHByRQBmcABmTABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxM0Z1bmN0aW9uUGFyYW1FAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTI0Rm9yd2FyZFRlbXBsYXRlUmVmZXJlbmNlRQBUcwBzdHJ1Y3QAVHUAdW5pb24AVGUAZW51bQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUyMkVsYWJvcmF0ZWRUeXBlU3BlZlR5cGVFAFN0TABTdABzdGQ6OgBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNlN0ZFF1YWxpZmllZE5hbWVFAERDAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTIxU3RydWN0dXJlZEJpbmRpbmdOYW1lRQBVdABVbAB2RQAnbGFtYmRhACcoAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE1Q2xvc3VyZVR5cGVOYW1lRQAndW5uYW1lZAAnAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE1VW5uYW1lZFR5cGVOYW1lRQBzdHJpbmcgbGl0ZXJhbABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU5TG9jYWxOYW1lRQBzdGQATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTJDdG9yRHRvck5hbWVFAGJhc2ljX2lzdHJlYW0AYmFzaWNfb3N0cmVhbQBiYXNpY19pb3N0cmVhbQBzdGQ6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6OmFsbG9jYXRvcjxjaGFyPiA+AHN0ZDo6YmFzaWNfaXN0cmVhbTxjaGFyLCBzdGQ6OmNoYXJfdHJhaXRzPGNoYXI+ID4Ac3RkOjpiYXNpY19vc3RyZWFtPGNoYXIsIHN0ZDo6Y2hhcl90cmFpdHM8Y2hhcj4gPgBzdGQ6OmJhc2ljX2lvc3RyZWFtPGNoYXIsIHN0ZDo6Y2hhcl90cmFpdHM8Y2hhcj4gPgBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUyN0V4cGFuZGVkU3BlY2lhbFN1YnN0aXR1dGlvbkUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTBOZXN0ZWROYW1lRQA6OioATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTlQb2ludGVyVG9NZW1iZXJUeXBlRQBbAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTlBcnJheVR5cGVFAER2ACB2ZWN0b3JbAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwVmVjdG9yVHlwZUUAcGl4ZWwgdmVjdG9yWwBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNVBpeGVsVmVjdG9yVHlwZUUAZGVjbHR5cGUoAHVuc2lnbmVkIGxvbmcgbG9uZwBvYmpjcHJvdG8AIGNvbnN0ACB2b2xhdGlsZQAgcmVzdHJpY3QATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlOFF1YWxUeXBlRQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxN1ZlbmRvckV4dFF1YWxUeXBlRQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxM09iakNQcm90b05hbWVFAERvAG5vZXhjZXB0AERPAER3AER4AFJFAE9FACAmACAmJgBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMkZ1bmN0aW9uVHlwZUUAdGhyb3coAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTIwRHluYW1pY0V4Y2VwdGlvblNwZWNFAG5vZXhjZXB0KABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMk5vZXhjZXB0U3BlY0UATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTFTcGVjaWFsTmFtZUUATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlOURvdFN1ZmZpeEUAVWE5ZW5hYmxlX2lmSQBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNkZ1bmN0aW9uRW5jb2RpbmdFACBbZW5hYmxlX2lmOgBOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMkVuYWJsZUlmQXR0ckUAdGhyZWFkLWxvY2FsIHdyYXBwZXIgcm91dGluZSBmb3IgAHJlZmVyZW5jZSB0ZW1wb3JhcnkgZm9yIABndWFyZCB2YXJpYWJsZSBmb3IgAG5vbi12aXJ0dWFsIHRodW5rIHRvIAB2aXJ0dWFsIHRodW5rIHRvIAB0aHJlYWQtbG9jYWwgaW5pdGlhbGl6YXRpb24gcm91dGluZSBmb3IgAGNvbnN0cnVjdGlvbiB2dGFibGUgZm9yIAAtaW4tAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTIxQ3RvclZ0YWJsZVNwZWNpYWxOYW1lRQBjb3ZhcmlhbnQgcmV0dXJuIHRodW5rIHRvIAB0eXBlaW5mbyBuYW1lIGZvciAAdHlwZWluZm8gZm9yIABWVFQgZm9yIAB2dGFibGUgZm9yIABTdDExbG9naWNfZXJyb3IAU3QxMmxlbmd0aF9lcnJvcgBTdDEyb3V0X29mX3JhbmdlAE4xMF9fY3h4YWJpdjExN19fcGJhc2VfdHlwZV9pbmZvRQBOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQBOMTBfX2N4eGFiaXYxMjBfX2Z1bmN0aW9uX3R5cGVfaW5mb0UATjEwX19jeHhhYml2MTI5X19wb2ludGVyX3RvX21lbWJlcl90eXBlX2luZm9FAE4xMF9fY3h4YWJpdjEyM19fZnVuZGFtZW50YWxfdHlwZV9pbmZvRQB2AERuAGIAYwBoAGEAcwB0AGkAagBtAGYAZABOMTBfX2N4eGFiaXYxMjFfX3ZtaV9jbGFzc190eXBlX2luZm9FAHZvaWQAYm9vbABjaGFyAHNpZ25lZCBjaGFyAHVuc2lnbmVkIGNoYXIAc2hvcnQAdW5zaWduZWQgc2hvcnQAaW50AHVuc2lnbmVkIGludABsb25nAHVuc2lnbmVkIGxvbmcAZmxvYXQAZG91YmxlAHN0ZDo6c3RyaW5nAHN0ZDo6YmFzaWNfc3RyaW5nPHVuc2lnbmVkIGNoYXI+AHN0ZDo6d3N0cmluZwBlbXNjcmlwdGVuOjp2YWwAZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxmbG9hdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZG91YmxlPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nIGRvdWJsZT4ATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZUVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWRFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lmRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbUVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWxFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lqRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJaUVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXRFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lzRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJaEVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWFFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ljRUUATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUATlN0M19fMjEyYmFzaWNfc3RyaW5nSWhOU18xMWNoYXJfdHJhaXRzSWhFRU5TXzlhbGxvY2F0b3JJaEVFRUU=`);
  }
});

// fonts/wasm/woff2.bindings.ts
var woff2_bindings_exports = {};
__export(woff2_bindings_exports, {
  default: () => woff2_bindings_default
});
var Module, woff2_bindings_default;
var init_woff2_bindings = __esm({
  "fonts/wasm/woff2.bindings.ts"() {
    "use strict";
    init_define_import_meta_env();
    Module = function() {
      const _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      return function(Module2) {
        Module2 = Module2 || {};
        "use strict";
        var Module2 = typeof Module2 !== "undefined" ? Module2 : {};
        let moduleOverrides = {};
        let key;
        for (key in Module2) {
          if (Module2.hasOwnProperty(key)) {
            moduleOverrides[key] = Module2[key];
          }
        }
        let arguments_ = [];
        let thisProgram = "./this.program";
        let quit_ = function(status, toThrow) {
          throw toThrow;
        };
        let ENVIRONMENT_IS_WEB = false;
        let ENVIRONMENT_IS_WORKER = false;
        let ENVIRONMENT_IS_NODE = false;
        let ENVIRONMENT_HAS_NODE = false;
        let ENVIRONMENT_IS_SHELL = false;
        ENVIRONMENT_IS_WEB = typeof window === "object";
        ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
        ENVIRONMENT_HAS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
        ENVIRONMENT_IS_NODE = ENVIRONMENT_HAS_NODE && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;
        ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
        if (Module2.ENVIRONMENT) {
          throw new Error(
            "Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)"
          );
        }
        let scriptDirectory = "";
        function locateFile(path) {
          if (Module2.locateFile) {
            return Module2.locateFile(path, scriptDirectory);
          }
          return scriptDirectory + path;
        }
        let read_;
        let readAsync;
        let readBinary;
        let setWindowTitle;
        if (ENVIRONMENT_IS_NODE) {
          scriptDirectory = `${__dirname}/`;
          let nodeFS;
          let nodePath;
          read_ = function shell_read(filename, binary) {
            let ret;
            if (!nodeFS) {
              nodeFS = __require(["fs"].join());
            }
            if (!nodePath) {
              nodePath = __require(["path"].join());
            }
            filename = nodePath.normalize(filename);
            ret = nodeFS.readFileSync(filename);
            return binary ? ret : ret.toString();
          };
          readBinary = function readBinary2(filename) {
            let ret = read_(filename, true);
            if (!ret.buffer) {
              ret = new Uint8Array(ret);
            }
            assert(ret.buffer);
            return ret;
          };
          if (process.argv.length > 1) {
            thisProgram = process.argv[1].replace(/\\/g, "/");
          }
          arguments_ = process.argv.slice(2);
          process.on("uncaughtException", (ex) => {
            if (!(ex instanceof ExitStatus)) {
              throw ex;
            }
          });
          process.on("unhandledRejection", abort);
          quit_ = function(status) {
            process.exit(status);
          };
          Module2.inspect = function() {
            return "[Emscripten Module object]";
          };
        } else if (ENVIRONMENT_IS_SHELL) {
          if (typeof read != "undefined") {
            read_ = function shell_read(f) {
              return read(f);
            };
          }
          readBinary = function readBinary2(f) {
            let data;
            if (typeof readbuffer === "function") {
              return new Uint8Array(readbuffer(f));
            }
            data = read(f, "binary");
            assert(typeof data === "object");
            return data;
          };
          if (typeof scriptArgs != "undefined") {
            arguments_ = scriptArgs;
          } else if (typeof arguments != "undefined") {
            arguments_ = arguments;
          }
          if (typeof quit === "function") {
            quit_ = function(status) {
              quit(status);
            };
          }
          if (typeof print !== "undefined") {
            if (typeof console === "undefined") {
              console = {};
            }
            console.log = print;
            console.warn = console.error = typeof printErr !== "undefined" ? printErr : print;
          }
        } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = self.location.href;
          } else if (document.currentScript) {
            scriptDirectory = document.currentScript.src;
          }
          if (_scriptDir) {
            scriptDirectory = _scriptDir;
          }
          if (scriptDirectory.indexOf("blob:") !== 0) {
            scriptDirectory = scriptDirectory.substr(
              0,
              scriptDirectory.lastIndexOf("/") + 1
            );
          } else {
            scriptDirectory = "";
          }
          read_ = function shell_read(url) {
            const xhr = new XMLHttpRequest();
            xhr.open("GET", url, false);
            xhr.send(null);
            return xhr.responseText;
          };
          if (ENVIRONMENT_IS_WORKER) {
            readBinary = function readBinary2(url) {
              const xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.responseType = "arraybuffer";
              xhr.send(null);
              return new Uint8Array(xhr.response);
            };
          }
          readAsync = function readAsync2(url, onload, onerror) {
            const xhr = new XMLHttpRequest();
            xhr.open("GET", url, true);
            xhr.responseType = "arraybuffer";
            xhr.onload = function xhr_onload() {
              if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                onload(xhr.response);
                return;
              }
              onerror();
            };
            xhr.onerror = onerror;
            xhr.send(null);
          };
          setWindowTitle = function(title) {
            document.title = title;
          };
        } else {
          throw new Error("environment detection error");
        }
        let out = Module2.print || function() {
        };
        let err = Module2.printErr || function() {
        };
        for (key in moduleOverrides) {
          if (moduleOverrides.hasOwnProperty(key)) {
            Module2[key] = moduleOverrides[key];
          }
        }
        moduleOverrides = null;
        if (Module2.arguments) {
          arguments_ = Module2.arguments;
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "arguments")) {
          Object.defineProperty(Module2, "arguments", {
            configurable: true,
            get() {
              abort("Module.arguments has been replaced with plain arguments_");
            }
          });
        }
        if (Module2.thisProgram) {
          thisProgram = Module2.thisProgram;
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "thisProgram")) {
          Object.defineProperty(Module2, "thisProgram", {
            configurable: true,
            get() {
              abort("Module.thisProgram has been replaced with plain thisProgram");
            }
          });
        }
        if (Module2.quit) {
          quit_ = Module2.quit;
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "quit")) {
          Object.defineProperty(Module2, "quit", {
            configurable: true,
            get() {
              abort("Module.quit has been replaced with plain quit_");
            }
          });
        }
        assert(
          typeof Module2.memoryInitializerPrefixURL === "undefined",
          "Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead"
        );
        assert(
          typeof Module2.pthreadMainPrefixURL === "undefined",
          "Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead"
        );
        assert(
          typeof Module2.cdInitializerPrefixURL === "undefined",
          "Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead"
        );
        assert(
          typeof Module2.filePackagePrefixURL === "undefined",
          "Module.filePackagePrefixURL option was removed, use Module.locateFile instead"
        );
        assert(
          typeof Module2.read === "undefined",
          "Module.read option was removed (modify read_ in JS)"
        );
        assert(
          typeof Module2.readAsync === "undefined",
          "Module.readAsync option was removed (modify readAsync in JS)"
        );
        assert(
          typeof Module2.readBinary === "undefined",
          "Module.readBinary option was removed (modify readBinary in JS)"
        );
        assert(
          typeof Module2.setWindowTitle === "undefined",
          "Module.setWindowTitle option was removed (modify setWindowTitle in JS)"
        );
        if (!Object.getOwnPropertyDescriptor(Module2, "read")) {
          Object.defineProperty(Module2, "read", {
            configurable: true,
            get() {
              abort("Module.read has been replaced with plain read_");
            }
          });
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "readAsync")) {
          Object.defineProperty(Module2, "readAsync", {
            configurable: true,
            get() {
              abort("Module.readAsync has been replaced with plain readAsync");
            }
          });
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "readBinary")) {
          Object.defineProperty(Module2, "readBinary", {
            configurable: true,
            get() {
              abort("Module.readBinary has been replaced with plain readBinary");
            }
          });
        }
        stackSave = stackRestore = stackAlloc = function() {
          abort(
            "cannot use the stack before compiled code is ready to run, and has provided stack access"
          );
        };
        function warnOnce(text) {
          if (!warnOnce.shown) {
            warnOnce.shown = {};
          }
          if (!warnOnce.shown[text]) {
            warnOnce.shown[text] = 1;
            err(text);
          }
        }
        const asm2wasmImports = {
          "f64-rem"(x, y) {
            return x % y;
          },
          debugger() {
            debugger;
          }
        };
        const functionPointers = new Array(0);
        let tempRet0 = 0;
        const setTempRet0 = function(value) {
          tempRet0 = value;
        };
        let wasmBinary;
        if (Module2.wasmBinary) {
          wasmBinary = Module2.wasmBinary;
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "wasmBinary")) {
          Object.defineProperty(Module2, "wasmBinary", {
            configurable: true,
            get() {
              abort("Module.wasmBinary has been replaced with plain wasmBinary");
            }
          });
        }
        let noExitRuntime;
        if (Module2.noExitRuntime) {
          noExitRuntime = Module2.noExitRuntime;
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "noExitRuntime")) {
          Object.defineProperty(Module2, "noExitRuntime", {
            configurable: true,
            get() {
              abort(
                "Module.noExitRuntime has been replaced with plain noExitRuntime"
              );
            }
          });
        }
        if (typeof WebAssembly !== "object") {
          abort(
            "No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead."
          );
        }
        let wasmMemory;
        const wasmTable = new WebAssembly.Table({
          initial: 352,
          maximum: 352,
          element: "anyfunc"
        });
        let ABORT = false;
        let EXITSTATUS = 0;
        function assert(condition, text) {
          if (!condition) {
            abort(`Assertion failed: ${text}`);
          }
        }
        function getCFunc(ident) {
          const func = Module2[`_${ident}`];
          assert(
            func,
            `Cannot call unknown function ${ident}, make sure it is exported`
          );
          return func;
        }
        function ccall(ident, returnType, argTypes, args, opts) {
          const toC = {
            string(str) {
              let ret2 = 0;
              if (str !== null && str !== void 0 && str !== 0) {
                const len = (str.length << 2) + 1;
                ret2 = stackAlloc(len);
                stringToUTF8(str, ret2, len);
              }
              return ret2;
            },
            array(arr) {
              const ret2 = stackAlloc(arr.length);
              writeArrayToMemory(arr, ret2);
              return ret2;
            }
          };
          function convertReturnValue(ret2) {
            if (returnType === "string") {
              return UTF8ToString(ret2);
            }
            if (returnType === "boolean") {
              return Boolean(ret2);
            }
            return ret2;
          }
          const func = getCFunc(ident);
          const cArgs = [];
          let stack = 0;
          assert(returnType !== "array", 'Return type should not be "array".');
          if (args) {
            for (let i = 0; i < args.length; i++) {
              const converter = toC[argTypes[i]];
              if (converter) {
                if (stack === 0) {
                  stack = stackSave();
                }
                cArgs[i] = converter(args[i]);
              } else {
                cArgs[i] = args[i];
              }
            }
          }
          let ret = func.apply(null, cArgs);
          ret = convertReturnValue(ret);
          if (stack !== 0) {
            stackRestore(stack);
          }
          return ret;
        }
        function cwrap(ident, returnType, argTypes, opts) {
          return function() {
            return ccall(ident, returnType, argTypes, arguments, opts);
          };
        }
        const UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
        function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {
          const endIdx = idx + maxBytesToRead;
          let endPtr = idx;
          while (u8Array[endPtr] && !(endPtr >= endIdx)) {
            ++endPtr;
          }
          if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
            return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));
          }
          let str = "";
          while (idx < endPtr) {
            let u0 = u8Array[idx++];
            if (!(u0 & 128)) {
              str += String.fromCharCode(u0);
              continue;
            }
            const u1 = u8Array[idx++] & 63;
            if ((u0 & 224) == 192) {
              str += String.fromCharCode((u0 & 31) << 6 | u1);
              continue;
            }
            const u2 = u8Array[idx++] & 63;
            if ((u0 & 240) == 224) {
              u0 = (u0 & 15) << 12 | u1 << 6 | u2;
            } else {
              if ((u0 & 248) != 240) {
                warnOnce(
                  `Invalid UTF-8 leading byte 0x${u0.toString(
                    16
                  )} encountered when deserializing a UTF-8 string on the asm.js/wasm heap to a JS string!`
                );
              }
              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u8Array[idx++] & 63;
            }
            if (u0 < 65536) {
              str += String.fromCharCode(u0);
            } else {
              const ch = u0 - 65536;
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            }
          }
          return str;
        }
        function UTF8ToString(ptr, maxBytesToRead) {
          return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
        }
        function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
          if (!(maxBytesToWrite > 0)) {
            return 0;
          }
          const startIdx = outIdx;
          const endIdx = outIdx + maxBytesToWrite - 1;
          for (let i = 0; i < str.length; ++i) {
            let u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343) {
              const u1 = str.charCodeAt(++i);
              u = 65536 + ((u & 1023) << 10) | u1 & 1023;
            }
            if (u <= 127) {
              if (outIdx >= endIdx) {
                break;
              }
              outU8Array[outIdx++] = u;
            } else if (u <= 2047) {
              if (outIdx + 1 >= endIdx) {
                break;
              }
              outU8Array[outIdx++] = 192 | u >> 6;
              outU8Array[outIdx++] = 128 | u & 63;
            } else if (u <= 65535) {
              if (outIdx + 2 >= endIdx) {
                break;
              }
              outU8Array[outIdx++] = 224 | u >> 12;
              outU8Array[outIdx++] = 128 | u >> 6 & 63;
              outU8Array[outIdx++] = 128 | u & 63;
            } else {
              if (outIdx + 3 >= endIdx) {
                break;
              }
              if (u >= 2097152) {
                warnOnce(
                  `Invalid Unicode code point 0x${u.toString(
                    16
                  )} encountered when serializing a JS string to an UTF-8 string on the asm.js/wasm heap! (Valid unicode code points should be in range 0-0x1FFFFF).`
                );
              }
              outU8Array[outIdx++] = 240 | u >> 18;
              outU8Array[outIdx++] = 128 | u >> 12 & 63;
              outU8Array[outIdx++] = 128 | u >> 6 & 63;
              outU8Array[outIdx++] = 128 | u & 63;
            }
          }
          outU8Array[outIdx] = 0;
          return outIdx - startIdx;
        }
        function stringToUTF8(str, outPtr, maxBytesToWrite) {
          assert(
            typeof maxBytesToWrite == "number",
            "stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!"
          );
          return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
        }
        function lengthBytesUTF8(str) {
          let len = 0;
          for (let i = 0; i < str.length; ++i) {
            let u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343) {
              u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
            }
            if (u <= 127) {
              ++len;
            } else if (u <= 2047) {
              len += 2;
            } else if (u <= 65535) {
              len += 3;
            } else {
              len += 4;
            }
          }
          return len;
        }
        const UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : void 0;
        function writeArrayToMemory(array, buffer2) {
          assert(
            array.length >= 0,
            "writeArrayToMemory array must have a length (should be an array or typed array)"
          );
          HEAP8.set(array, buffer2);
        }
        const WASM_PAGE_SIZE = 65536;
        function alignUp(x, multiple) {
          if (x % multiple > 0) {
            x += multiple - x % multiple;
          }
          return x;
        }
        let buffer;
        let HEAP8;
        let HEAPU8;
        let HEAP16;
        let HEAPU16;
        let HEAP32;
        let HEAPU32;
        let HEAPF32;
        let HEAPF64;
        function updateGlobalBufferAndViews(buf) {
          buffer = buf;
          Module2.HEAP8 = HEAP8 = new Int8Array(buf);
          Module2.HEAP16 = HEAP16 = new Int16Array(buf);
          Module2.HEAP32 = HEAP32 = new Int32Array(buf);
          Module2.HEAPU8 = HEAPU8 = new Uint8Array(buf);
          Module2.HEAPU16 = HEAPU16 = new Uint16Array(buf);
          Module2.HEAPU32 = HEAPU32 = new Uint32Array(buf);
          Module2.HEAPF32 = HEAPF32 = new Float32Array(buf);
          Module2.HEAPF64 = HEAPF64 = new Float64Array(buf);
        }
        const STACK_BASE = 434112;
        const STACK_MAX = 5676992;
        const DYNAMIC_BASE = 5676992;
        const DYNAMICTOP_PTR = 433920;
        assert(STACK_BASE % 16 === 0, "stack must start aligned");
        assert(DYNAMIC_BASE % 16 === 0, "heap must start aligned");
        const TOTAL_STACK = 5242880;
        if (Module2.TOTAL_STACK) {
          assert(
            TOTAL_STACK === Module2.TOTAL_STACK,
            "the stack size can no longer be determined at runtime"
          );
        }
        let INITIAL_TOTAL_MEMORY = Module2.TOTAL_MEMORY || 16777216;
        if (!Object.getOwnPropertyDescriptor(Module2, "TOTAL_MEMORY")) {
          Object.defineProperty(Module2, "TOTAL_MEMORY", {
            configurable: true,
            get() {
              abort(
                "Module.TOTAL_MEMORY has been replaced with plain INITIAL_TOTAL_MEMORY"
              );
            }
          });
        }
        assert(
          INITIAL_TOTAL_MEMORY >= TOTAL_STACK,
          `TOTAL_MEMORY should be larger than TOTAL_STACK, was ${INITIAL_TOTAL_MEMORY}! (TOTAL_STACK=${TOTAL_STACK})`
        );
        assert(
          typeof Int32Array !== "undefined" && typeof Float64Array !== "undefined" && Int32Array.prototype.subarray !== void 0 && Int32Array.prototype.set !== void 0,
          "JS engine does not provide full typed array support"
        );
        if (Module2.wasmMemory) {
          wasmMemory = Module2.wasmMemory;
        } else {
          wasmMemory = new WebAssembly.Memory({
            initial: INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE
          });
        }
        if (wasmMemory) {
          buffer = wasmMemory.buffer;
        }
        INITIAL_TOTAL_MEMORY = buffer.byteLength;
        assert(INITIAL_TOTAL_MEMORY % WASM_PAGE_SIZE === 0);
        updateGlobalBufferAndViews(buffer);
        HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
        function writeStackCookie() {
          assert((STACK_MAX & 3) == 0);
          HEAPU32[(STACK_MAX >> 2) - 1] = 34821223;
          HEAPU32[(STACK_MAX >> 2) - 2] = 2310721022;
          HEAP32[0] = 1668509029;
        }
        function checkStackCookie() {
          const cookie1 = HEAPU32[(STACK_MAX >> 2) - 1];
          const cookie2 = HEAPU32[(STACK_MAX >> 2) - 2];
          if (cookie1 != 34821223 || cookie2 != 2310721022) {
            abort(
              `Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x${cookie2.toString(
                16
              )} ${cookie1.toString(16)}`
            );
          }
          if (HEAP32[0] !== 1668509029) {
            abort(
              "Runtime error: The application has corrupted its heap memory area (address zero)!"
            );
          }
        }
        function abortStackOverflow(allocSize) {
          abort(
            `Stack overflow! Attempted to allocate ${allocSize} bytes on the stack, but stack has only ${STACK_MAX - stackSave() + allocSize} bytes available!`
          );
        }
        (function() {
          const h16 = new Int16Array(1);
          const h8 = new Int8Array(h16.buffer);
          h16[0] = 25459;
          if (h8[0] !== 115 || h8[1] !== 99) {
            throw "Runtime error: expected the system to be little-endian!";
          }
        })();
        function abortFnPtrError(ptr, sig) {
          abort(
            `Invalid function pointer ${ptr} called with signature '${sig}'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this). Build with ASSERTIONS=2 for more info.`
          );
        }
        function callRuntimeCallbacks(callbacks) {
          while (callbacks.length > 0) {
            const callback = callbacks.shift();
            if (typeof callback == "function") {
              callback();
              continue;
            }
            const func = callback.func;
            if (typeof func === "number") {
              if (callback.arg === void 0) {
                Module2.dynCall_v(func);
              } else {
                Module2.dynCall_vi(func, callback.arg);
              }
            } else {
              func(callback.arg === void 0 ? null : callback.arg);
            }
          }
        }
        const __ATPRERUN__ = [];
        const __ATINIT__ = [];
        const __ATMAIN__ = [];
        const __ATPOSTRUN__ = [];
        let runtimeInitialized = false;
        let runtimeExited = false;
        function preRun() {
          if (Module2.preRun) {
            if (typeof Module2.preRun == "function") {
              Module2.preRun = [Module2.preRun];
            }
            while (Module2.preRun.length) {
              addOnPreRun(Module2.preRun.shift());
            }
          }
          callRuntimeCallbacks(__ATPRERUN__);
        }
        function initRuntime() {
          checkStackCookie();
          assert(!runtimeInitialized);
          runtimeInitialized = true;
          callRuntimeCallbacks(__ATINIT__);
        }
        function preMain() {
          checkStackCookie();
          callRuntimeCallbacks(__ATMAIN__);
        }
        function exitRuntime() {
          checkStackCookie();
          runtimeExited = true;
        }
        function postRun() {
          checkStackCookie();
          if (Module2.postRun) {
            if (typeof Module2.postRun == "function") {
              Module2.postRun = [Module2.postRun];
            }
            while (Module2.postRun.length) {
              addOnPostRun(Module2.postRun.shift());
            }
          }
          callRuntimeCallbacks(__ATPOSTRUN__);
        }
        function addOnPreRun(cb) {
          __ATPRERUN__.unshift(cb);
        }
        function addOnPostRun(cb) {
          __ATPOSTRUN__.unshift(cb);
        }
        assert(
          Math.imul,
          "This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"
        );
        assert(
          Math.fround,
          "This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"
        );
        assert(
          Math.clz32,
          "This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"
        );
        assert(
          Math.trunc,
          "This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"
        );
        let runDependencies = 0;
        let runDependencyWatcher = null;
        let dependenciesFulfilled = null;
        const runDependencyTracking = {};
        function addRunDependency(id) {
          runDependencies++;
          if (Module2.monitorRunDependencies) {
            Module2.monitorRunDependencies(runDependencies);
          }
          if (id) {
            assert(!runDependencyTracking[id]);
            runDependencyTracking[id] = 1;
            if (runDependencyWatcher === null && typeof setInterval !== "undefined") {
              runDependencyWatcher = setInterval(() => {
                if (ABORT) {
                  clearInterval(runDependencyWatcher);
                  runDependencyWatcher = null;
                  return;
                }
                let shown = false;
                for (const dep in runDependencyTracking) {
                  if (!shown) {
                    shown = true;
                    err("still waiting on run dependencies:");
                  }
                  err(`dependency: ${dep}`);
                }
                if (shown) {
                  err("(end of list)");
                }
              }, 1e4);
            }
          } else {
            err("warning: run dependency added without ID");
          }
        }
        function removeRunDependency(id) {
          runDependencies--;
          if (Module2.monitorRunDependencies) {
            Module2.monitorRunDependencies(runDependencies);
          }
          if (id) {
            assert(runDependencyTracking[id]);
            delete runDependencyTracking[id];
          } else {
            err("warning: run dependency removed without ID");
          }
          if (runDependencies == 0) {
            if (runDependencyWatcher !== null) {
              clearInterval(runDependencyWatcher);
              runDependencyWatcher = null;
            }
            if (dependenciesFulfilled) {
              const callback = dependenciesFulfilled;
              dependenciesFulfilled = null;
              callback();
            }
          }
        }
        Module2.preloadedImages = {};
        Module2.preloadedAudios = {};
        function abort(what) {
          if (Module2.onAbort) {
            Module2.onAbort(what);
          }
          what += "";
          out(what);
          err(what);
          ABORT = true;
          EXITSTATUS = 1;
          const extra = "";
          const output = `abort(${what}) at ${stackTrace()}${extra}`;
          throw output;
        }
        var FS = {
          error() {
            abort(
              "Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1"
            );
          },
          init() {
            FS.error();
          },
          createDataFile() {
            FS.error();
          },
          createPreloadedFile() {
            FS.error();
          },
          createLazyFile() {
            FS.error();
          },
          open() {
            FS.error();
          },
          mkdev() {
            FS.error();
          },
          registerDevice() {
            FS.error();
          },
          analyzePath() {
            FS.error();
          },
          loadFilesFromDB() {
            FS.error();
          },
          ErrnoError: function ErrnoError() {
            FS.error();
          }
        };
        Module2.FS_createDataFile = FS.createDataFile;
        Module2.FS_createPreloadedFile = FS.createPreloadedFile;
        const dataURIPrefix = "data:application/octet-stream;base64,";
        function isDataURI(filename) {
          return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;
        }
        let wasmBinaryFile = "woff2.wasm";
        if (!isDataURI(wasmBinaryFile)) {
          wasmBinaryFile = locateFile(wasmBinaryFile);
        }
        function getBinary() {
          try {
            if (wasmBinary) {
              return new Uint8Array(wasmBinary);
            }
            if (readBinary) {
              return readBinary(wasmBinaryFile);
            }
            throw "both async and sync fetching of the wasm failed";
          } catch (err2) {
            abort(err2);
          }
        }
        function getBinaryPromise() {
          if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === "function") {
            return fetch(wasmBinaryFile, { credentials: "same-origin" }).then((response) => {
              if (!response.ok) {
                throw `failed to load wasm binary file at '${wasmBinaryFile}'`;
              }
              return response.arrayBuffer();
            }).catch(() => {
              return getBinary();
            });
          }
          return new Promise((resolve, reject) => {
            resolve(getBinary());
          });
        }
        function createWasm() {
          const info = {
            env: asmLibraryArg,
            wasi_unstable: asmLibraryArg,
            global: { NaN: NaN, Infinity: Infinity },
            "global.Math": Math,
            asm2wasm: asm2wasmImports
          };
          function receiveInstance(instance, module) {
            const exports = instance.exports;
            Module2.asm = exports;
            removeRunDependency("wasm-instantiate");
          }
          addRunDependency("wasm-instantiate");
          let trueModule = Module2;
          function receiveInstantiatedSource(output) {
            assert(
              Module2 === trueModule,
              "the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?"
            );
            trueModule = null;
            receiveInstance(output.instance);
          }
          function instantiateArrayBuffer(receiver) {
            return getBinaryPromise().then((binary) => {
              return WebAssembly.instantiate(binary, info);
            }).then(receiver, (reason) => {
              err(`failed to asynchronously prepare wasm: ${reason}`);
              abort(reason);
            });
          }
          function instantiateAsync() {
            if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && typeof fetch === "function" && typeof process === "object" && process.versions && process.versions.node && +process.versions.node.split(".")[0] < 17) {
              fetch(wasmBinaryFile, { credentials: "same-origin" }).then(
                (response) => {
                  const result = WebAssembly.instantiateStreaming(response, info);
                  return result.then(receiveInstantiatedSource, (reason) => {
                    err(`wasm streaming compile failed: ${reason}`);
                    err("falling back to ArrayBuffer instantiation");
                    instantiateArrayBuffer(receiveInstantiatedSource);
                  });
                }
              );
            } else {
              return instantiateArrayBuffer(receiveInstantiatedSource);
            }
          }
          if (Module2.instantiateWasm) {
            try {
              const exports = Module2.instantiateWasm(info, receiveInstance);
              return exports;
            } catch (e) {
              err(`Module.instantiateWasm callback failed with error: ${e}`);
              return false;
            }
          }
          instantiateAsync();
          return {};
        }
        Module2.asm = createWasm;
        __ATINIT__.push({
          func() {
            globalCtors();
          }
        });
        const tempDoublePtr = 434096;
        assert(tempDoublePtr % 8 == 0);
        function demangle(func) {
          const __cxa_demangle_func = Module2.___cxa_demangle || Module2.__cxa_demangle;
          assert(__cxa_demangle_func);
          try {
            let s = func;
            if (s.startsWith("__Z")) {
              s = s.substr(1);
            }
            const len = lengthBytesUTF8(s) + 1;
            var buf = _malloc(len);
            stringToUTF8(s, buf, len);
            var status = _malloc(4);
            var ret = __cxa_demangle_func(buf, 0, 0, status);
            if (HEAP32[status >> 2] === 0 && ret) {
              return UTF8ToString(ret);
            }
          } catch (e) {
          } finally {
            if (buf) {
              _free(buf);
            }
            if (status) {
              _free(status);
            }
            if (ret) {
              _free(ret);
            }
          }
          return func;
        }
        function demangleAll(text) {
          const regex = /\b__Z[\w\d_]+/g;
          return text.replace(regex, (x) => {
            const y = demangle(x);
            return x === y ? x : `${y} [${x}]`;
          });
        }
        function jsStackTrace() {
          let err2 = new Error();
          if (!err2.stack) {
            try {
              throw new Error(0);
            } catch (e) {
              err2 = e;
            }
            if (!err2.stack) {
              return "(no stack trace available)";
            }
          }
          return err2.stack.toString();
        }
        function stackTrace() {
          let js = jsStackTrace();
          if (Module2.extraStackTrace) {
            js += `
${Module2.extraStackTrace()}`;
          }
          return demangleAll(js);
        }
        function ___assert_fail(condition, filename, line, func) {
          abort(
            `Assertion failed: ${UTF8ToString(condition)}, at: ${[
              filename ? UTF8ToString(filename) : "unknown filename",
              line,
              func ? UTF8ToString(func) : "unknown function"
            ]}`
          );
        }
        function ___cxa_allocate_exception(size) {
          return _malloc(size);
        }
        const ___exception_infos = {};
        let ___exception_last = 0;
        function ___cxa_throw(ptr, type, destructor) {
          ___exception_infos[ptr] = {
            ptr,
            adjusted: [ptr],
            type,
            destructor,
            refcount: 0,
            caught: false,
            rethrown: false
          };
          ___exception_last = ptr;
          if (!("uncaught_exception" in __ZSt18uncaught_exceptionv)) {
            __ZSt18uncaught_exceptionv.uncaught_exceptions = 1;
          } else {
            __ZSt18uncaught_exceptionv.uncaught_exceptions++;
          }
          throw `${ptr} - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.`;
        }
        function ___lock() {
        }
        function ___unlock() {
        }
        var PATH = {
          splitPath(filename) {
            const splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
            return splitPathRe.exec(filename).slice(1);
          },
          normalizeArray(parts, allowAboveRoot) {
            let up = 0;
            for (let i = parts.length - 1; i >= 0; i--) {
              const last = parts[i];
              if (last === ".") {
                parts.splice(i, 1);
              } else if (last === "..") {
                parts.splice(i, 1);
                up++;
              } else if (up) {
                parts.splice(i, 1);
                up--;
              }
            }
            if (allowAboveRoot) {
              for (; up; up--) {
                parts.unshift("..");
              }
            }
            return parts;
          },
          normalize(path) {
            const isAbsolute = path.charAt(0) === "/";
            const trailingSlash = path.substr(-1) === "/";
            path = PATH.normalizeArray(
              path.split("/").filter((p) => {
                return !!p;
              }),
              !isAbsolute
            ).join("/");
            if (!path && !isAbsolute) {
              path = ".";
            }
            if (path && trailingSlash) {
              path += "/";
            }
            return (isAbsolute ? "/" : "") + path;
          },
          dirname(path) {
            const result = PATH.splitPath(path);
            const root = result[0];
            let dir = result[1];
            if (!root && !dir) {
              return ".";
            }
            if (dir) {
              dir = dir.substr(0, dir.length - 1);
            }
            return root + dir;
          },
          basename(path) {
            if (path === "/") {
              return "/";
            }
            const lastSlash = path.lastIndexOf("/");
            if (lastSlash === -1) {
              return path;
            }
            return path.substr(lastSlash + 1);
          },
          extname(path) {
            return PATH.splitPath(path)[3];
          },
          join() {
            const paths = Array.prototype.slice.call(arguments, 0);
            return PATH.normalize(paths.join("/"));
          },
          join2(l, r) {
            return PATH.normalize(`${l}/${r}`);
          }
        };
        var SYSCALLS = {
          buffers: [null, [], []],
          printChar(stream, curr) {
            const buffer2 = SYSCALLS.buffers[stream];
            assert(buffer2);
            if (curr === 0 || curr === 10) {
              (stream === 1 ? out : err)(UTF8ArrayToString(buffer2, 0));
              buffer2.length = 0;
            } else {
              buffer2.push(curr);
            }
          },
          varargs: 0,
          get(varargs) {
            SYSCALLS.varargs += 4;
            const ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
            return ret;
          },
          getStr() {
            const ret = UTF8ToString(SYSCALLS.get());
            return ret;
          },
          get64() {
            const low = SYSCALLS.get();
            const high = SYSCALLS.get();
            if (low >= 0) {
              assert(high === 0);
            } else {
              assert(high === -1);
            }
            return low;
          },
          getZero() {
            assert(SYSCALLS.get() === 0);
          }
        };
        function _fd_close(fd) {
          try {
            abort(
              "it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM"
            );
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) {
              abort(e);
            }
            return e.errno;
          }
        }
        function ___wasi_fd_close() {
          return _fd_close.apply(null, arguments);
        }
        function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
          try {
            abort(
              "it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM"
            );
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) {
              abort(e);
            }
            return e.errno;
          }
        }
        function ___wasi_fd_seek() {
          return _fd_seek.apply(null, arguments);
        }
        function flush_NO_FILESYSTEM() {
          const fflush = Module2._fflush;
          if (fflush) {
            fflush(0);
          }
          const buffers = SYSCALLS.buffers;
          if (buffers[1].length) {
            SYSCALLS.printChar(1, 10);
          }
          if (buffers[2].length) {
            SYSCALLS.printChar(2, 10);
          }
        }
        function _fd_write(fd, iov, iovcnt, pnum) {
          try {
            let num = 0;
            for (let i = 0; i < iovcnt; i++) {
              const ptr = HEAP32[iov + i * 8 >> 2];
              const len = HEAP32[iov + (i * 8 + 4) >> 2];
              for (let j = 0; j < len; j++) {
                SYSCALLS.printChar(fd, HEAPU8[ptr + j]);
              }
              num += len;
            }
            HEAP32[pnum >> 2] = num;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) {
              abort(e);
            }
            return e.errno;
          }
        }
        function ___wasi_fd_write() {
          return _fd_write.apply(null, arguments);
        }
        function getShiftFromSize(size) {
          switch (size) {
            case 1:
              return 0;
            case 2:
              return 1;
            case 4:
              return 2;
            case 8:
              return 3;
            default:
              throw new TypeError(`Unknown type size: ${size}`);
          }
        }
        function embind_init_charCodes() {
          const codes = new Array(256);
          for (let i = 0; i < 256; ++i) {
            codes[i] = String.fromCharCode(i);
          }
          embind_charCodes = codes;
        }
        var embind_charCodes = void 0;
        function readLatin1String(ptr) {
          let ret = "";
          let c = ptr;
          while (HEAPU8[c]) {
            ret += embind_charCodes[HEAPU8[c++]];
          }
          return ret;
        }
        const awaitingDependencies = {};
        const registeredTypes = {};
        const typeDependencies = {};
        const char_0 = 48;
        const char_9 = 57;
        function makeLegalFunctionName(name) {
          if (void 0 === name) {
            return "_unknown";
          }
          name = name.replace(/[^a-zA-Z0-9_]/g, "$");
          const f = name.charCodeAt(0);
          if (f >= char_0 && f <= char_9) {
            return `_${name}`;
          }
          return name;
        }
        function createNamedFunction(name, body) {
          name = makeLegalFunctionName(name);
          return new Function(
            "body",
            `return function ${name}() {
    "use strict";    return body.apply(this, arguments);
};
`
          )(body);
        }
        function extendError(baseErrorType, errorName) {
          const errorClass = createNamedFunction(errorName, function(message) {
            this.name = errorName;
            this.message = message;
            const stack = new Error(message).stack;
            if (stack !== void 0) {
              this.stack = `${this.toString()}
${stack.replace(
                /^Error(:[^\n]*)?\n/,
                ""
              )}`;
            }
          });
          errorClass.prototype = Object.create(baseErrorType.prototype);
          errorClass.prototype.constructor = errorClass;
          errorClass.prototype.toString = function() {
            if (this.message === void 0) {
              return this.name;
            }
            return `${this.name}: ${this.message}`;
          };
          return errorClass;
        }
        let BindingError = void 0;
        function throwBindingError(message) {
          throw new BindingError(message);
        }
        let InternalError = void 0;
        function throwInternalError(message) {
          throw new InternalError(message);
        }
        function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
          myTypes.forEach((type) => {
            typeDependencies[type] = dependentTypes;
          });
          function onComplete(typeConverters2) {
            const myTypeConverters = getTypeConverters(typeConverters2);
            if (myTypeConverters.length !== myTypes.length) {
              throwInternalError("Mismatched type converter count");
            }
            for (let i = 0; i < myTypes.length; ++i) {
              registerType(myTypes[i], myTypeConverters[i]);
            }
          }
          const typeConverters = new Array(dependentTypes.length);
          const unregisteredTypes = [];
          let registered = 0;
          dependentTypes.forEach((dt, i) => {
            if (registeredTypes.hasOwnProperty(dt)) {
              typeConverters[i] = registeredTypes[dt];
            } else {
              unregisteredTypes.push(dt);
              if (!awaitingDependencies.hasOwnProperty(dt)) {
                awaitingDependencies[dt] = [];
              }
              awaitingDependencies[dt].push(() => {
                typeConverters[i] = registeredTypes[dt];
                ++registered;
                if (registered === unregisteredTypes.length) {
                  onComplete(typeConverters);
                }
              });
            }
          });
          if (0 === unregisteredTypes.length) {
            onComplete(typeConverters);
          }
        }
        function registerType(rawType, registeredInstance, options) {
          options = options || {};
          if (!("argPackAdvance" in registeredInstance)) {
            throw new TypeError(
              "registerType registeredInstance requires argPackAdvance"
            );
          }
          const name = registeredInstance.name;
          if (!rawType) {
            throwBindingError(
              `type "${name}" must have a positive integer typeid pointer`
            );
          }
          if (registeredTypes.hasOwnProperty(rawType)) {
            if (options.ignoreDuplicateRegistrations) {
              return;
            }
            throwBindingError(`Cannot register type '${name}' twice`);
          }
          registeredTypes[rawType] = registeredInstance;
          delete typeDependencies[rawType];
          if (awaitingDependencies.hasOwnProperty(rawType)) {
            const callbacks = awaitingDependencies[rawType];
            delete awaitingDependencies[rawType];
            callbacks.forEach((cb) => {
              cb();
            });
          }
        }
        function __embind_register_bool(rawType, name, size, trueValue, falseValue) {
          const shift = getShiftFromSize(size);
          name = readLatin1String(name);
          registerType(rawType, {
            name,
            fromWireType(wt) {
              return !!wt;
            },
            toWireType(destructors, o) {
              return o ? trueValue : falseValue;
            },
            argPackAdvance: 8,
            readValueFromPointer(pointer) {
              let heap;
              if (size === 1) {
                heap = HEAP8;
              } else if (size === 2) {
                heap = HEAP16;
              } else if (size === 4) {
                heap = HEAP32;
              } else {
                throw new TypeError(`Unknown boolean type size: ${name}`);
              }
              return this.fromWireType(heap[pointer >> shift]);
            },
            destructorFunction: null
          });
        }
        function ClassHandle_isAliasOf(other) {
          if (!(this instanceof ClassHandle)) {
            return false;
          }
          if (!(other instanceof ClassHandle)) {
            return false;
          }
          let leftClass = this.$$.ptrType.registeredClass;
          let left = this.$$.ptr;
          let rightClass = other.$$.ptrType.registeredClass;
          let right = other.$$.ptr;
          while (leftClass.baseClass) {
            left = leftClass.upcast(left);
            leftClass = leftClass.baseClass;
          }
          while (rightClass.baseClass) {
            right = rightClass.upcast(right);
            rightClass = rightClass.baseClass;
          }
          return leftClass === rightClass && left === right;
        }
        function shallowCopyInternalPointer(o) {
          return {
            count: o.count,
            deleteScheduled: o.deleteScheduled,
            preservePointerOnDelete: o.preservePointerOnDelete,
            ptr: o.ptr,
            ptrType: o.ptrType,
            smartPtr: o.smartPtr,
            smartPtrType: o.smartPtrType
          };
        }
        function throwInstanceAlreadyDeleted(obj) {
          function getInstanceTypeName(handle) {
            return handle.$$.ptrType.registeredClass.name;
          }
          throwBindingError(`${getInstanceTypeName(obj)} instance already deleted`);
        }
        let finalizationGroup = false;
        function detachFinalizer(handle) {
        }
        function runDestructor($$) {
          if ($$.smartPtr) {
            $$.smartPtrType.rawDestructor($$.smartPtr);
          } else {
            $$.ptrType.registeredClass.rawDestructor($$.ptr);
          }
        }
        function releaseClassHandle($$) {
          $$.count.value -= 1;
          const toDelete = 0 === $$.count.value;
          if (toDelete) {
            runDestructor($$);
          }
        }
        function attachFinalizer(handle) {
          if ("undefined" === typeof FinalizationGroup) {
            attachFinalizer = function(handle2) {
              return handle2;
            };
            return handle;
          }
          finalizationGroup = new FinalizationGroup((iter) => {
            for (let result = iter.next(); !result.done; result = iter.next()) {
              const $$ = result.value;
              if (!$$.ptr) {
                console.warn(`object already deleted: ${$$.ptr}`);
              } else {
                releaseClassHandle($$);
              }
            }
          });
          attachFinalizer = function(handle2) {
            finalizationGroup.register(handle2, handle2.$$, handle2.$$);
            return handle2;
          };
          detachFinalizer = function(handle2) {
            finalizationGroup.unregister(handle2.$$);
          };
          return attachFinalizer(handle);
        }
        function ClassHandle_clone() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.preservePointerOnDelete) {
            this.$$.count.value += 1;
            return this;
          }
          const clone2 = attachFinalizer(
            Object.create(Object.getPrototypeOf(this), {
              $$: { value: shallowCopyInternalPointer(this.$$) }
            })
          );
          clone2.$$.count.value += 1;
          clone2.$$.deleteScheduled = false;
          return clone2;
        }
        function ClassHandle_delete() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
            throwBindingError("Object already scheduled for deletion");
          }
          detachFinalizer(this);
          releaseClassHandle(this.$$);
          if (!this.$$.preservePointerOnDelete) {
            this.$$.smartPtr = void 0;
            this.$$.ptr = void 0;
          }
        }
        function ClassHandle_isDeleted() {
          return !this.$$.ptr;
        }
        let delayFunction = void 0;
        const deletionQueue = [];
        function flushPendingDeletes() {
          while (deletionQueue.length) {
            const obj = deletionQueue.pop();
            obj.$$.deleteScheduled = false;
            obj.delete();
          }
        }
        function ClassHandle_deleteLater() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
            throwBindingError("Object already scheduled for deletion");
          }
          deletionQueue.push(this);
          if (deletionQueue.length === 1 && delayFunction) {
            delayFunction(flushPendingDeletes);
          }
          this.$$.deleteScheduled = true;
          return this;
        }
        function init_ClassHandle() {
          ClassHandle.prototype.isAliasOf = ClassHandle_isAliasOf;
          ClassHandle.prototype.clone = ClassHandle_clone;
          ClassHandle.prototype.delete = ClassHandle_delete;
          ClassHandle.prototype.isDeleted = ClassHandle_isDeleted;
          ClassHandle.prototype.deleteLater = ClassHandle_deleteLater;
        }
        function ClassHandle() {
        }
        const registeredPointers = {};
        function ensureOverloadTable(proto, methodName, humanName) {
          if (void 0 === proto[methodName].overloadTable) {
            const prevFunc = proto[methodName];
            proto[methodName] = function() {
              if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                throwBindingError(
                  `Function '${humanName}' called with an invalid number of arguments (${arguments.length}) - expects one of (${proto[methodName].overloadTable})!`
                );
              }
              return proto[methodName].overloadTable[arguments.length].apply(
                this,
                arguments
              );
            };
            proto[methodName].overloadTable = [];
            proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
          }
        }
        function exposePublicSymbol(name, value, numArguments) {
          if (Module2.hasOwnProperty(name)) {
            if (void 0 === numArguments || void 0 !== Module2[name].overloadTable && void 0 !== Module2[name].overloadTable[numArguments]) {
              throwBindingError(`Cannot register public name '${name}' twice`);
            }
            ensureOverloadTable(Module2, name, name);
            if (Module2.hasOwnProperty(numArguments)) {
              throwBindingError(
                `Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`
              );
            }
            Module2[name].overloadTable[numArguments] = value;
          } else {
            Module2[name] = value;
            if (void 0 !== numArguments) {
              Module2[name].numArguments = numArguments;
            }
          }
        }
        function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
          this.name = name;
          this.constructor = constructor;
          this.instancePrototype = instancePrototype;
          this.rawDestructor = rawDestructor;
          this.baseClass = baseClass;
          this.getActualType = getActualType;
          this.upcast = upcast;
          this.downcast = downcast;
          this.pureVirtualFunctions = [];
        }
        function upcastPointer(ptr, ptrClass, desiredClass) {
          while (ptrClass !== desiredClass) {
            if (!ptrClass.upcast) {
              throwBindingError(
                `Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`
              );
            }
            ptr = ptrClass.upcast(ptr);
            ptrClass = ptrClass.baseClass;
          }
          return ptr;
        }
        function constNoSmartPtrRawPointerToWireType(destructors, handle) {
          if (handle === null) {
            if (this.isReference) {
              throwBindingError(`null is not a valid ${this.name}`);
            }
            return 0;
          }
          if (!handle.$$) {
            throwBindingError(
              `Cannot pass "${_embind_repr(handle)}" as a ${this.name}`
            );
          }
          if (!handle.$$.ptr) {
            throwBindingError(
              `Cannot pass deleted object as a pointer of type ${this.name}`
            );
          }
          const handleClass = handle.$$.ptrType.registeredClass;
          const ptr = upcastPointer(
            handle.$$.ptr,
            handleClass,
            this.registeredClass
          );
          return ptr;
        }
        function genericPointerToWireType(destructors, handle) {
          let ptr;
          if (handle === null) {
            if (this.isReference) {
              throwBindingError(`null is not a valid ${this.name}`);
            }
            if (this.isSmartPointer) {
              ptr = this.rawConstructor();
              if (destructors !== null) {
                destructors.push(this.rawDestructor, ptr);
              }
              return ptr;
            }
            return 0;
          }
          if (!handle.$$) {
            throwBindingError(
              `Cannot pass "${_embind_repr(handle)}" as a ${this.name}`
            );
          }
          if (!handle.$$.ptr) {
            throwBindingError(
              `Cannot pass deleted object as a pointer of type ${this.name}`
            );
          }
          if (!this.isConst && handle.$$.ptrType.isConst) {
            throwBindingError(
              `Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`
            );
          }
          const handleClass = handle.$$.ptrType.registeredClass;
          ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          if (this.isSmartPointer) {
            if (void 0 === handle.$$.smartPtr) {
              throwBindingError("Passing raw pointer to smart pointer is illegal");
            }
            switch (this.sharingPolicy) {
              case 0:
                if (handle.$$.smartPtrType === this) {
                  ptr = handle.$$.smartPtr;
                } else {
                  throwBindingError(
                    `Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`
                  );
                }
                break;
              case 1:
                ptr = handle.$$.smartPtr;
                break;
              case 2:
                if (handle.$$.smartPtrType === this) {
                  ptr = handle.$$.smartPtr;
                } else {
                  const clonedHandle = handle.clone();
                  ptr = this.rawShare(
                    ptr,
                    __emval_register(() => {
                      clonedHandle.delete();
                    })
                  );
                  if (destructors !== null) {
                    destructors.push(this.rawDestructor, ptr);
                  }
                }
                break;
              default:
                throwBindingError("Unsupporting sharing policy");
            }
          }
          return ptr;
        }
        function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
          if (handle === null) {
            if (this.isReference) {
              throwBindingError(`null is not a valid ${this.name}`);
            }
            return 0;
          }
          if (!handle.$$) {
            throwBindingError(
              `Cannot pass "${_embind_repr(handle)}" as a ${this.name}`
            );
          }
          if (!handle.$$.ptr) {
            throwBindingError(
              `Cannot pass deleted object as a pointer of type ${this.name}`
            );
          }
          if (handle.$$.ptrType.isConst) {
            throwBindingError(
              `Cannot convert argument of type ${handle.$$.ptrType.name} to parameter type ${this.name}`
            );
          }
          const handleClass = handle.$$.ptrType.registeredClass;
          const ptr = upcastPointer(
            handle.$$.ptr,
            handleClass,
            this.registeredClass
          );
          return ptr;
        }
        function simpleReadValueFromPointer(pointer) {
          return this.fromWireType(HEAPU32[pointer >> 2]);
        }
        function RegisteredPointer_getPointee(ptr) {
          if (this.rawGetPointee) {
            ptr = this.rawGetPointee(ptr);
          }
          return ptr;
        }
        function RegisteredPointer_destructor(ptr) {
          if (this.rawDestructor) {
            this.rawDestructor(ptr);
          }
        }
        function RegisteredPointer_deleteObject(handle) {
          if (handle !== null) {
            handle.delete();
          }
        }
        function downcastPointer(ptr, ptrClass, desiredClass) {
          if (ptrClass === desiredClass) {
            return ptr;
          }
          if (void 0 === desiredClass.baseClass) {
            return null;
          }
          const rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
          if (rv === null) {
            return null;
          }
          return desiredClass.downcast(rv);
        }
        function getInheritedInstanceCount() {
          return Object.keys(registeredInstances).length;
        }
        function getLiveInheritedInstances() {
          const rv = [];
          for (const k in registeredInstances) {
            if (registeredInstances.hasOwnProperty(k)) {
              rv.push(registeredInstances[k]);
            }
          }
          return rv;
        }
        function setDelayFunction(fn) {
          delayFunction = fn;
          if (deletionQueue.length && delayFunction) {
            delayFunction(flushPendingDeletes);
          }
        }
        function init_embind() {
          Module2.getInheritedInstanceCount = getInheritedInstanceCount;
          Module2.getLiveInheritedInstances = getLiveInheritedInstances;
          Module2.flushPendingDeletes = flushPendingDeletes;
          Module2.setDelayFunction = setDelayFunction;
        }
        var registeredInstances = {};
        function getBasestPointer(class_, ptr) {
          if (ptr === void 0) {
            throwBindingError("ptr should not be undefined");
          }
          while (class_.baseClass) {
            ptr = class_.upcast(ptr);
            class_ = class_.baseClass;
          }
          return ptr;
        }
        function getInheritedInstance(class_, ptr) {
          ptr = getBasestPointer(class_, ptr);
          return registeredInstances[ptr];
        }
        function makeClassHandle(prototype, record) {
          if (!record.ptrType || !record.ptr) {
            throwInternalError("makeClassHandle requires ptr and ptrType");
          }
          const hasSmartPtrType = !!record.smartPtrType;
          const hasSmartPtr = !!record.smartPtr;
          if (hasSmartPtrType !== hasSmartPtr) {
            throwInternalError("Both smartPtrType and smartPtr must be specified");
          }
          record.count = { value: 1 };
          return attachFinalizer(
            Object.create(prototype, { $$: { value: record } })
          );
        }
        function RegisteredPointer_fromWireType(ptr) {
          const rawPointer = this.getPointee(ptr);
          if (!rawPointer) {
            this.destructor(ptr);
            return null;
          }
          const registeredInstance = getInheritedInstance(
            this.registeredClass,
            rawPointer
          );
          if (void 0 !== registeredInstance) {
            if (0 === registeredInstance.$$.count.value) {
              registeredInstance.$$.ptr = rawPointer;
              registeredInstance.$$.smartPtr = ptr;
              return registeredInstance.clone();
            }
            const rv = registeredInstance.clone();
            this.destructor(ptr);
            return rv;
          }
          function makeDefaultHandle() {
            if (this.isSmartPointer) {
              return makeClassHandle(this.registeredClass.instancePrototype, {
                ptrType: this.pointeeType,
                ptr: rawPointer,
                smartPtrType: this,
                smartPtr: ptr
              });
            }
            return makeClassHandle(this.registeredClass.instancePrototype, {
              ptrType: this,
              ptr
            });
          }
          const actualType = this.registeredClass.getActualType(rawPointer);
          const registeredPointerRecord = registeredPointers[actualType];
          if (!registeredPointerRecord) {
            return makeDefaultHandle.call(this);
          }
          let toType;
          if (this.isConst) {
            toType = registeredPointerRecord.constPointerType;
          } else {
            toType = registeredPointerRecord.pointerType;
          }
          const dp = downcastPointer(
            rawPointer,
            this.registeredClass,
            toType.registeredClass
          );
          if (dp === null) {
            return makeDefaultHandle.call(this);
          }
          if (this.isSmartPointer) {
            return makeClassHandle(toType.registeredClass.instancePrototype, {
              ptrType: toType,
              ptr: dp,
              smartPtrType: this,
              smartPtr: ptr
            });
          }
          return makeClassHandle(toType.registeredClass.instancePrototype, {
            ptrType: toType,
            ptr: dp
          });
        }
        function init_RegisteredPointer() {
          RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
          RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
          RegisteredPointer.prototype.argPackAdvance = 8;
          RegisteredPointer.prototype.readValueFromPointer = simpleReadValueFromPointer;
          RegisteredPointer.prototype.deleteObject = RegisteredPointer_deleteObject;
          RegisteredPointer.prototype.fromWireType = RegisteredPointer_fromWireType;
        }
        function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
          this.name = name;
          this.registeredClass = registeredClass;
          this.isReference = isReference;
          this.isConst = isConst;
          this.isSmartPointer = isSmartPointer;
          this.pointeeType = pointeeType;
          this.sharingPolicy = sharingPolicy;
          this.rawGetPointee = rawGetPointee;
          this.rawConstructor = rawConstructor;
          this.rawShare = rawShare;
          this.rawDestructor = rawDestructor;
          if (!isSmartPointer && registeredClass.baseClass === void 0) {
            if (isConst) {
              this.toWireType = constNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
            } else {
              this.toWireType = nonConstNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
            }
          } else {
            this.toWireType = genericPointerToWireType;
          }
        }
        function replacePublicSymbol(name, value, numArguments) {
          if (!Module2.hasOwnProperty(name)) {
            throwInternalError("Replacing nonexistant public symbol");
          }
          if (void 0 !== Module2[name].overloadTable && void 0 !== numArguments) {
            Module2[name].overloadTable[numArguments] = value;
          } else {
            Module2[name] = value;
            Module2[name].argCount = numArguments;
          }
        }
        function embind__requireFunction(signature, rawFunction) {
          signature = readLatin1String(signature);
          function makeDynCaller(dynCall) {
            const args = [];
            for (let i = 1; i < signature.length; ++i) {
              args.push(`a${i}`);
            }
            const name = `dynCall_${signature}_${rawFunction}`;
            let body = `return function ${name}(${args.join(", ")}) {
`;
            body += `    return dynCall(rawFunction${args.length ? ", " : ""}${args.join(", ")});
`;
            body += "};\n";
            return new Function("dynCall", "rawFunction", body)(
              dynCall,
              rawFunction
            );
          }
          let fp;
          if (Module2[`FUNCTION_TABLE_${signature}`] !== void 0) {
            fp = Module2[`FUNCTION_TABLE_${signature}`][rawFunction];
          } else if (typeof FUNCTION_TABLE !== "undefined") {
            fp = FUNCTION_TABLE[rawFunction];
          } else {
            let dc = Module2[`dynCall_${signature}`];
            if (dc === void 0) {
              dc = Module2[`dynCall_${signature.replace(/f/g, "d")}`];
              if (dc === void 0) {
                throwBindingError(`No dynCall invoker for signature: ${signature}`);
              }
            }
            fp = makeDynCaller(dc);
          }
          if (typeof fp !== "function") {
            throwBindingError(
              `unknown function pointer with signature ${signature}: ${rawFunction}`
            );
          }
          return fp;
        }
        let UnboundTypeError = void 0;
        function getTypeName(type) {
          const ptr = ___getTypeName(type);
          const rv = readLatin1String(ptr);
          _free(ptr);
          return rv;
        }
        function throwUnboundTypeError(message, types) {
          const unboundTypes = [];
          const seen = {};
          function visit(type) {
            if (seen[type]) {
              return;
            }
            if (registeredTypes[type]) {
              return;
            }
            if (typeDependencies[type]) {
              typeDependencies[type].forEach(visit);
              return;
            }
            unboundTypes.push(type);
            seen[type] = true;
          }
          types.forEach(visit);
          throw new UnboundTypeError(
            `${message}: ${unboundTypes.map(getTypeName).join([", "])}`
          );
        }
        function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {
          name = readLatin1String(name);
          getActualType = embind__requireFunction(
            getActualTypeSignature,
            getActualType
          );
          if (upcast) {
            upcast = embind__requireFunction(upcastSignature, upcast);
          }
          if (downcast) {
            downcast = embind__requireFunction(downcastSignature, downcast);
          }
          rawDestructor = embind__requireFunction(
            destructorSignature,
            rawDestructor
          );
          const legalFunctionName = makeLegalFunctionName(name);
          exposePublicSymbol(legalFunctionName, () => {
            throwUnboundTypeError(`Cannot construct ${name} due to unbound types`, [
              baseClassRawType
            ]);
          });
          whenDependentTypesAreResolved(
            [rawType, rawPointerType, rawConstPointerType],
            baseClassRawType ? [baseClassRawType] : [],
            (base) => {
              base = base[0];
              let baseClass;
              let basePrototype;
              if (baseClassRawType) {
                baseClass = base.registeredClass;
                basePrototype = baseClass.instancePrototype;
              } else {
                basePrototype = ClassHandle.prototype;
              }
              const constructor = createNamedFunction(
                legalFunctionName,
                function() {
                  if (Object.getPrototypeOf(this) !== instancePrototype) {
                    throw new BindingError(`Use 'new' to construct ${name}`);
                  }
                  if (void 0 === registeredClass.constructor_body) {
                    throw new BindingError(`${name} has no accessible constructor`);
                  }
                  const body = registeredClass.constructor_body[arguments.length];
                  if (void 0 === body) {
                    throw new BindingError(
                      `Tried to invoke ctor of ${name} with invalid number of parameters (${arguments.length}) - expected (${Object.keys(
                        registeredClass.constructor_body
                      ).toString()}) parameters instead!`
                    );
                  }
                  return body.apply(this, arguments);
                }
              );
              var instancePrototype = Object.create(basePrototype, {
                constructor: { value: constructor }
              });
              constructor.prototype = instancePrototype;
              var registeredClass = new RegisteredClass(
                name,
                constructor,
                instancePrototype,
                rawDestructor,
                baseClass,
                getActualType,
                upcast,
                downcast
              );
              const referenceConverter = new RegisteredPointer(
                name,
                registeredClass,
                true,
                false,
                false
              );
              const pointerConverter = new RegisteredPointer(
                `${name}*`,
                registeredClass,
                false,
                false,
                false
              );
              const constPointerConverter = new RegisteredPointer(
                `${name} const*`,
                registeredClass,
                false,
                true,
                false
              );
              registeredPointers[rawType] = {
                pointerType: pointerConverter,
                constPointerType: constPointerConverter
              };
              replacePublicSymbol(legalFunctionName, constructor);
              return [referenceConverter, pointerConverter, constPointerConverter];
            }
          );
        }
        function heap32VectorToArray(count, firstElement) {
          const array = [];
          for (let i = 0; i < count; i++) {
            array.push(HEAP32[(firstElement >> 2) + i]);
          }
          return array;
        }
        function runDestructors(destructors) {
          while (destructors.length) {
            const ptr = destructors.pop();
            const del = destructors.pop();
            del(ptr);
          }
        }
        function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
          const rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          invoker = embind__requireFunction(invokerSignature, invoker);
          whenDependentTypesAreResolved([], [rawClassType], (classType) => {
            classType = classType[0];
            const humanName = `constructor ${classType.name}`;
            if (void 0 === classType.registeredClass.constructor_body) {
              classType.registeredClass.constructor_body = [];
            }
            if (void 0 !== classType.registeredClass.constructor_body[argCount - 1]) {
              throw new BindingError(
                `Cannot register multiple constructors with identical number of parameters (${argCount - 1}) for class '${classType.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`
              );
            }
            classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {
              throwUnboundTypeError(
                `Cannot construct ${classType.name} due to unbound types`,
                rawArgTypes
              );
            };
            whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {
              classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {
                if (arguments.length !== argCount - 1) {
                  throwBindingError(
                    `${humanName} called with ${arguments.length} arguments, expected ${argCount - 1}`
                  );
                }
                const destructors = [];
                const args = new Array(argCount);
                args[0] = rawConstructor;
                for (let i = 1; i < argCount; ++i) {
                  args[i] = argTypes[i].toWireType(destructors, arguments[i - 1]);
                }
                const ptr = invoker.apply(null, args);
                runDestructors(destructors);
                return argTypes[0].fromWireType(ptr);
              };
              return [];
            });
            return [];
          });
        }
        function new_(constructor, argumentList) {
          if (!(constructor instanceof Function)) {
            throw new TypeError(
              `new_ called with constructor type ${typeof constructor} which is not a function`
            );
          }
          const dummy = createNamedFunction(
            constructor.name || "unknownFunctionName",
            () => {
            }
          );
          dummy.prototype = constructor.prototype;
          const obj = new dummy();
          const r = constructor.apply(obj, argumentList);
          return r instanceof Object ? r : obj;
        }
        function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
          const argCount = argTypes.length;
          if (argCount < 2) {
            throwBindingError(
              "argTypes array size mismatch! Must at least get return value and 'this' types!"
            );
          }
          const isClassMethodFunc = argTypes[1] !== null && classType !== null;
          let needsDestructorStack = false;
          for (var i = 1; i < argTypes.length; ++i) {
            if (argTypes[i] !== null && argTypes[i].destructorFunction === void 0) {
              needsDestructorStack = true;
              break;
            }
          }
          const returns = argTypes[0].name !== "void";
          let argsList = "";
          let argsListWired = "";
          for (var i = 0; i < argCount - 2; ++i) {
            argsList += `${i !== 0 ? ", " : ""}arg${i}`;
            argsListWired += `${i !== 0 ? ", " : ""}arg${i}Wired`;
          }
          let invokerFnBody = `return function ${makeLegalFunctionName(humanName)}(${argsList}) {
if (arguments.length !== ${argCount - 2}) {
throwBindingError('function ${humanName} called with ' + arguments.length + ' arguments, expected ${argCount - 2} args!');
}
`;
          if (needsDestructorStack) {
            invokerFnBody += "var destructors = [];\n";
          }
          const dtorStack = needsDestructorStack ? "destructors" : "null";
          const args1 = [
            "throwBindingError",
            "invoker",
            "fn",
            "runDestructors",
            "retType",
            "classParam"
          ];
          const args2 = [
            throwBindingError,
            cppInvokerFunc,
            cppTargetFunc,
            runDestructors,
            argTypes[0],
            argTypes[1]
          ];
          if (isClassMethodFunc) {
            invokerFnBody += `var thisWired = classParam.toWireType(${dtorStack}, this);
`;
          }
          for (var i = 0; i < argCount - 2; ++i) {
            invokerFnBody += `var arg${i}Wired = argType${i}.toWireType(${dtorStack}, arg${i}); // ${argTypes[i + 2].name}
`;
            args1.push(`argType${i}`);
            args2.push(argTypes[i + 2]);
          }
          if (isClassMethodFunc) {
            argsListWired = `thisWired${argsListWired.length > 0 ? ", " : ""}${argsListWired}`;
          }
          invokerFnBody += `${returns ? "var rv = " : ""}invoker(fn${argsListWired.length > 0 ? ", " : ""}${argsListWired});
`;
          if (needsDestructorStack) {
            invokerFnBody += "runDestructors(destructors);\n";
          } else {
            for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
              const paramName = i === 1 ? "thisWired" : `arg${i - 2}Wired`;
              if (argTypes[i].destructorFunction !== null) {
                invokerFnBody += `${paramName}_dtor(${paramName}); // ${argTypes[i].name}
`;
                args1.push(`${paramName}_dtor`);
                args2.push(argTypes[i].destructorFunction);
              }
            }
          }
          if (returns) {
            invokerFnBody += "var ret = retType.fromWireType(rv);\nreturn ret;\n";
          } else {
          }
          invokerFnBody += "}\n";
          args1.push(invokerFnBody);
          const invokerFunction = new_(Function, args1).apply(null, args2);
          return invokerFunction;
        }
        function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {
          const rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          methodName = readLatin1String(methodName);
          rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
          whenDependentTypesAreResolved([], [rawClassType], (classType) => {
            classType = classType[0];
            const humanName = `${classType.name}.${methodName}`;
            if (isPureVirtual) {
              classType.registeredClass.pureVirtualFunctions.push(methodName);
            }
            function unboundTypesHandler() {
              throwUnboundTypeError(
                `Cannot call ${humanName} due to unbound types`,
                rawArgTypes
              );
            }
            const proto = classType.registeredClass.instancePrototype;
            const method = proto[methodName];
            if (void 0 === method || void 0 === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {
              unboundTypesHandler.argCount = argCount - 2;
              unboundTypesHandler.className = classType.name;
              proto[methodName] = unboundTypesHandler;
            } else {
              ensureOverloadTable(proto, methodName, humanName);
              proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
            }
            whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {
              const memberFunction = craftInvokerFunction(
                humanName,
                argTypes,
                classType,
                rawInvoker,
                context
              );
              if (void 0 === proto[methodName].overloadTable) {
                memberFunction.argCount = argCount - 2;
                proto[methodName] = memberFunction;
              } else {
                proto[methodName].overloadTable[argCount - 2] = memberFunction;
              }
              return [];
            });
            return [];
          });
        }
        const emval_free_list = [];
        const emval_handle_array = [
          {},
          { value: void 0 },
          { value: null },
          { value: true },
          { value: false }
        ];
        function __emval_decref(handle) {
          if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {
            emval_handle_array[handle] = void 0;
            emval_free_list.push(handle);
          }
        }
        function count_emval_handles() {
          let count = 0;
          for (let i = 5; i < emval_handle_array.length; ++i) {
            if (emval_handle_array[i] !== void 0) {
              ++count;
            }
          }
          return count;
        }
        function get_first_emval() {
          for (let i = 5; i < emval_handle_array.length; ++i) {
            if (emval_handle_array[i] !== void 0) {
              return emval_handle_array[i];
            }
          }
          return null;
        }
        function init_emval() {
          Module2.count_emval_handles = count_emval_handles;
          Module2.get_first_emval = get_first_emval;
        }
        function __emval_register(value) {
          switch (value) {
            case void 0: {
              return 1;
            }
            case null: {
              return 2;
            }
            case true: {
              return 3;
            }
            case false: {
              return 4;
            }
            default: {
              const handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;
              emval_handle_array[handle] = { refcount: 1, value };
              return handle;
            }
          }
        }
        function __embind_register_emval(rawType, name) {
          name = readLatin1String(name);
          registerType(rawType, {
            name,
            fromWireType(handle) {
              const rv = emval_handle_array[handle].value;
              __emval_decref(handle);
              return rv;
            },
            toWireType(destructors, value) {
              return __emval_register(value);
            },
            argPackAdvance: 8,
            readValueFromPointer: simpleReadValueFromPointer,
            destructorFunction: null
          });
        }
        function _embind_repr(v) {
          if (v === null) {
            return "null";
          }
          const t2 = typeof v;
          if (t2 === "object" || t2 === "array" || t2 === "function") {
            return v.toString();
          }
          return `${v}`;
        }
        function floatReadValueFromPointer(name, shift) {
          switch (shift) {
            case 2:
              return function(pointer) {
                return this.fromWireType(HEAPF32[pointer >> 2]);
              };
            case 3:
              return function(pointer) {
                return this.fromWireType(HEAPF64[pointer >> 3]);
              };
            default:
              throw new TypeError(`Unknown float type: ${name}`);
          }
        }
        function __embind_register_float(rawType, name, size) {
          const shift = getShiftFromSize(size);
          name = readLatin1String(name);
          registerType(rawType, {
            name,
            fromWireType(value) {
              return value;
            },
            toWireType(destructors, value) {
              if (typeof value !== "number" && typeof value !== "boolean") {
                throw new TypeError(
                  `Cannot convert "${_embind_repr(value)}" to ${this.name}`
                );
              }
              return value;
            },
            argPackAdvance: 8,
            readValueFromPointer: floatReadValueFromPointer(name, shift),
            destructorFunction: null
          });
        }
        function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {
          const argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          name = readLatin1String(name);
          rawInvoker = embind__requireFunction(signature, rawInvoker);
          exposePublicSymbol(
            name,
            () => {
              throwUnboundTypeError(
                `Cannot call ${name} due to unbound types`,
                argTypes
              );
            },
            argCount - 1
          );
          whenDependentTypesAreResolved([], argTypes, (argTypes2) => {
            const invokerArgsArray = [argTypes2[0], null].concat(argTypes2.slice(1));
            replacePublicSymbol(
              name,
              craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn),
              argCount - 1
            );
            return [];
          });
        }
        function integerReadValueFromPointer(name, shift, signed) {
          switch (shift) {
            case 0:
              return signed ? function readS8FromPointer(pointer) {
                return HEAP8[pointer];
              } : function readU8FromPointer(pointer) {
                return HEAPU8[pointer];
              };
            case 1:
              return signed ? function readS16FromPointer(pointer) {
                return HEAP16[pointer >> 1];
              } : function readU16FromPointer(pointer) {
                return HEAPU16[pointer >> 1];
              };
            case 2:
              return signed ? function readS32FromPointer(pointer) {
                return HEAP32[pointer >> 2];
              } : function readU32FromPointer(pointer) {
                return HEAPU32[pointer >> 2];
              };
            default:
              throw new TypeError(`Unknown integer type: ${name}`);
          }
        }
        function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {
          name = readLatin1String(name);
          if (maxRange === -1) {
            maxRange = 4294967295;
          }
          const shift = getShiftFromSize(size);
          let fromWireType = function(value) {
            return value;
          };
          if (minRange === 0) {
            const bitshift = 32 - 8 * size;
            fromWireType = function(value) {
              return value << bitshift >>> bitshift;
            };
          }
          const isUnsignedType = name.indexOf("unsigned") != -1;
          registerType(primitiveType, {
            name,
            fromWireType,
            toWireType(destructors, value) {
              if (typeof value !== "number" && typeof value !== "boolean") {
                throw new TypeError(
                  `Cannot convert "${_embind_repr(value)}" to ${this.name}`
                );
              }
              if (value < minRange || value > maxRange) {
                throw new TypeError(
                  `Passing a number "${_embind_repr(
                    value
                  )}" from JS side to C/C++ side to an argument of type "${name}", which is outside the valid range [${minRange}, ${maxRange}]!`
                );
              }
              return isUnsignedType ? value >>> 0 : value | 0;
            },
            argPackAdvance: 8,
            readValueFromPointer: integerReadValueFromPointer(
              name,
              shift,
              minRange !== 0
            ),
            destructorFunction: null
          });
        }
        function __embind_register_memory_view(rawType, dataTypeIndex, name) {
          const typeMapping = [
            Int8Array,
            Uint8Array,
            Int16Array,
            Uint16Array,
            Int32Array,
            Uint32Array,
            Float32Array,
            Float64Array
          ];
          const TA = typeMapping[dataTypeIndex];
          function decodeMemoryView(handle) {
            handle = handle >> 2;
            const heap = HEAPU32;
            const size = heap[handle];
            const data = heap[handle + 1];
            return new TA(heap.buffer, data, size);
          }
          name = readLatin1String(name);
          registerType(
            rawType,
            {
              name,
              fromWireType: decodeMemoryView,
              argPackAdvance: 8,
              readValueFromPointer: decodeMemoryView
            },
            { ignoreDuplicateRegistrations: true }
          );
        }
        function __embind_register_std_string(rawType, name) {
          name = readLatin1String(name);
          const stdStringIsUTF8 = name === "std::string";
          registerType(rawType, {
            name,
            fromWireType(value) {
              const length = HEAPU32[value >> 2];
              let str;
              if (stdStringIsUTF8) {
                const endChar = HEAPU8[value + 4 + length];
                let endCharSwap = 0;
                if (endChar != 0) {
                  endCharSwap = endChar;
                  HEAPU8[value + 4 + length] = 0;
                }
                let decodeStartPtr = value + 4;
                for (var i = 0; i <= length; ++i) {
                  const currentBytePtr = value + 4 + i;
                  if (HEAPU8[currentBytePtr] == 0) {
                    const stringSegment = UTF8ToString(decodeStartPtr);
                    if (str === void 0) {
                      str = stringSegment;
                    } else {
                      str += String.fromCharCode(0);
                      str += stringSegment;
                    }
                    decodeStartPtr = currentBytePtr + 1;
                  }
                }
                if (endCharSwap != 0) {
                  HEAPU8[value + 4 + length] = endCharSwap;
                }
              } else {
                const a = new Array(length);
                for (var i = 0; i < length; ++i) {
                  a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);
                }
                str = a.join("");
              }
              _free(value);
              return str;
            },
            toWireType(destructors, value) {
              if (Object.prototype.toString.call(value) === "[object ArrayBuffer]") {
                value = new Uint8Array(value);
              }
              let getLength;
              const valueIsOfTypeString = typeof value === "string";
              if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
                throwBindingError("Cannot pass non-string to std::string");
              }
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                getLength = function() {
                  return lengthBytesUTF8(value);
                };
              } else {
                getLength = function() {
                  return value.length;
                };
              }
              const length = getLength();
              const ptr = _malloc(4 + length + 1);
              HEAPU32[ptr >> 2] = length;
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                stringToUTF8(value, ptr + 4, length + 1);
              } else if (valueIsOfTypeString) {
                for (var i = 0; i < length; ++i) {
                  const charCode = value.charCodeAt(i);
                  if (charCode > 255) {
                    _free(ptr);
                    throwBindingError(
                      "String has UTF-16 code units that do not fit in 8 bits"
                    );
                  }
                  HEAPU8[ptr + 4 + i] = charCode;
                }
              } else {
                for (var i = 0; i < length; ++i) {
                  HEAPU8[ptr + 4 + i] = value[i];
                }
              }
              if (destructors !== null) {
                destructors.push(_free, ptr);
              }
              return ptr;
            },
            argPackAdvance: 8,
            readValueFromPointer: simpleReadValueFromPointer,
            destructorFunction(ptr) {
              _free(ptr);
            }
          });
        }
        function __embind_register_std_wstring(rawType, charSize, name) {
          name = readLatin1String(name);
          let getHeap;
          let shift;
          if (charSize === 2) {
            getHeap = function() {
              return HEAPU16;
            };
            shift = 1;
          } else if (charSize === 4) {
            getHeap = function() {
              return HEAPU32;
            };
            shift = 2;
          }
          registerType(rawType, {
            name,
            fromWireType(value) {
              const HEAP = getHeap();
              const length = HEAPU32[value >> 2];
              const a = new Array(length);
              const start2 = value + 4 >> shift;
              for (let i = 0; i < length; ++i) {
                a[i] = String.fromCharCode(HEAP[start2 + i]);
              }
              _free(value);
              return a.join("");
            },
            toWireType(destructors, value) {
              const length = value.length;
              const ptr = _malloc(4 + length * charSize);
              const HEAP = getHeap();
              HEAPU32[ptr >> 2] = length;
              const start2 = ptr + 4 >> shift;
              for (let i = 0; i < length; ++i) {
                HEAP[start2 + i] = value.charCodeAt(i);
              }
              if (destructors !== null) {
                destructors.push(_free, ptr);
              }
              return ptr;
            },
            argPackAdvance: 8,
            readValueFromPointer: simpleReadValueFromPointer,
            destructorFunction(ptr) {
              _free(ptr);
            }
          });
        }
        function __embind_register_void(rawType, name) {
          name = readLatin1String(name);
          registerType(rawType, {
            isVoid: true,
            name,
            argPackAdvance: 0,
            fromWireType() {
              return void 0;
            },
            toWireType(destructors, o) {
              return void 0;
            }
          });
        }
        function __emval_incref(handle) {
          if (handle > 4) {
            emval_handle_array[handle].refcount += 1;
          }
        }
        function requireRegisteredType(rawType, humanName) {
          const impl = registeredTypes[rawType];
          if (void 0 === impl) {
            throwBindingError(
              `${humanName} has unknown type ${getTypeName(rawType)}`
            );
          }
          return impl;
        }
        function __emval_take_value(type, argv) {
          type = requireRegisteredType(type, "_emval_take_value");
          const v = type.readValueFromPointer(argv);
          return __emval_register(v);
        }
        function _abort() {
          abort();
        }
        function _emscripten_get_heap_size() {
          return HEAP8.length;
        }
        function emscripten_realloc_buffer(size) {
          try {
            wasmMemory.grow(size - buffer.byteLength + 65535 >> 16);
            updateGlobalBufferAndViews(wasmMemory.buffer);
            return 1;
          } catch (e) {
            console.error(
              `emscripten_realloc_buffer: Attempted to grow heap from ${buffer.byteLength} bytes to ${size} bytes, but got error: ${e}`
            );
          }
        }
        function _emscripten_resize_heap(requestedSize) {
          const oldSize = _emscripten_get_heap_size();
          assert(requestedSize > oldSize);
          const PAGE_MULTIPLE = 65536;
          const LIMIT = 2147483648 - PAGE_MULTIPLE;
          if (requestedSize > LIMIT) {
            err(
              `Cannot enlarge memory, asked to go up to ${requestedSize} bytes, but the limit is ${LIMIT} bytes!`
            );
            return false;
          }
          const MIN_TOTAL_MEMORY = 16777216;
          let newSize = Math.max(oldSize, MIN_TOTAL_MEMORY);
          while (newSize < requestedSize) {
            if (newSize <= 536870912) {
              newSize = alignUp(2 * newSize, PAGE_MULTIPLE);
            } else {
              newSize = Math.min(
                alignUp((3 * newSize + 2147483648) / 4, PAGE_MULTIPLE),
                LIMIT
              );
            }
            if (newSize === oldSize) {
              warnOnce(
                `Cannot ask for more memory since we reached the practical limit in browsers (which is just below 2GB), so the request would have failed. Requesting only ${HEAP8.length}`
              );
            }
          }
          const replacement = emscripten_realloc_buffer(newSize);
          if (!replacement) {
            err(
              `Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`
            );
            return false;
          }
          return true;
        }
        function _exit(status) {
          exit(status);
        }
        function _llvm_log2_f32(x) {
          return Math.log(x) / Math.LN2;
        }
        function _llvm_log2_f64(a0) {
          return _llvm_log2_f32(a0);
        }
        function _llvm_trap() {
          abort("trap!");
        }
        function _emscripten_memcpy_big(dest, src, num) {
          HEAPU8.set(HEAPU8.subarray(src, src + num), dest);
        }
        embind_init_charCodes();
        BindingError = Module2.BindingError = extendError(Error, "BindingError");
        InternalError = Module2.InternalError = extendError(Error, "InternalError");
        init_ClassHandle();
        init_RegisteredPointer();
        init_embind();
        UnboundTypeError = Module2.UnboundTypeError = extendError(
          Error,
          "UnboundTypeError"
        );
        init_emval();
        function nullFunc_i(x) {
          abortFnPtrError(x, "i");
        }
        function nullFunc_ii(x) {
          abortFnPtrError(x, "ii");
        }
        function nullFunc_iidiiii(x) {
          abortFnPtrError(x, "iidiiii");
        }
        function nullFunc_iii(x) {
          abortFnPtrError(x, "iii");
        }
        function nullFunc_iiii(x) {
          abortFnPtrError(x, "iiii");
        }
        function nullFunc_iiiii(x) {
          abortFnPtrError(x, "iiiii");
        }
        function nullFunc_jiji(x) {
          abortFnPtrError(x, "jiji");
        }
        function nullFunc_v(x) {
          abortFnPtrError(x, "v");
        }
        function nullFunc_vi(x) {
          abortFnPtrError(x, "vi");
        }
        function nullFunc_vii(x) {
          abortFnPtrError(x, "vii");
        }
        function nullFunc_viii(x) {
          abortFnPtrError(x, "viii");
        }
        function nullFunc_viiii(x) {
          abortFnPtrError(x, "viiii");
        }
        function nullFunc_viiiii(x) {
          abortFnPtrError(x, "viiiii");
        }
        function nullFunc_viiiiii(x) {
          abortFnPtrError(x, "viiiiii");
        }
        const asmGlobalArg = {};
        var asmLibraryArg = {
          ___assert_fail,
          ___cxa_allocate_exception,
          ___cxa_throw,
          ___lock,
          ___unlock,
          ___wasi_fd_close,
          ___wasi_fd_seek,
          ___wasi_fd_write,
          __embind_register_bool,
          __embind_register_class,
          __embind_register_class_constructor,
          __embind_register_class_function,
          __embind_register_emval,
          __embind_register_float,
          __embind_register_function,
          __embind_register_integer,
          __embind_register_memory_view,
          __embind_register_std_string,
          __embind_register_std_wstring,
          __embind_register_void,
          __emval_decref,
          __emval_incref,
          __emval_take_value,
          __memory_base: 1024,
          __table_base: 0,
          _abort,
          _emscripten_get_heap_size,
          _emscripten_memcpy_big,
          _emscripten_resize_heap,
          _exit,
          _llvm_log2_f64,
          _llvm_trap,
          abortStackOverflow,
          memory: wasmMemory,
          nullFunc_i,
          nullFunc_ii,
          nullFunc_iidiiii,
          nullFunc_iii,
          nullFunc_iiii,
          nullFunc_iiiii,
          nullFunc_jiji,
          nullFunc_v,
          nullFunc_vi,
          nullFunc_vii,
          nullFunc_viii,
          nullFunc_viiii,
          nullFunc_viiiii,
          nullFunc_viiiiii,
          setTempRet0,
          table: wasmTable
        };
        const asm = Module2.asm(asmGlobalArg, asmLibraryArg, buffer);
        Module2.asm = asm;
        var __ZSt18uncaught_exceptionv = Module2.__ZSt18uncaught_exceptionv = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm.__ZSt18uncaught_exceptionv.apply(null, arguments);
        };
        const ___cxa_demangle = Module2.___cxa_demangle = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm.___cxa_demangle.apply(null, arguments);
        };
        const ___embind_register_native_and_builtin_types = Module2.___embind_register_native_and_builtin_types = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm.___embind_register_native_and_builtin_types.apply(
            null,
            arguments
          );
        };
        var ___getTypeName = Module2.___getTypeName = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm.___getTypeName.apply(null, arguments);
        };
        const _fflush = Module2._fflush = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm._fflush.apply(null, arguments);
        };
        var _free = Module2._free = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm._free.apply(null, arguments);
        };
        var _malloc = Module2._malloc = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm._malloc.apply(null, arguments);
        };
        const establishStackSpace = Module2.establishStackSpace = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm.establishStackSpace.apply(null, arguments);
        };
        var globalCtors = Module2.globalCtors = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm.globalCtors.apply(null, arguments);
        };
        var stackAlloc = Module2.stackAlloc = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm.stackAlloc.apply(null, arguments);
        };
        var stackRestore = Module2.stackRestore = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm.stackRestore.apply(null, arguments);
        };
        var stackSave = Module2.stackSave = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm.stackSave.apply(null, arguments);
        };
        const dynCall_i = Module2.dynCall_i = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm.dynCall_i.apply(null, arguments);
        };
        const dynCall_ii = Module2.dynCall_ii = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm.dynCall_ii.apply(null, arguments);
        };
        const dynCall_iidiiii = Module2.dynCall_iidiiii = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm.dynCall_iidiiii.apply(null, arguments);
        };
        const dynCall_iii = Module2.dynCall_iii = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm.dynCall_iii.apply(null, arguments);
        };
        const dynCall_iiii = Module2.dynCall_iiii = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm.dynCall_iiii.apply(null, arguments);
        };
        const dynCall_iiiii = Module2.dynCall_iiiii = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm.dynCall_iiiii.apply(null, arguments);
        };
        const dynCall_jiji = Module2.dynCall_jiji = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm.dynCall_jiji.apply(null, arguments);
        };
        const dynCall_v = Module2.dynCall_v = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm.dynCall_v.apply(null, arguments);
        };
        const dynCall_vi = Module2.dynCall_vi = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm.dynCall_vi.apply(null, arguments);
        };
        const dynCall_vii = Module2.dynCall_vii = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm.dynCall_vii.apply(null, arguments);
        };
        const dynCall_viii = Module2.dynCall_viii = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm.dynCall_viii.apply(null, arguments);
        };
        const dynCall_viiii = Module2.dynCall_viiii = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm.dynCall_viiii.apply(null, arguments);
        };
        const dynCall_viiiii = Module2.dynCall_viiiii = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm.dynCall_viiiii.apply(null, arguments);
        };
        const dynCall_viiiiii = Module2.dynCall_viiiiii = function() {
          assert(
            runtimeInitialized,
            "you need to wait for the runtime to be ready (e.g. wait for main() to be called)"
          );
          assert(
            !runtimeExited,
            "the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)"
          );
          return Module2.asm.dynCall_viiiiii.apply(null, arguments);
        };
        Module2.asm = asm;
        if (!Object.getOwnPropertyDescriptor(Module2, "intArrayFromString")) {
          Module2.intArrayFromString = function() {
            abort(
              "'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "intArrayToString")) {
          Module2.intArrayToString = function() {
            abort(
              "'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        Module2.ccall = ccall;
        Module2.cwrap = cwrap;
        if (!Object.getOwnPropertyDescriptor(Module2, "setValue")) {
          Module2.setValue = function() {
            abort(
              "'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "getValue")) {
          Module2.getValue = function() {
            abort(
              "'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "allocate")) {
          Module2.allocate = function() {
            abort(
              "'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "getMemory")) {
          Module2.getMemory = function() {
            abort(
              "'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "AsciiToString")) {
          Module2.AsciiToString = function() {
            abort(
              "'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "stringToAscii")) {
          Module2.stringToAscii = function() {
            abort(
              "'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "UTF8ArrayToString")) {
          Module2.UTF8ArrayToString = function() {
            abort(
              "'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "UTF8ToString")) {
          Module2.UTF8ToString = function() {
            abort(
              "'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "stringToUTF8Array")) {
          Module2.stringToUTF8Array = function() {
            abort(
              "'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        Module2.stringToUTF8 = stringToUTF8;
        if (!Object.getOwnPropertyDescriptor(Module2, "lengthBytesUTF8")) {
          Module2.lengthBytesUTF8 = function() {
            abort(
              "'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "UTF16ToString")) {
          Module2.UTF16ToString = function() {
            abort(
              "'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "stringToUTF16")) {
          Module2.stringToUTF16 = function() {
            abort(
              "'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "lengthBytesUTF16")) {
          Module2.lengthBytesUTF16 = function() {
            abort(
              "'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "UTF32ToString")) {
          Module2.UTF32ToString = function() {
            abort(
              "'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "stringToUTF32")) {
          Module2.stringToUTF32 = function() {
            abort(
              "'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "lengthBytesUTF32")) {
          Module2.lengthBytesUTF32 = function() {
            abort(
              "'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "allocateUTF8")) {
          Module2.allocateUTF8 = function() {
            abort(
              "'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "stackTrace")) {
          Module2.stackTrace = function() {
            abort(
              "'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "addOnPreRun")) {
          Module2.addOnPreRun = function() {
            abort(
              "'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "addOnInit")) {
          Module2.addOnInit = function() {
            abort(
              "'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "addOnPreMain")) {
          Module2.addOnPreMain = function() {
            abort(
              "'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "addOnExit")) {
          Module2.addOnExit = function() {
            abort(
              "'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "addOnPostRun")) {
          Module2.addOnPostRun = function() {
            abort(
              "'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "writeStringToMemory")) {
          Module2.writeStringToMemory = function() {
            abort(
              "'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "writeArrayToMemory")) {
          Module2.writeArrayToMemory = function() {
            abort(
              "'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "writeAsciiToMemory")) {
          Module2.writeAsciiToMemory = function() {
            abort(
              "'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "addRunDependency")) {
          Module2.addRunDependency = function() {
            abort(
              "'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "removeRunDependency")) {
          Module2.removeRunDependency = function() {
            abort(
              "'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "ENV")) {
          Module2.ENV = function() {
            abort(
              "'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "FS")) {
          Module2.FS = function() {
            abort(
              "'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "FS_createFolder")) {
          Module2.FS_createFolder = function() {
            abort(
              "'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "FS_createPath")) {
          Module2.FS_createPath = function() {
            abort(
              "'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "FS_createDataFile")) {
          Module2.FS_createDataFile = function() {
            abort(
              "'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "FS_createPreloadedFile")) {
          Module2.FS_createPreloadedFile = function() {
            abort(
              "'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "FS_createLazyFile")) {
          Module2.FS_createLazyFile = function() {
            abort(
              "'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "FS_createLink")) {
          Module2.FS_createLink = function() {
            abort(
              "'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "FS_createDevice")) {
          Module2.FS_createDevice = function() {
            abort(
              "'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "FS_unlink")) {
          Module2.FS_unlink = function() {
            abort(
              "'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "GL")) {
          Module2.GL = function() {
            abort(
              "'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "dynamicAlloc")) {
          Module2.dynamicAlloc = function() {
            abort(
              "'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "loadDynamicLibrary")) {
          Module2.loadDynamicLibrary = function() {
            abort(
              "'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "loadWebAssemblyModule")) {
          Module2.loadWebAssemblyModule = function() {
            abort(
              "'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "getLEB")) {
          Module2.getLEB = function() {
            abort(
              "'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "getFunctionTables")) {
          Module2.getFunctionTables = function() {
            abort(
              "'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "alignFunctionTables")) {
          Module2.alignFunctionTables = function() {
            abort(
              "'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "registerFunctions")) {
          Module2.registerFunctions = function() {
            abort(
              "'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "addFunction")) {
          Module2.addFunction = function() {
            abort(
              "'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "removeFunction")) {
          Module2.removeFunction = function() {
            abort(
              "'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "getFuncWrapper")) {
          Module2.getFuncWrapper = function() {
            abort(
              "'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "prettyPrint")) {
          Module2.prettyPrint = function() {
            abort(
              "'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "makeBigInt")) {
          Module2.makeBigInt = function() {
            abort(
              "'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "dynCall")) {
          Module2.dynCall = function() {
            abort(
              "'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "getCompilerSetting")) {
          Module2.getCompilerSetting = function() {
            abort(
              "'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "stackSave")) {
          Module2.stackSave = function() {
            abort(
              "'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "stackRestore")) {
          Module2.stackRestore = function() {
            abort(
              "'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "stackAlloc")) {
          Module2.stackAlloc = function() {
            abort(
              "'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "establishStackSpace")) {
          Module2.establishStackSpace = function() {
            abort(
              "'establishStackSpace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "print")) {
          Module2.print = function() {
            abort(
              "'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "printErr")) {
          Module2.printErr = function() {
            abort(
              "'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "getTempRet0")) {
          Module2.getTempRet0 = function() {
            abort(
              "'getTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "setTempRet0")) {
          Module2.setTempRet0 = function() {
            abort(
              "'setTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "callMain")) {
          Module2.callMain = function() {
            abort(
              "'callMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "abort")) {
          Module2.abort = function() {
            abort(
              "'abort' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "Pointer_stringify")) {
          Module2.Pointer_stringify = function() {
            abort(
              "'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "warnOnce")) {
          Module2.warnOnce = function() {
            abort(
              "'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
            );
          };
        }
        Module2.writeStackCookie = writeStackCookie;
        Module2.checkStackCookie = checkStackCookie;
        Module2.abortStackOverflow = abortStackOverflow;
        if (!Object.getOwnPropertyDescriptor(Module2, "ALLOC_NORMAL")) {
          Object.defineProperty(Module2, "ALLOC_NORMAL", {
            configurable: true,
            get() {
              abort(
                "'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
              );
            }
          });
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "ALLOC_STACK")) {
          Object.defineProperty(Module2, "ALLOC_STACK", {
            configurable: true,
            get() {
              abort(
                "'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
              );
            }
          });
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "ALLOC_DYNAMIC")) {
          Object.defineProperty(Module2, "ALLOC_DYNAMIC", {
            configurable: true,
            get() {
              abort(
                "'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
              );
            }
          });
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "ALLOC_NONE")) {
          Object.defineProperty(Module2, "ALLOC_NONE", {
            configurable: true,
            get() {
              abort(
                "'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)"
              );
            }
          });
        }
        if (!Object.getOwnPropertyDescriptor(Module2, "calledRun")) {
          Object.defineProperty(Module2, "calledRun", {
            configurable: true,
            get() {
              abort(
                "'calledRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you"
              );
            }
          });
        }
        let calledRun;
        Module2.then = function(func) {
          if (calledRun) {
            func(Module2);
          } else {
            const old = Module2.onRuntimeInitialized;
            Module2.onRuntimeInitialized = function() {
              if (old) {
                old();
              }
              func(Module2);
            };
          }
          return Module2;
        };
        function ExitStatus(status) {
          this.name = "ExitStatus";
          this.message = `Program terminated with exit(${status})`;
          this.status = status;
        }
        dependenciesFulfilled = function runCaller() {
          if (!calledRun) {
            run();
          }
          if (!calledRun) {
            dependenciesFulfilled = runCaller;
          }
        };
        function run(args) {
          args = args || arguments_;
          if (runDependencies > 0) {
            return;
          }
          writeStackCookie();
          preRun();
          if (runDependencies > 0) {
            return;
          }
          function doRun() {
            if (calledRun) {
              return;
            }
            calledRun = true;
            if (ABORT) {
              return;
            }
            initRuntime();
            preMain();
            if (Module2.onRuntimeInitialized) {
              Module2.onRuntimeInitialized();
            }
            assert(
              !Module2._main,
              'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]'
            );
            postRun();
          }
          if (Module2.setStatus) {
            Module2.setStatus("Running...");
            setTimeout(() => {
              setTimeout(() => {
                Module2.setStatus("");
              }, 1);
              doRun();
            }, 1);
          } else {
            doRun();
          }
          checkStackCookie();
        }
        Module2.run = run;
        function checkUnflushedContent() {
          const print2 = out;
          const printErr2 = err;
          let has = false;
          out = err = function(x) {
            has = true;
          };
          try {
            const flush = flush_NO_FILESYSTEM;
            if (flush) {
              flush(0);
            }
          } catch (e) {
          }
          out = print2;
          err = printErr2;
          if (has) {
            warnOnce(
              "stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc."
            );
            warnOnce(
              "(this may also be due to not including full filesystem support - try building with -s FORCE_FILESYSTEM=1)"
            );
          }
        }
        function exit(status, implicit) {
          checkUnflushedContent();
          if (implicit && noExitRuntime && status === 0) {
            return;
          }
          if (noExitRuntime) {
            if (!implicit) {
              err(
                `program exited (with status: ${status}), but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)`
              );
            }
          } else {
            ABORT = true;
            EXITSTATUS = status;
            exitRuntime();
            if (Module2.onExit) {
              Module2.onExit(status);
            }
          }
          quit_(status, new ExitStatus(status));
        }
        if (Module2.preInit) {
          if (typeof Module2.preInit == "function") {
            Module2.preInit = [Module2.preInit];
          }
          while (Module2.preInit.length > 0) {
            Module2.preInit.pop()();
          }
        }
        noExitRuntime = true;
        run();
        return Module2;
      };
    }();
    woff2_bindings_default = Module;
  }
});

// fonts/wasm/woff2.loader.ts
var loadedWasm, load, woff2_loader_default;
var init_woff2_loader = __esm({
  "fonts/wasm/woff2.loader.ts"() {
    "use strict";
    init_define_import_meta_env();
    loadedWasm = null;
    load = () => {
      return new Promise(async (resolve, reject) => {
        try {
          const [binary, bindings] = await Promise.all([
            Promise.resolve().then(() => (init_woff2_wasm(), woff2_wasm_exports)),
            Promise.resolve().then(() => (init_woff2_bindings(), woff2_bindings_exports))
          ]);
          bindings.default({ wasmBinary: binary.default }).then(
            (module) => {
              try {
                let convertFromVecToUint8Array2 = function(vector2) {
                  const arr = [];
                  for (let i = 0, l = vector2.size(); i < l; i++) {
                    arr.push(vector2.get(i));
                  }
                  return new Uint8Array(arr);
                };
                var convertFromVecToUint8Array = convertFromVecToUint8Array2;
                const woff2 = {
                  compress: (buffer) => convertFromVecToUint8Array2(
                    module.woff2Enc(buffer, buffer.byteLength)
                  ),
                  decompress: (buffer) => convertFromVecToUint8Array2(
                    module.woff2Dec(buffer, buffer.byteLength)
                  )
                };
                resolve(woff2);
              } catch (e) {
                reject(e);
              }
            }
          );
        } catch (e) {
          reject(e);
        }
      });
    };
    woff2_loader_default = () => {
      if (!loadedWasm) {
        loadedWasm = load();
      }
      return loadedWasm;
    };
  }
});

// fonts/wasm/hb-subset.wasm.ts
var hb_subset_wasm_exports = {};
__export(hb_subset_wasm_exports, {
  default: () => hb_subset_wasm_default
});
var __toBinary2, hb_subset_wasm_default;
var init_hb_subset_wasm = __esm({
  "fonts/wasm/hb-subset.wasm.ts"() {
    "use strict";
    init_define_import_meta_env();
    __toBinary2 = /* @__PURE__ */ (() => {
      const table = new Uint8Array(128);
      for (let i = 0; i < 64; i++) {
        table[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i * 4 - 205] = i;
      }
      return (base64) => {
        const n = base64.length;
        const bytes = new Uint8Array((n - (base64[n - 1] == "=") - (base64[n - 2] == "=")) * 3 / 4 | 0);
        for (let i2 = 0, j = 0; i2 < n; ) {
          const c0 = table[base64.charCodeAt(i2++)];
          const c1 = table[base64.charCodeAt(i2++)];
          const c2 = table[base64.charCodeAt(i2++)];
          const c3 = table[base64.charCodeAt(i2++)];
          bytes[j++] = c0 << 2 | c1 >> 4;
          bytes[j++] = c1 << 4 | c2 >> 2;
          bytes[j++] = c2 << 6 | c3;
        }
        return bytes;
      };
    })();
    hb_subset_wasm_default = __toBinary2(`AGFzbQEAAAAB+gIuYAJ/fwF/YAJ/fwBgAX8Bf2ABfwBgA39/fwF/YAR/f39/AX9gA39/fwBgBH9/f38AYAV/f39/fwF/YAZ/f39/f38Bf2AFf39/f38AYAZ/f39/f38AYAh/f39/f39/fwBgB39/f39/f38Bf2AIf39/f39/f38Bf2AAAX9gBn9/f319fwBgBX9/f39/AX1gB39/f39/f38AYAAAYAJ8fwF8YAh/f399fX19fwBgCn9/f319fX19fX8AYAl/f319fX19fX8AYAF/AXxgBH9/f38BfWACf30Bf2AEf39/fQF/YAZ/f399fX0Bf2AEfH9/fwF8YAJ/fAF8YA5/f39/f39/f39/f39/fwF/YAV/f39/fwF8YAZ/f39/f38BfWADf39/AX1gCn9/f39/f39/f38AYAt/f39/f39/f39/fwBgA399fwF/YAJ/fwF+YAN/fn8AYAV8fHx8fAF8YAJ/fQBgA399fQBgAXwBfGACfn8Bf2AGf3x/f39/AX8DkQ2PDRMABAAABAIBAQYDAQIIAgMDAwMCAgACBAQDBA8BAQIDBAIEAQEAAAEAAAEAAwMDAwAFAgQCAQMDAAAEAwQDAwMDCAAAAAICAgUFCA4ECQkFBQwACwAMAAsACQkICA0JCwwDBAQFAAUICQUFCQYJCA0JCQsMAQIDBgcDAgECAA8DBQgAAQQEAwEBAQIBAQIBAhgFAQAGBQAAAgUABgADAwMDAwMDAwAGAgICBgYCAgAAAAIKAQIBAgABAQcAAQMCAgAGAwAKAQMDAgcEAgICGQICEQ8DBAAaAgQAAAUBAwMCAAEEAQEGAQEBAwICAAEEAgICCAQABwcOAQEBAAQDAwMACAQEAAgAAAUDCAIDBwYAAAYEAwAHAAAEAwEAAAMDAgQIBAAEAQIHAQMPAwICAAIBAwQFBBscBAQCAAMCBAQFDQQdBwEeFAEEAQEBAQEBAQEBAQABAQEBAwMDAwMDAQEBAwAABAEAAwEAAAICAAEDAgYBCgoKAgECAAYLAgEGAQgCAgEBAQIAAQEBAAABAhEEBgIEAAEHAQEDAwMFAAUBAQYAAgAHAQIEAAABAAADBAYAAgAABAYCBwACAAQBAgABAgIBAQEDBQECAAEFAAMGAwEFAwYGBQAAAwEQEBUWBwcBAwEBAAEDBgMBAwEBAQECAwIGCgwAAQICAQQIDgkFDAUMCQgCAgIFBAQEBAQBBAQAAAQAAAAAAAADAAQEAAAEBAAABAUCAAARAAAAAB8EAQADAQYBAQkBCggAIAQEIQIBAQIEAgYGAAADAAAABAQFAAIABQMEAQMABwYBBQAEAgABAgMAAAIEAAUFBAACAAADAQMDAAIABAQCAAECAAAEAwMEBwoEBgUEAQEFBQQBACICAAAAAAACAAQAAAQEAAAEAQQABQAEBgECBgICAwAEAgIGBgECAQIFAAICAwMBBgIAAgIAAwYDBQoEAQcSBSMJAQAKBQADAwQEBgAEBAcACgUHJA4AAAAEBAQABAAEAAAAAAQEBAAABAAAAAAEAAUJBAQFCgIAAAQEAQABBAAAAAQAAAEAAQAGAQEFAwEACAgBAwQBBgYGAQEBAQEBAQEBAQQADQEDBgEDBQYGAQsBBwEBAwAJAwUCAQMDAwYGBgEBAgYGAwECAwIBAAsNBgYLAwAHAAQEAgMAAAAAAAIDAAMABgMGBwADAAADAAcAAwABBgABAQQAAAAAAAACBAQGAgEBAAQEBgEBAQYAAQABAAUBAQMCAQYEAAQCBgAEBAAGAQMBAAAABAAAAAAAAAAAAAAEBAQAAAAAAQcAAgACBAQlAQYBBwYBAAIDBQEBAAAFBQADAQYBAwcGBgMGAgIFBQYABAQEBgEHAQEBBwMABwAAAAIDAAQCCgQGAAMDAAEABQEEAwEDASYnAQoGAQcAAAAEAgQBAAIACQMEAAAHAQoABQIBAwEABwUCAQMEBgEBAgMBAAEBAQMBAQcDBQIBAgIFAQECAAsBBQIBAgIFAQECAQoDBwcBBgICBwcGBQUDAgEDAQEGBgEGBgoKCgoAAAIABAUFBQUBAwcCAAMABAQAAgMAAAAABAEGBAUEBgEBAQEBAAAAAQAAAAAAAAUDAQQNAQAEBhIGAQUDAgALAgAAAgAABQEABQACDAcFAwAABgUFBQUIAgMBAwEGCQkBAwUCAAICCQMDBQQBAggEBAYABAECAAEAAQAAAAAAAQIIAwEABAEAAQQAAAEEACgCBAUAAgAABQAFAgcCAgAABgAAAAAAAAApAAsIBAUAAAgABQgIAAUFBQUFBQAFBQUFBQMFBQACAAQEAQAACAQEBAQHBQICAQACAwQABAMBAwACDAUIAQEFAAUACQUDAgkAAAACCQgEBQECAAAKCggAAAQAAAUBAgQCAQIGAQIEAgcBAAIBAAIAAAMBAgACAQIAAAEABQQFCgUACQALAAYEBAUHBAMFAAQACQEBAwsGBwsBBgkBAQMBAQYCBwECCwASAQIBAQIBBQEACQEBAgQCAQMFAAIGCAcOAAQGBgQCBAcEAAAABAQFAQUFAAAAAwQBBwQEAwsBBAMBAgAAAAAAKgEAAAAAAAUAAQEGBAYGAAYAAAIDAAEBAQEGCgYGBgYBAAAABgMGCgwBAAEBBgEBAQcCAAAEBAAFAAQGCgIAARMEBAQCKwcAAhQIBgIGLAotAQQAAgIDAAEAAw8EBwUKBAQLBgcCBAUGBAQEBAQFCAkJCQkIBgUGCAYFBgEGBAcBcAGCAYIBBQYBAZAIkAgGCAF/AUGQ2wQLB/MGJgZtZW1vcnkCAARmcmVlAOcMDmhiX2Jsb2JfY3JlYXRlAA0PaGJfYmxvYl9kZXN0cm95AA8GbWFsbG9jAOYMEmhiX2Jsb2JfZ2V0X2xlbmd0aAAUEGhiX2Jsb2JfZ2V0X2RhdGEAFRFoYl9mYWNlX2dldF9lbXB0eQAbDmhiX2ZhY2VfY3JlYXRlADkPaGJfZmFjZV9kZXN0cm95AD0WaGJfZmFjZV9yZWZlcmVuY2VfYmxvYgBFDWhiX3NldF9jcmVhdGUA0gEOaGJfc2V0X2Rlc3Ryb3kA0wEMaGJfc2V0X2NsZWFyAN0BCmhiX3NldF9hZGQA4QEKaGJfc2V0X2RlbADjAQxoYl9zZXRfdW5pb24A5gENaGJfc2V0X2ludmVydADpAR5oYl9zdWJzZXRfaW5wdXRfY3JlYXRlX29yX2ZhaWwAqgIXaGJfc3Vic2V0X2lucHV0X2Rlc3Ryb3kAqwIZaGJfc3Vic2V0X2lucHV0X3JlZmVyZW5jZQCsAhtoYl9zdWJzZXRfaW5wdXRfdW5pY29kZV9zZXQAFBloYl9zdWJzZXRfaW5wdXRfZ2x5cGhfc2V0AK0CE2hiX3N1YnNldF9pbnB1dF9zZXQArgIZaGJfc3Vic2V0X2lucHV0X2dldF9mbGFncwCvAhloYl9zdWJzZXRfaW5wdXRfc2V0X2ZsYWdzALACHWhiX3N1YnNldF9pbnB1dF9zZXRfdXNlcl9kYXRhAEEdaGJfc3Vic2V0X2lucHV0X2dldF91c2VyX2RhdGEAQh9oYl9zdWJz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DEGgI2okACAFC4QDAgZ9Bn8gACoCRCIFIAEoAgQiCMGylCEGIAAqAkAiAyABKAIAIgnBspQhAiAFIAEoAgwgCGrBspQhByADIAEoAgggCWrBspQhBSAAKgI8IgRDAAAAAFwEQCAFIAYgBJQiAyAEIAeUIgQgAyAEYBuSIQUgAiADIAQgAyAEXxuSIQILIAECfyAGjiIDi0MAAABPXQRAIAOoDAELQYCAgIB4CyIINgIEIAECfyACjiICi0MAAABPXQRAIAKoDAELQYCAgIB4CyIJNgIAIAECfyAHjSAIspMiAotDAAAAT10EQCACqAwBC0GAgICAeAsiCjYCDCABAn8gBY0gCbKTIgKLQwAAAE9dBEAgAqgMAQtBgICAgHgLIg02AgggACgCMCILIAAoAjQiDHIEQCABIApBACAMayAMIAAoAiBBAEgbIgprNgIMIAEgCCAKajYCBEEAIAtrIAsgACgCHEEASBshCCAALQAsQQFGBEAgASAIQX5tIAlqNgIACyABIAggDWo2AggLCzgBAX8CQCAAQaASRg0AAkACQCAALQAADgQAAgIBAgsgACABai0AAQ8LIABBAWogARCWASECCyACC7UBAQN/AkAgAiABLwAAIgNBCHQgA0EIdnJB//8DcU8EQAwBCyABIAIQlwEhAwJAIAMgASACQQFqEJcBIgJNBEAgASABLwAAIgRBCHQgBEEIdnJB//8DcRCXASACTw0BCwwBCyABLQACIQUgAS8AACEEIABBADYCCCAAIAIgA2s2AgQgACABQQJqIAUgBEEIdCAEQQh2ckH//wNxQQFqbGogA2o2AgAPCyAAQgA3AgAgAEEANgIIC5MCAgF+An8gAigCSCEFQaASIAIoAtgBIANBGGxqIAIoAtQBIANNGygCFCECIABCADcDACAAQQA6ABAgAEEANgIIIABBFGpBAEGMIBDUDBogASkCACEEIABCADcDoCAgAEEANgIIIAAgBDcDACAAQaggaiIDQQA2AgAgAEHEIGoQ4gMgAEGwImoiBkIANwMAIABCADcDqCIgASkCACEEIABCADcDqCIgAEEANgLAICAAQgA3A7ggIABBATsAtSAgAEEANgKwICADQgA3AwAgACAENwOgICAGQgA3AwAgAEGUImogBRDjAyAAQZwiaiACEOMDIABBADoAyCIgAEEANgK8IiAA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BWovAAAiAkEIdCACQQh2csEiBCABTARAIAAgA0EBdGovAAAiAEEIdCAAQQh2csEgASAEa2oPCyACIAUgAEEEayIFai8AACIGRgRAIAUgA0EBdGovAAAiAEEIdCAAQQh2csEPCyABIAZBCHQgBkEIdnLBIgFrsiAAIANBAXQiAmovAAAiAEEIdCAAQQh2csEgAiAFai8AACIAQQh0IABBCHZywSIAa7KUIAQgAWuylSAAspJDAAAAP5KOIgiLQwAAAE9dBEAgCKgPC0GAgICAeCEBDAILIABBAWohAAwACwALIAELmAIBA38CQCAALQAAQQFHDQAgACABKAIcQQAQiQVFDQAgACABKAIENgIEIABBDGoiAigCACIDQQBIBEAgAiADQX9zNgIACyACQQBBAUEAEI0FGiACIAEoAhBBARD8ARoCQCACKAIAQQBIDQAgASgCFCEDIAIgASgCECIENgIEIARBA3QiBEUNACACKAIIIAMgBBDSDBoLIABBGGoiAigCACIDQQBIBEAgAiADQX9zNgIACyACQQBBAUEAEIwFGiACIAEoAhxBARCOBRoCQCACKAIAQQBIDQAgASgCICEDIAIgASgCHCIENgIEIARByABsIgRFDQAgAigCCCADIAQQ0gwaCwsgAC0AAEEBRgRAIAAgAS0AJDoAJAsLCgAgAEEMahDeAQsZACAAEIAHIAAtAABBAUYEQCAAQQA6ACQLCy4BAX8jAEEQayIBJAAgAUF/NgIMIAAgAUEMahDsARogASgCDCABQRBqJABBf0YLDwAgACABEKIMIAAtACRHCwwAIABBDGogARCOAQsiACAALQAkQQFGBEAgACABIAIQnAxBAQ8LIAAgASACEJ0MCwwAIABBDGogARDkAQscACAALQAkQQFGBEAgACABEJsMDwsgACABEJoMCyEAIAAtACRBAUYEQCAAIAEgAhCdDBoPCyAAIAEgAhCcDAsPACAAQQxqIAFBDGoQ5wELYQEBfwJAIAAtACQiAiABLQAkRgRAIAIEQCAAIAEQpwwMAgsgACABEKgMDAELIAIEQCAAIAEQqQwMAQsgACABEKoMCyAALQAAQQFGBEAgACAALQAkIAEtACRyQQFxOgAkCwthAQF/AkAgAC0AJCICIAEtACRGBEAgAgRAIAAgARCqDAwCCyAAIAEQqQwMAQsgAgRAIAAg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IAMgAUECdGogAkEYdCACQYD+A3FBCHRyIAJBCHZBgP4DcSACQRh2cnI2AAALCz8BAX8jAEEQayIDJAAgAyABNgIMIAAoAiAgA0EMahCCASgCACIAQX9HBEAgAiAANgIACyADQRBqJAAgAEF/RwtjAQJ/IABCADcCACAAQgA3AhAgAEIANwIIIABBGGohAgNAIAFBC0cEQCACIAFBAnRqQX82AgAgAUEBaiEBDAELCyAAQgA3AlAgAEKAgICAgMIINwJIIABCADcCWCAAQgA3AmALOQECfyAAKAIMIgIgACgCCEEEdGohAwNAIAMgAiIARwRAIABBEGohAiAAKAIEIAFHDQELCyAAIANHC18BAn8gAEEEaiADEPcEIgMgATYCBCACKAIIIQEgAigCBCEEIAMgACgCACIFIAIoAgBqNgIAIAMgBCAFayICQQAgAiAETRsiAiABIAVrIgMgAiADSRs6AAggACABNgIACxYAIAAgACgCVCAAQdwAakEAIAEQoQYLTAECfyAAIAFBACABQQBKGyIBQQAQpAIiAgRAAkAgACgCBCIDIAFJBEAgACABEKUCDAELIAEgA08NACAAIAEQogYLIAAgATYCBAsgAgtCAQF/IABBoBIgACgCWCIDKAIIIAFBDGxqIAMoAgQgAU0bQaASIAAoApgBIAFBNGxqIAAoApQBIAFNGyABIAIQoQYLcAECfyAAQbQBahCjBiAAQagBahDzBCAAQZwBahDzBCAAQdwAaiICQTRqIgEoAgAEQCABQQAQsAYgASgCCBDnDAsgAUEANgIIIAFCADcCACACEJ8CGiAAQcgAahAtIABBCGoiAEE0ahDHASAAELYBGguhAgEEfwJAIAAoAgQiAiAAKAIATgRAIAJBAWohBAJAIAAoAgAiA0EASA0AQQEhBSADIARPDQAgAyECA0AgAiAESQRAIAIgAkEBdmpBCGohAgwBCwsCfyACQc2Zs+YATwRAIANBf3MhAkEADAELAn8gACgCCCEDIAJFBEAgAxDnDEEADAELIAMgAkEUbBDoDAsiAyACRXJFBEAgAiAAKAIAIgNNDQIgA0F/cyECQQAMAQsgACADNgIIQQELIQUgACACNgIACyAFRQ0BIAAoAgQhAgsgACACQQFqNgIEIAAoAgggAkEUbGoiACABKAIQNgIQIAAgASkCCDcCCCAAIAEp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AyADQcggajYCtCAgBhDuBCECIAYoAgBBAEgNBCACQgA3AgAgAkIANwIQIAJCADcCCCACQoCAgIBwNwIYIANBtCBqIAIQ7wRFDQQCfyAFIAAoAtQBTwRAQeDQAEIANwMAQdjQAEIANwMAQdDQAEIANwMAQdDQAAwBCyAAKALYASAFQRhsagshBCABIAIoAhAgACACQRRqENQEIgdBoBJGDQQgAigCFCECIANBADoAICAIQQBBjCAQ1AwaIANBADYCGCADIAI2AhQgAyAHNgIQIAMgA0EQajYCDCAEQQA2AhAgBEIANwIIIARCADcCACAEQaASNgIUIANBDGogBBDuBkUNBCAEIAcgBCgCECAAEOgENgIUIAVBAWohBSAAKAJYIQQMAAsACwJ/IAAoAtQBRQRAQeDQAEIANwMAQdjQAEIANwMAQdDQAEIANwMAQdDQAAwBCyAAKALYAQshAiABIAAoArgBIAAgAEG8AWoQ1AQiAUGgEkYNAiAAKAK8ASEEIANBADoA2CAgA0HcIGpBAEGMIBDUDBogA0EANgLQICADIAQ2AswgIAMgATYCyCAgAyADQcggajYCECACQQA2AhAgAkIANwIIIAJCADcCACACQaASNgIUIANBEGogAhDuBkUNAiACIAEgAigCECAAEOgENgIUDAMFAn8gAiAAKALUAU8EQEHg0ABCADcDAEHY0ABCADcDAEHQ0ABCADcDAEHQ0AAMAQsgACgC2AEgAkEYbGoLIgRCADcCACAEQaASNgIUIARBADYCECAEQgA3AgggAkEBaiECDAELAAsACyAAEPEECyADQfDAAGokACAAQQA2AuQBIAALawEDfyAAQQRrIQIDQAJAIAAoAgAiAUUEQCACKAIARQRAQaASDwsgAEEEaygCACEDQQFB6AEQ6gwiAQRAIAEgAxDqAhoLIAFBoBIgARshASAAKAIADQEgACABNgIACyABDwsgARDbAgwACwALoQIBBH8jAEEQayIEJAAjAEFAaiIBJAACQAJAIAAoApwQIgJBBGogAEH0C2ogAhsiAi0ADEEBRw0AIAFBwqrNugQ2AgggAiABQQhqIgNBABCFAUUNACABQcKqzboENgIIIAIgAxCkBSgCACIARQ0BIAAoAgAiAkUNASAAIAJBAWo2AgAMAQsgAUIANwMQIAFCADcDGCABQgA3AB0gAUIA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AiAAIAJBCGsQygMaDAILIAQgBCACIARBf0cbIAtBAXEbIQQgBSAIQQFqIgggAmpxIQIMAAsACyAFCxcAIAAgARDLAyAAQQA2AhwgAEEtNgIYC1wBAn8CfyAAKAIERQRAQdDQAEIANwMAQdjQAEEANgIAQdDQAAwBCyAAKAIACyAAKAIcIgJBAXVqIQEgACgCGCEAIAEgAkEBcQR/IAEoAgAgAGooAgAFIAALEQIAC6MCAQR/IAAtAAxBAUcEQEEADwsCQCABBEAgACgCGCABQQF2IAFqSw0BC0EMQSAgACgCECICIAEgASACSRtBAXRBCGoiAWdrQQAgARsiAXQiAxDmDCICRQRAIABBADoADEEADwsgAUEdTQRAIAJBACADENQMGgsgAEIANwIQIAAoAhghAyAAQX8gAXRBf3M2AhggAUEfSwR/Qf////8HBSABQQJ0QZDGAGooAgALIQQgACgCICEFIAAgAjYCICAAIAQ2AhwgACABQQF0OwEOAkAgA0UNACADQQFqIQNBACEBA0AgASADRg0BIAUgAUEMbGoiAigCBCIEQQFxBEAgACACIARBAnYgAkEIahDHAxoLIAFBAWohAQwACwALIAUQ5wwLQQELCwAgACABQS4Q+QwLVwEBfiACKQIAIQQgACABKQIANwIAIAAgASgCCDYCCCAAIAM2AhQgACAENwIMIABBDGohAQNAAkAgACgCBEUNACABIAAoAgAQzQMNACAAEMYDDAELCyAACzUBAX8gASAAKAIEIgJBAXVqIQEgACgCACEAIAEgAkEBcQR/IAEoAgAgAGooAgAFIAALEQIAC8YBAQN/IwBBEGsiAyQAIABBADYCGCAAQgA3AhAgACAAKAIANgIEIAAgACgCDDYCCCAAENADIANBADYCDAJAAkAgAEEwaiIBKAIEIgIgASgCAE4EQCABIAJBAWpBABDYAUUNASABKAIEIQILIAEgAkEBajYCBCABKAIIIAJBAnRqQQA2AgAMAQtB0NAAQQA2AgALIABCADcBSiAAQQE6AEggAEEANgJEIABCgYCAgBA3AjwgAEIANwFSIABCADcBWCADQRBqJAALNwEBfwJ/IAAoAhgiA0UgASgCAEEASHFFBEBBACADDQEaQQEgAi0ADA0BGgsgAEEBNgIYQQALGgt3AQN/IAAoAjggACgCNCICQQBHQQJ0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IghqIgJCADcCACACQQA2AhggAkIANwIQIAJCADcCCCACIAAoAgggCGoiCRDiBCACIAkoAhg2AhggAiAJKQIQNwIQIAAoAgggCGpBBGoQLSAEQQFqIQQMAAsACyAHKAIAEOcMIAYLIgIgAUVyRQRAIAEgACgCACICTQ0CIAJBf3MhAUEADAELIAAgAjYCCEEBCyEFIAAgATYCAAsgBQRAAkAgACgCBCIBIANJBEAgACgCBCEBA0AgASADSQRAIAAoAgggAUEcbGoiAUIANwIAIAFBADYCGCABQgA3AhAgAUIANwIIIAAgACgCBEEBaiIBNgIEDAELCwwBCyABIANNDQAgACADENcECyAAIAM2AgQLIAULTQAgACAAKAIEQQFqENEERQRAQeDQAEIANwMAQdjQAEIANwMAQdDQAEIANwMAQejQAEEANgIAQdDQAA8LIAAoAgggACgCBEEcbGpBHGsL/QEBBX8gAUIANwIAIAFBADYCGCABQgA3AhAgAUIANwIIIAAoAgAiAigCBCEDIAIoAgghBANAAkAgBEEBaiADSyIFDQAgAhCYASEEIAAoAgAhAiMAQRBrIgMkAAJAAkAgBEESRgRAIAEgAkEQaiIGEOMENgIQIAEgBhDjBDYCFCACQQA2AhQMAQsgBCACENwEIAIoAhQNAQsgAigCCCACKAIESw0AIAItABBBAXENACADQQA2AgggA0IANwMAIANB//8DNgIEIAEgBCACIAMQ2gQLIANBEGokACAAKAIAIgIoAggiBCACKAIEIgNLDQAgAi0AEEEBcUUNAQsLIAULPAEBf0GgEiEEAkAgAUUNACACKAIMIAAgAWoiACACKAIEa0kNACAAQaASIAIgACADKAIAENYEGyEECyAECy0AIAAQNyAAQThqEC0gAEHsAGoQ2AQgAEH4AGoQ2AQgACgCMBAPIABBADYCMAsNACAAIAEgAkEBEKUECw0AIAAgAUEcQRgQ7gwLJwAgACgCAARAIABBABDXBCAAKAIIEOcMCyAAQQA2AgggAEIANwIACw0AIAAgAUECQQUQ7wwLXgECfyAAQQRqIAMQJSIDIAE2AgQgAigCCCEBIAIoAgQhBCADIAAoAgAiBSACKAIAajYCACADIAQgBWsiAkEAIAIgBE0bIgIgASAFayIDIAIgA0kbOgAIIAAgATYCAAtNAAJAAkAg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CEEBCyEFIAAgATYCAAsgBQRAAkAgACgCBCIBIANJBEAgACgCBCEBA0AgASADSQRAIAAoAgggAUEFdGoiAUIANwIAIAFCADcCGCABQgA3AhAgAUIANwIIIAAgACgCBEEBaiIBNgIEDAELCwwBCyABIANNDQAgACADEPwECyAAIAM2AgQLIAVFBEBB6NAAQgA3AwBB4NAAQgA3AwBB2NAAQgA3AwBB0NAAQgA3AwBB0NAADwsgACgCCCAAKAIEQQV0akEgawuyAgEFfyABQgA3AgAgAUIANwIQIAFCADcCCCABQoCAgIBwNwIYIAAoAgAiAigCBCEDIAIoAgghBANAAkAgBEEBaiADSyIGDQAgAhCYASEDIAAoAgAhAiMAQRBrIgQkAAJAAkACQAJ/AkACQAJAIANBhQJrDgMEAQQACyADQRJGDQEgA0GmAkcNACACQRBqIQVBHAwCCyADIAIQ3AQgAigCFEUNAwwECyABIAJBEGoiBRDjBDYCEEEUCyABaiAFEOMENgIACyACQQA2AhQLIAIoAgggAigCBEsNACACLQAQQQFxDQAgBEEANgIIIARCADcDACAEQf//AzYCBCABIAMgAiAEENoECyAEQRBqJAAgACgCACICKAIIIgQgAigCBCIDSw0AIAItABBBAXFFDQELCyAGC6cCAQV/IAFCADcCACABQaASNgIUIAFBADYCECABQgA3AgggACgCACICKAIEIQMgAigCCCEEA0ACQCAEQQFqIANLIgUNACACEJgBIQMgACgCACECIwBBEGsiBCQAIARBADoADCAEQoCAgIDw/z83AgQCQAJAAkACQCADQRVLDQBBASADdEHAn8ABcQ0BIANBE0cNACABIAJBEGoQ+QM2AhAMAQsgA0GJAmsiBkEKTUEAQQEgBnRBvw5xGw0AIAMgAhDcBCACKAIURQ0BDAILIAJBADYCFAsgAigCCCACKAIESw0AIAItABBBAXENACABIAMgAiAEQQRqENoECyAEQRBqJAAgACgCACICKAIIIgQgAigCBCIDSw0AIAItABBBAXFFDQELCyAFCy4AIAAQNyAAQeAAahAtIABBxAFqEPMEIABB0AFqEPQEIAAoAjAQDyAAQQA2AjALDQAgACABQRhBFBDuDAsnACAAKAIABEAgAEEAEPwEIAAoAggQ5wwLIABBADYCCCAAQgA3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IAAvAAIiA0EIdCADQQh2ckH//wNxIgMgAS8AAiIEQQh0IARBCHZyQf//A3EiBEkNASADIARLDQBBfyECIAAvAAQiAEEIdCAAQQh2ckH//wNxIgAgAS8ABCIBQQh0IAFBCHZyQf//A3EiAUkNACAAIAFLIQILIAIPC0F/C4oBAQd/AkAgASgCDCIGIAEoAggiAmsiByABKAIEIgggASgCACIDayIEaiIFRQRADAELIAUQ5gwiAUUEQAwBCyADIAhHBEAgASADIAQQ0gwaCyACIAZHBEAgASAEaiACIAcQ0gwaCyAAQQA2AgggACAFNgIEIAAgATYCAA8LIABCADcCACAAQQA2AggLewEFfyACQf////8DcSIEIAAoAhxwIQIDQAJAIAAoAiAgAkEMbGoiBigCBCIHQQJxBH8gB0ECdiAERw0BIAYgARCQBkUNAUEAIAAoAiAgAkEMbGoiACgCBEEBcWsgAHEFQQALDwsgACgCGCADQQFqIgMgAmpxIQIMAAsAC6ICAQR/IAAtAAxBAUcEQEEADwsCQCABBEAgACgCGCABQQF2IAFqSw0BC0EMQSAgACgCECICIAEgASACSRtBAXRBCGoiAWdrQQAgARsiAXQiAxDmDCICRQRAIABBADoADEEADwsgAUEdTQRAIAJBACADENQMGgsgAEIANwIQIAAoAhghAyAAQX8gAXRBf3M2AhggAUEfSwR/Qf////8HBSABQQJ0QZDGAGooAgALIQQgACgCICEFIAAgAjYCICAAIAQ2AhwgACABQQF0OwEOAkAgA0UNACADQQFqIQNBACEBA0AgASADRg0BIAUgAUEMbGoiAigCBCIEQQFxBEAgACACIARBAnYgAkEIahCNAgsgAUEBaiEBDAALAAsgBRDnDAtBAQusAQEGfyAAKAIAIQIgASgCACEBIwBBIGsiACQAAkAgAigCBCACKAIAIgRrIgUgASgCBCABKAIAIgZrRw0AIAIoAgwiByABKAIMRw0AIAQgBiAFEKgDDQAgAigCECECIABBADYCHCAAIAdBDGwiAzYCGCAAIAI2AhQgASgCECEBIABBADYCECAAIAM2AgwgACABNgIIIABBFGogAEEIahCiAyEDCyAAQSBqJAAgAwuGAQEDfyMAQRBrIgIkACABQQFqQYgDTwRAIAIgAUGHA2s2AgwgAiAAKAIANgIIAn8gAEEEaiIBIAJBDGoiAyACQQhqIgRBABCAAQRAIABBKGogAxDaARogACAAKAIAQQFqNgIAIAQMAQsgASACQQxqEIIBCygCAEGHA2ohAQsgAkEQaiQAIAELpwQBBH8gACgCOCIDQaASRwRAAn8gACgC3AEhBEEAIQACQAJAAkACQCADLQAADgMAAQIDCyABRSABIARPcg0CIAFBAXQgA2pBAWsvAAAiAEEIdCAAQQh2ckH//wNxDAMLAn8gA0EBaiEGQQAgASAETw0AGgJ/AkACQCACRQ0AIAIoAgQiACABSw0AIAIoAgAhAwwBC0EBIQBBACIDIAFFDQEaCyABIABrIQEDfyAGIANBA2xqIgQtAAIiBSABTwR/IAIEQCACIAA2AgQgAiADNgIACyABIAQvAAAiAEEIdCAAQQh2ckH//wNxagUgA0EBaiEDIAEgBUEBaiIEayEBIAAgBGohAAwBCwsLCwwCCwJ/IANBAWohBkEAIAEgBE8NABoCfwJAAkAgAkUNACACKAIEIgAgAUsNACACKAIAIQMMAQtBASEAQQAiAyABRQ0BGgsgASAAayEBA38gBiADQQJ0aiIELwACIgVBCHQgBUEIdnJB//8DcSIFIAFPBH8gAgRAIAIgADYCBCACIAM2AgALIAEgBC8AACIAQQh0IABBCHZyQf//A3FqBSADQQFqIQMgASAFQQFqIgRrIQEgACAEaiEADAELCwsLIQALIAALDwtBACECAkACQAJAAkAgACgCsAEOAwABAgMLIAFBACABQeUBSRsPCyABQaUBSw0BIAFBAXRBoAxqLwEADwsgAUHWAEsNACABQQF0QfAOai8BACECCyACC1QBA38gACgCCEEEayEEIAAoAgQhAAN/IAAEfyAEIABBA3RqIgMgASADKAIAIgNBf3NqIgE2AgAgAEEBayEAIAEgAnIhAiADIQEMAQUgAkH/AUsLCwsLACAAIAFBARCkBgtRAQF/AkAgACgCBCICIAAoAgBOBEAgACACQQFqQQAQwQJFDQEgACgCBCECCyAAIAJBAWo2AgQgACgCCCACaiABKAIAOgAADwtB0NAAQQA6AAALDQAgACABQQFBARC/AgsLACAAIAFBARCZBguBAQECfyAAIAFBACABQQBKGyIBQQAQpAIiAwRAAkAgACgCBCICIAFJBEAgACgCBCECA0Ag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AQR/IAAgAUEIdCABQQh2ckH//wNxagVBoBILLwAAIgFBCHQgAUEIdnJB//8DcSEDIAJB7ABqIAAvAAQiAQR/IAAgAUEIdCABQQh2ckH//wNxagVBoBILELoFIgFBADYCFCABQQE2AhwgASADNgIYIAIgASkCEDcDqAEgAiABKQIINwOgASACIAEpAhg3A7ABIAIgASkCADcDmAEgAkG2HjYCpAIgAiACKALsAUEIajYCoAIgAkHwAWogAkGYAWogAkGgAmoQ2AcgAkG3HjYCmAIgAC8ACiIBBH8gACABQQh0IAFBCHZyQf//A3FqBUGgEgshAyACQZgBaiACQfABaiIBQSwQ0gwaIAJBxABqrSAArUIghoQhDyACQewAaiABENkHA0AgAkGYAWoiASACQewAahDaBwRAIAEQ2wchBEEAIQEgAkEANgJoIAJCADcCYCADIAQQkwUvAAAhBSACQQE2AlwgAkEANgJUIAIgBUEIdCAFQQh2ckH//wNxNgJYIAJByABqIAJB1ABqEOgCA0AgAigCSCABRgRAIAMgBBCTBSACQQA2AhggAkEANgIIIAIgAikCZEIgiSIQNwIQIAIgEDcDACACKALsASACEOsHIAJB4ABqEC0gAkGYAWoQ3AcMAwUgAiABNgJEIAAvAAYhBSACQQE2AiwgAkEANgIkIAIgBUEIdCAFQQh2ckH//wNxNgIoIAJBxRc2AiAgAiACQcgBajYCHCACQTBqIAJBJGogAkEcahDsByACIAJBQGsoAgA2ArACIAIgAikCODcDqAIgAiACKQIwNwOgAiACIA83ArQCA0AgAigCoAIiBSACKAKkAkcEQCACIAUgAigCtAIoAgAgAigCuAIvAAYiCEEIdCAIQQh2ckH//wNxbGo2ArwCIAJB4ABqIAJBvAJqENoBGiACQaACahDtBwwBCwsgAUEBaiEBDAELAAsACwsgAkHIAWoQLyACQcACaiQACw8LIAAgARDWBw8LIAAvAABBgAJGBEAgACgABCICBH8gACACQRh0IAJBgP4DcUEIdHIgAkEIdkGA/gNxIAJBGHZycmoFQaASCyABIAAvAAIiAEEIdCAAQQh2ckH//wNxENUHCwsL5gcCA38BfiAALwAAQYACRgRAIwBBoAJrIgIkACACIAE2AswBIAJBxABqIgQgAC8AAiIDBH8gACADQQh0IANBCHZyQf//A3FqBUGgEgsgAC8ACCIDBH8gACADQQh0IANBCHZyQf//A3FqBUGgEgsQswUgAkG2HjYCrAEgAiABQQhqNgKoASACQfAAaiIBIAQgAkGoAWoQ5wcgAkHQAWogAUEoENIMGiACQbceNgL4ASACIAA2AoQCIAIgAkHMAWo2AoACA0AgAkHQAWoiARC2BQRAIAJBgAJqIAEQwQUQ6AcgARDpBwwBCwsgAkIANwG+ASACQgA3AcQBIAJCADcBtgEgAkEBOgC0ASACQQA2ArABIAJCgYCAgBA3AqgBIAAvAAIiAQR/IAAgAUEIdCABQQh2ckH//wNxagVBoBILIAAvAAgiAQR/IAAgAUEIdCABQQh2ckH//wNxagVBoBILIAIoAswBKAIIIAJBqAFqEOoHIAAvAAoiAQR/IAAgAUEIdCABQQh2ckH//wNxagVBoBILLwAAIgFBCHQgAUEIdnJB//8DcSEDIAJBxABqIgQgAC8ABCIBBH8gACABQQh0IAFBCHZyQf//A3FqBUGgEgsQugUiAUEANgIUIAFBATYCHCABIAM2AhggAiABKQIQNwOAASACIAEpAgg3A3ggAiABKQIYNwOIASACIAEpAgA3A3AgAkG2HjYChAIgAiACKALMAUEIajYCgAIgAkHQAWoiASACQfAAaiIDIAJBgAJqENgHIAJBtx42AvgBIAJBADYCpAEgAkIANwKcASADIAFBLBDSDBogAkFAa60gAK1CIIaEIQUgBCABENkHA0AgAkHwAGoiASACQcQAahDaBwRAIAIgARDbBzYCQCAALwAGIQEgAkEBNgIoIAJBADYCICACIAFBCHQgAUEIdnJB//8DcTYCJCACQcUXNgIcIAIgAkGoAWo2AhggAkEsaiACQSBqIAJBGGoQ7AcgAiACKAI8NgKQAiACIAIpAjQ3A4gCIAIgAikCLDcDgAIgAiAFNwKUAgNAIAIoAoACIgEgAigChAJHBEAgAiABIAIoApQCKAIAIAIoApgCLwAGIgNBCHQgA0EIdnJB//8DcWxqNgKcAiACQZwBaiACQZwCahDaARogAkGAAmoQ7QcMAQsLIAJB8ABqENwHDAEFIAAvAAoiAQR/IAAgAUEIdCABQQh2ckH//wNxagVBoBILIAJBADYCFCACQQA2AgggAiACKQKgAUIgiSIFNwIMIAIgBTcDACACKALMASACEOsHIAJBnAFqEC0gAkGoAWoQLyACQaACaiQACwsLC/YCAQN/IAAvAAAiAEEIdCAAQQh2ciIEQf//A3EhBiAAQQl2QQFxIARBAXFqIABBCnZBAXFqIABBC3ZBAXFqIQAgBEEQcQRAQaASIQRBoBIgAygCACAAQQF0aiADKAIEIABNGy8AACIFBH8gAiAFQQh0IAVBCHZyQf//A3FqBUGgEgsgARDUByAAQQFqIQALIAZBIHEEQEGgEiEEQaASIAMoAgAgAEEBdGogAygCBCAATRsvAAAiBQR/IAIgBUEIdCAFQQh2ckH//wNxagVBoBILIAEQ1AcgAEEBaiEACyAGQcAAcQRAQaASIQRBoBIgAygCACAAQQF0aiADKAIEIABNGy8AACIFBH8gAiAFQQh0IAVBCHZyQf//A3FqBUGgEgsgARDUByAAQQFqIQALIAZBgAFxBEBBoBIhBEGgEiADKAIAIABBAXRqIAMoAgQgAE0bLwAAIgAEfyACIABBCHQgAEEIdnJB//8DcWoFQaASCyABENQHCwtOAQF/IwBBIGsiAyQAIAMgASkCGDcDGCADIAEpAhA3AxAgAyABKQIINwMIIAMgASkCADcDACAAIAMgAigCACACKAIEEN0HGiADQSBqJAALNAEBfyMAQSBrIgIkACACIAEQ3gcgACACIAEoAiAgASgCJBDdByABKAIoNgIoIAJBIGokAAsVACAAIAEQ4AcgACgCFCABKAIUR3ELDQAgABC8BRogACgCFAsxAQJ/A0ACQCAAEMYFIAAQxAVFDQAgACgCICAAELwFIQIoAgBBDGogAhDgAUUNAQsLC2gAIAAgASkCADcCACAAIAEpAhg3AhggACABKQIQNwIQIAAgASkCCDcCCCAAIAM2AiQgACACNgIgA0ACQCAAEMQFRQ0AIAAoAiAgABC8BSECKAIAQQxqIAIQ4AENACAAEMYFDAELCyAAC0kBAX8jAEEgayICJAAgAkEMaiABEN8HIABBFGogAUEUahDoAiAAIAIoAhw2AhAgACACKQIUNwIIIAAgAikCDDcCACACQSBqJAALqQEBAn8jAEEQayICJAAgAEGgEhC6BSIAIAEoAgAiAzYCAAJAAkACQCADQQFrDgIAAQILIAEoAgQiAy8AAiEBIAAgAzYCBCAAIAFBCHQgAUEIdnJB//8DcTYCCAwBCyACIAEoAgQQvwUgASgCBC8AAiEBIAJBADYCDCACIAFBCHQgAUEIdnJB//8DcTYCBCAAIAIpAgg3AgwgACACKQIANwIECyACQRBqJAALUQECfyAAKAIAIgMgASgCAEcEQEEBDwsCQAJAAkAgA0EBaw4CAAECCyAAKAIIIAEoAghHDwsgACgCCCABKAIIRyAAKAIQIAEoAhBHciECCyACC4cDAQV/AkACQAJAIAAvAAAiAkEIdCACQQh2ckH//wNxQQFrDgIAAQILAn8gAC8ABCIDQQh0IANBCHZyQf//A3EhAiABQQxqIQQgAEEGaiEGQQAhAQJAA0AgASEDAkADQCACIANGDQFBoBIgBiADQQF0aiAALwAEIgVBCHQgBUEIdnJB//8DcSADTRsvAAAEQCADQQFqIQMMAQsLIAEgA0cEQCAEIAEgAC8AAiIFQQh0IAVBCHZyQf//A3EiBWogAyAFahDiAUUNAwsgA0EBaiEBDAELCyABIAJHBEAgBCABIAAvAAIiAEEIdCAAQQh2ckH//wNxIgBqIAAgAmoQ4gFFDQELQQEMAQtBAAsPCyAAQQRqIgIgAC8AAiIAQQh0IABBCHZyQf//A3FBBmxqIQADQAJAIAAgAkYiAw0AIAIvAAQEQCABQQxqIAIvAAAiBEEIdCAEQQh2ckH//wNxIAIvAAIiBEEIdCAEQQh2ckH//wNxEOIBRQ0BCyACQQZqIQIMAQsLCyADC0sAIAAgASkCADcCACAAIAEoAgg2AgggACADNgIQIAAgAjYCDANAAkAgACgCBCIBQX9GDQAgACgCDCABEOQHDQAgABC9AQwBCwsgAAtOACAAIAEpAgA3AgAgACABKAIINgIIIAAgAzYCECAAIAI2AgwDQAJAIAAoAgQiAUF/Rg0AIAAoAgxBDGogARDgAQ0AIAAQvQEMAQsLIAALDAAgACABEJUFQX9HCw8AIAAQvgUgAEEUahDZAwtcAQF/IAAvAABBgAZGBEAgAC8ABiICBH8gACACQQh0IAJBCHZyQf//A3FqBUGgEgsgARDUByAALwAIIgIEfyAAIAJBCHQgAkEIdnJB//8DcWoFQaASCyABENQHCwuAAQIBfwF+IwBBEGsiAyQAIAIpAgAhBCAAIAEpAgA3AgAgACABKQIINwIIIAAgASkCEDcCECAAIAEpAhg3AhggACAENwIgA0ACQCAAELYFRQ0AIAAoAiAgA0EIaiAAELcFKAIAQQxqIAMoAggQ4AENACAAEOUHDAELCyADQRBqJAALXAECfyAAKAIAKAIAIQMgACgCBCICLwAIIgAEfyACIABBCHQgAEEIdnJB//8DcWoFQaASCyECIAEvAAIiAAR/IAIgAEEIdCAAQQh2ckH//wNxagVBoBILIAMQ5gcLRwECfyMAQRBrIgEkAANAAkAgABDlByAAELYFRQ0AIAAoAiAgAUEIaiAAELcFKAIAQQxqIAEoAggQ4AFFDQELCyABQRBqJAALhAMBAn8jAEHAAWsiBCQAIARBAToAYCAEQQA2AlwgBEKBgICAEDcCVCAEQeQAakEAQSEQ1AwaIARBCGoiBSAAIAEQswUgBEG2HjYCBCAEIAI2AgAgBEEoaiIAIAUgBBDuByAEQYgBaiAAQSgQ0gwaIARBADYCuAEgBEE9NgK0ASAEQbceNgKwASAEQeAAaiECA0AgBEGIAWoiABC2BQRAIAAQwQUgBCgCuAEiBUEBdWohACAEKAK0ASEBIAIgACAFQQFxBH8gACgCACABaigCAAUgAQsRAgAQjgEgBEGIAWoQ8AcaDAELCyAEQQA2AgggBEGIAWogBEHUAGoQuAEgBCAEKAKQATYCMCAEIAQpAogBNwMoIAQoAogBIQADQAJAIAQoAiwiAUF/RgRAIAQoAiggAEYNAQsgBCABNgIAIAMgBEEAEIUBRQRAIAMgBCAEQQhqQQEQgAEaIAQgBCgCCEEBajYCCAsgBEEoahC9AQwBCwsgBEHUAGoQtgEaIARBwAFqJAALYQEDfyAAQQJqIQQgAigCACIDIAIoAgRBAnRqIQUDQCADIAVGRQRAIAQgAygCAEEBdGovAAAiAgR/IAAgAkEIdCACQQh2ckH//wNxagVBoBILIAEQ5gcgA0EEaiEDDAELCws6AQF/IwBBEGsiAyQAIAMgASgCCDYCCCADIAEpAgA3AwAgACADIAIoAgAgAigCBBDxBxogA0EQaiQAC08BA38jAEEQayIBJAADQAJAIAAgACgCACAAKAIIaiICNgIAIAIgACgCBEYNACAAKAIMIAEgAjYCDCABQQxqQQAQhQFFDQELCyABQRBqJAALTgEBfyMAQSBrIgMkACADIAEpAhg3AxggAyABKQIQNwMQIAMgASkCCDcDCCADIAEpAgA3AwAgACADIAIoAgAgAigCBBDyBxogA0EgaiQACxcAIAAvAAAiAEEIdCAAQQh2ckH//wNxC0YBAn8jAEEQayIBJAADQAJAIAAQ5QcgABC2BUUNACAAKAIgIAFBCGogABC3BUEMaiABKAIIEOABRQ0BCwsgAUEQaiQAIAALfQIBfwF+IwBBEGsiBCQAIAAgASkCACIFNwIAIAAgASgCCDYCCCAAIAM2AhAgACACNgIMIAWnIQEDQAJAIAEgACgCBEYNACAAKAIMIAQgATYCDCAEQQxqQQAQhQENACAAIAAoAgAgACgCCGoiATYCAAwBCwsgBEEQaiQAIAALfQEBfyMAQRBrIgQkACAAIAEpAgA3AgAgACABKQIYNwIYIAAgASkCEDcCECAAIAEpAgg3AgggACADNgIkIAAgAjYCIANAAkAgABC2BUUNACAAKAIgIARBCGogABC3BUEMaiAEKAIIEOABDQAgABDlBwwBCwsgBEEQaiQAIAALsQMBB38gAC8AAiIDBH8gACADQQh0IANBCHZyQf//A3FqBUGgEgsiB0ECaiIAIAcvAAAiA0EIdCADQQh2ckH//wNxQQZsaiEIA0AgACAIRwRAIAFBtAJqIAAoAAAiA0EYdCADQYD+A3FBCHRyIANBCHZBgP4DcSADQRh2cnIQ4AEEQCAALwAEIgMEfyAHIANBCHQgA0EIdnJB//8DcWoFQaASCyIDLwAAIgQEfyADIARBCHQgBEEIdnJB//8DcWoFQaASCyIFQQRqIgQgBS8AAiIGQQh0IAZBCHZyQf//A3FBAXRqIQkDQCAEIAlHBEAgBC8AACIGBH8gBSAGQQh0IAZBCHZyQf//A3FqBUGgEgsgAhD5ByAEQQJqIQQMAQsLIAMvAAIiBAR/IAMgBEEIdCAEQQh2ckH//wNxagVBoBILIAEgAhD4ByADQQZqIgQgAy8ABCIFQQh0IAVBCHZyQf//A3FBBmxqIQYDQCAEIAZHBEAgBC8ABCIFBH8gAyAFQQh0IAVBCHZyQf//A3FqBUGgEgsgASACEPgHIARBBmohBAwBCwsLIABBBmohAAwBCwsLjgEBAn8CQCABKAIMIAAgASgCBGtJDQAgASgCCCAAa0EISQ0AIAAvAABBgAJHDQAgAEEEaiABIAAQ9QdFDQAgAEEGaiABIAAQ9QdFDQBBASECIAAoAAAiA0EYdCADQYD+A3FBCHRyIANBCHZBgP4DcSADQRh2cnJBgYAESQ0AIABBCGogASAAEKAEIQILIAILmQgBEn8CQCAAIAEQmwVFDQBBASELAkAgAC8AACIERQ0AAkAgASgCDCACIARBCHQgBEEIdnJB//8DcWoiBCABKAIEa0kNACABKAIIIARrQQRJDQACfwJAIAQgARCbBUUNAEEBIQcCQCAELwAAIgJFDQAgBCACQQh0IAJBCHZyQf//A3FqIAEQowQNACABKAIgIgJBH0sNASABIAJBAWo2AiBBACEHIAEtABxBAUcNACAEQQA7AABBASEHCyAHDAELQQALRQ0AAn8CQCAEQQJqIAEQmwVFDQBBASEMAkAgBC8AAiICRQ0AAkAgASgCDCAEIAJBCHQgAkEIdnJB//8DcWoiCCABKAIEa0kNACABKAIIIAhrQQJJDQAgCCABEJwFRQ0AIAgvAAAiAkEIdCACQQh2ckH//wNxIREgCEECaiESQQAhBwNAIAcgEUYiDQ0BIAdBBmwhAyAHQQFqIQdBACECQQAhEAJAIAEoAgwgAyASaiIJIAEoAgRrSQ0AIAEoAgggCWtBBkkNAAJ/AkAgCUEEaiABEJsFRQ0AQQEhDgJAIAkvAAQiAkUNAAJAIAEoAgwgCCACQQh0IAJBCHZyQf//A3FqIgIgASgCBGtJDQAgASgCCCACa0EGSQ0AAn8CQCACIAEQmwVFDQBBASEDAkAgAi8AACIFRQ0AQQAhCgJAIAEoAgwgAiAFQQh0IAVBCHZyQf//A3FqIgUgASgCBGtJDQAgASgCCCAFa0EESQ0AIAVBAmogARCWBEUNACAFLwACIgZBCHQgBkEIdnJB//8DcSEPIAVBBGohE0EAIQYDQCAGIA9GIgoNASAGQQF0IRQgBkEBaiEGIBMgFGogASAFEPcHDQALCyAKDQAgASgCICIDQR9LDQEgASADQQFqNgIgQQAhAyABLQAcQQFHDQAgAkEAOwAAQQEhAwsgAwwBC0EAC0UNACACQQJqIAEgAhD2B0UNACACQQRqIAEQnAVFDQAgAi8ABCIDQQh0IANBCHZyQf//A3EhCiACQQZqIQ9BACEDA0AgAyAKRiIQDQEgA0EGbCEGIANBAWohA0EAIQUCQCABKAIMIAYgD2oiBiABKAIEa0kNACABKAIIIAZrQQZJDQAgBkEEaiABIAIQ9gchBQsgBQ0ACwsgEA0AIAEoAiAiAkEfSw0BIAEgAkEBajYCIEEAIQ4gAS0AHEEBRw0AIAlBADsABEEBIQ4LIA4MAQtBAAshAgsgAg0ACwsgDQ0AIAEoAiAiAkEfSw0BIAEgAkEBajYCIEEAIQwgAS0AHEEBRw0AIARBADsAAkEBIQwLIAwMAQtBAAshDQsgDQ0AIAEoAiAiAkEfSw0BIAEgAkEBajYCIEEAIQsgAS0AHEEBRw0AIABBADsAAEEBIQsLIAsPC0EAC7sCAQd/AkAgACABEJsFRQ0AQQEhBQJAIAAvAAAiA0UNAAJAIAEoAgwgAiADQQh0IANBCHZyQf//A3FqIgIgASgCBGtJDQAgASgCCCACa0EGSQ0AIAIgASACEPcHRQ0AIAJBAmogASACEPcHRQ0AIAJBBGogARCSBEUNACACLwAEIgNBCHQgA0EIdnJB//8DcSEHIAJBBmohCEEAIQMDQCADIAdGIgkNASADQQN0IQQgA0EBaiEDQQAhBgJAIAEoAgwgBCAIaiIEIAEoAgRrSQ0AIAEoAgggBGtBCEkNACAEQQRqIAEgAhD3B0UNACAEQQZqIAEgAhD3ByEGCyAGDQALCyAJDQAgASgCICICQR9LDQEgASACQQFqNgIgQQAhBSABLQAcQQFHDQAgAEEAOwAAQQEhBQsgBQ8LQQAL+AEBA38CQCAAIAEQmwVFDQBBASEEAkAgAC8AACIDRQ0AAn8CQCABKAIMIAIgA0EIdCADQQh2ckH//wNxaiICIAEoAgRrSQ0AIAEoAgggAmtBAkkNAAJAAkACQCACLwAAIgNBCHQgA0EIdnJB//8DcUEBaw4DAAECAwsgASgCCCACa0EDSyABKAIMIAIgASgCBGtPcQwDCyABKAIIIAJrQQdLIAEoAgwgAiABKAIEa09xDAILIAIgARCgBSEFCyAFCw0AIAEoAiAiAkEfSw0BIAEgAkEBajYCIEEAIQQgAS0AHEEBRw0AIABBADsAAEEBIQQLIAQPC0EAC4QCAQN/IAAvAAAiAwR/IAAgA0EIdCADQQh2ckH//wNxagVBoBILIAIQ+QcgAC8AAiIDBH8gACADQQh0IANBCHZyQf//A3FqBUGgEgsgAhD5ByAAQQZqIgMgAC8ABCIFQQh0IAVBCHZyQf//A3FBA3RqIQUDQCADIAVHBEAgAUGAAmogAygAACIEQRh0IARBgP4DcUEIdHIgBEEIdkGA/gNxIARBGHZychDgAQRAIAMvAAQiBAR/IAAgBEEIdCAEQQh2ckH//wNxagVBoBILIAIQ+QcgAy8ABiIEBH8gACAEQQh0IARBCHZyQf//A3FqBUGgEgsgAhD5BwsgA0EIaiEDDAELCwtsACAALwAAQYAGRgRAIAFBDGogAC8ABCIBBH8gACABQQh0IAFBCHZyQf//A3FqBUGgEgsiAC8ABEGAAUYEfyAAKAAAIgBBGHQgAEGA/gNxQQh0ciAAQQh2QYD+A3EgAEEYdnJyBUF/CxCOAQsL5AICCH8CfiAALQAMQQFHBEAPCwJAIAAoAhgiBiAAKAIUIgRBAXYgBGpNBEAgAEEAEM0HRQ0BIAAoAhghBgsgAkH/////A3EiCSAAKAIccCECIAEoAgAhBSAAKAIgIQdBfyEEA0ACQCAHIAJBBHRqIgooAgQiC0ECcQRAIAooAgAgBUcNAQsgByACIAQgBEF/RhtBBHRqIgItAARBAnEEQCAAIAAoAhRBAWs2AhQgACAAKAIQIAIoAgRBAXFrNgIQIAEoAgAhBQsgAiAFNgIAIAM1AgAhDCADKAIENQIAIQ0gAiAJQQJ0QQNyNgIEIAIgDCANQiCGhDcCCCAAIAAoAhRBAWoiATYCFCAAIAAoAhBBAWo2AhAgCCAALwEOTQ0CIAAoAhgiAiABQQN0Tw0CIAAgAkEIaxDNBxoMAgsgBCAEIAIgBEF/RxsgC0EBcRshBCAGIAhBAWoiCCACanEhAgwACwALCxMAIAAgARDgAiAAIAEpAhg3AhgLCwAgACABQT4QjA0LMAEBfyABKAIAIQIgACABKQMINwMIIAAgASkDGDcDGCAAIAEpAxA3AxAgACACNgIAC1UBAX4gAikCACEEIAAgASkCADcCACAAIAEoAgg2AgggACADNgIUIAAgBDcCDCAAQQxqIQEDQAJAIAAoAgRFDQAgASAAKAIAEM0DDQAgABD/BwwBCwsLCQAgAEEgEI0NC7IFAQ1/IAAtAAxBAUcEQEEADwsCQCABBEAgACgCGCABQQF2IAFqSw0BC0EUQSAgACgCECIDIAEgASADSRtBAXRBCGoiAWdrQQAgARsiBHQQ5gwiA0UEQCAAQQA6AAxBAA8LIANBASAEdCIFQRRsaiECIAMhAQNAIAEgAkYEQCAAQgA3AhAgACgCGCECIAAgBUEBazYCGCACQQFqQQAhASAEQR9LBH9B/////wcFIARBAnRBkMYAaigCAAshBkEAIAIbIQogACgCICEIIAAgAzYCICAAIAY2AhwgACAEQQF0OwEOA0ACQCABIApGBEBBACEBDAELIAggAUEUbGoiAygCBCIEQQFxBEACQCAEQQJ2IQQgA0EIaiEMQQAhBiAALQAMQQFHDQACQCAAKAIYIgkgACgCFCICQQF2IAJqTQRAIABBABCACEUNASAAKAIYIQkLIAQgACgCHHAhBSADKAIAIQcgACgCICELQX8hAgNAAkAgCyAFQRRsaiINKAIEIg5BAnEEQCANKAIAIAdHDQELIAsgBSACIAJBf0YbQRRsaiICLQAEQQJxBEAgACAAKAIUQQFrNgIUIAAgACgCECACKAIEQQFxazYCECADKAIAIQcLIAIgBzYCACACQQhqIAwQxAMgAiAEQQJ0QQNyNgIEIAAgACgCFEEBaiIDNgIUIAAgACgCEEEBajYCECAGIAAvAQ5NDQIgACgCGCIEIANBA3RPDQIgACAEQQhrEIAIGgwCCyACIAIgBSACQX9HGyAOQQFxGyECIAkgBkEBaiIGIAVqcSEFDAALAAsLCyABQQFqIQEMAQsLA0AgASAKRwRAIAggAUEUbGpBCGoQLSABQQFqIQEMAQsLIAgQ5wwFIAFCADcCACABQQA2AhAgAUIANwIIIAFBFGohAQwBCwsLQQELzgIBCH8gAC0ADEEBRwRADwsCQCAAKAIYIgYgACgCFCIEQQF2IARqTQRAIABBABCCCEUNASAAKAIYIQYLIAJB/////wNxIgkgACgCHHAhAiABKAIAIQUgACgCICEHQX8hBANAAkAgByACQRRsaiIKKAIEIgtBAnEEQCAKKAIAIAVHDQELIAcgAiAEIARBf0YbQRRsaiICLQAEQQJxBEAgACAAKAIUQQFrNgIUIAAgACgCECACKAIEQQFxazYCECABKAIAIQULIAIgBTYCACACQQhqIAMQxAMgAiAJQQJ0QQNyNgIEIAAgACgCFEEBaiIBNgIUIAAgACgCEEEBajYCECAIIAAvAQ5NDQIgACgCGCICIAFBA3RPDQIgACACQQhrEIIIGgwCCyAEIAQgAiAEQX9HGyALQQFxGyEEIAYgCEEBaiIIIAJqcSECDAALAAsL8AIBBX8gAC0ADEEBRwRAQQAPCwJAIAEEQCAAKAIYIAFBAXYgAWpLDQELQRRBICAAKAIQIgIgASABIAJJG0EBdEEIaiIBZ2tBACABGyIEdBDmDCICRQRAIABBADoADEEADwsgAkEBIAR0IgZBFGxqIQMgAiEBA0AgASADRgRAIABCADcCECAAKAIYIQMgACAGQQFrNgIYIANBAWpBACEBIARBH0sEf0H/////BwUgBEECdEGQxgBqKAIACyEGQQAgAxshBSAAKAIgIQMgACACNgIgIAAgBjYCHCAAIARBAXQ7AQ4DQAJAIAEgBUYEQEEAIQEMAQsgAyABQRRsaiICKAIEIgRBAXEEQCAAIAIgBEECdiACQQhqEIEICyABQQFqIQEMAQsLA0AgASAFRkUEQCADIAFBFGxqQQhqEC0gAUEBaiEBDAELCyADEOcMBSABQgA3AgAgAUEANgIQIAFCADcCCCABQRRqIQEMAQsLC0EBC30BA38CQCABKAIMIAAgASgCBGtJDQAgASgCCCAAa0EgSQ0AQQEhAyAAKAAAIgJBGHQgAkGA/gNxQQh0ciACQQh2QYD+A3EgAkEYdnJyIgRBgIAERg0AIARBgIAIRgR/IABBIGogARCWBA0BIAAoAAAFIAILQYAGRiEDCyADCxIAIAAgARBDIgAQDyAAQaASRgsyAQF/IwBBEGsiASQAIAFBBGogABCNBiABKAIEIgAgASgCCEECIABBAhANIAFBEGokAAtMAQF/IAAoAggiASAAKAIEQThsaiEAA0AgACABRwRAIAEtADRBAUYEQCABQQA6ADQgAUEcahCbAyABQShqEJsDCyABQThqIQEMAQsLC1gBAX8gAEIANwIAIABBADYCCCAAIAEoAgRBARD8ARoCQCAAKAIAQQBIDQAgASgCCCECIAAgASgCBCIBNgIEIAFBA3QiAUUNACAAKAIIIAIgARDSDBoLIAALEgAgACABIAJBOEGlkskkEIkNC1gBA38gACgCAC8AACIBQQh0IAFBCHZywUEBdCIBQQxqIgIgACgCCCIDSwRAQQAPCyAAKAIEIAFqLwAKIgBBCHQgAEEIdnJB//8DcSIAQQAgACACaiADTRsLqAEAIABFBEAgASABKAIAIANyNgIADwsgAEH/AWpB/gNNBEAgASABKAIAIAJyIgI2AgACQCAAQQBKBEAgASACIANyNgIADAELQQAgAGshAAsgBCAEKAIEIgFBAWo2AgQgASAEKAIIaiAAOgAADwsgBCAEKAIEIgFBAWo2AgQgASAEKAIIaiAAQQh2OgAAIAQgBCgCBCIBQQFqNgIEIAEgBCgCCGogADoAAAs/AQF/IwBBEGsiAyQAIAMgATYCDCAAKAIcIANBDGoQggEoAgAiAEF/RwRAIAIgADYCAAsgA0EQaiQAIABBf0cLYAEBfwJ/AkACQCACIAIoAgQiAiABKAIEQQAQ1gNFBEBBACECDAELIAEoAgQiAw0BC0EADAELIAIgASgCACADENIMGiABKAIECyEBIABBADYCCCAAIAE2AgQgACACNgIACxwAIABBAUEAEIICIgAEQCAAIAEtAAA6AAALIAALuwMCB38CfiMAQdAAayIBJAACQCAALQAYQQFHDQAgACgCBCEFA0AgAiAFRgRAA0AgAyAFRgRAIAAtABshAyAAKAIIIQRBACECA0AgAiAFRgRAIABBADoAGAwGBSAEIAJB8ABsai0AVCADQQFzQQFxckUEQCAAQQA6ABtBACEDCyACQQFqIQIMAQsACwALIAAoAgggA0HwAGxqIgIpAhghCSACKQIMIQggAUFAayICQQA2AgAgAUEANgJMIAEgCEIgiSIINwI4IAEgCUIgiTcCRCABIAEpAkg3AzAgASACKQIANwMoIAEgCDcDICABQQhqIAFBOGoQCANAIAEoAiwhAiABKAIwIQQgASgCJCEGAkAgASgCICIHIAEoAghHDQAgBiABKAIMRw0AIAIgASgCFEcNACAEIAEoAhhHDQAgA0EBaiEDDAILAn8gByACQaASIAQbIAYbKAIIIgIgACgCBE8EQEHQ0ABBAEHwABDUDBpB0NAADAELIAAoAgggAkHwAGxqCyADEJcIIAFBIGoQCgwACwALAAUgACgCCCACQfAAbGoQmAggAkEBaiECDAELAAsACyABQdAAaiQAC7QVAg5/A34jAEHwAGsiAiQAIABBAToAGiAAKAIEQQJPBEAjAEHgAGsiBCQAIAAtABlBAUYEQCAAQRlqIQwgACgCCCEFIAAoAgQhAQNAIAEgA0YEQAJ/IAFFBEBB0NAAQQBB8AAQ1AwaQdDQAAwBCyAFIAFB8ABsakHwAGsLQgA3AyggBEEANgJcIARCADcCVCAEQdQAaiIFIAEQmQggBUIAIAAoAgRBAWsQmwggBEEANgJQIARCADcCSCAEQcgAaiAAKAIEQQEQvQIaA0AgBCgCWCIKRSAEKAJUIgFBAEhyRQRAIARBMGogBEHUAGoQnAgCQCAEKAI4IgMgBCgCTEkiBUUEQEHQ0ABBADoAAAwBCyAEKAJQIANqLQAAQQFxDQILAn8gAyAAKAIEIglPBEBB0NAAQQBB8AAQ1AwaIAAoAgQhCUHQ0AAMAQsgACgCCCADQfAAbGoLIQECfiADIAlPBEBB0NAAQQBB8AAQ1AwaQgAMAQsgACgCCCADQfAAbGopAygLIRECfyAFRQRAQdDQAEEAOgAAQdDQAAwBCyAEKAJQIANqC0EBOgAAIAEpAhghECABKQIMIQ8gBEEANgI4IARBADYCRCAEIA9CIIkiDzcCMCAEIBBCIIk3AjwgBCAEQUBrKQIANwMoIAQgBCkCODcDICAEIA83AxggBCAEQTBqEAgDQCAEKAIkIQogBCgCKCEDIAQoAhwhAQJAIAQoAhgiBSAEKAIARw0AIAEgBCgCBEcNACAKIAQoAgxHDQAgAyAEKAIQRg0DCwJAAkAgBSAKQaASIAMbIAEbIgUoAggiASAEKAJMTwRAQdDQAEEAOgAADAELIAQoAlAgAWotAABBAXENAQsgESAAKAIIIAFB8ABsaiIDKAIEIAMoAgBrrHwgAygCMEEBaq0gBSgCAEEHcSIFQQN0QSAgBRuthnwiDyADKQMoWQ0AIAMgDzcDKCAEQdQAaiAPIAEQmwgLIARBGGoQCgwACwALCyAALQAbIgUgAUEASHEiAyAFQQFxIgFyBEAgAEEbaiIFIAUgDCABGyAMIAobIAMbQQA6AAALIARByABqEC0gBEHUAGoQLQUgBSADQfAAbGpC////////////ADcDKCADQQFqIQMMAQsLCyAEQeAAaiQAIAJBADYCbCACQgA3AmQgAkHkAGogACgCBBCZCCAAQQxqIgsgACgCBBC7AyEBAkAgASAALQAbIgVBAXFFckUEQCAAQQA6ABsMAQsgBUEBcUUNACACQQA2AmAgAkIANwJYIAJB2ABqIAAoAgRBAUEAEL8CIQECQCABIAAtABsiBUEBcUVyRQRAIABBADoAGwwBCyAFQQFxRQ0AIAJBADYCVCACQgA3AkwCQAJAIAJBzABqIAAoAgRBAUEAEL8CRSAALQAbQQFxIgVxDQAgBUUNASAAEI4IIAJB5ABqIAAoAgggACgCBCIFQfAAbGpB8ABrQaASIAUbQQAQmgggACgCBEEBaxCbCCAAKAIEIQlBASEIA0ACQCACKAJkIgFBAEgNACACKAJoRQ0AIAJBMGogAkHkAGoQnAgCfyACKAI4IgMgACgCBE8EQEHQ0ABBAEHwABDUDBpB0NAADAELIAAoAgggA0HwAGxqCyEFAn8gCUEBayIJIAAoAhBPBEBB0NAAQQBB8AAQ1AwaQdDQAAwBCyAAKAIUIAlB8ABsagsgBRDDAwJ/IAkgACgCEE8EQEHQ0ABBAEHwABDUDBpB0NAADAELIAAoAhQgCUHwAGxqCyEBIAAtABtBAXEiBSAJQQBIcQ0CIAVFDQMCfyADIAIoAlxPBEBB0NAAQQA2AgBB0NAADAELIAIoAmAgA0ECdGoLIAk2AgAgASkCGCEQIAEpAgwhDyACQQA2AjggAkEANgJEIAIgD0IgiSIPNwIwIAIgEEIgiTcCPCACIAJBQGspAgA3AyggAiACKQI4NwMgIAIgDzcDGCACIAJBMGoQCANAIAIoAiQhCiACKAIoIQMgAigCHCEBAkAgAigCGCIFIAIoAgBHDQAgASACKAIERw0AIAogAigCDEcNACADIAIoAhBGDQMLAn8gBSAKQaASIAMbIAEbIgEoAggiBSACKAJQTwRAQdDQAEEANgIAQdDQACEDQQAMAQsgAigCVCAFQQJ0aiIDKAIACyEFIAMgBUEBajYCAAJ/IAEoAggiAyAAKAIETwRAQdDQAEEAQfAAENQMGiABKAIIIQNBAAwBCyAAKAIIIANB8ABsaigCQAsCfyADIAIoAlBPBEBB0NAAQQA2AgBBAAwBCyACKAJUIANBAnRqKAIAC0YEQCACQeQAagJ/IAMgACgCBE8EQEHQ0ABBAEHwABDUDBpB0NAADAELIAAoAgggA0HwAGxqCyAIEJoIIAEoAggQmwggCEEBaiEICyACQRhqEAoMAAsACwsCQCAALQAbQQFxIgUgAUEASHFFBEAgBUUgCygCAEEATnINAQsgAEEAOgAbCyACQdgAaiEFQQAhCCMAQdAAayIHJAAgCygCBCEOA0ACQCAIIA5GDQACfyAIIAsoAgRPBEBB0NAAQQBB8AAQ1AwaQdDQAAwBCyALKAIIIAhB8ABsagshDSMAQZABayIGJAACQCANKAJEIgFBf0cEQCANQaASIAUoAgggAUECdGogBSgCBCABTRsoAgA2AkRBASEBDAELIAZCADcBYiAGQgA3AWggBkIANwFaIAZBAToAWCAGQQA2AlQgBkKBgICAEDcCTCAGQcwAaiANKAJYEMoDGiAGQSxqIA1ByABqIgQQnwggBkHwAGoiASAEEJ8IIAZBDGogARALIAYgBikCiAE3AiQgBkH0AGohCgNAIAYoAjAhAwJAIAYoAiwiASAGKAIMRw0AIAMgBigCEEcNACANLQBUIAYtAFhxIgFBAXEEQCAEIAZBzABqEP0CCyAGQcwAahAvDAILIANFBEBB0NAAQgA3AwBB2NAAQQA2AgBB0NAAIQELIAYoAkQhDCAGQfAAaiABIAYoAkgiA0EBdWoiASADQQFxBH8gASgCACAMaigCAAUgDAsRAQAgBkHMAGpBoBIgBSgCCCAGKAJwIgFBAnRqIAUoAgQgAU0bIAoQvAMaIAZBLGoQDBoMAAsACyAGQZABaiQAIAFBAXFFDQAgCygCCCAIQfAAbGoiASkCGCEQIAEpAgwhDyAHQUBrIgFBADYCACAHQQA2AkwgByAPQiCJIg83AjggByAQQiCJNwJEIAcgBykCSDcDMCAHIAEpAgA3AyggByAPNwMgIAdBCGogB0E4ahAIA0AgBygCJCEBAkAgBygCICIDIAcoAghHDQAgASAHKAIMRw0AIAcoAiwgBygCFEcNACAHKAIwIAcoAhhHDQAgCEEBaiEIDAMLAkAgAQ0AIAcoAjBFBEBB0NAAQgA3AwBB2NAAQQA2AgBB0NAAIQMMAQsgBygCLCEDCyADQaASIAUoAgggAygCCCIBQQJ0aiAFKAIEIAFNGygCADYCCCAHQSBqEAoMAAsACwsgB0HQAGokAAJAIAggDk8NACAALQAbQQFxRQ0AIABBADoAGwsgACALEMQDIAlFDQEgAC0AG0EBcUUNAQsgAEEAOgAbCyACQcwAahAtCyACQdgAahAtCyACQeQAahAtCyACQfAAaiQAC+MGAgx/AX4jAEFAaiIDJAAgAQRAIAFBAEEBQQAQjQUaCyAALQAaQQFGBEAgACgCBCEGA0AgBkEBayIGQQBIBEAgAEEAOgAaBQJ/IAYgACgCBE8EQEEAIQRB0NAAIQdB0NAAQQBB8AAQ1AwaQQAMAQsgACgCCCAGQfAAbGoiBygCACEEIAcoAgQLIQUgByACNgI0IAcgBSAEayACaiICNgI4DAELCwsgA0IANwEyIANCADcBOCADQgA3ASogA0EBOgAoIANBADYCJCADQoGAgIAQNwIcIAAoAgQhBwJ/A0AgB0EBayIHQQBOBEAgACgCCCAHQfAAbGoiAigCECIGIAIoAgxBDGxqIQoDQCAGIApGDQICQAJ/QaASIAAoAggiAiAHQfAAbGogACgCBCIEIAdNGyEFQaASIAIgBigCCCIIQfAAbGogBCAITRshBEEAIQICQAJAAkACQCAGKAIAIghBBHZBA3EOAwABAgMLIAQoAjQgBSgCNGshAgwCCyAEKAI0IAUoAjhrIQIMAQsgBCgCNCECCyAGKAIAIgRBCHEiBUEARyACrSAIQQZ2rX0iDkIAWXIgBEEHcSICRQ0AGiAFBEAgDkKAgICACHxCgICAgBBUIAJBBEYNARogDkKAgAJ8QoCABFQMAQsCQAJAAkAgAkEDaw4CAQACCyAOQoCAgIAQVAwCCyAOQoCAgAhUDAELIA5CgIAEVAsNAEEBIAFFDQQaIAMgBzYCFCADIAYoAgg2AhggAyADQRRqIgg2AhACfyADQRBqIQJBACADQRxqIgQoAiBFDQAaAn9BACEJIAIoAgAiBSgCBEGx893xeWwgBSgCAEHv+N7FAmxqQf////8DcSILIAQoAhxwIQUDQAJAIAQoAiAgBUEMbGoiDCgCBCINQQJxBH8gDUECdiALRw0BIAwgAhChCEUNAUEAIAQoAiAgBUEMbGoiBSgCBEEBcWsgBXEFQQALDAILIAQoAhggCUEBaiIJIAVqcSEFDAALAAsLDQAgASAIEPkBIAMgCDYCECADQQE6AA8gBCACIAIoAgAiAigCBEGx893xeWwgAigCAEHv+N7FAmxqIANBD2oQoAgLIAZBDGohBgwACwALC0EAIAFFDQAaIAEoAgRBAEcLIANBHGoQLyADQUBrJAALtQEBA38jAEEgayIDJAAjAEEgayICJAAgASgCGCEEIAEoAiAhASACQQA2AhAgAiABNgIIIAIgBEEBakEAIAQbNgIMIAJBADYCHCACQQE2AhggAiACKQIYNwMAIAMgAkEIaiACQcUXEMwDGiACQSBqJAAgA0E/NgIYIANBADYCHCAAIAMpAhA3AhAgACADKQIINwIIIAAgAykCADcCACAAIAMpAhg3AhggAEH4GjYCICADQSBqJAALVgECfAJ/IAAoAgi4IAAoAgS4oyICIAEoAgi4IAEoAgS4oyIDYQRAIAEoAgAgACgCAGsMAQtBfyADIAKhIgJEAAAAAAAAAABkIAJEAAAAAAAAAABjGwsLygICBX8CfiMAQdAAayIEJAACQCACQQxqIgYgARDgAQ0AIAYgARCOAQJ/IAEgACgCBE8EQEHQ0AAhAUHQ0ABBAEHwABDUDBpBAAwBCyAAKAIIIAFB8ABsaiIBKAIEIAEoAgBrCyEFIANFDQAgASkCGCEKIAEpAgwhCSAEQUBrIgFBADYCACAEQQA2AkwgBCAJQiCJIgk3AjggBCAKQiCJNwJEIAQgBCkCSDcDMCAEIAEpAgA3AyggBCAJNwMgIANBAWshByAEQQhqIARBOGoQCANAIAQoAiwhASAEKAIwIQMgBCgCJCEGAkAgBCgCICIIIAQoAghHDQAgBiAEKAIMRw0AIAEgBCgCFEcNACADIAQoAhhGDQILIAAgCCABQaASIAMbIAYbKAIIIAIgBxCTCCAFaiEFIARBIGoQCgwACwALIARB0ABqJAAgBQvVEAEQfyMAQeACayICJAAgABCOCCACQgA3AYoBIAJCADcBkAEgAkIANwGCASACQQE6AIABIAJBADYCfCACQoGAgIAQNwJ0IAJBAToATCACQQA2AkggAkKBgICAEDcCQCACQdAAakEAQSEQ1AwaIAJBuAJqIAEQuAEgAkGQAmogARC5ASACQcwAaiEGIAIoApACIQkgAigClAIhCgJAAkADQAJAAkAgAigCvAIiAyAKRw0AIAIoArgCIAlHDQAgAi0AgAFFDQQgACgCBCEEIAJCADcBMiACQgA3ATggAkIANwEqIAJBAToAKCACQQA2AiQgAkKBgICAEDcCHCACQbgCaiIDIAJB9ABqEIcBIAIgAikC0AI3A6gCIAIgAikCyAI3A6ACIAIgAikCwAI3A5gCIAIgAikCuAI3A5ACIAJBmAFqIAMQiAFBACEDA0ACQCACKAKQAiACKAKYAUcNACACKAKUAiACKAKcAUcNACAALQAbQQFHDQUgACgCAEEASA0FIAAoAhxBAE4gA3FFDQUCQCAEIAAoAgRGDQAgBiAEQQFrIgMQ4AFFDQAgBiAAKAIEQQFrEI4BIAYgAxDkAQsgAkGYAWoiAyACQfQAahCMASACIAJBHGo2ArwBIAIoAixFDQMgAkG4AmogA0EoENIMGiACQZACaiADEPoIIAIgAigCvAE2ArQCIAJB3AJqIQgDQCACKAK4AiACKAKQAkYEQCACKAK8AiACKAKUAkYNBQsgAkG4AmoQjQEhBCMAQRBrIgMkACADIAQ2AgwgCCgCACADQQxqIgQgA0EIahCFASEFIAMoAgggBCAFGygCACEEIANBEGokAAJ/IAQgACgCBE8EQEEAIQNB0NAAQQBB8AAQ1AwaQQAhBkEAIQdBAAwBCyAAKAIIIARB8ABsaiIFKAIYIQMgBSgCHCEGIAUoAgwhByAFKAIQCyEFIAJBADYCgAIgAiADNgKIAiACIAc2AvwBIAIgBTYC+AEgAiAGNgKEAiACQQA2AowCIAIgAikCiAI3A/ABIAIgAikCgAI3A+gBIAIgAikC+AE3A+ABIAJByAFqIAJB+AFqEAgDQCACKALkASEFAkAgAigC4AEiAyACKALIAUcNACAFIAIoAswBRw0AIAIoAuwBIAIoAtQBRw0AIAIoAvABIAIoAtgBRw0AIAJBuAJqEAwaDAILAkAgBQ0AIAIoAvABRQRAQdDQAEIANwMAQdjQAEEANgIAQdDQACEDDAELIAIoAuwBIQMLIAJBHGogA0EIaiACQcQBahCFAQRAIAAgAyAEIAIoAsQBKAIAELAICyACQeABahAKDAALAAsACyACQfgBaiACQZACahCJAQJAIAIoAvgBIgUgACgCBE8EQEHQ0ABBAEHwABDUDBoMAQsgAigC/AEgACgCCCAFQfAAbGooAkBPDQAgACAFIAJBHGoQ+whBASEDCyACQZACahAMGgwACwALIAIgAzYCmAEjAEGQAWsiBCQAIARB5ABqIgVBoBIgACgCCCADQfAAbGogACgCBCADTRsQwQggBEE4aiAFQSwQ0gwaIAJBzABqIQsgBEEMaiAFEMIIQQAhByAEKAIcIQ0gBCgCGCEOIAQoAhAhDyAEKAIMIRADQAJAAkAgBCgCOCAQRw0AIAQoAjwgD0cNACAEKAJEIA5HDQAgBCgCSCANRg0BCyAEQThqEMMIIQVBoBIgACgCCCAFKAIAIghB8ABsaiAAKAIEIAhNGyIMKAIQIgUgDCgCDEEMbGohDANAIAUgDEYEQCAEQThqEMQIDAMFAkAgBSgCCCADRw0AIAUoAgAiEUEIcSARQQdxQQNrQQFLcg0AIAsgCBCOASAHQQFqIQcLIAVBDGohBQwBCwALAAsLIARBkAFqJAAgAiAHNgIcIAJB9ABqIgMgAkGYAWogAkEcakEBEIABGiAAIAIoApgBIAMQ/AggAkG4AmoQvQEMAQsLIAJBEGogAkFAaxC4ASACIAIoAhg2AgggAiACKQIQNwMAIwBB4ABrIgMkAAJAIAJBHGoiCSgCEEUNACADIAIoAgg2AlggAyACKQIANwNQIAIoAgAhCgNAIAMoAlQiBUF/RgRAIAMoAlAgCkYNAgsCfyAFIAAoAgRPBEBBACEGQdDQAEEAQfAAENQMGkEAIQdBACEIQQAMAQsgACgCCCAFQfAAbGoiBCgCGCEGIAQoAhwhByAEKAIMIQggBCgCEAshBCADQUBrIgtBADYCACADIAY2AkggAyAINgI8IAMgBDYCOCADIAc2AkQgA0EANgJMIAMgAykCSDcDMCADIAspAgA3AyggAyADKQI4NwMgIANBCGogA0E4ahAIA0AgAygCJCEGAkAgAygCICIEIAMoAghHDQAgBiADKAIMRw0AIAMoAiwgAygCFEcNACADKAIwIAMoAhhHDQAgA0HQAGoQvQEMAgsCQCAGDQAgAygCMEUEQEHQ0ABCADcDAEHY0ABBADYCAEHQ0AAhBAwBCyADKAIsIQQLAkAgCSAEQQhqIANBBGoQhQFFDQAgBCgCAEEPcUEERw0AIAAgBCAFIAMoAgQoAgAQsAgLIANBIGoQCgwACwALAAsgA0HgAGokACACQbgCaiABELgBIAJBkAJqIAEQuQEgAUEMaiEAIAIoApACIQEgAigClAIhAwNAAkAgAigCvAIiBCADRw0AIAIoArgCIAFHDQAMAgsgAiAENgKYASACQRxqIAJBmAFqIAJB+AFqEIUBBEAgACACKAKYARDkASAAIAIoAvgBKAIAEI4BCyACQbgCahC9AQwACwALIAJBHGoQLwsgAkFAaxC2ARogAkH0AGoQLyACQeACaiQAC+8EAQl/IwBB4ABrIgMkAEF/IQUCQCABQQxqIgQQ3wENACAAEI4IAn8gAiAAKAIETwRAQdDQAEEAQfAAENQMGkHQ0AAMAQsgACgCCCACQfAAbGoLIQYgBBDrARogBBDqARogA0EwaiABELgBIANBGGogARC5AUEAIQQgAygCGCEHIAMoAhwhCANAAkAgAygCNCIJIAhHDQAgAygCMCAHRw0AIAYoAkAgBE0NAiAAIAIQrwgiBUF/RgRAQQAhBQwDCyADQdQAaiABELgBIANByABqIAEQuQEgAygCSCEKIAMoAkwhCwNAIAsgAygCWCIBRgRAIAMoAlQgCkYNBAsCfyABIAEgBUZqIgYgACgCBE8EQEEAIQdB0NAAQQBB8AAQ1AwaQQAhCEEAIQlBAAwBCyAAKAIIIAZB8ABsaiIBKAIYIQcgASgCHCEIIAEoAgwhCSABKAIQCyEEIANBADYCOCADQUBrIgEgBzYCACADIAk2AjQgAyAENgIwIAMgCDYCPCADQQA2AkQgAyABKQIANwMoIAMgAykCODcDICADIAMpAjA3AxggAyADQTBqEAgDQCADKAIcIQECQCADKAIYIgQgAygCAEcNACABIAMoAgRHDQAgAygCJCADKAIMRw0AIAMoAiggAygCEEcNACADQdQAahC9AQwCCwJAIAENACADKAIoRQRAQdDQAEIANwMAQdjQAEEANgIAQdDQACEEDAELIAMoAiQhBAsgAiAEKAIIRgRAIAAgBCAGIAUQsAgLIANBGGoQCgwACwALAAsgBiAJEK4IIARqIQQgA0EwahC9AQwACwALIANB4ABqJAAgBQsnACAAKAIABEAgAEEAEMADIAAoAggQ5wwLIABBADYCCCAAQgA3AgALvgEBAX8jAEEQayICJAAgAiABNgIMAkAgACgCQEUEQCAAQQE2AkAgACABNgJEDAELIABBxABqIgEoAgBBf0cEQCACQQE2AgggAEHIAGogASACQQhqELwDRQ0BIAFBfzYCAAsCQCAAQcgAaiIBIAJBDGogAkEIahCFAQRAIAIoAggiASABKAIAQQFqNgIADAELIAJBATYCBCABIAJBDGogAkEEahC8A0UNAQsgACAAKAJAQQFqNgJACyACQRBqJAALFgAgAEKAgICAcDcDQCAAQcgAahD+AQsMACAAIAFBABD4BBoLcgIBfgF/IAFB//8Pca1C////////AQJ+QgAgACgCPCIBRQ0AGiAAKAIEIAAoAgBrIgNBfm2sIAFBAUYNABpCACADrH0LIAApAyh8IgJCACACQgBVGyICIAJC////////AVkb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ACkCEDcDECABIAApAgg3AwggASAAKQIANwMAQQAhAANAAkAgASgCAEEBa0EBSw0AIAEoAgggASgCBC8AAiICQQh0IAJBCHZyQf//A3FPDQAgAEEBaiEAIAEQ3wgaDAELCyABQSBqJAAgAAsTACAAIAEQ5AggACABKAIgNgIgCyMBAX8jAEEQayIBJAAgAUEIaiAAEOEIIAEoAgggAUEQaiQAC0MBAX8jAEEQayIBJAADQAJAIAAQvgUgABC7BUUNACABQQhqIAAQ4QggACgCGCgCACABKAIMTQ0BCwsgAUEQaiQAIAALcwEBfyMAQRBrIgQkACAAIAEpAgA3AgAgACABKQIYNwIYIAAgASkCEDcCECAAIAEpAgg3AgggACADNgIkIAAgAjYCIANAAkAgABC7BUUNACAEQQhqIAAQ4QggBCgCDA0AIAAQ3wgaDAELCyAEQRBqJAAgAAskAQF/IAEQvAUhAiAAIAEoAhQoAgggAhClATYCBCAAIAI2AgALLQEBfyMAQSBrIgIkACACIAEQ5AggACACIAEoAiAgASgCJBDgCBogAkEgaiQACzgBAn8jAEEQayIBJAADQCAAEN8IIgIQuwUEQCABQQhqIAIQ4QggASgCDEUNAQsLIAFBEGokACACCzIBAn8jAEEgayICJAAgAkEIaiIDIAEQxwggACADIAEoAhggASgCHBDbCBogAkEgaiQACxMAIAAgASABIAIgAxACIAQQ6AgLJwAgACgCAARAIABBABDpCCAAKAIIEOcMCyAAQQA2AgggAEIANwIACxEAIAAgASABIAIgAxACEOoIC4UBAQN/AkAgAiABKAIETw0AIAEoAgggAkHwAGxqIgEoAgAiBEUNACABKAIEIAEoAgBrIgVBAk4EfyAFIAMgBC8AACIGQQh0IAZBCHZyQf//A3FsQQF0QQJqTwVBAAtFDQAgACAENgIIIAAgATYCBCAAIAI2AgAPCyAAQQA2AgggAEIANwIACz8BAn8gACgCBCICIAFrIQMgACgCCCACQQZ0aiECA0AgAwRAIANBAWshAyACQUBqEOwIIQIMAQsLIAAgATYCBAuEAQECfwJAIAIgASgCBE8NACABKAIIIAJB8ABsaiIBKAIAIgRFDQAgASgCBCABKAIAayIDQQJOBH8gA60gBC8AACIDQQh0IANBCHZyrUL//wODQgKG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ICEBIAAgAzcCGCAAIAIpAhA3AhAgACACKQIINwIIIAAgAikCADcCACAAIAE2AiAgAkEgaiQAC9wCAgR/An4jAEHQAGsiAyQAIAMgATYCTAJAIAIgA0HMAGpBABCFAQ0AIAMgACADKAJMEK8IIgE2AkggAC0AGyIEQQFxRSABQX9HckUEQCAAQQA6ABsMAQsgBEEBcUUNACACIANBzABqIANByABqQQEQgAEaQaASIAAoAgggAygCTCIBQfAAbGogACgCBCABTRsiASkCDCEHIAEpAhghCCADQQA2AjggA0EANgJEIAMgCEIgiTcCPCADIAdCIIk3AjAgAyADQUBrKQIANwMoIAMgAykCODcDICADIAMpAjA3AxggAyADQTBqEAgDQCADKAIkIQEgAygCKCEEIAMoAhwhBQJAIAMoAhgiBiADKAIARw0AIAUgAygCBEcNACABIAMoAgxHDQAgBCADKAIQRg0CCyAAIAYgAUGgEiAEGyAFGygCCCACEPsIIANBGGoQCgwACwALIANB0ABqJAAL3wIBBX8jAEHQAGsiAyQAAn8gASAAKAIETwRAQdDQAEEAQfAAENQMGkEADAELIAAoAgggAUHwAGxqIgEoAhghBCABKAIcIQUgASgCDCEGIAEoAhALIQEgA0FAayIHQQA2AgAgAyAENgJIIAMgBjYCPCADIAE2AjggAyAFNgJEIANBADYCTCADIAMpAkg3AzAgAyAHKQIANwMoIAMgAykCODcDICADQQhqIANBOGoQCANAAkAgAygCLCEBIAMoAjAhBCADKAIkIQUCQCADKAIgIgYgAygCCEcNACAFIAMoAgxHDQAgASADKAIURw0AIAQgAygCGEYNAQsCQCACIAYgAUGgEiAEGyAFG0EIaiIBIANBBGoQhQEEQCADKAIEIgEgASgCAEEBajYCAAwBCyADQQE2AgAgAiABIANBARCAARogACABKAIAIAIQ/AgLIANBIGoQCgwBCwsgA0HQAGokAAsRACAAIAEgAiADIARBDBDzDAsRACAAIAEgAiADIARBBBDzDAsRACAAIAEgAiADIARBChDzDAsRACAAIAEgAiADIARBAxDzDAuOAQEDfwJAIAEoAgwgACABKAIEa0kNACABKAIIIABrQQhJDQAgAC8AAiICQQh0IAJBCHZyQf//A3EiBK0gACgABCICQRh0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IAFBgP4DcUEIdnI7AAQgACACQQh0IAJBgP4DcUEIdnIiADsAAAsgByAFQQZsaiAAOwACIAFBAWohASADQdgCahCOCxogAiEADAEFIAZFDQQgCC8AAiEAIANBADYC4AIgAyAHNgLYAiADIABBCHQgAEEIdnJB//8DcTYC3AIgCiACEIsGCwsLCwsLC0EBIQAgBCAJIARBARCGAkEAQQAQhQYMAgsgBBCJAgtBACEACyADQZADaiQAIAAFQQELIQMLIAMLC6cQARB/QQEhAgJAAkACQAJAIAAvAAAiBEEIdCAEQQh2ckH//wNxQQFrDgMAAQIDCyMAQfABayICJAAgASgCCCIEKAIcIQYCQCABKAIMIgUgBSgCBCIFEIcGRQRAQQAhAAwBCyAEQdAEaiEDIAUgAC8AADsAACACIAEoAghB7AVBkAYgASgCEEHCqs26BEYbajYCnAEgAkEANgKYASACQgA3ApABIAJBDGoiByAALwACIgQEfyAAIARBCHQgBEEIdnJB//8DcWoFQaASCyAAQQRqELMFIAJBth42AgggAiADNgIEIAJBLGoiBCAHIAJBBGoQwAUgAkHUAGogBEEoENIMGiACQbceNgKMASACIAA2AoQBIAIgBUEEajYCgAEgAiABNgJ8IAIgAkGcAWo2AogBIAJB/ABqIQQDQAJAIAJB1ABqIgAQtgVFDQAgAkGgAWogABC3BSAEIAIoAqQBEKQLDQAgABC4BRoMAQsLIAJBoAFqIAJB1ABqQTwQ0gwaIAIgBjYC4AEgAkG2HjYC3AEgAkHIAWohAANAIAJBoAFqIgQQtgUEQCACKALgASEGIAJB6AFqIAQQtwUgAiACKALoATYC5AEgAkGQAWogBiACQeQBahCCARDaARoDQCACQaABahC4BSIEELYFRQ0CIAJB6AFqIAQQtwUgACACKALsARCkC0UNAAsMAQsLIAEoAgwhACACIAIpApQBQiCJNwKgASACQQA2AqgBIAVBAmogACACQaABahDbChogAigClAFBAEchACACQZABahAtCyACQfABaiQAIAAPC0EAIQIjAEGwAmsiAyQAAkAgASgCDCIFIAUoAgQiBBDXA0UNACAEIAAvAAA7AAAgBEECaiABIABBAmogABCnC0UNACADQgA3AY4CIANCADcBlAIgA0IANwGGAiADQQE6AIQCIANB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aiIEELYFBEAgAigC4AEhAyACQegBaiAEELcFIAIgAigC6AE2AuQBIAJBkAFqIAMgAkHkAWoQggEQ2gEaA0AgAkGgAWoQuAUiBBC2BUUNAiACQegBaiAEELcFIAAgAigC7AEQqgtFDQALDAELCyABKAIMIQAgAiACKQKUAUIgiTcCoAEgAkEANgKoASAFQQJqIAAgAkGgAWoQ2woaIAIoApQBQQBHIQAgAkGQAWoQLQsgAkHwAWokACAADwsjAEGAA2siAyQAAkAgASgCDCICIAIoAgQiBRApRQRAQQAhAgwBCyAFIAAvAAA7AAAgBUECaiABIABBAmogABCnCxogA0IANwHeAiADQgA3AeQCIANCADcB1gIgA0EBOgDUAkEAIQIgA0EANgLQAiADQoGAgIAQNwLIAiADQgA3AboCIANCADcBwAIgA0IANwGyAiADQQE6ALACIANBADYCrAIgA0KBgICAEDcCpAIgA0IANwGWAiADQgA3AZwCIANCADcBjgIgA0EBOgCMAiADQQA2AogCIANCgYCAgBA3AoACIAMgA0HIAmo2AswBIAVBBGogASAAQQRqIAAgA0HMAWoiBBCoCyADIANBpAJqNgLMASAFQQZqIAEgAEEGaiAAIAQQqAsgAyADQYACajYCzAEgBUEIaiABIABBCGogACAEEKgLAkACQAJAIAEoAgwiBCgCGCIGRQRAIAMtANQCQQFxRQ0BCyAGDQIgAy0AsAJBAUcNACADLQCMAg0BCyAEQQE2AhgMAQsgASgCCCEEIANBAToA2AEgA0EANgLUASADQoGAgIAQNwLMASADQdwBakEAQSEQ1AwaIAAvAAIiAgR/IAAgAkEIdCACQQh2ckH//wNxagVBoBILIARB0ARqIANBzAFqEKsFIANBAToApAEgA0EANgKgASADQoGAgIAQNwKYASADQagBakEAQSEQ1AwaIAAvAAYiAgR/IAAgAkEIdCACQQh2ckH//wNxagVBoBILIANBzAFqIANBmAFqEJEHIAMgASgCCEHsBUGQBiABKAIQQcKqzboERhtqNgKUASABKAIMIgIoAiwiBgRAIAYoAgwhCyAGKAIYIQcLIANBpAFqIRAgAigCCCEMIAIoAgQhDSACKAIYIQ4gAC8ACiECIANBADYCaCADIABBDGo2AmAgA0KAgICAEDcDWCADIAJBCHQg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CxoDQCAAIAAoAqgBIAAoArABaiIINgKoASAIIAAoAqwBRg0CIA8gCBDkC0UNAAsMAQsLIAkgCyAJQQEQhgJBAEEAEIUGQQEMAQsgCRCJAkEACyAEciEECwNAIABB2ABqIggQvQUgCBC2BUUNASAAKAJ4IABBqAFqIAgQtwVBDGogACgCqAEQ4AFFDQALDAALAAtBACEECyAAQZACaiQAIAJBIGokACAEQQFxBEAgByABIAdBARCGAkEAQQAQhQZBAQwCCyAHEIkCC0EACyECDAMLIAgQiQIMAQsgCBCJAgtBACECCyAGQYwBahAvCyAGQfACaiQAIAIFQQELDAULIAEgABC5CwwECyABIAAQgwsMAwsgASAAEIQLDAILIAEvAABBgAJGBH8jAEEQayICJAAgACgCDCIDIAMoAgQiAxDXAwR/IAMgAS8AADsAACADIAEvAAI7AAIgAiABLwACIgRBCHQgBEEIdnJB//8DcTYCDAJ/IAJBDGohBCADQQRqIgZBADYAACABKAAEBEAgACgCDCIDECEaIAAgASgABCIABH8gASAAQRh0IABBgP4DcUEIdHIgAEEIdkGA/gNxIABBGHZycmoFQaASCyAEELgLBEAgAyAGIANBARCGAkEAQQAQ/ghBAQwCCyADEIkCC0EACwVBAAsgAkEQaiQABUEBCyEDCyADCwuiDQILfwF+IAAvAABBgAJGBH8jAEHgAmsiAiQAIAEoAggiBCgCHCEHIAEoAgwiAyADKAIEIgUQKQRAIAUgAC8AADsAACACQgA3AbICIAJCADcBuAIgAkIANwGqAiACQQE6AKgCIAJBADYCpAIgAkKBgICAEDcCnAIgAC8AAiIDBH8gACADQQh0IANBCHZyQf//A3FqBUGgEgsgAC8ACCIDBH8gACADQQh0IANBCHZyQf//A3FqBUGgEgsgBEHQBGoiCSACQZwCahDqByACKAKsAiIDBEAgBSADQQh0IANBgP4DcUEIdnI7AAYgAkG4AWoiBCAALwACIgMEfyAAIANBCHQgA0EIdnJB//8DcWoFQaASCyAAQQhqIggvAAAiAwR/IAAgA0EIdCADQQh2ckH//wNxagVBoBILELMFIAJBth42AlwgAiAJNgJYIAJB9AFqIgMgBCACQdgAahDuByACQQA2AvABIAJCADcC6AEgBCADQSgQ0gwaIAIg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BH8gByAELwAAOwEAIARBAmohBCACQQFxBH8gASAHEMsJBUEACwVBAAshCiAGQQJxBEAgByAELwAAOwEIIAJBAnEEQCABIAdBCGoQywkhCAsgBEECaiEECyAGQQRxBH8gByAELwAAOwEQIARBAmohBCACQQRxBH8gASAHQRBqEMsJBUEACwVBAAshCyAGQQhxBEAgByAELwAAOwEYIAJBCHEEQCABIAdBGGoQywkhCQsgBEECaiEECyAALwAAQYAgSQ0AIAZBEHEEQCAKIAMgBCAFEMALIAEgAyAEIAUgAkEQEMELIARBAmohBAsgBkEgcQRAIAggAyAEIAUQwAsgASADIAQgBSACQSAQwQsgBEECaiEECyAGQcAAcQRAIAsgAyAEIAUQwAsgASADIAQgBSACQcAAEMELIARBAmohBAsgBkGAAXFFDQAgCSADIAQgBRDACyABIAMgBCAFIAJBgAEQwQsLIAdBIGokAAvtBwIIfwF+IwBBgAFrIgMkACAAQQA7AAAgARAhIQYgAyACKQIYNwMYIAMgAikCEDcDECADIAIpAgg3AwggAyACKQIANwMAAkACQCABIAYQkAJFDQAgAygCCCEIIAMgAykDGDcDeCADIAMpAxA3A3AgAyADKQMINwNoIAMgAykDADcDYCADQUBrIAMQwgtBfiEEQQAhAgNAAkACQCADKAJkIAMoAkRHDQAgAygCYCADKAJARw0AIAZBgARBgAIgCSAIIAdBA2xLckEBcSIEGzsAACACQf//A0sEQCABKAIYDQQgAUEINgIYDAQLIARFBEAgAyADKQMYNwN4IAMgAykDEDcDcCADIAMpAwgiCzcDaCADIAMpAwA3A2BBACECIAZBAmogASALpyIEQQAQngNFDQQgBkEEaiEFA0AgAiAERg0DIAUgAkEBdGogA0HgAGoiCBCgCy8BACIGQQh0IAZBCHZyOwAAIAJBAWohAiAIEL0BDAALAAsgAyADKQMYNwM4IAMgAykDEDcDMCADIAMpAwg3AyggAyADKQMANwMgIAEgBhAoRQ0DIAMgAykDODcDeCADIAMpAzA3A3AgAyADKQMoNwNoIAMgAykDIDcDYCADQUBrIANBIGoQwgtBACECQX4hBANAAkAgAygCZCADKAJERw0AIAMoAmAgAygCQEcNACAGQQJqIAEgAhCKBkUNBSACRQ0D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AkAgAiAAKAIQIgMEfyADBSAAENUMDQEgACgCEAsgACgCFCIEa0sEQCAAIAEgAiAAKAIkEQQAGgwBCwJAAkAgAkUgACgCUEEASHINACACIQMDQCABIANqIgVBAWstAABBCkcEQCADQQFrIgMNAQwCCwsgACABIAMgACgCJBEEACADSQ0CIAIgA2shAiAAKAIUIQQMAQsgASEFCyAEIAUgAhDSDBogACAAKAIUIAJqNgIUCwsLbwEFfyAAKAIAIgMsAABBMGsiAUEJSwRAQQAPCwNAQX8hBCACQcyZs+YATQRAQX8gASACQQpsIgVqIAEgBUH/////B3NLGyEECyAAIANBAWoiBTYCACADLAABIAQhAiAFIQNBMGsiAUEKSQ0ACyACC7oCAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4SAAgJCggJAQIDBAoJCgoICQUGBwsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACEOIMCw8LIAIgAigCACIBQQRqNgIAIAAgATQCADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATUCADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASkDADcDAAt/AgF+A38CQCAAQoCAgIAQVARAIAAhAgwBCwNAIAFBAWsiASAAIABCCoAiAkIKfn2nQTByOgAAIABC/////58BViACIQANAAsLIAJQRQRAIAKnIQMDQCABQQFrIgEgAyADQQpuIgRBCmxrQTByOgAAIANBCUsgBCEDDQALCyABC2wBAX8jAEGAAmsiBSQAIARBgMAEcSACIANMckUEQCAFIAEgAiADayIDQYACIANBgAJJIgEbENQMGiABRQRAA0AgACAFQYACENwMIANBgAJrIgNB/wFLDQALCyAAIAUgAxDcDAsgBUGAAmokAAucGAMSfwF8A34jAEGwBGsiDCQAIAxBADYCLAJAIAG9IhlCAFMEQEEBIRBB4h0hEyABmiIBvSEZ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c2l4AHNldmVuAGVpZ2h0AG5pbmUAY29sb24Ac2VtaWNvbG9uAGxlc3MAZXF1YWwAZ3JlYXRlcgBxdWVzdGlvbgBhdABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAYnJhY2tldGxlZnQAYmFja3NsYXNoAGJyYWNrZXRyaWdodABhc2NpaWNpcmN1bQB1bmRlcnNjb3JlAGdyYXZlAGEAYgBjAGQAZQBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQByAHMAdAB1AHYAdwB4AHkAegBicmFjZWxlZnQAYmFyAGJyYWNlcmlnaHQAYXNjaWl0aWxkZQBBZGllcmVzaXMAQXJpbmcAQ2NlZGlsbGEARWFjdXRlAE50aWxkZQBPZGllcmVzaXMAVWRpZXJlc2lzAGFhY3V0ZQBhZ3JhdmUAYWNpcmN1bWZsZXgAYWRpZXJlc2lzAGF0aWxkZQBhcmluZwBjY2VkaWxsYQBlYWN1dGUAZWdyYXZlAGVjaXJjdW1mbGV4AGVkaWVyZXNpcwBpYWN1dGUAaWdyYXZlAGljaXJjdW1mbGV4AGlkaWVyZXNpcwBudGlsZGUAb2FjdXRlAG9ncmF2ZQBvY2lyY3VtZmxleABvZGllcmVzaXMAb3RpbGRlAHVhY3V0ZQB1Z3JhdmUAdWNpcmN1bWZsZXgAdWRpZXJlc2lzAGRhZ2dlcgBkZWdyZWUAY2VudABzdGVybGluZwBzZWN0aW9uAGJ1bGxldABwYXJhZ3JhcGgAZ2VybWFuZGJscwByZWdpc3RlcmVkAGNvcHlyaWdodAB0cmFkZW1hcmsAYWN1dGUAZGllcmVzaXMAbm90ZXF1YWwAQUUAT3NsYXNoAGluZmluaXR5AHBsdXNtaW51cwBsZXNzZXF1YWwAZ3JlYXRlcmVxdWFsAHllbgBtdQBwYXJ0aWFsZGlmZgBzdW1tYXRpb24AcHJvZHVjdABwaQBpbnRlZ3JhbABvcmRmZW1pbmluZQBvcmRtYXNjdWxpbmUAT21lZ2EAYWUAb3NsYXNoAHF1ZXN0aW9uZG93bgBleGNsYW1kb3duAGxvZ2ljYWxub3QAcmFkaWNhbABmbG9yaW4AYXBwcm94ZXF1YWwARGVsdGEAZ3VpbGxlbW90bGVmdABndWlsbGVtb3RyaWdodABlbGxpcHNpcwBub25icmVha2luZ3NwYWNlAEFncmF2ZQBBdGlsZGUAT3RpbGRlAE9FAG9lAGVuZGFzaABlbWRhc2gAcXVvdGVkYmxsZWZ0AHF1b3RlZGJscmlnaHQAcXVvdGVsZWZ0AHF1b3RlcmlnaHQAZGl2aWRlAGxvemVuZ2UAeWRpZXJlc2lzAFlkaWVyZXNpcwBmcmFjdGlvbgBjdXJyZW5jeQBndWlsc2luZ2xsZWZ0AGd1aWxzaW5nbHJpZ2h0AGZpAGZsAGRhZ2dlcmRibABwZXJpb2RjZW50ZXJlZABxdW90ZXNpbmdsYmFzZQBxdW90ZWRibGJhc2UAcGVydGhvdXNhbmQAQWNpcmN1bWZsZXgARWNpcmN1bWZsZXgAQWFjdXRlAEVkaWVyZXNpcwBFZ3JhdmUASWFjdXRlAEljaXJjdW1mbGV4AElkaWVyZXNpcwBJZ3JhdmUAT2FjdXRlAE9jaXJjdW1mbGV4AGFwcGxlAE9ncmF2ZQBVYWN1dGUAVWNpcmN1bWZsZXgAVWdyYXZlAGRvdGxlc3NpAGNpcmN1bWZsZXgAdGlsZGUAbWFjcm9uAGJyZXZlAGRvdGFjY2VudAByaW5nAGNlZGlsbGEAaHVuZ2FydW1sYXV0AG9nb25lawBjYXJvbgBMc2xhc2gAbHNsYXNoAFNjYXJvbgBzY2Fyb24AWmNhcm9uAHpjYXJvbgBicm9rZW5iYXIARXRoAGV0aABZYWN1dGUAeWFjdXRlAFRob3JuAHRob3JuAG1pbnVzAG11bHRpcGx5AG9uZXN1cGVyaW9yAHR3b3N1cGVyaW9yAHRocmVlc3VwZXJpb3IAb25laGFsZgBvbmVxdWFydGVyAHRocmVlcXVhcnRlcnMAZnJhbmMAR2JyZXZlAGdicmV2ZQBJZG90YWNjZW50AFNjZWRpbGxhAHNjZWRpbGxhAENhY3V0ZQBjYWN1dGUAQ2Nhcm9uAGNjYXJvbgBkY3JvYXQAQZQuC4YICAAAAA4AAAAfAAAAJQAAACwAAAA1AAAAQAAAAEcAAABPAAAAWQAAAGUAAABvAAAAegAAAIMAAACIAAAAjgAAAJUAAACcAAAAogAAAKcAAACrAAAArwAAALUAAAC6AAAAvwAAAMMAAADJAAAAzwAAANQAAADaAAAA5AAAAOkAAADvAAAA9wAAAAABAAADAQAABQEAAAcBAAAJAQAACwEAAA0BAAAPAQAAEQEAABMBAAAVAQAAFwEAABkBAAAbAQAAHQEAAB8BAAAhAQAAIwEAACUBAAAnAQAAKQEAACsBAAAtAQAALwEAADEBAAAzAQAANQEAADcBAABDAQAATQEAAFoBAABmAQAAcQEAAHcBAAB5AQAAewEAAH0BAAB/AQAAgQEAAIMBAACFAQAAhwEAAIkBAACLAQAAjQEAAI8BAACRAQAAkwEAAJUBAACXAQAAmQEAAJsBAACdAQAAnwEAAKEBAACjAQAApQEAAKcBAACpAQAAqwEAALUBAAC5AQAAxAEAAM8BAADZAQAA3wEAAOgBAADvAQAA9gEAAAACAAAKAgAAEQIAABgCAAAkAgAALgIAADUCAAA7AgAARAIAAEsCAABSAgAAXgIAAGgCAABvAgAAdgIAAIICAACMAgAAkwIAAJoCAAChAgAArQIAALcCAAC+AgAAxQIAAMwCAADYAgAA4gIAAOkCAADwAgAA9QIAAP4CAAAGAwAADQMAABcDAAAiAwAALQMAADcDAABBAwAARwMAAFADAABZAwAAXAMAAGMDAABsAwAAdgMAAIADAACNAwAAkQMAAJQDAACgAwAAqgMAALIDAAC1AwAAvgMAAMoDAADXAwAA3QMAAOADAADnAwAA9AMAAP8DAAAKBAAAEgQAABkEAAAlBAAAKwQAADkEAABIBAAAUQQAAGIEAABpBAAAcAQAAHcEAAB6BAAAfQQAAIQEAACLBAAAmAQAAKYEAACwBAAAuwQAAMIEAADKBAAA1AQAAN4EAADnBAAA8AQAAP4EAAANBQAAEAUAABMFAAAdBQAALAUAADsFAABIBQAAVAUAAGAFAABsBQAAcwUAAH0FAACEBQAAiwUAAJcFAAChBQAAqAUAAK8FAAC7BQAAwQUAAMgFAADPBQAA2wUAAOIFAADrBQAA9gUAAPwFAAADBgAACQYAABMGAAAYBgAAIAYAAC0GAAA0BgAAOgYAAEEGAABIBgAATwYAAFYGAABdBgAAZAYAAG4GAAByBgAAdgYAAH0GAACEBgAAigYAAJAGAACWBgAAnwYAAKsGAAC3BgAAxQYAAM0GAADYBgAA5gYAAOwGAADzBgAA+gYAAAUHAAAOBwAAFwcAAB4HAAAlBwAALAcAADMHAAA6BwBBpDYLrRF/AAAAAAAAAIAAAAD/AAAAAQAAAAABAAB/AQAAAgAAAIABAABPAgAAAwAAAFACAACvAgAABAAAALACAAD/AgAABQAAAAADAABvAwAABgAAAHADAAD/AwAABwAAAAAEAAD/BAAACQAAAAAFAAAvBQAACQAAADAFAACPBQAACgAAAJAFAAD/BQAACwAAAAAGAAD/BgAADQAAAAAHAABPBwAARwAAAFAHAAB/BwAADQAAAIAHAAC/BwAASAAAAMAHAAD/BwAADgAAAAAJAAB/CQAADwAAAIAJAAD/CQAAEAAAAAAKAAB/CgAAEQAAAIAKAAD/CgAAEgAAAAALAAB/CwAAEwAAAIALAAD/CwAAFAAAAAAMAAB/DAAAFQAAAIAMAAD/DAAAFgAAAAANAAB/DQAAFwAAAIANAAD/DQAASQAAAAAOAAB/DgAAGAAAAIAOAAD/DgAAGQAAAAAPAAD/DwAARgAAAAAQAACfEAAASgAAAKAQAAD/EAAAGgAAAAARAAD/EQAAHAAAAAASAAB/EwAASwAAAIATAACfEwAASwAAAKATAAD/EwAATAAAAAAUAAB/FgAATQAAAIAWAACfFgAATgAAAKAWAAD/FgAATwAAAAAXAAAfFwAAVAAAACAXAAA/FwAAVAAAAEAXAABfFwAAVAAAAGAXAAB/FwAAVAAAAIAXAAD/FwAAUAAAAAAYAACvGAAAUQAAAAAZAABPGQAAXQAAAFAZAAB/GQAAXgAAAIAZAADfGQAAXwAAAOAZAAD/GQAAUAAAAAAaAAAfGgAAYAAAAAAbAAB/GwAAGwAAAIAbAAC/GwAAcAAAAAAcAABPHAAAcQAAAFAcAAB/HAAAcgAAAAAdAAB/HQAABAAAAIAdAAC/HQAABAAAAMAdAAD/HQAABgAAAAAeAAD/HgAAHQAAAAAfAAD/HwAAHgAAAAAgAABvIAAAHwAAAHAgAACfIAAAIAAAAKAgAADPIAAAIQAAANAgAAD/IAAAIgAAAAAhAABPIQAAIwAAAFAhAACPIQAAJAAAAJAhAAD/IQAAJQAAAAAiAAD/IgAAJgAAAAAjAAD/IwAAJwAAAAAkAAA/JAAAKAAAAEAkAABfJAAAKQAAAGAkAAD/JAAAKgAAAAAlAAB/JQAAKwAAAIAlAACfJQAALAAAAKAlAAD/JQAALQAAAAAmAAD/JgAALgAAAAAnAAC/JwAALwAAAMAnAADvJwAAJgAAAPAnAAD/JwAAJQAAAAAoAAD/KAAAUgAAAAApAAB/KQAAJQAAAIApAAD/KQAAJgAAAAAqAAD/KgAAJgAAAAArAAD/KwAAJQAAAAAsAABfLAAAYQAAAGAsAAB/LAAAHQAAAIAsAAD/LAAACAAAAAAtAAAvLQAAGgAAADAtAAB/LQAAYgAAAIAtAADfLQAASwAAAOAtAAD/LQAACQAAAAAuAAB/LgAAHwAAAIAuAAD/LgAAOwAAAAAvAADfLwAAOwAAAPAvAAD/LwAAOwAAAAAwAAA/MAAAMAAAAEAwAACfMAAAMQAAAKAwAAD/MAAAMgAAAAAxAAAvMQAAMwAAADAxAACPMQAANAAAAJAxAACfMQAAOwAAAKAxAAC/MQAAMwAAAMAxAADvMQAAPQAAAPAxAAD/MQAAMgAAAAAyAAD/MgAANgAAAAAzAAD/MwAANwAAAAA0AAC/TQAAOwAAAMBNAAD/TQAAYwAAAABOAAD/nwAAOwAAAACgAACPpAAAUwAAAJCkAADPpAAAUwAAAAClAAA/pgAADAAAAECmAACfpgAACQAAAACnAAAfpwAABQAAACCnAAD/pwAAHQAAAACoAAAvqAAAZAAAAECoAAB/qAAANQAAAICoAADfqAAAcwAAAACpAAAvqQAAdAAAADCpAABfqQAAdQAAAACqAABfqgAAdgAAAACsAACv1wAAOAAAAADYAAD/3wAAOQAAAADgAAD/+AAAPAAAAAD5AAD/+gAAPQAAAAD7AABP+wAAPgAAAFD7AAD//QAAPwAAAAD+AAAP/gAAWwAAABD+AAAf/gAAQQAAACD+AAAv/gAAQAAAADD+AABP/gAAQQAAAFD+AABv/gAAQgAAAHD+AAD//gAAQwAAAAD/AADv/wAARAAAAPD/AAD//wAARQAAAAAAAQB/AAEAZQAAAIAAAQD/AAEAZQAAAAABAQA/AQEAZQAAAEABAQCPAQEAZgAAAJABAQDPAQEAdwAAANABAQD/AQEAeAAAAIACAQCfAgEAeQAAAKACAQDfAgEAeQAAAAADAQAvAwEAVQAAADADAQBPAwEAVgAAAIADAQCfAwEAZwAAAKADAQDfAwEAaAAAAAAEAQBPBAEAVwAAAFAEAQB/BAEAaQAAAIAEAQCvBAEAagAAAAAIAQA/CAEAawAAAAAJAQAfCQEAOgAAACAJAQA/CQEAeQAAAAAKAQBfCgEAbAAAAAAgAQD/IwEAbgAAAAAkAQB/JAEAbgAAAADQAQD/0AEAWAAAAADRAQD/0QEAWAAAAADSAQBP0gEAWAAAAADTAQBf0wEAbQAAAGDTAQB/0wEAbwAAAADUAQD/1wEAWQAAAADwAQAv8AEAegAAADDwAQCf8AEAegAAAAAAAgDfpgIAOwAAAAD4AgAf+gIAPQAAAAAADgB/AA4AXAAAAAABDgDvAQ4AWwAAAAAADwD9/w8AWgAAAAAAEAD9/xAAWgAAAAAAAAABAAAAAgAAAAMAAAAHAAAADQAAAB8AAAA9AAAAfwAAAPsAAAD9AQAA/QMAAPcHAAD9DwAA/x8AAP0/AADtfwAA8f8AAP//AQD7/wMA//8HAP3/DwD3/x8A/f8/APH/fwD9//8A2f//Afv//wPZ//8Hx///D/3//x/d//8/////fxkACwAZGRkAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAGQAKChkZGQMKBwABAAkLGAAACQYLAAALAAYZAAAAGRkZAEHhxwALIQ4AAAAAAAAAABkACw0ZGRkADQAAAgAJDgAAAAkADgAADgBBm8gACwEMAEGnyAALFRMAAAAAEwAAAAAJDAAAAAAADAAADABB1cgACwEQAEHhyAALFQ8AAAAEDwAAAAAJEAAAAAAAEAAAEABBj8kACwESAEGbyQALHhEAAAAAEQAAAAAJEgAAAAAAEgAAEgAAGgAAABoaGgBB0skACw4aAAAAGhoaAAAAAAAACQBBg8oACwEUAEGPygALFRcAAAAAFwAAAAAJFAAAAAAAFAAAFABBvcoACwEWAEHJygALJxUAAAAAFQAAAAAJFgAAAAAAFgAAFgAAMDEyMzQ1Njc4OUFCQ0RFRgBBjMsACwLoAwBBmMwAC0VfAAAAYAAAAGEAAAAPAAAAYgAAAGMAAABkAAAAEQAAABIAAABlAAAAZgAAAGcAAABoAAAAaQAAAGoAAABrAAAAbAAAAG0AQfTMAAtFDAAAAA0AAAAOAAAADwAAABAAAABuAAAAbwAAABEAAAASAAAAcAAAABMAAABxAAAAFAAAAHIAAABzAAAAdAAAAHUAAAB2AEHYzQALCnAlAADoAwAA6AMAQezNAAsBAQBBgs4ACxGAPwAAgD8AAAEAAAAAAAAAAQBBpM4ACwT/////AEG0zgALAgQmAEHIzgALAsQLAEHYzgALEXcAAAB4AAAAeQAAAHoAAAB7AEGAzwALywFyYXZhRVNBQlREQkNDTEJDIEZGQzJGRkNwYW1jUkxPQ0xBUENyYXZjIHR2Y0dJU0RUREJFQ0xCRUNTQkVtZ3BmcmF2ZnBzYWdGRURHZnlsZ1NPUEdCVVNHcmF2Z3htZGhkYWVoYWVoaHh0bWhSQVZIRlRTSm5yZWthY29sSFNUTEhUQU1weGFtR1JFTWF0ZW1SQVZNVExDUHRzb3BwZXJweGlic1RBVFMgR1ZTWE1EVmFlaHZ4dG12R1JPVlJBVlZlbWFuMi9TT5AtAQ==`);
  }
});

// fonts/wasm/hb-subset.bindings.ts
var hb_subset_bindings_exports = {};
__export(hb_subset_bindings_exports, {
  default: () => hb_subset_bindings_default
});
function subset(hbSubsetWasm, heapu8, font, codePoints) {
  const input = hbSubsetWasm.hb_subset_input_create_or_fail();
  if (input === 0) {
    throw new Error(
      "hb_subset_input_create_or_fail (harfbuzz) returned zero, indicating failure"
    );
  }
  const fontBuffer = hbSubsetWasm.malloc(font.byteLength);
  heapu8.set(new Uint8Array(font), fontBuffer);
  const blob = hbSubsetWasm.hb_blob_create(
    fontBuffer,
    font.byteLength,
    2,
    // HB_MEMORY_MODE_WRITABLE
    0,
    0
  );
  const face = hbSubsetWasm.hb_face_create(blob, 0);
  hbSubsetWasm.hb_blob_destroy(blob);
  const layoutFeatures = hbSubsetWasm.hb_subset_input_set(
    input,
    6
    // HB_SUBSET_SETS_LAYOUT_FEATURE_TAG
  );
  hbSubsetWasm.hb_set_clear(layoutFeatures);
  hbSubsetWasm.hb_set_invert(layoutFeatures);
  const inputUnicodes = hbSubsetWasm.hb_subset_input_unicode_set(input);
  for (const c of codePoints) {
    hbSubsetWasm.hb_set_add(inputUnicodes, c);
  }
  let subset2;
  try {
    subset2 = hbSubsetWasm.hb_subset_or_fail(face, input);
    if (subset2 === 0) {
      hbSubsetWasm.hb_face_destroy(face);
      hbSubsetWasm.free(fontBuffer);
      throw new Error(
        "hb_subset_or_fail (harfbuzz) returned zero, indicating failure. Maybe the input file is corrupted?"
      );
    }
  } finally {
    hbSubsetWasm.hb_subset_input_destroy(input);
  }
  const result = hbSubsetWasm.hb_face_reference_blob(subset2);
  const offset2 = hbSubsetWasm.hb_blob_get_data(result, 0);
  const subsetByteLength = hbSubsetWasm.hb_blob_get_length(result);
  if (subsetByteLength === 0) {
    hbSubsetWasm.hb_blob_destroy(result);
    hbSubsetWasm.hb_face_destroy(subset2);
    hbSubsetWasm.hb_face_destroy(face);
    hbSubsetWasm.free(fontBuffer);
    throw new Error(
      "Failed to create subset font, maybe the input file is corrupted?"
    );
  }
  const subsetFont = new Uint8Array(
    heapu8.subarray(offset2, offset2 + subsetByteLength)
  );
  hbSubsetWasm.hb_blob_destroy(result);
  hbSubsetWasm.hb_face_destroy(subset2);
  hbSubsetWasm.hb_face_destroy(face);
  hbSubsetWasm.free(fontBuffer);
  return subsetFont;
}
var hb_subset_bindings_default;
var init_hb_subset_bindings = __esm({
  "fonts/wasm/hb-subset.bindings.ts"() {
    "use strict";
    init_define_import_meta_env();
    hb_subset_bindings_default = {
      subset
    };
  }
});

// fonts/wasm/hb-subset.loader.ts
var loadedWasm2, load2, hb_subset_loader_default;
var init_hb_subset_loader = __esm({
  "fonts/wasm/hb-subset.loader.ts"() {
    "use strict";
    init_define_import_meta_env();
    loadedWasm2 = null;
    load2 = () => {
      return new Promise(async (resolve, reject) => {
        try {
          const [binary, bindings] = await Promise.all([
            Promise.resolve().then(() => (init_hb_subset_wasm(), hb_subset_wasm_exports)),
            Promise.resolve().then(() => (init_hb_subset_bindings(), hb_subset_bindings_exports))
          ]);
          WebAssembly.instantiate(binary.default).then((module) => {
            try {
              const harfbuzzJsWasm = module.instance.exports;
              const heapu8 = new Uint8Array(harfbuzzJsWasm.memory.buffer);
              const hbSubset = {
                subset: (fontBuffer, codePoints) => {
                  return bindings.default.subset(
                    harfbuzzJsWasm,
                    heapu8,
                    fontBuffer,
                    codePoints
                  );
                }
              };
              resolve(hbSubset);
            } catch (e) {
              reject(e);
            }
          });
        } catch (error) {
          reject(error);
        }
      });
    };
    hb_subset_loader_default = () => {
      if (!loadedWasm2) {
        loadedWasm2 = load2();
      }
      return loadedWasm2;
    };
  }
});

// fonts/ExcalidrawFont.ts
var UNPKG_FALLBACK_URL, ExcalidrawFont;
var init_ExcalidrawFont = __esm({
  "fonts/ExcalidrawFont.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_encode();
    init_metadata();
    init_woff2_loader();
    init_hb_subset_loader();
    UNPKG_FALLBACK_URL = `https://unpkg.com/${define_import_meta_env_default.VITE_PKG_NAME ? `${define_import_meta_env_default.VITE_PKG_NAME}@${define_import_meta_env_default.PKG_VERSION}` : "@excalidraw/excalidraw"}/dist/prod/`;
    ExcalidrawFont = class _ExcalidrawFont {
      urls;
      fontFace;
      constructor(family, uri, descriptors) {
        this.urls = _ExcalidrawFont.createUrls(uri);
        const sources = this.urls.map((url) => `url(${url}) ${_ExcalidrawFont.getFormat(url)}`).join(", ");
        this.fontFace = new FontFace(family, sources, {
          display: "swap",
          style: "normal",
          weight: "400",
          ...descriptors
        });
      }
      /**
       * Tries to fetch woff2 content, based on the registered urls (from first to last, treated as fallbacks).
       *
       * NOTE: assumes usage of `dataurl` outside the browser environment
       *
       * @returns base64 with subsetted glyphs based on the passed codepoint, last defined url otherwise
       */
      async getContent(codePoints) {
        let i = 0;
        const errorMessages = [];
        while (i < this.urls.length) {
          const url = this.urls[i];
          if (url.protocol === "data:") {
            const arrayBuffer = base64ToArrayBuffer(url.toString().split(",")[1]);
            const base64 = await _ExcalidrawFont.subsetGlyphsByCodePoints(
              arrayBuffer,
              codePoints
            );
            return base64;
          }
          try {
            const response = await fetch(url, {
              headers: {
                Accept: "font/woff2"
              }
            });
            if (response.ok) {
              const arrayBuffer = await response.arrayBuffer();
              const base64 = await _ExcalidrawFont.subsetGlyphsByCodePoints(
                arrayBuffer,
                codePoints
              );
              return base64;
            }
            errorMessages.push(
              `"${url.toString()}" returned status "${response.status}"`
            );
          } catch (e) {
            errorMessages.push(`"${url.toString()}" returned error "${e}"`);
          }
          i++;
        }
        console.error(
          `Failed to fetch font "${this.fontFace.family}" from urls "${this.urls.toString()}`,
          JSON.stringify(errorMessages, void 0, 2)
        );
        return this.urls.length ? this.urls[this.urls.length - 1].toString() : "";
      }
      /**
       * Tries to subset glyphs in a font based on the used codepoints, returning the font as daturl.
       *
       * @param arrayBuffer font data buffer, preferrably in the woff2 format, though others should work as well
       * @param codePoints codepoints used to subset the glyphs
       *
       * @returns font with subsetted glyphs (all glyphs in case of errors) converted into a dataurl
       */
      static async subsetGlyphsByCodePoints(arrayBuffer, codePoints) {
        try {
          const { compress, decompress } = await woff2_loader_default();
          const { subset: subset2 } = await hb_subset_loader_default();
          const decompressedBinary = decompress(arrayBuffer).buffer;
          const subsetSnft = subset2(decompressedBinary, codePoints);
          const compressedBinary = compress(subsetSnft.buffer);
          return _ExcalidrawFont.toBase64(compressedBinary.buffer);
        } catch (e) {
          console.error("Skipped glyph subsetting", e);
          return _ExcalidrawFont.toBase64(arrayBuffer);
        }
      }
      static async toBase64(arrayBuffer) {
        let base64;
        if (typeof Buffer !== "undefined") {
          base64 = Buffer.from(arrayBuffer).toString("base64");
        } else {
          base64 = await stringToBase64(await toByteString(arrayBuffer), true);
        }
        return `data:font/woff2;base64,${base64}`;
      }
      static createUrls(uri) {
        if (uri.startsWith(LOCAL_FONT_PROTOCOL)) {
          return [];
        }
        if (uri.startsWith("http") || uri.startsWith("data")) {
          return [new URL(uri)];
        }
        const assetUrl = uri.replace(/^\/+/, "");
        const urls = [];
        if (typeof window.EXCALIDRAW_ASSET_PATH === "string") {
          const normalizedBaseUrl = this.normalizeBaseUrl(
            window.EXCALIDRAW_ASSET_PATH
          );
          urls.push(new URL(assetUrl, normalizedBaseUrl));
        } else if (Array.isArray(window.EXCALIDRAW_ASSET_PATH)) {
          window.EXCALIDRAW_ASSET_PATH.forEach((path) => {
            const normalizedBaseUrl = this.normalizeBaseUrl(path);
            urls.push(new URL(assetUrl, normalizedBaseUrl));
          });
        }
        urls.push(new URL(assetUrl, UNPKG_FALLBACK_URL));
        return urls;
      }
      static getFormat(url) {
        try {
          const parts = new URL(url).pathname.split(".");
          if (parts.length === 1) {
            return "";
          }
          return `format('${parts.pop()}')`;
        } catch (error) {
          return "";
        }
      }
      static normalizeBaseUrl(baseUrl) {
        let result = baseUrl;
        if (/^\.?\//.test(result)) {
          result = new URL(
            result.replace(/^\.?\/+/, ""),
            window?.location?.origin
          ).toString();
        }
        result = `${result.replace(/\/+$/, "")}/`;
        return result;
      }
    };
  }
});

// fonts/assets/Virgil-Regular.woff2
var Virgil_Regular_default;
var init_Virgil_Regular = __esm({
  "fonts/assets/Virgil-Regular.woff2"() {
    Virgil_Regular_default = "./Virgil-Regular-YHAB2VGJ.woff2";
  }
});

// fonts/assets/Excalifont-Regular.woff2
var Excalifont_Regular_default;
var init_Excalifont_Regular = __esm({
  "fonts/assets/Excalifont-Regular.woff2"() {
    Excalifont_Regular_default = "./Excalifont-Regular-CPKEUDVM.woff2";
  }
});

// fonts/assets/CascadiaCode-Regular.woff2
var CascadiaCode_Regular_default;
var init_CascadiaCode_Regular = __esm({
  "fonts/assets/CascadiaCode-Regular.woff2"() {
    CascadiaCode_Regular_default = "./CascadiaCode-Regular-TMZI7IJ5.woff2";
  }
});

// fonts/assets/ComicShanns-Regular.woff2
var ComicShanns_Regular_default;
var init_ComicShanns_Regular = __esm({
  "fonts/assets/ComicShanns-Regular.woff2"() {
    ComicShanns_Regular_default = "./ComicShanns-Regular-6TOETDFT.woff2";
  }
});

// fonts/assets/LiberationSans-Regular.woff2
var LiberationSans_Regular_default;
var init_LiberationSans_Regular = __esm({
  "fonts/assets/LiberationSans-Regular.woff2"() {
    LiberationSans_Regular_default = "./LiberationSans-Regular-ZQD73GJM.woff2";
  }
});

// fonts/assets/Lilita-Regular-i7dPIFZ9Zz-WBtRtedDbYEF8RXi4EwQ.woff2
var Lilita_Regular_i7dPIFZ9Zz_WBtRtedDbYEF8RXi4EwQ_default;
var init_Lilita_Regular_i7dPIFZ9Zz_WBtRtedDbYEF8RXi4EwQ = __esm({
  "fonts/assets/Lilita-Regular-i7dPIFZ9Zz-WBtRtedDbYEF8RXi4EwQ.woff2"() {
    Lilita_Regular_i7dPIFZ9Zz_WBtRtedDbYEF8RXi4EwQ_default = "./Lilita-Regular-i7dPIFZ9Zz-WBtRtedDbYEF8RXi4EwQ-AQ4UK4L6.woff2";
  }
});

// fonts/assets/Lilita-Regular-i7dPIFZ9Zz-WBtRtedDbYE98RXi4EwSsbg.woff2
var Lilita_Regular_i7dPIFZ9Zz_WBtRtedDbYE98RXi4EwSsbg_default;
var init_Lilita_Regular_i7dPIFZ9Zz_WBtRtedDbYE98RXi4EwSsbg = __esm({
  "fonts/assets/Lilita-Regular-i7dPIFZ9Zz-WBtRtedDbYE98RXi4EwSsbg.woff2"() {
    Lilita_Regular_i7dPIFZ9Zz_WBtRtedDbYE98RXi4EwSsbg_default = "./Lilita-Regular-i7dPIFZ9Zz-WBtRtedDbYE98RXi4EwSsbg-YICRZMBJ.woff2";
  }
});

// fonts/assets/Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTQ3j6zbXWjgeg.woff2
var Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTQ3j6zbXWjgeg_default;
var init_Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTQ3j6zbXWjgeg = __esm({
  "fonts/assets/Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTQ3j6zbXWjgeg.woff2"() {
    Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTQ3j6zbXWjgeg_default = "./Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTQ3j6zbXWjgeg-S2BZMVTH.woff2";
  }
});

// fonts/assets/Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTo3j6zbXWjgevT5.woff2
var Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTo3j6zbXWjgevT5_default;
var init_Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTo3j6zbXWjgevT5 = __esm({
  "fonts/assets/Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTo3j6zbXWjgevT5.woff2"() {
    Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTo3j6zbXWjgevT5_default = "./Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTo3j6zbXWjgevT5-PWTUGLZK.woff2";
  }
});

// fonts/assets/Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTA3j6zbXWjgevT5.woff2
var Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTA3j6zbXWjgevT5_default;
var init_Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTA3j6zbXWjgevT5 = __esm({
  "fonts/assets/Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTA3j6zbXWjgevT5.woff2"() {
    Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTA3j6zbXWjgevT5_default = "./Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTA3j6zbXWjgevT5-P2CSI5V6.woff2";
  }
});

// fonts/assets/Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTk3j6zbXWjgevT5.woff2
var Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTk3j6zbXWjgevT5_default;
var init_Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTk3j6zbXWjgevT5 = __esm({
  "fonts/assets/Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTk3j6zbXWjgevT5.woff2"() {
    Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTk3j6zbXWjgevT5_default = "./Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTk3j6zbXWjgevT5-F252BD3S.woff2";
  }
});

// fonts/assets/Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTs3j6zbXWjgevT5.woff2
var Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTs3j6zbXWjgevT5_default;
var init_Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTs3j6zbXWjgevT5 = __esm({
  "fonts/assets/Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTs3j6zbXWjgevT5.woff2"() {
    Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTs3j6zbXWjgevT5_default = "./Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTs3j6zbXWjgevT5-YZLWO63P.woff2";
  }
});

// fonts/index.ts
function register2(family, metadata, ...params) {
  const familyId = FONT_FAMILY[family];
  const registeredFamily = this.registered.get(familyId);
  if (!registeredFamily) {
    this.registered.set(familyId, {
      metadata,
      fonts: params.map(
        ({ uri, descriptors }) => new ExcalidrawFont(family, uri, descriptors)
      )
    });
  }
  return this.registered;
}
var Fonts, getVerticalOffset, getLineHeight;
var init_fonts = __esm({
  "fonts/index.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_ShapeCache();
    init_element();
    init_utils2();
    init_constants();
    init_metadata();
    init_ExcalidrawFont();
    init_textElement();
    init_Virgil_Regular();
    init_Excalifont_Regular();
    init_CascadiaCode_Regular();
    init_ComicShanns_Regular();
    init_LiberationSans_Regular();
    init_Lilita_Regular_i7dPIFZ9Zz_WBtRtedDbYEF8RXi4EwQ();
    init_Lilita_Regular_i7dPIFZ9Zz_WBtRtedDbYE98RXi4EwSsbg();
    init_Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTQ3j6zbXWjgeg();
    init_Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTo3j6zbXWjgevT5();
    init_Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTA3j6zbXWjgevT5();
    init_Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTk3j6zbXWjgevT5();
    init_Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTs3j6zbXWjgevT5();
    Fonts = class _Fonts {
      // it's ok to track fonts across multiple instances only once, so let's use
      // a static member to reduce memory footprint
      static loadedFontsCache = /* @__PURE__ */ new Set();
      static _registered;
      static _initialized = false;
      static get registered() {
        if (!_Fonts._registered) {
          _Fonts._registered = _Fonts.init();
        } else if (!_Fonts._initialized) {
          _Fonts._registered = new Map([
            ..._Fonts.init().entries(),
            ..._Fonts._registered.entries()
          ]);
        }
        return _Fonts._registered;
      }
      get registered() {
        return _Fonts.registered;
      }
      scene;
      constructor({ scene }) {
        this.scene = scene;
      }
      /**
       * if we load a (new) font, it's likely that text elements using it have
       * already been rendered using a fallback font. Thus, we want invalidate
       * their shapes and rerender. See #637.
       *
       * Invalidates text elements and rerenders scene, provided that at least one
       * of the supplied fontFaces has not already been processed.
       */
      onLoaded = (fontFaces) => {
        if (
          // bail if all fonts with have been processed. We're checking just a
          // subset of the font properties (though it should be enough), so it
          // can technically bail on a false positive.
          fontFaces.every((fontFace) => {
            const sig = `${fontFace.family}-${fontFace.style}-${fontFace.weight}-${fontFace.unicodeRange}`;
            if (_Fonts.loadedFontsCache.has(sig)) {
              return true;
            }
            _Fonts.loadedFontsCache.add(sig);
            return false;
          })
        ) {
          return false;
        }
        let didUpdate = false;
        const elementsMap = this.scene.getNonDeletedElementsMap();
        for (const element of this.scene.getNonDeletedElements()) {
          if (isTextElement(element)) {
            didUpdate = true;
            ShapeCache.delete(element);
            const container = getContainerElement(element, elementsMap);
            if (container) {
              ShapeCache.delete(container);
            }
          }
        }
        if (didUpdate) {
          this.scene.triggerUpdate();
        }
      };
      /**
       * Load font faces for a given scene and trigger scene update.
       */
      loadSceneFonts = async () => {
        const sceneFamilies = this.getSceneFontFamilies();
        const loaded = await _Fonts.loadFontFaces(sceneFamilies);
        this.onLoaded(loaded);
        return loaded;
      };
      /**
       * Gets all the font families for the given scene.
       */
      getSceneFontFamilies = () => {
        return _Fonts.getFontFamilies(this.scene.getNonDeletedElements());
      };
      /**
       * Load font faces for passed elements - use when the scene is unavailable (i.e. export).
       */
      static loadFontsForElements = async (elements) => {
        const fontFamilies = _Fonts.getFontFamilies(elements);
        return await _Fonts.loadFontFaces(fontFamilies);
      };
      static async loadFontFaces(fontFamilies) {
        for (const { fonts, metadata } of _Fonts.registered.values()) {
          if (metadata.local) {
            continue;
          }
          for (const { fontFace } of fonts) {
            if (!window.document.fonts.has(fontFace)) {
              window.document.fonts.add(fontFace);
            }
          }
        }
        const loadedFontFaces = await Promise.all(
          fontFamilies.map(async (fontFamily) => {
            const fontString = getFontString({
              fontFamily,
              fontSize: 16
            });
            if (!window.document.fonts.check(fontString)) {
              try {
                return await window.document.fonts.load(fontString);
              } catch (e) {
                console.error(
                  `Failed to load font "${fontString}" from urls "${_Fonts.registered.get(fontFamily)?.fonts.map((x) => x.urls)}"`,
                  e
                );
              }
            }
            return Promise.resolve();
          })
        );
        return loadedFontFaces.flat().filter(Boolean);
      }
      /**
       * WARN: should be called just once on init, even across multiple instances.
       */
      static init() {
        const fonts = {
          registered: /* @__PURE__ */ new Map()
        };
        const _register = register2.bind(fonts);
        _register("Virgil", FONT_METADATA[FONT_FAMILY.Virgil], {
          uri: Virgil_Regular_default
        });
        _register("Excalifont", FONT_METADATA[FONT_FAMILY.Excalifont], {
          uri: Excalifont_Regular_default
        });
        _register("Helvetica", FONT_METADATA[FONT_FAMILY.Helvetica], {
          uri: LOCAL_FONT_PROTOCOL
        });
        _register(
          "Liberation Sans",
          FONT_METADATA[FONT_FAMILY["Liberation Sans"]],
          {
            uri: LiberationSans_Regular_default
          }
        );
        _register("Cascadia", FONT_METADATA[FONT_FAMILY.Cascadia], {
          uri: CascadiaCode_Regular_default
        });
        _register("Comic Shanns", FONT_METADATA[FONT_FAMILY["Comic Shanns"]], {
          uri: ComicShanns_Regular_default
        });
        _register(
          "Lilita One",
          FONT_METADATA[FONT_FAMILY["Lilita One"]],
          { uri: Lilita_Regular_i7dPIFZ9Zz_WBtRtedDbYE98RXi4EwSsbg_default, descriptors: { unicodeRange: RANGES.LATIN_EXT } },
          { uri: Lilita_Regular_i7dPIFZ9Zz_WBtRtedDbYEF8RXi4EwQ_default, descriptors: { unicodeRange: RANGES.LATIN } }
        );
        _register(
          "Nunito",
          FONT_METADATA[FONT_FAMILY.Nunito],
          {
            uri: Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTk3j6zbXWjgevT5_default,
            descriptors: { unicodeRange: RANGES.CYRILIC_EXT, weight: "500" }
          },
          {
            uri: Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTA3j6zbXWjgevT5_default,
            descriptors: { unicodeRange: RANGES.CYRILIC, weight: "500" }
          },
          {
            uri: Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTs3j6zbXWjgevT5_default,
            descriptors: { unicodeRange: RANGES.VIETNAMESE, weight: "500" }
          },
          {
            uri: Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTo3j6zbXWjgevT5_default,
            descriptors: { unicodeRange: RANGES.LATIN_EXT, weight: "500" }
          },
          {
            uri: Nunito_Regular_XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTQ3j6zbXWjgeg_default,
            descriptors: { unicodeRange: RANGES.LATIN, weight: "500" }
          }
        );
        _Fonts._initialized = true;
        return fonts.registered;
      }
      static getFontFamilies(elements) {
        return Array.from(
          elements.reduce((families, element) => {
            if (isTextElement(element)) {
              families.add(element.fontFamily);
            }
            return families;
          }, /* @__PURE__ */ new Set())
        );
      }
    };
    getVerticalOffset = (fontFamily, fontSize, lineHeightPx) => {
      const { unitsPerEm, ascender, descender } = Fonts.registered.get(fontFamily)?.metadata.metrics || FONT_METADATA[FONT_FAMILY.Virgil].metrics;
      const fontSizeEm = fontSize / unitsPerEm;
      const lineGap = (lineHeightPx - fontSizeEm * ascender + fontSizeEm * descender) / 2;
      const verticalOffset = fontSizeEm * ascender + lineGap;
      return verticalOffset;
    };
    getLineHeight = (fontFamily) => {
      const { lineHeight } = Fonts.registered.get(fontFamily)?.metadata.metrics || FONT_METADATA[FONT_FAMILY.Excalifont].metrics;
      return lineHeight;
    };
  }
});

// element/newElement.ts
var _newElementBase, newElement, newEmbeddableElement, newIframeElement, newFrameElement, newMagicFrameElement, getTextElementPositionOffsets, newTextElement, getAdjustedDimensions, adjustXYWithRotation, refreshTextDimensions, newFreeDrawElement, newLinearElement, newArrowElement, newImageElement, _deepCopyElement, deepCopyElement, regenerateId, duplicateElement, duplicateElements;
var init_newElement = __esm({
  "element/newElement.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_utils2();
    init_random();
    init_mutateElement();
    init_groups();
    init_element();
    init_bounds();
    init_textElement();
    init_constants();
    init_fonts();
    _newElementBase = (type, {
      x,
      y,
      strokeColor = DEFAULT_ELEMENT_PROPS.strokeColor,
      backgroundColor = DEFAULT_ELEMENT_PROPS.backgroundColor,
      fillStyle = DEFAULT_ELEMENT_PROPS.fillStyle,
      strokeWidth = DEFAULT_ELEMENT_PROPS.strokeWidth,
      strokeStyle = DEFAULT_ELEMENT_PROPS.strokeStyle,
      roughness = DEFAULT_ELEMENT_PROPS.roughness,
      opacity = DEFAULT_ELEMENT_PROPS.opacity,
      width = 0,
      height = 0,
      angle = 0,
      groupIds = [],
      frameId = null,
      index = null,
      roundness = null,
      boundElements = null,
      link = null,
      locked = DEFAULT_ELEMENT_PROPS.locked,
      ...rest
    }) => {
      const element = {
        id: rest.id || randomId(),
        type,
        x,
        y,
        width,
        height,
        angle,
        strokeColor,
        backgroundColor,
        fillStyle,
        strokeWidth,
        strokeStyle,
        roughness,
        opacity,
        groupIds,
        frameId,
        index,
        roundness,
        seed: rest.seed ?? randomInteger(),
        version: rest.version || 1,
        versionNonce: rest.versionNonce ?? 0,
        isDeleted: false,
        boundElements,
        updated: getUpdatedTimestamp(),
        link,
        locked,
        customData: rest.customData
      };
      return element;
    };
    newElement = (opts) => _newElementBase(opts.type, opts);
    newEmbeddableElement = (opts) => {
      return _newElementBase("embeddable", opts);
    };
    newIframeElement = (opts) => {
      return {
        ..._newElementBase("iframe", opts)
      };
    };
    newFrameElement = (opts) => {
      const frameElement = newElementWith(
        {
          ..._newElementBase("frame", opts),
          type: "frame",
          name: opts?.name || null
        },
        {}
      );
      return frameElement;
    };
    newMagicFrameElement = (opts) => {
      const frameElement = newElementWith(
        {
          ..._newElementBase("magicframe", opts),
          type: "magicframe",
          name: opts?.name || null
        },
        {}
      );
      return frameElement;
    };
    getTextElementPositionOffsets = (opts, metrics) => {
      return {
        x: opts.textAlign === "center" ? metrics.width / 2 : opts.textAlign === "right" ? metrics.width : 0,
        y: opts.verticalAlign === "middle" ? metrics.height / 2 : 0
      };
    };
    newTextElement = (opts) => {
      const fontFamily = opts.fontFamily || DEFAULT_FONT_FAMILY;
      const fontSize = opts.fontSize || DEFAULT_FONT_SIZE;
      const lineHeight = opts.lineHeight || getLineHeight(fontFamily);
      const text = normalizeText(opts.text);
      const metrics = measureText(
        text,
        getFontString({ fontFamily, fontSize }),
        lineHeight
      );
      const textAlign = opts.textAlign || DEFAULT_TEXT_ALIGN;
      const verticalAlign = opts.verticalAlign || DEFAULT_VERTICAL_ALIGN;
      const offsets = getTextElementPositionOffsets(
        { textAlign, verticalAlign },
        metrics
      );
      const textElementProps = {
        ..._newElementBase("text", opts),
        text,
        fontSize,
        fontFamily,
        textAlign,
        verticalAlign,
        x: opts.x - offsets.x,
        y: opts.y - offsets.y,
        width: metrics.width,
        height: metrics.height,
        containerId: opts.containerId || null,
        originalText: opts.originalText ?? text,
        autoResize: opts.autoResize ?? true,
        lineHeight
      };
      const textElement = newElementWith(
        textElementProps,
        {}
      );
      return textElement;
    };
    getAdjustedDimensions = (element, elementsMap, nextText) => {
      let { width: nextWidth, height: nextHeight } = measureText(
        nextText,
        getFontString(element),
        element.lineHeight
      );
      if (!element.autoResize) {
        nextWidth = element.width;
      }
      const { textAlign, verticalAlign } = element;
      let x;
      let y;
      if (textAlign === "center" && verticalAlign === VERTICAL_ALIGN.MIDDLE && !element.containerId && element.autoResize) {
        const prevMetrics = measureText(
          element.text,
          getFontString(element),
          element.lineHeight
        );
        const offsets = getTextElementPositionOffsets(element, {
          width: nextWidth - prevMetrics.width,
          height: nextHeight - prevMetrics.height
        });
        x = element.x - offsets.x;
        y = element.y - offsets.y;
      } else {
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
        const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(
          element,
          nextWidth,
          nextHeight,
          false
        );
        const deltaX1 = (x1 - nextX1) / 2;
        const deltaY1 = (y1 - nextY1) / 2;
        const deltaX2 = (x2 - nextX2) / 2;
        const deltaY2 = (y2 - nextY2) / 2;
        [x, y] = adjustXYWithRotation(
          {
            s: true,
            e: textAlign === "center" || textAlign === "left",
            w: textAlign === "center" || textAlign === "right"
          },
          element.x,
          element.y,
          element.angle,
          deltaX1,
          deltaY1,
          deltaX2,
          deltaY2
        );
      }
      return {
        width: nextWidth,
        height: nextHeight,
        x: Number.isFinite(x) ? x : element.x,
        y: Number.isFinite(y) ? y : element.y
      };
    };
    adjustXYWithRotation = (sides, x, y, angle, deltaX1, deltaY1, deltaX2, deltaY2) => {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      if (sides.e && sides.w) {
        x += deltaX1 + deltaX2;
      } else if (sides.e) {
        x += deltaX1 * (1 + cos);
        y += deltaX1 * sin;
        x += deltaX2 * (1 - cos);
        y += deltaX2 * -sin;
      } else if (sides.w) {
        x += deltaX1 * (1 - cos);
        y += deltaX1 * -sin;
        x += deltaX2 * (1 + cos);
        y += deltaX2 * sin;
      }
      if (sides.n && sides.s) {
        y += deltaY1 + deltaY2;
      } else if (sides.n) {
        x += deltaY1 * sin;
        y += deltaY1 * (1 - cos);
        x += deltaY2 * -sin;
        y += deltaY2 * (1 + cos);
      } else if (sides.s) {
        x += deltaY1 * -sin;
        y += deltaY1 * (1 + cos);
        x += deltaY2 * sin;
        y += deltaY2 * (1 - cos);
      }
      return [x, y];
    };
    refreshTextDimensions = (textElement, container, elementsMap, text = textElement.text) => {
      if (textElement.isDeleted) {
        return;
      }
      if (container || !textElement.autoResize) {
        text = wrapText(
          text,
          getFontString(textElement),
          container ? getBoundTextMaxWidth(container, textElement) : textElement.width
        );
      }
      const dimensions = getAdjustedDimensions(textElement, elementsMap, text);
      return { text, ...dimensions };
    };
    newFreeDrawElement = (opts) => {
      return {
        ..._newElementBase(opts.type, opts),
        points: opts.points || [],
        pressures: opts.pressures || [],
        simulatePressure: opts.simulatePressure,
        lastCommittedPoint: null
      };
    };
    newLinearElement = (opts) => {
      return {
        ..._newElementBase(opts.type, opts),
        points: opts.points || [],
        lastCommittedPoint: null,
        startBinding: null,
        endBinding: null,
        startArrowhead: null,
        endArrowhead: null
      };
    };
    newArrowElement = (opts) => {
      return {
        ..._newElementBase(opts.type, opts),
        points: opts.points || [],
        lastCommittedPoint: null,
        startBinding: null,
        endBinding: null,
        startArrowhead: opts.startArrowhead || null,
        endArrowhead: opts.endArrowhead || null,
        elbowed: opts.elbowed || false
      };
    };
    newImageElement = (opts) => {
      return {
        ..._newElementBase("image", opts),
        // in the future we'll support changing stroke color for some SVG elements,
        // and `transparent` will likely mean "use original colors of the image"
        strokeColor: "transparent",
        status: opts.status ?? "pending",
        fileId: opts.fileId ?? null,
        scale: opts.scale ?? [1, 1]
      };
    };
    _deepCopyElement = (val, depth = 0) => {
      if (val == null || typeof val !== "object") {
        return val;
      }
      const objectType = Object.prototype.toString.call(val);
      if (objectType === "[object Object]") {
        const tmp = typeof val.constructor === "function" ? Object.create(Object.getPrototypeOf(val)) : {};
        for (const key in val) {
          if (val.hasOwnProperty(key)) {
            if (depth === 0 && (key === "shape" || key === "canvas")) {
              continue;
            }
            tmp[key] = _deepCopyElement(val[key], depth + 1);
          }
        }
        return tmp;
      }
      if (Array.isArray(val)) {
        let k = val.length;
        const arr = new Array(k);
        while (k--) {
          arr[k] = _deepCopyElement(val[k], depth + 1);
        }
        return arr;
      }
      if (define_import_meta_env_default.DEV) {
        if (objectType !== "[object Object]" && objectType !== "[object Array]" && objectType.startsWith("[object ")) {
          console.warn(
            `_deepCloneElement: unexpected object type ${objectType}. This value will not be cloned!`
          );
        }
      }
      return val;
    };
    deepCopyElement = (val) => {
      return _deepCopyElement(val);
    };
    regenerateId = (previousId) => {
      if (isTestEnv() && previousId) {
        let nextId = `${previousId}_copy`;
        if (window.h?.app?.getSceneElementsIncludingDeleted().find((el) => el.id === nextId)) {
          nextId += "_copy";
        }
        return nextId;
      }
      return randomId();
    };
    duplicateElement = (editingGroupId, groupIdMapForOperation, element, overrides) => {
      let copy = deepCopyElement(element);
      copy.id = regenerateId(copy.id);
      copy.boundElements = null;
      copy.updated = getUpdatedTimestamp();
      copy.seed = randomInteger();
      copy.groupIds = getNewGroupIdsForDuplication(
        copy.groupIds,
        editingGroupId,
        (groupId) => {
          if (!groupIdMapForOperation.has(groupId)) {
            groupIdMapForOperation.set(groupId, regenerateId(groupId));
          }
          return groupIdMapForOperation.get(groupId);
        }
      );
      if (overrides) {
        copy = Object.assign(copy, overrides);
      }
      return copy;
    };
    duplicateElements = (elements, opts) => {
      const clonedElements = [];
      const origElementsMap = arrayToMap(elements);
      const elementNewIdsMap = /* @__PURE__ */ new Map();
      const maybeGetNewId = (id) => {
        if (elementNewIdsMap.has(id)) {
          return elementNewIdsMap.get(id);
        }
        if (origElementsMap.has(id)) {
          const newId = regenerateId(id);
          elementNewIdsMap.set(id, newId);
          return newId;
        }
        return null;
      };
      const groupNewIdsMap = /* @__PURE__ */ new Map();
      for (const element of elements) {
        const clonedElement = _deepCopyElement(element);
        clonedElement.id = maybeGetNewId(element.id);
        if (opts?.randomizeSeed) {
          clonedElement.seed = randomInteger();
          bumpVersion(clonedElement);
        }
        if (clonedElement.groupIds) {
          clonedElement.groupIds = clonedElement.groupIds.map((groupId) => {
            if (!groupNewIdsMap.has(groupId)) {
              groupNewIdsMap.set(groupId, regenerateId(groupId));
            }
            return groupNewIdsMap.get(groupId);
          });
        }
        if ("containerId" in clonedElement && clonedElement.containerId) {
          const newContainerId = maybeGetNewId(clonedElement.containerId);
          clonedElement.containerId = newContainerId;
        }
        if ("boundElements" in clonedElement && clonedElement.boundElements) {
          clonedElement.boundElements = clonedElement.boundElements.reduce(
            (acc, binding) => {
              const newBindingId = maybeGetNewId(binding.id);
              if (newBindingId) {
                acc.push({ ...binding, id: newBindingId });
              }
              return acc;
            },
            []
          );
        }
        if ("endBinding" in clonedElement && clonedElement.endBinding) {
          const newEndBindingId = maybeGetNewId(clonedElement.endBinding.elementId);
          clonedElement.endBinding = newEndBindingId ? {
            ...clonedElement.endBinding,
            elementId: newEndBindingId
          } : null;
        }
        if ("startBinding" in clonedElement && clonedElement.startBinding) {
          const newEndBindingId = maybeGetNewId(
            clonedElement.startBinding.elementId
          );
          clonedElement.startBinding = newEndBindingId ? {
            ...clonedElement.startBinding,
            elementId: newEndBindingId
          } : null;
        }
        if (clonedElement.frameId) {
          clonedElement.frameId = maybeGetNewId(clonedElement.frameId);
        }
        clonedElements.push(clonedElement);
      }
      return clonedElements;
    };
  }
});

// change.ts
var Delta, AppStateChange, ElementsChange;
var init_change = __esm({
  "change.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_binding();
    init_linearElementEditor();
    init_mutateElement();
    init_textElement();
    init_typeChecks();
    init_fractionalIndex();
    init_groups();
    init_store();
    init_utils2();
    Delta = class _Delta {
      constructor(deleted, inserted) {
        this.deleted = deleted;
        this.inserted = inserted;
      }
      static create(deleted, inserted, modifier, modifierOptions) {
        const modifiedDeleted = modifier && modifierOptions !== "inserted" ? modifier(deleted) : deleted;
        const modifiedInserted = modifier && modifierOptions !== "deleted" ? modifier(inserted) : inserted;
        return new _Delta(modifiedDeleted, modifiedInserted);
      }
      /**
       * Calculates the delta between two objects.
       *
       * @param prevObject - The previous state of the object.
       * @param nextObject - The next state of the object.
       *
       * @returns new delta instance.
       */
      static calculate(prevObject, nextObject, modifier, postProcess) {
        if (prevObject === nextObject) {
          return _Delta.empty();
        }
        const deleted = {};
        const inserted = {};
        for (const key of this.distinctKeysIterator(
          "full",
          prevObject,
          nextObject
        )) {
          deleted[key] = prevObject[key];
          inserted[key] = nextObject[key];
        }
        const [processedDeleted, processedInserted] = postProcess ? postProcess(deleted, inserted) : [deleted, inserted];
        return _Delta.create(processedDeleted, processedInserted, modifier);
      }
      static empty() {
        return new _Delta({}, {});
      }
      static isEmpty(delta) {
        return !Object.keys(delta.deleted).length && !Object.keys(delta.inserted).length;
      }
      /**
       * Merges deleted and inserted object partials.
       */
      static mergeObjects(prev, added, removed) {
        const cloned = { ...prev };
        for (const key of Object.keys(removed)) {
          delete cloned[key];
        }
        return { ...cloned, ...added };
      }
      /**
       * Merges deleted and inserted array partials.
       */
      static mergeArrays(prev, added, removed, predicate) {
        return Object.values(
          _Delta.mergeObjects(
            arrayToObject(prev ?? [], predicate),
            arrayToObject(added ?? [], predicate),
            arrayToObject(removed ?? [], predicate)
          )
        );
      }
      /**
       * Diff object partials as part of the `postProcess`.
       */
      static diffObjects(deleted, inserted, property, setValue) {
        if (!deleted[property] && !inserted[property]) {
          return;
        }
        if (typeof deleted[property] === "object" || typeof inserted[property] === "object") {
          const deletedObject = deleted[property] ?? {};
          const insertedObject = inserted[property] ?? {};
          const deletedDifferences = _Delta.getLeftDifferences(
            deletedObject,
            insertedObject
          ).reduce((acc, curr) => {
            acc[curr] = setValue(deletedObject[curr]);
            return acc;
          }, {});
          const insertedDifferences = _Delta.getRightDifferences(
            deletedObject,
            insertedObject
          ).reduce((acc, curr) => {
            acc[curr] = setValue(insertedObject[curr]);
            return acc;
          }, {});
          if (Object.keys(deletedDifferences).length || Object.keys(insertedDifferences).length) {
            Reflect.set(deleted, property, deletedDifferences);
            Reflect.set(inserted, property, insertedDifferences);
          } else {
            Reflect.deleteProperty(deleted, property);
            Reflect.deleteProperty(inserted, property);
          }
        }
      }
      /**
       * Diff array partials as part of the `postProcess`.
       */
      static diffArrays(deleted, inserted, property, groupBy) {
        if (!deleted[property] && !inserted[property]) {
          return;
        }
        if (Array.isArray(deleted[property]) || Array.isArray(inserted[property])) {
          const deletedArray = Array.isArray(deleted[property]) ? deleted[property] : [];
          const insertedArray = Array.isArray(inserted[property]) ? inserted[property] : [];
          const deletedDifferences = arrayToObject(
            _Delta.getLeftDifferences(
              arrayToObject(deletedArray, groupBy),
              arrayToObject(insertedArray, groupBy)
            )
          );
          const insertedDifferences = arrayToObject(
            _Delta.getRightDifferences(
              arrayToObject(deletedArray, groupBy),
              arrayToObject(insertedArray, groupBy)
            )
          );
          if (Object.keys(deletedDifferences).length || Object.keys(insertedDifferences).length) {
            const deletedValue = deletedArray.filter(
              (x) => deletedDifferences[groupBy ? groupBy(x) : String(x)]
            );
            const insertedValue = insertedArray.filter(
              (x) => insertedDifferences[groupBy ? groupBy(x) : String(x)]
            );
            Reflect.set(deleted, property, deletedValue);
            Reflect.set(inserted, property, insertedValue);
          } else {
            Reflect.deleteProperty(deleted, property);
            Reflect.deleteProperty(inserted, property);
          }
        }
      }
      /**
       * Compares if object1 contains any different value compared to the object2.
       */
      static isLeftDifferent(object1, object2, skipShallowCompare = false) {
        const anyDistinctKey = this.distinctKeysIterator(
          "left",
          object1,
          object2,
          skipShallowCompare
        ).next().value;
        return !!anyDistinctKey;
      }
      /**
       * Compares if object2 contains any different value compared to the object1.
       */
      static isRightDifferent(object1, object2, skipShallowCompare = false) {
        const anyDistinctKey = this.distinctKeysIterator(
          "right",
          object1,
          object2,
          skipShallowCompare
        ).next().value;
        return !!anyDistinctKey;
      }
      /**
       * Returns all the object1 keys that have distinct values.
       */
      static getLeftDifferences(object1, object2, skipShallowCompare = false) {
        return Array.from(
          this.distinctKeysIterator("left", object1, object2, skipShallowCompare)
        );
      }
      /**
       * Returns all the object2 keys that have distinct values.
       */
      static getRightDifferences(object1, object2, skipShallowCompare = false) {
        return Array.from(
          this.distinctKeysIterator("right", object1, object2, skipShallowCompare)
        );
      }
      /**
       * Iterator comparing values of object properties based on the passed joining strategy.
       *
       * @yields keys of properties with different values
       *
       * WARN: it's based on shallow compare performed only on the first level and doesn't go deeper than that.
       */
      static *distinctKeysIterator(join2, object1, object2, skipShallowCompare = false) {
        if (object1 === object2) {
          return;
        }
        let keys = [];
        if (join2 === "left") {
          keys = Object.keys(object1);
        } else if (join2 === "right") {
          keys = Object.keys(object2);
        } else if (join2 === "full") {
          keys = Array.from(
            /* @__PURE__ */ new Set([...Object.keys(object1), ...Object.keys(object2)])
          );
        } else {
          assertNever(
            join2,
            `Unknown distinctKeysIterator's join param "${join2}"`,
            true
          );
        }
        for (const key of keys) {
          const object1Value = object1[key];
          const object2Value = object2[key];
          if (object1Value !== object2Value) {
            if (!skipShallowCompare && typeof object1Value === "object" && typeof object2Value === "object" && object1Value !== null && object2Value !== null && isShallowEqual(object1Value, object2Value)) {
              continue;
            }
            yield key;
          }
        }
      }
    };
    AppStateChange = class _AppStateChange {
      constructor(delta) {
        this.delta = delta;
      }
      static calculate(prevAppState, nextAppState) {
        const delta = Delta.calculate(
          prevAppState,
          nextAppState,
          void 0,
          _AppStateChange.postProcess
        );
        return new _AppStateChange(delta);
      }
      static empty() {
        return new _AppStateChange(Delta.create({}, {}));
      }
      inverse() {
        const inversedDelta = Delta.create(this.delta.inserted, this.delta.deleted);
        return new _AppStateChange(inversedDelta);
      }
      applyTo(appState, nextElements) {
        try {
          const {
            selectedElementIds: removedSelectedElementIds = {},
            selectedGroupIds: removedSelectedGroupIds = {}
          } = this.delta.deleted;
          const {
            selectedElementIds: addedSelectedElementIds = {},
            selectedGroupIds: addedSelectedGroupIds = {},
            selectedLinearElementId,
            editingLinearElementId,
            ...directlyApplicablePartial
          } = this.delta.inserted;
          const mergedSelectedElementIds = Delta.mergeObjects(
            appState.selectedElementIds,
            addedSelectedElementIds,
            removedSelectedElementIds
          );
          const mergedSelectedGroupIds = Delta.mergeObjects(
            appState.selectedGroupIds,
            addedSelectedGroupIds,
            removedSelectedGroupIds
          );
          const selectedLinearElement = selectedLinearElementId && nextElements.has(selectedLinearElementId) ? new LinearElementEditor(
            nextElements.get(
              selectedLinearElementId
            )
          ) : null;
          const editingLinearElement = editingLinearElementId && nextElements.has(editingLinearElementId) ? new LinearElementEditor(
            nextElements.get(
              editingLinearElementId
            )
          ) : null;
          const nextAppState = {
            ...appState,
            ...directlyApplicablePartial,
            selectedElementIds: mergedSelectedElementIds,
            selectedGroupIds: mergedSelectedGroupIds,
            selectedLinearElement: typeof selectedLinearElementId !== "undefined" ? selectedLinearElement : appState.selectedLinearElement,
            // otherwise assign what we had before
            editingLinearElement: typeof editingLinearElementId !== "undefined" ? editingLinearElement : appState.editingLinearElement
            // otherwise assign what we had before
          };
          const constainsVisibleChanges = this.filterInvisibleChanges(
            appState,
            nextAppState,
            nextElements
          );
          return [nextAppState, constainsVisibleChanges];
        } catch (e) {
          console.error(`Couldn't apply appstate change`, e);
          if (define_import_meta_env_default.DEV || define_import_meta_env_default.MODE === ENV.TEST) {
            throw e;
          }
          return [appState, false];
        }
      }
      isEmpty() {
        return Delta.isEmpty(this.delta);
      }
      /**
       * It is necessary to post process the partials in case of reference values,
       * for which we need to calculate the real diff between `deleted` and `inserted`.
       */
      static postProcess(deleted, inserted) {
        try {
          Delta.diffObjects(
            deleted,
            inserted,
            "selectedElementIds",
            // ts language server has a bit trouble resolving this, so we are giving it a little push
            (_) => true
          );
          Delta.diffObjects(
            deleted,
            inserted,
            "selectedGroupIds",
            (prevValue) => prevValue ?? false
          );
        } catch (e) {
          console.error(`Couldn't postprocess appstate change deltas.`);
          if (define_import_meta_env_default.DEV || define_import_meta_env_default.MODE === ENV.TEST) {
            throw e;
          }
        } finally {
          return [deleted, inserted];
        }
      }
      /**
       * Mutates `nextAppState` be filtering out state related to deleted elements.
       *
       * @returns `true` if a visible change is found, `false` otherwise.
       */
      filterInvisibleChanges(prevAppState, nextAppState, nextElements) {
        const prevObservedAppState = getObservedAppState(prevAppState);
        const nextObservedAppState = getObservedAppState(nextAppState);
        const containsStandaloneDifference = Delta.isRightDifferent(
          _AppStateChange.stripElementsProps(prevObservedAppState),
          _AppStateChange.stripElementsProps(nextObservedAppState)
        );
        const containsElementsDifference = Delta.isRightDifferent(
          _AppStateChange.stripStandaloneProps(prevObservedAppState),
          _AppStateChange.stripStandaloneProps(nextObservedAppState)
        );
        if (!containsStandaloneDifference && !containsElementsDifference) {
          return false;
        }
        const visibleDifferenceFlag = {
          value: containsStandaloneDifference
        };
        if (containsElementsDifference) {
          const changedElementsProps = Delta.getRightDifferences(
            _AppStateChange.stripStandaloneProps(prevObservedAppState),
            _AppStateChange.stripStandaloneProps(nextObservedAppState)
          );
          let nonDeletedGroupIds = /* @__PURE__ */ new Set();
          if (changedElementsProps.includes("editingGroupId") || changedElementsProps.includes("selectedGroupIds")) {
            nonDeletedGroupIds = getNonDeletedGroupIds(nextElements);
          }
          for (const key of changedElementsProps) {
            switch (key) {
              case "selectedElementIds":
                nextAppState[key] = _AppStateChange.filterSelectedElements(
                  nextAppState[key],
                  nextElements,
                  visibleDifferenceFlag
                );
                break;
              case "selectedGroupIds":
                nextAppState[key] = _AppStateChange.filterSelectedGroups(
                  nextAppState[key],
                  nonDeletedGroupIds,
                  visibleDifferenceFlag
                );
                break;
              case "editingGroupId":
                const editingGroupId = nextAppState[key];
                if (!editingGroupId) {
                  visibleDifferenceFlag.value = true;
                } else if (nonDeletedGroupIds.has(editingGroupId)) {
                  visibleDifferenceFlag.value = true;
                } else {
                  nextAppState[key] = null;
                }
                break;
              case "selectedLinearElementId":
              case "editingLinearElementId":
                const appStateKey = _AppStateChange.convertToAppStateKey(key);
                const linearElement = nextAppState[appStateKey];
                if (!linearElement) {
                  visibleDifferenceFlag.value = true;
                } else {
                  const element = nextElements.get(linearElement.elementId);
                  if (element && !element.isDeleted) {
                    visibleDifferenceFlag.value = true;
                  } else {
                    nextAppState[appStateKey] = null;
                  }
                }
                break;
              default: {
                assertNever(
                  key,
                  `Unknown ObservedElementsAppState's key "${key}"`,
                  true
                );
              }
            }
          }
        }
        return visibleDifferenceFlag.value;
      }
      static convertToAppStateKey(key) {
        switch (key) {
          case "selectedLinearElementId":
            return "selectedLinearElement";
          case "editingLinearElementId":
            return "editingLinearElement";
        }
      }
      static filterSelectedElements(selectedElementIds, elements, visibleDifferenceFlag) {
        const ids = Object.keys(selectedElementIds);
        if (!ids.length) {
          visibleDifferenceFlag.value = true;
          return selectedElementIds;
        }
        const nextSelectedElementIds = { ...selectedElementIds };
        for (const id of ids) {
          const element = elements.get(id);
          if (element && !element.isDeleted) {
            visibleDifferenceFlag.value = true;
          } else {
            delete nextSelectedElementIds[id];
          }
        }
        return nextSelectedElementIds;
      }
      static filterSelectedGroups(selectedGroupIds, nonDeletedGroupIds, visibleDifferenceFlag) {
        const ids = Object.keys(selectedGroupIds);
        if (!ids.length) {
          visibleDifferenceFlag.value = true;
          return selectedGroupIds;
        }
        const nextSelectedGroupIds = { ...selectedGroupIds };
        for (const id of Object.keys(nextSelectedGroupIds)) {
          if (nonDeletedGroupIds.has(id)) {
            visibleDifferenceFlag.value = true;
          } else {
            delete nextSelectedGroupIds[id];
          }
        }
        return nextSelectedGroupIds;
      }
      static stripElementsProps(delta) {
        const {
          editingGroupId,
          selectedGroupIds,
          selectedElementIds,
          editingLinearElementId,
          selectedLinearElementId,
          ...standaloneProps
        } = delta;
        return standaloneProps;
      }
      static stripStandaloneProps(delta) {
        const { name, viewBackgroundColor, ...elementsProps } = delta;
        return elementsProps;
      }
    };
    ElementsChange = class _ElementsChange {
      constructor(added, removed, updated) {
        this.added = added;
        this.removed = removed;
        this.updated = updated;
      }
      static create(added, removed, updated, options = { shouldRedistribute: false }) {
        let change;
        if (options.shouldRedistribute) {
          const nextAdded = /* @__PURE__ */ new Map();
          const nextRemoved = /* @__PURE__ */ new Map();
          const nextUpdated = /* @__PURE__ */ new Map();
          const deltas = [...added, ...removed, ...updated];
          for (const [id, delta] of deltas) {
            if (this.satisfiesAddition(delta)) {
              nextAdded.set(id, delta);
            } else if (this.satisfiesRemoval(delta)) {
              nextRemoved.set(id, delta);
            } else {
              nextUpdated.set(id, delta);
            }
          }
          change = new _ElementsChange(nextAdded, nextRemoved, nextUpdated);
        } else {
          change = new _ElementsChange(added, removed, updated);
        }
        if (define_import_meta_env_default.DEV || define_import_meta_env_default.MODE === ENV.TEST) {
          _ElementsChange.validate(change, "added", this.satisfiesAddition);
          _ElementsChange.validate(change, "removed", this.satisfiesRemoval);
          _ElementsChange.validate(change, "updated", this.satisfiesUpdate);
        }
        return change;
      }
      static satisfiesAddition = ({
        deleted,
        inserted
      }) => (
        // dissallowing added as "deleted", which could cause issues when resolving conflicts
        deleted.isDeleted === true && !inserted.isDeleted
      );
      static satisfiesRemoval = ({
        deleted,
        inserted
      }) => !deleted.isDeleted && inserted.isDeleted === true;
      static satisfiesUpdate = ({
        deleted,
        inserted
      }) => !!deleted.isDeleted === !!inserted.isDeleted;
      static validate(change, type, satifies) {
        for (const [id, delta] of change[type].entries()) {
          if (!satifies(delta)) {
            console.error(
              `Broken invariant for "${type}" delta, element "${id}", delta:`,
              delta
            );
            throw new Error(`ElementsChange invariant broken for element "${id}".`);
          }
        }
      }
      /**
       * Calculates the `Delta`s between the previous and next set of elements.
       *
       * @param prevElements - Map representing the previous state of elements.
       * @param nextElements - Map representing the next state of elements.
       *
       * @returns `ElementsChange` instance representing the `Delta` changes between the two sets of elements.
       */
      static calculate(prevElements, nextElements) {
        if (prevElements === nextElements) {
          return _ElementsChange.empty();
        }
        const added = /* @__PURE__ */ new Map();
        const removed = /* @__PURE__ */ new Map();
        const updated = /* @__PURE__ */ new Map();
        for (const prevElement of prevElements.values()) {
          const nextElement = nextElements.get(prevElement.id);
          if (!nextElement) {
            const deleted = { ...prevElement, isDeleted: false };
            const inserted = { isDeleted: true };
            const delta = Delta.create(
              deleted,
              inserted,
              _ElementsChange.stripIrrelevantProps
            );
            removed.set(prevElement.id, delta);
          }
        }
        for (const nextElement of nextElements.values()) {
          const prevElement = prevElements.get(nextElement.id);
          if (!prevElement) {
            const deleted = { isDeleted: true };
            const inserted = {
              ...nextElement,
              isDeleted: false
            };
            const delta = Delta.create(
              deleted,
              inserted,
              _ElementsChange.stripIrrelevantProps
            );
            added.set(nextElement.id, delta);
            continue;
          }
          if (prevElement.versionNonce !== nextElement.versionNonce) {
            const delta = Delta.calculate(
              prevElement,
              nextElement,
              _ElementsChange.stripIrrelevantProps,
              _ElementsChange.postProcess
            );
            if (
              // making sure we don't get here some non-boolean values (i.e. undefined, null, etc.)
              typeof prevElement.isDeleted === "boolean" && typeof nextElement.isDeleted === "boolean" && prevElement.isDeleted !== nextElement.isDeleted
            ) {
              if (prevElement.isDeleted && !nextElement.isDeleted) {
                added.set(nextElement.id, delta);
              } else {
                removed.set(nextElement.id, delta);
              }
              continue;
            }
            if (!Delta.isEmpty(delta)) {
              updated.set(nextElement.id, delta);
            }
          }
        }
        return _ElementsChange.create(added, removed, updated);
      }
      static empty() {
        return _ElementsChange.create(/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map());
      }
      inverse() {
        const inverseInternal = (deltas) => {
          const inversedDeltas = /* @__PURE__ */ new Map();
          for (const [id, delta] of deltas.entries()) {
            inversedDeltas.set(id, Delta.create(delta.inserted, delta.deleted));
          }
          return inversedDeltas;
        };
        const added = inverseInternal(this.added);
        const removed = inverseInternal(this.removed);
        const updated = inverseInternal(this.updated);
        return _ElementsChange.create(removed, added, updated);
      }
      isEmpty() {
        return this.added.size === 0 && this.removed.size === 0 && this.updated.size === 0;
      }
      /**
       * Update delta/s based on the existing elements.
       *
       * @param elements current elements
       * @param modifierOptions defines which of the delta (`deleted` or `inserted`) will be updated
       * @returns new instance with modified delta/s
       */
      applyLatestChanges(elements) {
        const modifier = (element) => (partial) => {
          const latestPartial = {};
          for (const key of Object.keys(partial)) {
            switch (key) {
              case "boundElements":
                latestPartial[key] = partial[key];
                break;
              default:
                latestPartial[key] = element[key];
            }
          }
          return latestPartial;
        };
        const applyLatestChangesInternal = (deltas) => {
          const modifiedDeltas = /* @__PURE__ */ new Map();
          for (const [id, delta] of deltas.entries()) {
            const existingElement = elements.get(id);
            if (existingElement) {
              const modifiedDelta = Delta.create(
                delta.deleted,
                delta.inserted,
                modifier(existingElement),
                "inserted"
              );
              modifiedDeltas.set(id, modifiedDelta);
            } else {
              modifiedDeltas.set(id, delta);
            }
          }
          return modifiedDeltas;
        };
        const added = applyLatestChangesInternal(this.added);
        const removed = applyLatestChangesInternal(this.removed);
        const updated = applyLatestChangesInternal(this.updated);
        return _ElementsChange.create(added, removed, updated, {
          shouldRedistribute: true
          // redistribute the deltas as `isDeleted` could have been updated
        });
      }
      applyTo(elements, snapshot) {
        let nextElements = toBrandedType(new Map(elements));
        let changedElements;
        const flags = {
          containsVisibleDifference: false,
          containsZindexDifference: false
        };
        try {
          const applyDeltas = _ElementsChange.createApplier(
            nextElements,
            snapshot,
            flags
          );
          const addedElements = applyDeltas(this.added);
          const removedElements = applyDeltas(this.removed);
          const updatedElements = applyDeltas(this.updated);
          const affectedElements = this.resolveConflicts(elements, nextElements);
          changedElements = new Map([
            ...addedElements,
            ...removedElements,
            ...updatedElements,
            ...affectedElements
          ]);
        } catch (e) {
          console.error(`Couldn't apply elements change`, e);
          if (define_import_meta_env_default.DEV || define_import_meta_env_default.MODE === ENV.TEST) {
            throw e;
          }
          return [elements, true];
        }
        try {
          _ElementsChange.redrawTextBoundingBoxes(nextElements, changedElements);
          nextElements = _ElementsChange.reorderElements(
            nextElements,
            changedElements,
            flags
          );
          _ElementsChange.redrawBoundArrows(nextElements, changedElements);
        } catch (e) {
          console.error(
            `Couldn't mutate elements after applying elements change`,
            e
          );
          if (define_import_meta_env_default.DEV || define_import_meta_env_default.MODE === ENV.TEST) {
            throw e;
          }
        } finally {
          return [nextElements, flags.containsVisibleDifference];
        }
      }
      static createApplier = (nextElements, snapshot, flags) => {
        const getElement = _ElementsChange.createGetter(
          nextElements,
          snapshot,
          flags
        );
        return (deltas) => Array.from(deltas.entries()).reduce((acc, [id, delta]) => {
          const element = getElement(id, delta.inserted);
          if (element) {
            const newElement2 = _ElementsChange.applyDelta(element, delta, flags);
            nextElements.set(newElement2.id, newElement2);
            acc.set(newElement2.id, newElement2);
          }
          return acc;
        }, /* @__PURE__ */ new Map());
      };
      static createGetter = (elements, snapshot, flags) => (id, partial) => {
        let element = elements.get(id);
        if (!element) {
          element = snapshot.get(id);
          if (element) {
            flags.containsZindexDifference = true;
            if (partial.isDeleted === false || partial.isDeleted !== true && element.isDeleted === false) {
              flags.containsVisibleDifference = true;
            }
          }
        }
        return element;
      };
      static applyDelta(element, delta, flags = {
        // by default we don't care about about the flags
        containsVisibleDifference: true,
        containsZindexDifference: true
      }) {
        const { boundElements, ...directlyApplicablePartial } = delta.inserted;
        if (delta.deleted.boundElements?.length || delta.inserted.boundElements?.length) {
          const mergedBoundElements = Delta.mergeArrays(
            element.boundElements,
            delta.inserted.boundElements,
            delta.deleted.boundElements,
            (x) => x.id
          );
          Object.assign(directlyApplicablePartial, {
            boundElements: mergedBoundElements
          });
        }
        if (!flags.containsVisibleDifference) {
          const { index, ...rest } = directlyApplicablePartial;
          const containsVisibleDifference = _ElementsChange.checkForVisibleDifference(element, rest);
          flags.containsVisibleDifference = containsVisibleDifference;
        }
        if (!flags.containsZindexDifference) {
          flags.containsZindexDifference = delta.deleted.index !== delta.inserted.index;
        }
        return newElementWith(element, directlyApplicablePartial);
      }
      /**
       * Check for visible changes regardless of whether they were removed, added or updated.
       */
      static checkForVisibleDifference(element, partial) {
        if (element.isDeleted && partial.isDeleted !== false) {
          return false;
        }
        if (element.isDeleted && partial.isDeleted === false) {
          return true;
        }
        if (element.isDeleted === false && partial.isDeleted) {
          return true;
        }
        return Delta.isRightDifferent(element, partial);
      }
      /**
       * Resolves conflicts for all previously added, removed and updated elements.
       * Updates the previous deltas with all the changes after conflict resolution.
       *
       * @returns all elements affected by the conflict resolution
       */
      resolveConflicts(prevElements, nextElements) {
        const nextAffectedElements = /* @__PURE__ */ new Map();
        const updater = (element, updates) => {
          const nextElement = nextElements.get(element.id);
          if (!nextElement) {
            return;
          }
          let affectedElement;
          if (prevElements.get(element.id) === nextElement) {
            affectedElement = newElementWith(
              nextElement,
              updates
            );
          } else {
            affectedElement = mutateElement(
              nextElement,
              updates
            );
          }
          nextAffectedElements.set(affectedElement.id, affectedElement);
          nextElements.set(affectedElement.id, affectedElement);
        };
        for (const [id] of this.removed) {
          _ElementsChange.unbindAffected(prevElements, nextElements, id, updater);
        }
        for (const [id] of this.added) {
          _ElementsChange.rebindAffected(prevElements, nextElements, id, updater);
        }
        for (const [id] of Array.from(this.updated).filter(
          ([_, delta]) => Object.keys({ ...delta.deleted, ...delta.inserted }).find(
            (prop) => bindingProperties.has(prop)
          )
        )) {
          const updatedElement = nextElements.get(id);
          if (!updatedElement || updatedElement.isDeleted) {
            continue;
          }
          _ElementsChange.rebindAffected(prevElements, nextElements, id, updater);
        }
        const prevAffectedElements = new Map(
          Array.from(prevElements).filter(([id]) => nextAffectedElements.has(id))
        );
        const { added, removed, updated } = _ElementsChange.calculate(
          prevAffectedElements,
          nextAffectedElements
        );
        for (const [id, delta] of added) {
          this.added.set(id, delta);
        }
        for (const [id, delta] of removed) {
          this.removed.set(id, delta);
        }
        for (const [id, delta] of updated) {
          this.updated.set(id, delta);
        }
        return nextAffectedElements;
      }
      /**
       * Non deleted affected elements of removed elements (before and after applying delta),
       * should be unbound ~ bindings should not point from non deleted into the deleted element/s.
       */
      static unbindAffected(prevElements, nextElements, id, updater) {
        const prevElement = () => prevElements.get(id);
        const nextElement = () => nextElements.get(id);
        BoundElement.unbindAffected(nextElements, prevElement(), updater);
        BoundElement.unbindAffected(nextElements, nextElement(), updater);
        BindableElement.unbindAffected(nextElements, prevElement(), updater);
        BindableElement.unbindAffected(nextElements, nextElement(), updater);
      }
      /**
       * Non deleted affected elements of added or updated element/s (before and after applying delta),
       * should be rebound (if possible) with the current element ~ bindings should be bidirectional.
       */
      static rebindAffected(prevElements, nextElements, id, updater) {
        const prevElement = () => prevElements.get(id);
        const nextElement = () => nextElements.get(id);
        BoundElement.unbindAffected(nextElements, prevElement(), updater);
        BoundElement.rebindAffected(nextElements, nextElement(), updater);
        BindableElement.unbindAffected(
          nextElements,
          prevElement(),
          (element, updates) => {
            if (isTextElement(element)) {
              updater(element, updates);
            }
          }
        );
        BindableElement.rebindAffected(nextElements, nextElement(), updater);
      }
      static redrawTextBoundingBoxes(elements, changed) {
        const boxesToRedraw = /* @__PURE__ */ new Map();
        for (const element of changed.values()) {
          if (isBoundToContainer(element)) {
            const { containerId } = element;
            const container = containerId ? elements.get(containerId) : void 0;
            if (container) {
              boxesToRedraw.set(container.id, {
                container,
                boundText: element
              });
            }
          }
          if (hasBoundTextElement(element)) {
            const boundTextElementId = getBoundTextElementId(element);
            const boundText = boundTextElementId ? elements.get(boundTextElementId) : void 0;
            if (boundText) {
              boxesToRedraw.set(element.id, {
                container: element,
                boundText
              });
            }
          }
        }
        for (const { container, boundText } of boxesToRedraw.values()) {
          if (container.isDeleted || boundText.isDeleted) {
            continue;
          }
          redrawTextBoundingBox(boundText, container, elements, false);
        }
      }
      static redrawBoundArrows(elements, changed) {
        for (const element of changed.values()) {
          if (!element.isDeleted && isBindableElement(element)) {
            updateBoundElements(element, elements, {
              changedElements: changed
            });
          }
        }
      }
      static reorderElements(elements, changed, flags) {
        if (!flags.containsZindexDifference) {
          return elements;
        }
        const unordered = Array.from(elements.values());
        const ordered = orderByFractionalIndex([...unordered]);
        const moved = Delta.getRightDifferences(unordered, ordered, true).reduce(
          (acc, arrayIndex) => {
            const candidate = unordered[Number(arrayIndex)];
            if (candidate && changed.has(candidate.id)) {
              acc.set(candidate.id, candidate);
            }
            return acc;
          },
          /* @__PURE__ */ new Map()
        );
        if (!flags.containsVisibleDifference && moved.size) {
          flags.containsVisibleDifference = true;
        }
        return arrayToMap(syncMovedIndices(ordered, moved));
      }
      /**
       * It is necessary to post process the partials in case of reference values,
       * for which we need to calculate the real diff between `deleted` and `inserted`.
       */
      static postProcess(deleted, inserted) {
        try {
          Delta.diffArrays(deleted, inserted, "boundElements", (x) => x.id);
        } catch (e) {
          console.error(`Couldn't postprocess elements change deltas.`);
          if (define_import_meta_env_default.DEV || define_import_meta_env_default.MODE === ENV.TEST) {
            throw e;
          }
        } finally {
          return [deleted, inserted];
        }
      }
      static stripIrrelevantProps(partial) {
        const { id, updated, version, versionNonce, seed, ...strippedPartial } = partial;
        return strippedPartial;
      }
    };
  }
});

// emitter.ts
var Emitter;
var init_emitter = __esm({
  "emitter.ts"() {
    "use strict";
    init_define_import_meta_env();
    Emitter = class {
      subscribers = [];
      /**
       * Attaches subscriber
       *
       * @returns unsubscribe function
       */
      on(...handlers) {
        const _handlers = handlers.flat().filter((item) => typeof item === "function");
        this.subscribers.push(..._handlers);
        return () => this.off(_handlers);
      }
      once(...handlers) {
        const _handlers = handlers.flat().filter((item) => typeof item === "function");
        _handlers.push(() => detach());
        const detach = this.on(..._handlers);
        return detach;
      }
      off(...handlers) {
        const _handlers = handlers.flat();
        this.subscribers = this.subscribers.filter(
          (handler) => !_handlers.includes(handler)
        );
      }
      trigger(...payload) {
        for (const handler of this.subscribers) {
          handler(...payload);
        }
        return this;
      }
      clear() {
        this.subscribers = [];
      }
    };
  }
});

// store.ts
var hiddenObservedAppStateProp, getObservedAppState, isObservedAppState, StoreAction, StoreIncrementEvent, Store, Snapshot;
var init_store = __esm({
  "store.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_appState();
    init_change();
    init_constants();
    init_mutateElement();
    init_newElement();
    init_emitter();
    init_utils2();
    hiddenObservedAppStateProp = "__observedAppState";
    getObservedAppState = (appState) => {
      const observedAppState = {
        name: appState.name,
        editingGroupId: appState.editingGroupId,
        viewBackgroundColor: appState.viewBackgroundColor,
        selectedElementIds: appState.selectedElementIds,
        selectedGroupIds: appState.selectedGroupIds,
        editingLinearElementId: appState.editingLinearElement?.elementId || null,
        selectedLinearElementId: appState.selectedLinearElement?.elementId || null
      };
      Reflect.defineProperty(observedAppState, hiddenObservedAppStateProp, {
        value: true,
        enumerable: false
      });
      return observedAppState;
    };
    isObservedAppState = (appState) => !!Reflect.get(appState, hiddenObservedAppStateProp);
    StoreAction = {
      /**
       * Immediately undoable.
       *
       * Use for updates which should be captured.
       * Should be used for most of the local updates.
       *
       * These updates will _immediately_ make it to the local undo / redo stacks.
       */
      CAPTURE: "capture",
      /**
       * Never undoable.
       *
       * Use for updates which should never be recorded, such as remote updates
       * or scene initialization.
       *
       * These updates will _never_ make it to the local undo / redo stacks.
       */
      UPDATE: "update",
      /**
       * Eventually undoable.
       *
       * Use for updates which should not be captured immediately - likely
       * exceptions which are part of some async multi-step process. Otherwise, all
       * such updates would end up being captured with the next
       * `StoreAction.CAPTURE` - triggered either by the next `updateScene`
       * or internally by the editor.
       *
       * These updates will _eventually_ make it to the local undo / redo stacks.
       */
      NONE: "none"
    };
    StoreIncrementEvent = class {
      constructor(elementsChange, appStateChange) {
        this.elementsChange = elementsChange;
        this.appStateChange = appStateChange;
      }
    };
    Store = class {
      onStoreIncrementEmitter = new Emitter();
      scheduledActions = /* @__PURE__ */ new Set();
      _snapshot = Snapshot.empty();
      get snapshot() {
        return this._snapshot;
      }
      set snapshot(snapshot) {
        this._snapshot = snapshot;
      }
      // TODO: Suspicious that this is called so many places. Seems error-prone.
      shouldCaptureIncrement = () => {
        this.scheduleAction(StoreAction.CAPTURE);
      };
      shouldUpdateSnapshot = () => {
        this.scheduleAction(StoreAction.UPDATE);
      };
      scheduleAction = (action) => {
        this.scheduledActions.add(action);
        this.satisfiesScheduledActionsInvariant();
      };
      commit = (elements, appState) => {
        try {
          if (this.scheduledActions.has(StoreAction.CAPTURE)) {
            this.captureIncrement(elements, appState);
          } else if (this.scheduledActions.has(StoreAction.UPDATE)) {
            this.updateSnapshot(elements, appState);
          }
        } finally {
          this.satisfiesScheduledActionsInvariant();
          this.scheduledActions = /* @__PURE__ */ new Set();
        }
      };
      captureIncrement = (elements, appState) => {
        const prevSnapshot = this.snapshot;
        const nextSnapshot = this.snapshot.maybeClone(elements, appState);
        if (prevSnapshot !== nextSnapshot) {
          const elementsChange = nextSnapshot.meta.didElementsChange ? ElementsChange.calculate(prevSnapshot.elements, nextSnapshot.elements) : ElementsChange.empty();
          const appStateChange = nextSnapshot.meta.didAppStateChange ? AppStateChange.calculate(prevSnapshot.appState, nextSnapshot.appState) : AppStateChange.empty();
          if (!elementsChange.isEmpty() || !appStateChange.isEmpty()) {
            this.onStoreIncrementEmitter.trigger(
              new StoreIncrementEvent(elementsChange, appStateChange)
            );
          }
          this.snapshot = nextSnapshot;
        }
      };
      updateSnapshot = (elements, appState) => {
        const nextSnapshot = this.snapshot.maybeClone(elements, appState);
        if (this.snapshot !== nextSnapshot) {
          this.snapshot = nextSnapshot;
        }
      };
      filterUncomittedElements = (prevElements, nextElements) => {
        for (const [id, prevElement] of prevElements.entries()) {
          const nextElement = nextElements.get(id);
          if (!nextElement) {
            continue;
          }
          const elementSnapshot = this.snapshot.elements.get(id);
          if (!elementSnapshot) {
            nextElements.delete(id);
          } else if (elementSnapshot.version < prevElement.version) {
            nextElements.set(id, elementSnapshot);
          }
        }
        return nextElements;
      };
      clear = () => {
        this.snapshot = Snapshot.empty();
        this.scheduledActions = /* @__PURE__ */ new Set();
      };
      satisfiesScheduledActionsInvariant = () => {
        if (!(this.scheduledActions.size >= 0 && this.scheduledActions.size <= 3)) {
          const message = `There can be at most three store actions scheduled at the same time, but there are "${this.scheduledActions.size}".`;
          console.error(message, this.scheduledActions.values());
          if (define_import_meta_env_default.DEV || define_import_meta_env_default.MODE === ENV.TEST) {
            throw new Error(message);
          }
        }
      };
    };
    Snapshot = class _Snapshot {
      constructor(elements, appState, meta = {
        didElementsChange: false,
        didAppStateChange: false,
        isEmpty: false
      }) {
        this.elements = elements;
        this.appState = appState;
        this.meta = meta;
      }
      static empty() {
        return new _Snapshot(
          /* @__PURE__ */ new Map(),
          getObservedAppState(getDefaultAppState()),
          { didElementsChange: false, didAppStateChange: false, isEmpty: true }
        );
      }
      isEmpty() {
        return this.meta.isEmpty;
      }
      /**
       * Efficiently clone the existing snapshot, only if we detected changes.
       *
       * @returns same instance if there are no changes detected, new instance otherwise.
       */
      maybeClone(elements, appState) {
        const nextElementsSnapshot = this.maybeCreateElementsSnapshot(elements);
        const nextAppStateSnapshot = this.maybeCreateAppStateSnapshot(appState);
        let didElementsChange = false;
        let didAppStateChange = false;
        if (this.elements !== nextElementsSnapshot) {
          didElementsChange = true;
        }
        if (this.appState !== nextAppStateSnapshot) {
          didAppStateChange = true;
        }
        if (!didElementsChange && !didAppStateChange) {
          return this;
        }
        const snapshot = new _Snapshot(nextElementsSnapshot, nextAppStateSnapshot, {
          didElementsChange,
          didAppStateChange
        });
        return snapshot;
      }
      maybeCreateAppStateSnapshot(appState) {
        if (!appState) {
          return this.appState;
        }
        const nextAppStateSnapshot = !isObservedAppState(appState) ? getObservedAppState(appState) : appState;
        const didAppStateChange = this.detectChangedAppState(nextAppStateSnapshot);
        if (!didAppStateChange) {
          return this.appState;
        }
        return nextAppStateSnapshot;
      }
      detectChangedAppState(nextObservedAppState) {
        return !isShallowEqual(this.appState, nextObservedAppState, {
          selectedElementIds: isShallowEqual,
          selectedGroupIds: isShallowEqual
        });
      }
      maybeCreateElementsSnapshot(elements) {
        if (!elements) {
          return this.elements;
        }
        const didElementsChange = this.detectChangedElements(elements);
        if (!didElementsChange) {
          return this.elements;
        }
        const elementsSnapshot = this.createElementsSnapshot(elements);
        return elementsSnapshot;
      }
      /**
       * Detect if there any changed elements.
       *
       * NOTE: we shouldn't just use `sceneVersionNonce` instead, as we need to call this before the scene updates.
       */
      detectChangedElements(nextElements) {
        if (this.elements === nextElements) {
          return false;
        }
        if (this.elements.size !== nextElements.size) {
          return true;
        }
        const keys = Array.from(nextElements.keys());
        for (let i = keys.length - 1; i >= 0; i--) {
          const prev = this.elements.get(keys[i]);
          const next = nextElements.get(keys[i]);
          if (!prev || !next || prev.id !== next.id || prev.versionNonce !== next.versionNonce) {
            return true;
          }
        }
        return false;
      }
      /**
       * Perform structural clone, cloning only elements that changed.
       */
      createElementsSnapshot(nextElements) {
        const clonedElements = /* @__PURE__ */ new Map();
        for (const [id, prevElement] of this.elements.entries()) {
          if (!nextElements.get(id)) {
            clonedElements.set(
              id,
              newElementWith(prevElement, { isDeleted: true })
            );
          } else {
            clonedElements.set(id, prevElement);
          }
        }
        for (const [id, nextElement] of nextElements.entries()) {
          const prevElement = clonedElements.get(id);
          if (!prevElement || // element was added
          prevElement && prevElement.versionNonce !== nextElement.versionNonce) {
            clonedElements.set(id, deepCopyElement(nextElement));
          }
        }
        return clonedElements;
      }
    };
  }
});

// element/embeddable.ts
var embeddedLinkCache, RE_YOUTUBE, RE_VIMEO, RE_FIGMA, RE_GH_GIST, RE_GH_GIST_EMBED, RE_TWITTER, RE_TWITTER_EMBED, RE_VALTOWN, RE_GENERIC_EMBED, RE_GIPHY, RE_REDDIT, RE_REDDIT_EMBED, ALLOWED_DOMAINS, ALLOW_SAME_ORIGIN, createSrcDoc, getEmbedLink, createPlaceholderEmbeddableLabel, actionSetEmbeddableAsActiveTool, matchHostname, maybeParseEmbedSrc, embeddableURLValidator;
var init_embeddable = __esm({
  "element/embeddable.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_register();
    init_constants();
    init_utils2();
    init_cursor();
    init_newElement();
    init_textElement();
    init_typeChecks();
    init_url();
    init_store();
    embeddedLinkCache = /* @__PURE__ */ new Map();
    RE_YOUTUBE = /^(?:http(?:s)?:\/\/)?(?:www\.)?youtu(?:be\.com|\.be)\/(embed\/|watch\?v=|shorts\/|playlist\?list=|embed\/videoseries\?list=)?([a-zA-Z0-9_-]+)(?:\?t=|&t=|\?start=|&start=)?([a-zA-Z0-9_-]+)?[^\s]*$/;
    RE_VIMEO = /^(?:http(?:s)?:\/\/)?(?:(?:w){3}\.)?(?:player\.)?vimeo\.com\/(?:video\/)?([^?\s]+)(?:\?.*)?$/;
    RE_FIGMA = /^https:\/\/(?:www\.)?figma\.com/;
    RE_GH_GIST = /^https:\/\/gist\.github\.com\/([\w_-]+)\/([\w_-]+)/;
    RE_GH_GIST_EMBED = /^<script[\s\S]*?\ssrc=["'](https:\/\/gist\.github\.com\/.*?)\.js["']/i;
    RE_TWITTER = /(?:https?:\/\/)?(?:(?:w){3}\.)?(?:twitter|x)\.com\/[^/]+\/status\/(\d+)/;
    RE_TWITTER_EMBED = /^<blockquote[\s\S]*?\shref=["'](https?:\/\/(?:twitter|x)\.com\/[^"']*)/i;
    RE_VALTOWN = /^https:\/\/(?:www\.)?val\.town\/(v|embed)\/[a-zA-Z_$][0-9a-zA-Z_$]+\.[a-zA-Z_$][0-9a-zA-Z_$]+/;
    RE_GENERIC_EMBED = /^<(?:iframe|blockquote)[\s\S]*?\s(?:src|href)=["']([^"']*)["'][\s\S]*?>$/i;
    RE_GIPHY = /giphy.com\/(?:clips|embed|gifs)\/[a-zA-Z0-9]*?-?([a-zA-Z0-9]+)(?:[^a-zA-Z0-9]|$)/;
    RE_REDDIT = /^(?:http(?:s)?:\/\/)?(?:www\.)?reddit\.com\/r\/([a-zA-Z0-9_]+)\/comments\/([a-zA-Z0-9_]+)\/([a-zA-Z0-9_]+)\/?(?:\?[^#\s]*)?(?:#[^\s]*)?$/;
    RE_REDDIT_EMBED = /^<blockquote[\s\S]*?\shref=["'](https?:\/\/(?:www\.)?reddit\.com\/[^"']*)/i;
    ALLOWED_DOMAINS = /* @__PURE__ */ new Set([
      "youtube.com",
      "youtu.be",
      "vimeo.com",
      "player.vimeo.com",
      "figma.com",
      "link.excalidraw.com",
      "gist.github.com",
      "twitter.com",
      "x.com",
      "*.simplepdf.eu",
      "stackblitz.com",
      "val.town",
      "giphy.com",
      "reddit.com"
    ]);
    ALLOW_SAME_ORIGIN = /* @__PURE__ */ new Set([
      "youtube.com",
      "youtu.be",
      "vimeo.com",
      "player.vimeo.com",
      "figma.com",
      "twitter.com",
      "x.com",
      "*.simplepdf.eu",
      "stackblitz.com",
      "reddit.com"
    ]);
    createSrcDoc = (body) => {
      return `<html><body>${body}</body></html>`;
    };
    getEmbedLink = (link) => {
      if (!link) {
        return null;
      }
      if (embeddedLinkCache.has(link)) {
        return embeddedLinkCache.get(link);
      }
      const originalLink = link;
      const allowSameOrigin = ALLOW_SAME_ORIGIN.has(
        matchHostname(link, ALLOW_SAME_ORIGIN) || ""
      );
      let type = "generic";
      let aspectRatio = { w: 560, h: 840 };
      const ytLink = link.match(RE_YOUTUBE);
      if (ytLink?.[2]) {
        const time = ytLink[3] ? `&start=${ytLink[3]}` : ``;
        const isPortrait = link.includes("shorts");
        type = "video";
        switch (ytLink[1]) {
          case "embed/":
          case "watch?v=":
          case "shorts/":
            link = `https://www.youtube.com/embed/${ytLink[2]}?enablejsapi=1${time}`;
            break;
          case "playlist?list=":
          case "embed/videoseries?list=":
            link = `https://www.youtube.com/embed/videoseries?list=${ytLink[2]}&enablejsapi=1${time}`;
            break;
          default:
            link = `https://www.youtube.com/embed/${ytLink[2]}?enablejsapi=1${time}`;
            break;
        }
        aspectRatio = isPortrait ? { w: 315, h: 560 } : { w: 560, h: 315 };
        embeddedLinkCache.set(originalLink, {
          link,
          intrinsicSize: aspectRatio,
          type,
          sandbox: { allowSameOrigin }
        });
        return {
          link,
          intrinsicSize: aspectRatio,
          type,
          sandbox: { allowSameOrigin }
        };
      }
      const vimeoLink = link.match(RE_VIMEO);
      if (vimeoLink?.[1]) {
        const target = vimeoLink?.[1];
        const error = !/^\d+$/.test(target) ? new URIError("Invalid embed link format") : void 0;
        type = "video";
        link = `https://player.vimeo.com/video/${target}?api=1`;
        aspectRatio = { w: 560, h: 315 };
        embeddedLinkCache.set(originalLink, {
          link,
          intrinsicSize: aspectRatio,
          type,
          sandbox: { allowSameOrigin }
        });
        return {
          link,
          intrinsicSize: aspectRatio,
          type,
          error,
          sandbox: { allowSameOrigin }
        };
      }
      const figmaLink = link.match(RE_FIGMA);
      if (figmaLink) {
        type = "generic";
        link = `https://www.figma.com/embed?embed_host=share&url=${encodeURIComponent(
          link
        )}`;
        aspectRatio = { w: 550, h: 550 };
        embeddedLinkCache.set(originalLink, {
          link,
          intrinsicSize: aspectRatio,
          type,
          sandbox: { allowSameOrigin }
        });
        return {
          link,
          intrinsicSize: aspectRatio,
          type,
          sandbox: { allowSameOrigin }
        };
      }
      const valLink = link.match(RE_VALTOWN);
      if (valLink) {
        link = valLink[1] === "embed" ? valLink[0] : valLink[0].replace("/v", "/embed");
        embeddedLinkCache.set(originalLink, {
          link,
          intrinsicSize: aspectRatio,
          type,
          sandbox: { allowSameOrigin }
        });
        return {
          link,
          intrinsicSize: aspectRatio,
          type,
          sandbox: { allowSameOrigin }
        };
      }
      if (RE_TWITTER.test(link)) {
        const postId = link.match(RE_TWITTER)[1];
        const safeURL = sanitizeHTMLAttribute(
          `https://twitter.com/x/status/${postId}`
        );
        const ret = {
          type: "document",
          srcdoc: (theme) => createSrcDoc(
            `<blockquote class="twitter-tweet" data-dnt="true" data-theme="${theme}"><a href="${safeURL}"></a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"><\/script>`
          ),
          intrinsicSize: { w: 480, h: 480 },
          sandbox: { allowSameOrigin }
        };
        embeddedLinkCache.set(originalLink, ret);
        return ret;
      }
      if (RE_REDDIT.test(link)) {
        const [, page, postId, title] = link.match(RE_REDDIT);
        const safeURL = sanitizeHTMLAttribute(
          `https://reddit.com/r/${page}/comments/${postId}/${title}`
        );
        const ret = {
          type: "document",
          srcdoc: (theme) => createSrcDoc(
            `<blockquote class="reddit-embed-bq" data-embed-theme="${theme}"><a href="${safeURL}"></a><br></blockquote><script async="" src="https://embed.reddit.com/widgets.js" charset="UTF-8"><\/script>`
          ),
          intrinsicSize: { w: 480, h: 480 },
          sandbox: { allowSameOrigin }
        };
        embeddedLinkCache.set(originalLink, ret);
        return ret;
      }
      if (RE_GH_GIST.test(link)) {
        const [, user, gistId] = link.match(RE_GH_GIST);
        const safeURL = sanitizeHTMLAttribute(
          `https://gist.github.com/${user}/${gistId}`
        );
        const ret = {
          type: "document",
          srcdoc: () => createSrcDoc(`
          <script src="${safeURL}.js"><\/script>
          <style type="text/css">
            * { margin: 0px; }
            table, .gist { height: 100%; }
            .gist .gist-file { height: calc(100vh - 2px); padding: 0px; display: grid; grid-template-rows: 1fr auto; }
          </style>
        `),
          intrinsicSize: { w: 550, h: 720 },
          sandbox: { allowSameOrigin }
        };
        embeddedLinkCache.set(link, ret);
        return ret;
      }
      embeddedLinkCache.set(link, {
        link,
        intrinsicSize: aspectRatio,
        type,
        sandbox: { allowSameOrigin }
      });
      return {
        link,
        intrinsicSize: aspectRatio,
        type,
        sandbox: { allowSameOrigin }
      };
    };
    createPlaceholderEmbeddableLabel = (element) => {
      let text;
      if (isIframeElement(element)) {
        text = "IFrame element";
      } else {
        text = !element.link || element?.link === "" ? "Empty Web-Embed" : element.link;
      }
      const fontSize = Math.max(
        Math.min(element.width / 2, element.width / text.length),
        element.width / 30
      );
      const fontFamily = FONT_FAMILY.Helvetica;
      const fontString = getFontString({
        fontSize,
        fontFamily
      });
      return newTextElement({
        x: element.x + element.width / 2,
        y: element.y + element.height / 2,
        strokeColor: element.strokeColor !== "transparent" ? element.strokeColor : "black",
        backgroundColor: "transparent",
        fontFamily,
        fontSize,
        text: wrapText(text, fontString, element.width - 20),
        textAlign: "center",
        verticalAlign: VERTICAL_ALIGN.MIDDLE,
        angle: element.angle ?? 0
      });
    };
    actionSetEmbeddableAsActiveTool = register({
      name: "setEmbeddableAsActiveTool",
      trackEvent: { category: "toolbar" },
      target: "Tool",
      label: "toolBar.embeddable",
      perform: (elements, appState, _, app) => {
        const nextActiveTool = updateActiveTool(appState, {
          type: "embeddable"
        });
        setCursorForShape(app.canvas, {
          ...appState,
          activeTool: nextActiveTool
        });
        return {
          elements,
          appState: {
            ...appState,
            activeTool: updateActiveTool(appState, {
              type: "embeddable"
            })
          },
          storeAction: StoreAction.NONE
        };
      }
    });
    matchHostname = (url, allowedHostnames) => {
      try {
        const { hostname } = new URL(url);
        const bareDomain = hostname.replace(/^www\./, "");
        if (allowedHostnames instanceof Set) {
          if (ALLOWED_DOMAINS.has(bareDomain)) {
            return bareDomain;
          }
          const bareDomainWithFirstSubdomainWildcarded = bareDomain.replace(
            /^([^.]+)/,
            "*"
          );
          if (ALLOWED_DOMAINS.has(bareDomainWithFirstSubdomainWildcarded)) {
            return bareDomainWithFirstSubdomainWildcarded;
          }
          return null;
        }
        const bareAllowedHostname = allowedHostnames.replace(/^www\./, "");
        if (bareDomain === bareAllowedHostname) {
          return bareAllowedHostname;
        }
      } catch (error) {
      }
      return null;
    };
    maybeParseEmbedSrc = (str) => {
      const twitterMatch = str.match(RE_TWITTER_EMBED);
      if (twitterMatch && twitterMatch.length === 2) {
        return twitterMatch[1];
      }
      const redditMatch = str.match(RE_REDDIT_EMBED);
      if (redditMatch && redditMatch.length === 2) {
        return redditMatch[1];
      }
      const gistMatch = str.match(RE_GH_GIST_EMBED);
      if (gistMatch && gistMatch.length === 2) {
        return gistMatch[1];
      }
      if (RE_GIPHY.test(str)) {
        return `https://giphy.com/embed/${RE_GIPHY.exec(str)[1]}`;
      }
      const match = str.match(RE_GENERIC_EMBED);
      if (match && match.length === 2) {
        return match[1];
      }
      return str;
    };
    embeddableURLValidator = (url, validateEmbeddable) => {
      if (!url) {
        return false;
      }
      if (validateEmbeddable != null) {
        if (typeof validateEmbeddable === "function") {
          const ret = validateEmbeddable(url);
          if (typeof ret === "boolean") {
            return ret;
          }
        } else if (typeof validateEmbeddable === "boolean") {
          return validateEmbeddable;
        } else if (validateEmbeddable instanceof RegExp) {
          return validateEmbeddable.test(url);
        } else if (Array.isArray(validateEmbeddable)) {
          for (const domain of validateEmbeddable) {
            if (domain instanceof RegExp) {
              if (url.match(domain)) {
                return true;
              }
            } else if (matchHostname(url, domain)) {
              return true;
            }
          }
          return false;
        }
      }
      return !!matchHostname(url, ALLOWED_DOMAINS);
    };
  }
});

// renderer/staticSvgScene.ts
var roughSVGDrawWithPrecision, maybeWrapNodesInFrameClipPath, renderElementToSvg, renderSceneToSvg;
var init_staticSvgScene = __esm({
  "renderer/staticSvgScene.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_url();
    init_element();
    init_embeddable();
    init_linearElementEditor();
    init_textElement();
    init_typeChecks();
    init_frame();
    init_ShapeCache();
    init_utils2();
    init_renderElement();
    init_fonts();
    init_shapes();
    roughSVGDrawWithPrecision = (rsvg, drawable, precision) => {
      if (typeof precision === "undefined") {
        return rsvg.draw(drawable);
      }
      const pshape = {
        sets: drawable.sets,
        shape: drawable.shape,
        options: { ...drawable.options, fixedDecimalPlaceDigits: precision }
      };
      return rsvg.draw(pshape);
    };
    maybeWrapNodesInFrameClipPath = (element, root, nodes, frameRendering, elementsMap) => {
      if (!frameRendering.enabled || !frameRendering.clip) {
        return null;
      }
      const frame = getContainingFrame(element, elementsMap);
      if (frame) {
        const g = root.ownerDocument.createElementNS(SVG_NS, "g");
        g.setAttributeNS(SVG_NS, "clip-path", `url(#${frame.id})`);
        nodes.forEach((node) => g.appendChild(node));
        return g;
      }
      return null;
    };
    renderElementToSvg = (element, elementsMap, rsvg, svgRoot, files, offsetX, offsetY, renderConfig) => {
      const offset2 = { x: offsetX, y: offsetY };
      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
      let cx = (x2 - x1) / 2 - (element.x - x1);
      let cy = (y2 - y1) / 2 - (element.y - y1);
      if (isTextElement(element)) {
        const container = getContainerElement(element, elementsMap);
        if (isArrowElement(container)) {
          const [x12, y12, x22, y22] = getElementAbsoluteCoords(container, elementsMap);
          const boundTextCoords = LinearElementEditor.getBoundTextElementPosition(
            container,
            element,
            elementsMap
          );
          cx = (x22 - x12) / 2 - (boundTextCoords.x - x12);
          cy = (y22 - y12) / 2 - (boundTextCoords.y - y12);
          offsetX = offsetX + boundTextCoords.x - element.x;
          offsetY = offsetY + boundTextCoords.y - element.y;
        }
      }
      const degree = 180 * element.angle / Math.PI;
      let root = svgRoot;
      if (element.link) {
        const anchorTag = svgRoot.ownerDocument.createElementNS(SVG_NS, "a");
        anchorTag.setAttribute("href", normalizeLink(element.link));
        root.appendChild(anchorTag);
        root = anchorTag;
      }
      const addToRoot = (node, element2) => {
        if (isTestEnv()) {
          node.setAttribute("data-id", element2.id);
        }
        root.appendChild(node);
      };
      const opacity = (getContainingFrame(element, elementsMap)?.opacity ?? 100) * element.opacity / 1e4;
      switch (element.type) {
        case "selection": {
          throw new Error("Selection rendering is not supported for SVG");
        }
        case "rectangle":
        case "diamond":
        case "ellipse": {
          const shape = ShapeCache.generateElementShape(element, null);
          const node = roughSVGDrawWithPrecision(
            rsvg,
            shape,
            MAX_DECIMALS_FOR_SVG_EXPORT
          );
          if (opacity !== 1) {
            node.setAttribute("stroke-opacity", `${opacity}`);
            node.setAttribute("fill-opacity", `${opacity}`);
          }
          node.setAttribute("stroke-linecap", "round");
          node.setAttribute(
            "transform",
            `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
          );
          const g = maybeWrapNodesInFrameClipPath(
            element,
            root,
            [node],
            renderConfig.frameRendering,
            elementsMap
          );
          addToRoot(g || node, element);
          break;
        }
        case "iframe":
        case "embeddable": {
          const shape = ShapeCache.generateElementShape(element, renderConfig);
          const node = roughSVGDrawWithPrecision(
            rsvg,
            shape,
            MAX_DECIMALS_FOR_SVG_EXPORT
          );
          const opacity2 = element.opacity / 100;
          if (opacity2 !== 1) {
            node.setAttribute("stroke-opacity", `${opacity2}`);
            node.setAttribute("fill-opacity", `${opacity2}`);
          }
          node.setAttribute("stroke-linecap", "round");
          node.setAttribute(
            "transform",
            `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
          );
          addToRoot(node, element);
          const label = createPlaceholderEmbeddableLabel(element);
          renderElementToSvg(
            label,
            elementsMap,
            rsvg,
            root,
            files,
            label.x + offset2.x - element.x,
            label.y + offset2.y - element.y,
            renderConfig
          );
          const embeddableNode = roughSVGDrawWithPrecision(
            rsvg,
            shape,
            MAX_DECIMALS_FOR_SVG_EXPORT
          );
          embeddableNode.setAttribute("stroke-linecap", "round");
          embeddableNode.setAttribute(
            "transform",
            `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
          );
          while (embeddableNode.firstChild) {
            embeddableNode.removeChild(embeddableNode.firstChild);
          }
          const radius = getCornerRadius(
            Math.min(element.width, element.height),
            element
          );
          const embedLink = getEmbedLink(toValidURL(element.link || ""));
          if (renderConfig.renderEmbeddables === false || embedLink?.type === "document") {
            const anchorTag = svgRoot.ownerDocument.createElementNS(SVG_NS, "a");
            anchorTag.setAttribute("href", normalizeLink(element.link || ""));
            anchorTag.setAttribute("target", "_blank");
            anchorTag.setAttribute("rel", "noopener noreferrer");
            anchorTag.style.borderRadius = `${radius}px`;
            embeddableNode.appendChild(anchorTag);
          } else {
            const foreignObject = svgRoot.ownerDocument.createElementNS(
              SVG_NS,
              "foreignObject"
            );
            foreignObject.style.width = `${element.width}px`;
            foreignObject.style.height = `${element.height}px`;
            foreignObject.style.border = "none";
            const div = foreignObject.ownerDocument.createElementNS(SVG_NS, "div");
            div.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
            div.style.width = "100%";
            div.style.height = "100%";
            const iframe = div.ownerDocument.createElement("iframe");
            iframe.src = embedLink?.link ?? "";
            iframe.style.width = "100%";
            iframe.style.height = "100%";
            iframe.style.border = "none";
            iframe.style.borderRadius = `${radius}px`;
            iframe.style.top = "0";
            iframe.style.left = "0";
            iframe.allowFullscreen = true;
            div.appendChild(iframe);
            foreignObject.appendChild(div);
            embeddableNode.appendChild(foreignObject);
          }
          addToRoot(embeddableNode, element);
          break;
        }
        case "line":
        case "arrow": {
          const boundText = getBoundTextElement(element, elementsMap);
          const maskPath = svgRoot.ownerDocument.createElementNS(SVG_NS, "mask");
          if (boundText) {
            maskPath.setAttribute("id", `mask-${element.id}`);
            const maskRectVisible = svgRoot.ownerDocument.createElementNS(
              SVG_NS,
              "rect"
            );
            offsetX = offsetX || 0;
            offsetY = offsetY || 0;
            maskRectVisible.setAttribute("x", "0");
            maskRectVisible.setAttribute("y", "0");
            maskRectVisible.setAttribute("fill", "#fff");
            maskRectVisible.setAttribute(
              "width",
              `${element.width + 100 + offsetX}`
            );
            maskRectVisible.setAttribute(
              "height",
              `${element.height + 100 + offsetY}`
            );
            maskPath.appendChild(maskRectVisible);
            const maskRectInvisible = svgRoot.ownerDocument.createElementNS(
              SVG_NS,
              "rect"
            );
            const boundTextCoords = LinearElementEditor.getBoundTextElementPosition(
              element,
              boundText,
              elementsMap
            );
            const maskX = offsetX + boundTextCoords.x - element.x;
            const maskY = offsetY + boundTextCoords.y - element.y;
            maskRectInvisible.setAttribute("x", maskX.toString());
            maskRectInvisible.setAttribute("y", maskY.toString());
            maskRectInvisible.setAttribute("fill", "#000");
            maskRectInvisible.setAttribute("width", `${boundText.width}`);
            maskRectInvisible.setAttribute("height", `${boundText.height}`);
            maskRectInvisible.setAttribute("opacity", "1");
            maskPath.appendChild(maskRectInvisible);
          }
          const group = svgRoot.ownerDocument.createElementNS(SVG_NS, "g");
          if (boundText) {
            group.setAttribute("mask", `url(#mask-${element.id})`);
          }
          group.setAttribute("stroke-linecap", "round");
          const shapes = ShapeCache.generateElementShape(element, renderConfig);
          shapes.forEach((shape) => {
            const node = roughSVGDrawWithPrecision(
              rsvg,
              shape,
              MAX_DECIMALS_FOR_SVG_EXPORT
            );
            if (opacity !== 1) {
              node.setAttribute("stroke-opacity", `${opacity}`);
              node.setAttribute("fill-opacity", `${opacity}`);
            }
            node.setAttribute(
              "transform",
              `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
            );
            if (element.type === "line" && isPathALoop(element.points) && element.backgroundColor !== "transparent") {
              node.setAttribute("fill-rule", "evenodd");
            }
            group.appendChild(node);
          });
          const g = maybeWrapNodesInFrameClipPath(
            element,
            root,
            [group, maskPath],
            renderConfig.frameRendering,
            elementsMap
          );
          if (g) {
            addToRoot(g, element);
            root.appendChild(g);
          } else {
            addToRoot(group, element);
            root.append(maskPath);
          }
          break;
        }
        case "freedraw": {
          const backgroundFillShape = ShapeCache.generateElementShape(
            element,
            renderConfig
          );
          const node = backgroundFillShape ? roughSVGDrawWithPrecision(
            rsvg,
            backgroundFillShape,
            MAX_DECIMALS_FOR_SVG_EXPORT
          ) : svgRoot.ownerDocument.createElementNS(SVG_NS, "g");
          if (opacity !== 1) {
            node.setAttribute("stroke-opacity", `${opacity}`);
            node.setAttribute("fill-opacity", `${opacity}`);
          }
          node.setAttribute(
            "transform",
            `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
          );
          node.setAttribute("stroke", "none");
          const path = svgRoot.ownerDocument.createElementNS(SVG_NS, "path");
          path.setAttribute("fill", element.strokeColor);
          path.setAttribute("d", getFreeDrawSvgPath(element));
          node.appendChild(path);
          const g = maybeWrapNodesInFrameClipPath(
            element,
            root,
            [node],
            renderConfig.frameRendering,
            elementsMap
          );
          addToRoot(g || node, element);
          break;
        }
        case "image": {
          const width = Math.round(element.width);
          const height = Math.round(element.height);
          const fileData = isInitializedImageElement(element) && files[element.fileId];
          if (fileData) {
            const symbolId = `image-${fileData.id}`;
            let symbol = svgRoot.querySelector(`#${symbolId}`);
            if (!symbol) {
              symbol = svgRoot.ownerDocument.createElementNS(SVG_NS, "symbol");
              symbol.id = symbolId;
              const image = svgRoot.ownerDocument.createElementNS(SVG_NS, "image");
              image.setAttribute("width", "100%");
              image.setAttribute("height", "100%");
              image.setAttribute("href", fileData.dataURL);
              image.setAttribute("preserveAspectRatio", "none");
              symbol.appendChild(image);
              root.prepend(symbol);
            }
            const use = svgRoot.ownerDocument.createElementNS(SVG_NS, "use");
            use.setAttribute("href", `#${symbolId}`);
            if (renderConfig.exportWithDarkMode && fileData.mimeType !== MIME_TYPES.svg) {
              use.setAttribute("filter", IMAGE_INVERT_FILTER);
            }
            use.setAttribute("width", `${width}`);
            use.setAttribute("height", `${height}`);
            use.setAttribute("opacity", `${opacity}`);
            if (element.scale[0] !== 1 || element.scale[1] !== 1) {
              const translateX = element.scale[0] !== 1 ? -width : 0;
              const translateY = element.scale[1] !== 1 ? -height : 0;
              use.setAttribute(
                "transform",
                `scale(${element.scale[0]}, ${element.scale[1]}) translate(${translateX} ${translateY})`
              );
            }
            const g = svgRoot.ownerDocument.createElementNS(SVG_NS, "g");
            g.appendChild(use);
            g.setAttribute(
              "transform",
              `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
            );
            if (element.roundness) {
              const clipPath = svgRoot.ownerDocument.createElementNS(
                SVG_NS,
                "clipPath"
              );
              clipPath.id = `image-clipPath-${element.id}`;
              const clipRect = svgRoot.ownerDocument.createElementNS(
                SVG_NS,
                "rect"
              );
              const radius = getCornerRadius(
                Math.min(element.width, element.height),
                element
              );
              clipRect.setAttribute("width", `${element.width}`);
              clipRect.setAttribute("height", `${element.height}`);
              clipRect.setAttribute("rx", `${radius}`);
              clipRect.setAttribute("ry", `${radius}`);
              clipPath.appendChild(clipRect);
              addToRoot(clipPath, element);
              g.setAttributeNS(SVG_NS, "clip-path", `url(#${clipPath.id})`);
            }
            const clipG = maybeWrapNodesInFrameClipPath(
              element,
              root,
              [g],
              renderConfig.frameRendering,
              elementsMap
            );
            addToRoot(clipG || g, element);
          }
          break;
        }
        case "frame":
        case "magicframe": {
          if (renderConfig.frameRendering.enabled && renderConfig.frameRendering.outline) {
            const rect = document.createElementNS(SVG_NS, "rect");
            rect.setAttribute(
              "transform",
              `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
            );
            rect.setAttribute("width", `${element.width}px`);
            rect.setAttribute("height", `${element.height}px`);
            rect.setAttribute("rx", FRAME_STYLE.radius.toString());
            rect.setAttribute("ry", FRAME_STYLE.radius.toString());
            rect.setAttribute("fill", "none");
            rect.setAttribute("stroke", FRAME_STYLE.strokeColor);
            rect.setAttribute("stroke-width", FRAME_STYLE.strokeWidth.toString());
            addToRoot(rect, element);
          }
          break;
        }
        default: {
          if (isTextElement(element)) {
            const node = svgRoot.ownerDocument.createElementNS(SVG_NS, "g");
            if (opacity !== 1) {
              node.setAttribute("stroke-opacity", `${opacity}`);
              node.setAttribute("fill-opacity", `${opacity}`);
            }
            node.setAttribute(
              "transform",
              `translate(${offsetX || 0} ${offsetY || 0}) rotate(${degree} ${cx} ${cy})`
            );
            const lines = element.text.replace(/\r\n?/g, "\n").split("\n");
            const lineHeightPx = getLineHeightInPx(
              element.fontSize,
              element.lineHeight
            );
            const horizontalOffset = element.textAlign === "center" ? element.width / 2 : element.textAlign === "right" ? element.width : 0;
            const verticalOffset = getVerticalOffset(
              element.fontFamily,
              element.fontSize,
              lineHeightPx
            );
            const direction = isRTL(element.text) ? "rtl" : "ltr";
            const textAnchor = element.textAlign === "center" ? "middle" : element.textAlign === "right" || direction === "rtl" ? "end" : "start";
            for (let i = 0; i < lines.length; i++) {
              const text = svgRoot.ownerDocument.createElementNS(SVG_NS, "text");
              text.textContent = lines[i];
              text.setAttribute("x", `${horizontalOffset}`);
              text.setAttribute("y", `${i * lineHeightPx + verticalOffset}`);
              text.setAttribute("font-family", getFontFamilyString(element));
              text.setAttribute("font-size", `${element.fontSize}px`);
              text.setAttribute("fill", element.strokeColor);
              text.setAttribute("text-anchor", textAnchor);
              text.setAttribute("style", "white-space: pre;");
              text.setAttribute("direction", direction);
              text.setAttribute("dominant-baseline", "alphabetic");
              node.appendChild(text);
            }
            const g = maybeWrapNodesInFrameClipPath(
              element,
              root,
              [node],
              renderConfig.frameRendering,
              elementsMap
            );
            addToRoot(g || node, element);
          } else {
            throw new Error(`Unimplemented type ${element.type}`);
          }
        }
      }
    };
    renderSceneToSvg = (elements, elementsMap, rsvg, svgRoot, files, renderConfig) => {
      if (!svgRoot) {
        return;
      }
      elements.filter((el) => !isIframeLikeElement(el)).forEach((element) => {
        if (!element.isDeleted) {
          if (isTextElement(element) && element.containerId && elementsMap.has(element.containerId)) {
            return;
          }
          try {
            renderElementToSvg(
              element,
              elementsMap,
              rsvg,
              svgRoot,
              files,
              element.x + renderConfig.offsetX,
              element.y + renderConfig.offsetY,
              renderConfig
            );
            const boundTextElement = getBoundTextElement(element, elementsMap);
            if (boundTextElement) {
              renderElementToSvg(
                boundTextElement,
                elementsMap,
                rsvg,
                svgRoot,
                files,
                boundTextElement.x + renderConfig.offsetX,
                boundTextElement.y + renderConfig.offsetY,
                renderConfig
              );
            }
          } catch (error) {
            console.error(error);
          }
        }
      });
      elements.filter((el) => isIframeLikeElement(el)).forEach((element) => {
        if (!element.isDeleted) {
          try {
            renderElementToSvg(
              element,
              elementsMap,
              rsvg,
              svgRoot,
              files,
              element.x + renderConfig.offsetX,
              element.y + renderConfig.offsetY,
              renderConfig
            );
          } catch (error) {
            console.error(error);
          }
        }
      });
    };
  }
});

// element/image.ts
var loadHTMLImageElement, updateImageCache, getInitializedImageElements, isHTMLSVGElement, normalizeSVG;
var init_image2 = __esm({
  "element/image.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_typeChecks();
    loadHTMLImageElement = (dataURL) => {
      return new Promise((resolve, reject) => {
        const image = new Image();
        image.onload = () => {
          resolve(image);
        };
        image.onerror = (error) => {
          reject(error);
        };
        image.src = dataURL;
      });
    };
    updateImageCache = async ({
      fileIds,
      files,
      imageCache
    }) => {
      const updatedFiles = /* @__PURE__ */ new Map();
      const erroredFiles = /* @__PURE__ */ new Map();
      await Promise.all(
        fileIds.reduce((promises, fileId) => {
          const fileData = files[fileId];
          if (fileData && !updatedFiles.has(fileId)) {
            updatedFiles.set(fileId, true);
            return promises.concat(
              (async () => {
                try {
                  if (fileData.mimeType === MIME_TYPES.binary) {
                    throw new Error("Only images can be added to ImageCache");
                  }
                  const imagePromise = loadHTMLImageElement(fileData.dataURL);
                  const data = {
                    image: imagePromise,
                    mimeType: fileData.mimeType
                  };
                  imageCache.set(fileId, data);
                  const image = await imagePromise;
                  imageCache.set(fileId, { ...data, image });
                } catch (error) {
                  erroredFiles.set(fileId, true);
                }
              })()
            );
          }
          return promises;
        }, [])
      );
      return {
        imageCache,
        /** includes errored files because they cache was updated nonetheless */
        updatedFiles,
        /** files that failed when creating HTMLImageElement */
        erroredFiles
      };
    };
    getInitializedImageElements = (elements) => elements.filter(
      (element) => isInitializedImageElement(element)
    );
    isHTMLSVGElement = (node) => {
      return node?.nodeName.toLowerCase() === "svg";
    };
    normalizeSVG = async (SVGString) => {
      const doc = new DOMParser().parseFromString(SVGString, MIME_TYPES.svg);
      const svg = doc.querySelector("svg");
      const errorNode = doc.querySelector("parsererror");
      if (errorNode || !isHTMLSVGElement(svg)) {
        throw new Error("Invalid SVG");
      } else {
        if (!svg.hasAttribute("xmlns")) {
          svg.setAttribute("xmlns", SVG_NS);
        }
        if (!svg.hasAttribute("width") || !svg.hasAttribute("height")) {
          const viewBox = svg.getAttribute("viewBox");
          let width = svg.getAttribute("width") || "50";
          let height = svg.getAttribute("height") || "50";
          if (viewBox) {
            const match = viewBox.match(/\d+ +\d+ +(\d+) +(\d+)/);
            if (match) {
              [, width, height] = match;
            }
          }
          svg.setAttribute("width", width);
          svg.setAttribute("height", height);
        }
        return svg.outerHTML;
      }
    };
  }
});

// components/hyperlink/helpers.ts
var EXTERNAL_LINK_IMG, getLinkHandleFromCoords, isPointHittingLinkIcon, isPointHittingLink;
var init_helpers = __esm({
  "components/hyperlink/helpers.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_math();
    init_constants();
    init_bounds();
    init_collision2();
    init_renderElement();
    EXTERNAL_LINK_IMG = document.createElement("img");
    EXTERNAL_LINK_IMG.src = `data:${MIME_TYPES.svg}, ${encodeURIComponent(
      `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#1971c2" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg>`
    )}`;
    getLinkHandleFromCoords = ([x1, y1, x2, y2], angle, appState) => {
      const size = DEFAULT_LINK_SIZE;
      const linkWidth = size / appState.zoom.value;
      const linkHeight = size / appState.zoom.value;
      const linkMarginY = size / appState.zoom.value;
      const centerX = (x1 + x2) / 2;
      const centerY = (y1 + y2) / 2;
      const centeringOffset = (size - 8) / (2 * appState.zoom.value);
      const dashedLineMargin = 4 / appState.zoom.value;
      const x = x2 + dashedLineMargin - centeringOffset;
      const y = y1 - dashedLineMargin - linkMarginY + centeringOffset;
      const [rotatedX, rotatedY] = pointRotateRads(
        pointFrom(x + linkWidth / 2, y + linkHeight / 2),
        pointFrom(centerX, centerY),
        angle
      );
      return [
        rotatedX - linkWidth / 2,
        rotatedY - linkHeight / 2,
        linkWidth,
        linkHeight
      ];
    };
    isPointHittingLinkIcon = (element, elementsMap, appState, [x, y]) => {
      const threshold = 4 / appState.zoom.value;
      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
      const [linkX, linkY, linkWidth, linkHeight] = getLinkHandleFromCoords(
        [x1, y1, x2, y2],
        element.angle,
        appState
      );
      const hitLink = x > linkX - threshold && x < linkX + threshold + linkWidth && y > linkY - threshold && y < linkY + linkHeight + threshold;
      return hitLink;
    };
    isPointHittingLink = (element, elementsMap, appState, [x, y], isMobile) => {
      if (!element.link || appState.selectedElementIds[element.id]) {
        return false;
      }
      if (!isMobile && appState.viewModeEnabled && hitElementBoundingBox(x, y, element, elementsMap)) {
        return true;
      }
      return isPointHittingLinkIcon(
        element,
        elementsMap,
        appState,
        pointFrom(x, y)
      );
    };
  }
});

// renderer/helpers.ts
var fillCircle, getNormalizedCanvasDimensions, bootstrapCanvas;
var init_helpers2 = __esm({
  "renderer/helpers.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    fillCircle = (context, cx, cy, radius, stroke = true) => {
      context.beginPath();
      context.arc(cx, cy, radius, 0, Math.PI * 2);
      context.fill();
      if (stroke) {
        context.stroke();
      }
    };
    getNormalizedCanvasDimensions = (canvas2, scale) => {
      return [canvas2.width / scale, canvas2.height / scale];
    };
    bootstrapCanvas = ({
      canvas: canvas2,
      scale,
      normalizedWidth,
      normalizedHeight,
      theme,
      isExporting,
      viewBackgroundColor
    }) => {
      const context = canvas2.getContext("2d");
      context.setTransform(1, 0, 0, 1, 0, 0);
      context.scale(scale, scale);
      if (isExporting && theme === THEME.DARK) {
        context.filter = THEME_FILTER;
      }
      if (typeof viewBackgroundColor === "string") {
        const hasTransparence = viewBackgroundColor === "transparent" || viewBackgroundColor.length === 5 || // #RGBA
        viewBackgroundColor.length === 9 || // #RRGGBBA
        /(hsla|rgba)\(/.test(viewBackgroundColor);
        if (hasTransparence) {
          context.clearRect(0, 0, normalizedWidth, normalizedHeight);
        }
        context.save();
        context.fillStyle = viewBackgroundColor;
        context.fillRect(0, 0, normalizedWidth, normalizedHeight);
        context.restore();
      } else {
        context.clearRect(0, 0, normalizedWidth, normalizedHeight);
      }
      return context;
    };
  }
});

// renderer/staticScene.ts
var GridLineColor, strokeGrid, frameClip, linkCanvasCache, renderLinkIcon, _renderStaticScene, renderStaticSceneThrottled, renderStaticScene;
var init_staticScene = __esm({
  "renderer/staticScene.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_element();
    init_frame();
    init_typeChecks();
    init_renderElement();
    init_embeddable();
    init_helpers();
    init_helpers2();
    init_utils2();
    init_textElement();
    GridLineColor = {
      Bold: "#dddddd",
      Regular: "#e5e5e5"
    };
    strokeGrid = (context, gridSize, gridStep, scrollX, scrollY, zoom, width, height) => {
      const offsetX = scrollX % gridSize - gridSize;
      const offsetY = scrollY % gridSize - gridSize;
      const actualGridSize = gridSize * zoom.value;
      const spaceWidth = 1 / zoom.value;
      context.save();
      if (zoom.value === 1) {
        context.translate(offsetX % 1 ? 0 : 0.5, offsetY % 1 ? 0 : 0.5);
      }
      for (let x = offsetX; x < offsetX + width + gridSize * 2; x += gridSize) {
        const isBold = gridStep > 1 && Math.round(x - scrollX) % (gridStep * gridSize) === 0;
        if (!isBold && actualGridSize < 10) {
          continue;
        }
        const lineWidth = Math.min(1 / zoom.value, isBold ? 4 : 1);
        context.lineWidth = lineWidth;
        const lineDash = [lineWidth * 3, spaceWidth + (lineWidth + spaceWidth)];
        context.beginPath();
        context.setLineDash(isBold ? [] : lineDash);
        context.strokeStyle = isBold ? GridLineColor.Bold : GridLineColor.Regular;
        context.moveTo(x, offsetY - gridSize);
        context.lineTo(x, Math.ceil(offsetY + height + gridSize * 2));
        context.stroke();
      }
      for (let y = offsetY; y < offsetY + height + gridSize * 2; y += gridSize) {
        const isBold = gridStep > 1 && Math.round(y - scrollY) % (gridStep * gridSize) === 0;
        if (!isBold && actualGridSize < 10) {
          continue;
        }
        const lineWidth = Math.min(1 / zoom.value, isBold ? 4 : 1);
        context.lineWidth = lineWidth;
        const lineDash = [lineWidth * 3, spaceWidth + (lineWidth + spaceWidth)];
        context.beginPath();
        context.setLineDash(isBold ? [] : lineDash);
        context.strokeStyle = isBold ? GridLineColor.Bold : GridLineColor.Regular;
        context.moveTo(offsetX - gridSize, y);
        context.lineTo(Math.ceil(offsetX + width + gridSize * 2), y);
        context.stroke();
      }
      context.restore();
    };
    frameClip = (frame, context, renderConfig, appState) => {
      context.translate(frame.x + appState.scrollX, frame.y + appState.scrollY);
      context.beginPath();
      if (context.roundRect) {
        context.roundRect(
          0,
          0,
          frame.width,
          frame.height,
          FRAME_STYLE.radius / appState.zoom.value
        );
      } else {
        context.rect(0, 0, frame.width, frame.height);
      }
      context.clip();
      context.translate(
        -(frame.x + appState.scrollX),
        -(frame.y + appState.scrollY)
      );
    };
    renderLinkIcon = (element, context, appState, elementsMap) => {
      if (element.link && !appState.selectedElementIds[element.id]) {
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
        const [x, y, width, height] = getLinkHandleFromCoords(
          [x1, y1, x2, y2],
          element.angle,
          appState
        );
        const centerX = x + width / 2;
        const centerY = y + height / 2;
        context.save();
        context.translate(appState.scrollX + centerX, appState.scrollY + centerY);
        context.rotate(element.angle);
        if (!linkCanvasCache || linkCanvasCache.zoom !== appState.zoom.value) {
          linkCanvasCache = document.createElement("canvas");
          linkCanvasCache.zoom = appState.zoom.value;
          linkCanvasCache.width = width * window.devicePixelRatio * appState.zoom.value;
          linkCanvasCache.height = height * window.devicePixelRatio * appState.zoom.value;
          const linkCanvasCacheContext = linkCanvasCache.getContext("2d");
          linkCanvasCacheContext.scale(
            window.devicePixelRatio * appState.zoom.value,
            window.devicePixelRatio * appState.zoom.value
          );
          linkCanvasCacheContext.fillStyle = "#fff";
          linkCanvasCacheContext.fillRect(0, 0, width, height);
          linkCanvasCacheContext.drawImage(EXTERNAL_LINK_IMG, 0, 0, width, height);
          linkCanvasCacheContext.restore();
          context.drawImage(
            linkCanvasCache,
            x - centerX,
            y - centerY,
            width,
            height
          );
        } else {
          context.drawImage(
            linkCanvasCache,
            x - centerX,
            y - centerY,
            width,
            height
          );
        }
        context.restore();
      }
    };
    _renderStaticScene = ({
      canvas: canvas2,
      rc,
      elementsMap,
      allElementsMap,
      visibleElements,
      scale,
      appState,
      renderConfig
    }) => {
      if (canvas2 === null) {
        return;
      }
      const { renderGrid = true, isExporting } = renderConfig;
      const [normalizedWidth, normalizedHeight] = getNormalizedCanvasDimensions(
        canvas2,
        scale
      );
      const context = bootstrapCanvas({
        canvas: canvas2,
        scale,
        normalizedWidth,
        normalizedHeight,
        theme: appState.theme,
        isExporting,
        viewBackgroundColor: appState.viewBackgroundColor
      });
      context.scale(appState.zoom.value, appState.zoom.value);
      if (renderGrid) {
        strokeGrid(
          context,
          appState.gridSize,
          appState.gridStep,
          appState.scrollX,
          appState.scrollY,
          appState.zoom,
          normalizedWidth / appState.zoom.value,
          normalizedHeight / appState.zoom.value
        );
      }
      const groupsToBeAddedToFrame = /* @__PURE__ */ new Set();
      visibleElements.forEach((element) => {
        if (element.groupIds.length > 0 && appState.frameToHighlight && appState.selectedElementIds[element.id] && (elementOverlapsWithFrame(
          element,
          appState.frameToHighlight,
          elementsMap
        ) || element.groupIds.find((groupId) => groupsToBeAddedToFrame.has(groupId)))) {
          element.groupIds.forEach(
            (groupId) => groupsToBeAddedToFrame.add(groupId)
          );
        }
      });
      visibleElements.filter((el) => !isIframeLikeElement(el)).forEach((element) => {
        try {
          const frameId = element.frameId || appState.frameToHighlight?.id;
          if (isTextElement(element) && element.containerId && elementsMap.has(element.containerId)) {
            return;
          }
          context.save();
          if (frameId && appState.frameRendering.enabled && appState.frameRendering.clip) {
            const frame = getTargetFrame(element, elementsMap, appState);
            if (frame && isElementInFrame(element, elementsMap, appState)) {
              frameClip(frame, context, renderConfig, appState);
            }
            renderElement(
              element,
              elementsMap,
              allElementsMap,
              rc,
              context,
              renderConfig,
              appState
            );
          } else {
            renderElement(
              element,
              elementsMap,
              allElementsMap,
              rc,
              context,
              renderConfig,
              appState
            );
          }
          const boundTextElement = getBoundTextElement(element, elementsMap);
          if (boundTextElement) {
            renderElement(
              boundTextElement,
              elementsMap,
              allElementsMap,
              rc,
              context,
              renderConfig,
              appState
            );
          }
          context.restore();
          if (!isExporting) {
            renderLinkIcon(element, context, appState, elementsMap);
          }
        } catch (error) {
          console.error(error);
        }
      });
      visibleElements.filter((el) => isIframeLikeElement(el)).forEach((element) => {
        try {
          const render = () => {
            renderElement(
              element,
              elementsMap,
              allElementsMap,
              rc,
              context,
              renderConfig,
              appState
            );
            if (isIframeLikeElement(element) && (isExporting || isEmbeddableElement(element) && renderConfig.embedsValidationStatus.get(element.id) !== true) && element.width && element.height) {
              const label = createPlaceholderEmbeddableLabel(element);
              renderElement(
                label,
                elementsMap,
                allElementsMap,
                rc,
                context,
                renderConfig,
                appState
              );
            }
            if (!isExporting) {
              renderLinkIcon(element, context, appState, elementsMap);
            }
          };
          const frameId = element.frameId || appState.frameToHighlight?.id;
          if (frameId && appState.frameRendering.enabled && appState.frameRendering.clip) {
            context.save();
            const frame = getTargetFrame(element, elementsMap, appState);
            if (frame && isElementInFrame(element, elementsMap, appState)) {
              frameClip(frame, context, renderConfig, appState);
            }
            render();
            context.restore();
          } else {
            render();
          }
        } catch (error) {
          console.error(error);
        }
      });
      renderConfig.pendingFlowchartNodes?.forEach((element) => {
        try {
          renderElement(
            element,
            elementsMap,
            allElementsMap,
            rc,
            context,
            renderConfig,
            appState
          );
        } catch (error) {
          console.error(error);
        }
      });
    };
    renderStaticSceneThrottled = throttleRAF(
      (config) => {
        _renderStaticScene(config);
      },
      { trailing: true }
    );
    renderStaticScene = (renderConfig, throttle6) => {
      if (throttle6) {
        renderStaticSceneThrottled(renderConfig);
        return;
      }
      _renderStaticScene(renderConfig);
    };
  }
});

// scene/export.ts
import rough from "roughjs/bin/rough";
var SVG_EXPORT_TAG, truncateText, addFrameLabelsAsTextElements, getFrameRenderingConfig, prepareElementsForRender, exportToCanvas, exportToSvg, getCanvasSize, getExportSize, getFontFaces;
var init_export = __esm({
  "scene/export.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_bounds();
    init_staticSvgScene();
    init_utils2();
    init_constants();
    init_appState();
    init_json();
    init_image2();
    init_frame();
    init_element();
    init_mutateElement();
    init_typeChecks();
    init_fractionalIndex();
    init_staticScene();
    init_fonts();
    SVG_EXPORT_TAG = `<!-- svg-source:excalidraw -->`;
    truncateText = (element, maxWidth) => {
      if (element.width <= maxWidth) {
        return element;
      }
      const canvas2 = document.createElement("canvas");
      const ctx = canvas2.getContext("2d");
      ctx.font = getFontString({
        fontFamily: element.fontFamily,
        fontSize: element.fontSize
      });
      let text = element.text;
      const metrics = ctx.measureText(text);
      if (metrics.width > maxWidth) {
        for (let i = text.length; i > 0; i--) {
          const newText = `${text.slice(0, i)}...`;
          if (ctx.measureText(newText).width <= maxWidth) {
            text = newText;
            break;
          }
        }
      }
      return newElementWith(element, { text, width: maxWidth });
    };
    addFrameLabelsAsTextElements = (elements, opts) => {
      const nextElements = [];
      for (const element of elements) {
        if (isFrameLikeElement(element)) {
          let textElement = newTextElement({
            x: element.x,
            y: element.y - FRAME_STYLE.nameOffsetY,
            fontFamily: FONT_FAMILY.Helvetica,
            fontSize: FRAME_STYLE.nameFontSize,
            lineHeight: FRAME_STYLE.nameLineHeight,
            strokeColor: opts.exportWithDarkMode ? FRAME_STYLE.nameColorDarkTheme : FRAME_STYLE.nameColorLightTheme,
            text: getFrameLikeTitle(element)
          });
          textElement.y -= textElement.height;
          textElement = truncateText(textElement, element.width);
          nextElements.push(textElement);
        }
        nextElements.push(element);
      }
      return nextElements;
    };
    getFrameRenderingConfig = (exportingFrame, frameRendering) => {
      frameRendering = frameRendering || getDefaultAppState().frameRendering;
      return {
        enabled: exportingFrame ? true : frameRendering.enabled,
        outline: exportingFrame ? false : frameRendering.outline,
        name: exportingFrame ? false : frameRendering.name,
        clip: exportingFrame ? true : frameRendering.clip
      };
    };
    prepareElementsForRender = ({
      elements,
      exportingFrame,
      frameRendering,
      exportWithDarkMode
    }) => {
      let nextElements;
      if (exportingFrame) {
        nextElements = getElementsOverlappingFrame(elements, exportingFrame);
      } else if (frameRendering.enabled && frameRendering.name) {
        nextElements = addFrameLabelsAsTextElements(elements, {
          exportWithDarkMode
        });
      } else {
        nextElements = elements;
      }
      return nextElements;
    };
    exportToCanvas = async (elements, appState, files, {
      exportBackground,
      exportPadding = DEFAULT_EXPORT_PADDING,
      viewBackgroundColor,
      exportingFrame
    }, createCanvas = (width, height) => {
      const canvas2 = document.createElement("canvas");
      canvas2.width = width * appState.exportScale;
      canvas2.height = height * appState.exportScale;
      return { canvas: canvas2, scale: appState.exportScale };
    }, loadFonts = async () => {
      await Fonts.loadFontsForElements(elements);
    }) => {
      await loadFonts();
      const frameRendering = getFrameRenderingConfig(
        exportingFrame ?? null,
        appState.frameRendering ?? null
      );
      if (exportingFrame) {
        frameRendering.clip = false;
      }
      const elementsForRender = prepareElementsForRender({
        elements,
        exportingFrame,
        exportWithDarkMode: appState.exportWithDarkMode,
        frameRendering
      });
      if (exportingFrame) {
        exportPadding = 0;
      }
      const [minX, minY, width, height] = getCanvasSize(
        exportingFrame ? [exportingFrame] : getRootElements(elementsForRender),
        exportPadding
      );
      const { canvas: canvas2, scale = 1 } = createCanvas(width, height);
      const defaultAppState2 = getDefaultAppState();
      const { imageCache } = await updateImageCache({
        imageCache: /* @__PURE__ */ new Map(),
        fileIds: getInitializedImageElements(elementsForRender).map(
          (element) => element.fileId
        ),
        files
      });
      renderStaticScene({
        canvas: canvas2,
        rc: rough.canvas(canvas2),
        elementsMap: toBrandedType(
          arrayToMap(elementsForRender)
        ),
        allElementsMap: toBrandedType(
          arrayToMap(syncInvalidIndices(elements))
        ),
        visibleElements: elementsForRender,
        scale,
        appState: {
          ...appState,
          frameRendering,
          viewBackgroundColor: exportBackground ? viewBackgroundColor : null,
          scrollX: -minX + exportPadding,
          scrollY: -minY + exportPadding,
          zoom: defaultAppState2.zoom,
          shouldCacheIgnoreZoom: false,
          theme: appState.exportWithDarkMode ? THEME.DARK : THEME.LIGHT
        },
        renderConfig: {
          canvasBackgroundColor: viewBackgroundColor,
          imageCache,
          renderGrid: false,
          isExporting: true,
          // empty disables embeddable rendering
          embedsValidationStatus: /* @__PURE__ */ new Map(),
          elementsPendingErasure: /* @__PURE__ */ new Set(),
          pendingFlowchartNodes: null
        }
      });
      return canvas2;
    };
    exportToSvg = async (elements, appState, files, opts) => {
      const frameRendering = getFrameRenderingConfig(
        opts?.exportingFrame ?? null,
        appState.frameRendering ?? null
      );
      let {
        exportPadding = DEFAULT_EXPORT_PADDING,
        exportWithDarkMode = false,
        viewBackgroundColor,
        exportScale = 1,
        exportEmbedScene
      } = appState;
      const { exportingFrame = null } = opts || {};
      const elementsForRender = prepareElementsForRender({
        elements,
        exportingFrame,
        exportWithDarkMode,
        frameRendering
      });
      if (exportingFrame) {
        exportPadding = 0;
      }
      let metadata = "";
      if (exportEmbedScene) {
        try {
          metadata = await (await Promise.resolve().then(() => (init_image(), image_exports))).encodeSvgMetadata({
            // when embedding scene, we want to embed the origionally supplied
            // elements which don't contain the temp frame labels.
            // But it also requires that the exportToSvg is being supplied with
            // only the elements that we're exporting, and no extra.
            text: serializeAsJSON(elements, appState, files || {}, "local")
          });
        } catch (error) {
          console.error(error);
        }
      }
      const [minX, minY, width, height] = getCanvasSize(
        exportingFrame ? [exportingFrame] : getRootElements(elementsForRender),
        exportPadding
      );
      const svgRoot = document.createElementNS(SVG_NS, "svg");
      svgRoot.setAttribute("version", "1.1");
      svgRoot.setAttribute("xmlns", SVG_NS);
      svgRoot.setAttribute("viewBox", `0 0 ${width} ${height}`);
      svgRoot.setAttribute("width", `${width * exportScale}`);
      svgRoot.setAttribute("height", `${height * exportScale}`);
      if (exportWithDarkMode) {
        svgRoot.setAttribute("filter", THEME_FILTER);
      }
      const offsetX = -minX + exportPadding;
      const offsetY = -minY + exportPadding;
      const frameElements = getFrameLikeElements(elements);
      let exportingFrameClipPath = "";
      const elementsMap = arrayToMap(elements);
      for (const frame of frameElements) {
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(frame, elementsMap);
        const cx = (x2 - x1) / 2 - (frame.x - x1);
        const cy = (y2 - y1) / 2 - (frame.y - y1);
        exportingFrameClipPath += `<clipPath id=${frame.id}>
            <rect transform="translate(${frame.x + offsetX} ${frame.y + offsetY}) rotate(${frame.angle} ${cx} ${cy})"
          width="${frame.width}"
          height="${frame.height}"
          ${exportingFrame ? "" : `rx=${FRAME_STYLE.radius} ry=${FRAME_STYLE.radius}`}
          >
          </rect>
        </clipPath>`;
      }
      const fontFaces = opts?.skipInliningFonts ? [] : await getFontFaces(elements);
      svgRoot.innerHTML = `
  ${SVG_EXPORT_TAG}
  ${metadata}
  <defs>
    <style class="style-fonts">
      ${fontFaces.join("\n")}
    </style>
    ${exportingFrameClipPath}
  </defs>
  `;
      if (appState.exportBackground && viewBackgroundColor) {
        const rect = svgRoot.ownerDocument.createElementNS(SVG_NS, "rect");
        rect.setAttribute("x", "0");
        rect.setAttribute("y", "0");
        rect.setAttribute("width", `${width}`);
        rect.setAttribute("height", `${height}`);
        rect.setAttribute("fill", viewBackgroundColor);
        svgRoot.appendChild(rect);
      }
      const rsvg = rough.svg(svgRoot);
      const renderEmbeddables = opts?.renderEmbeddables ?? false;
      renderSceneToSvg(
        elementsForRender,
        toBrandedType(arrayToMap(elementsForRender)),
        rsvg,
        svgRoot,
        files || {},
        {
          offsetX,
          offsetY,
          isExporting: true,
          exportWithDarkMode,
          renderEmbeddables,
          frameRendering,
          canvasBackgroundColor: viewBackgroundColor,
          embedsValidationStatus: renderEmbeddables ? new Map(
            elementsForRender.filter((element) => isFrameLikeElement(element)).map((element) => [element.id, true])
          ) : /* @__PURE__ */ new Map()
        }
      );
      return svgRoot;
    };
    getCanvasSize = (elements, exportPadding) => {
      const [minX, minY, maxX, maxY] = getCommonBounds(elements);
      const width = distance(minX, maxX) + exportPadding * 2;
      const height = distance(minY, maxY) + exportPadding * 2;
      return [minX, minY, width, height];
    };
    getExportSize = (elements, exportPadding, scale) => {
      const [, , width, height] = getCanvasSize(elements, exportPadding).map(
        (dimension) => Math.trunc(dimension * scale)
      );
      return [width, height];
    };
    getFontFaces = async (elements) => {
      const fontFamilies = /* @__PURE__ */ new Set();
      const codePoints = /* @__PURE__ */ new Set();
      for (const element of elements) {
        if (!isTextElement(element)) {
          continue;
        }
        fontFamilies.add(element.fontFamily);
        for (const codePoint of Array.from(
          element.originalText,
          (u) => u.codePointAt(0)
        )) {
          if (codePoint) {
            codePoints.add(codePoint);
          }
        }
      }
      const getSource = (font) => {
        try {
          return font.getContent(codePoints);
        } catch {
          return font.urls[0].toString();
        }
      };
      const fontFaces = await Promise.all(
        Array.from(fontFamilies).map(async (x) => {
          const { fonts, metadata } = Fonts.registered.get(x) ?? {};
          if (!Array.isArray(fonts)) {
            console.error(
              `Couldn't find registered fonts for font-family "${x}"`,
              Fonts.registered
            );
            return [];
          }
          if (metadata?.local) {
            return [];
          }
          return Promise.all(
            fonts.map(
              async (font) => `@font-face {
        font-family: ${font.fontFace.family};
        src: url(${await getSource(font)});
          }`
            )
          );
        })
      );
      return fontFaces.flat();
    };
  }
});

// charts.ts
var BAR_WIDTH, BAR_GAP, BAR_HEIGHT, GRID_OPACITY, NOT_SPREADSHEET, VALID_SPREADSHEET, tryParseNumber, isNumericColumn, tryParseCells, transposeCells, tryParseSpreadsheet, bgColors, commonProps, getChartDimensions, chartXLabels, chartYLabels, chartLines, chartBaseElements, chartTypeBar, chartTypeLine, renderSpreadsheet;
var init_charts = __esm({
  "charts.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_math();
    init_colors();
    init_constants();
    init_element();
    init_random();
    BAR_WIDTH = 32;
    BAR_GAP = 12;
    BAR_HEIGHT = 256;
    GRID_OPACITY = 50;
    NOT_SPREADSHEET = "NOT_SPREADSHEET";
    VALID_SPREADSHEET = "VALID_SPREADSHEET";
    tryParseNumber = (s) => {
      const match = /^([-+]?)[$]?([-+]?)([\d.,]+)[%]?$/.exec(s);
      if (!match) {
        return null;
      }
      return parseFloat(`${(match[1] || match[2]) + match[3]}`.replace(/,/g, ""));
    };
    isNumericColumn = (lines, columnIndex) => lines.slice(1).every((line) => tryParseNumber(line[columnIndex]) !== null);
    tryParseCells = (cells) => {
      const numCols = cells[0].length;
      if (numCols > 2) {
        return { type: NOT_SPREADSHEET, reason: "More than 2 columns" };
      }
      if (numCols === 1) {
        if (!isNumericColumn(cells, 0)) {
          return { type: NOT_SPREADSHEET, reason: "Value is not numeric" };
        }
        const hasHeader2 = tryParseNumber(cells[0][0]) === null;
        const values = (hasHeader2 ? cells.slice(1) : cells).map(
          (line) => tryParseNumber(line[0])
        );
        if (values.length < 2) {
          return { type: NOT_SPREADSHEET, reason: "Less than two rows" };
        }
        return {
          type: VALID_SPREADSHEET,
          spreadsheet: {
            title: hasHeader2 ? cells[0][0] : null,
            labels: null,
            values
          }
        };
      }
      const labelColumnNumeric = isNumericColumn(cells, 0);
      const valueColumnNumeric = isNumericColumn(cells, 1);
      if (!labelColumnNumeric && !valueColumnNumeric) {
        return { type: NOT_SPREADSHEET, reason: "Value is not numeric" };
      }
      const [labelColumnIndex, valueColumnIndex] = valueColumnNumeric ? [0, 1] : [1, 0];
      const hasHeader = tryParseNumber(cells[0][valueColumnIndex]) === null;
      const rows = hasHeader ? cells.slice(1) : cells;
      if (rows.length < 2) {
        return { type: NOT_SPREADSHEET, reason: "Less than 2 rows" };
      }
      return {
        type: VALID_SPREADSHEET,
        spreadsheet: {
          title: hasHeader ? cells[0][valueColumnIndex] : null,
          labels: rows.map((row) => row[labelColumnIndex]),
          values: rows.map((row) => tryParseNumber(row[valueColumnIndex]))
        }
      };
    };
    transposeCells = (cells) => {
      const nextCells = [];
      for (let col = 0; col < cells[0].length; col++) {
        const nextCellRow = [];
        for (let row = 0; row < cells.length; row++) {
          nextCellRow.push(cells[row][col]);
        }
        nextCells.push(nextCellRow);
      }
      return nextCells;
    };
    tryParseSpreadsheet = (text) => {
      let lines = text.trim().split("\n").map((line) => line.trim().split("	"));
      if (lines.length && lines[0].length !== 2) {
        lines = text.trim().split("\n").map((line) => line.trim().split(","));
      }
      if (lines.length === 0) {
        return { type: NOT_SPREADSHEET, reason: "No values" };
      }
      const numColsFirstLine = lines[0].length;
      const isSpreadsheet = lines.every((line) => line.length === numColsFirstLine);
      if (!isSpreadsheet) {
        return {
          type: NOT_SPREADSHEET,
          reason: "All rows don't have same number of columns"
        };
      }
      const result = tryParseCells(lines);
      if (result.type !== VALID_SPREADSHEET) {
        const transposedResults = tryParseCells(transposeCells(lines));
        if (transposedResults.type === VALID_SPREADSHEET) {
          return transposedResults;
        }
      }
      return result;
    };
    bgColors = getAllColorsSpecificShade(DEFAULT_CHART_COLOR_INDEX);
    commonProps = {
      fillStyle: "hachure",
      fontFamily: DEFAULT_FONT_FAMILY,
      fontSize: DEFAULT_FONT_SIZE,
      opacity: 100,
      roughness: 1,
      strokeColor: COLOR_PALETTE.black,
      roundness: null,
      strokeStyle: "solid",
      strokeWidth: 1,
      verticalAlign: VERTICAL_ALIGN.MIDDLE,
      locked: false
    };
    getChartDimensions = (spreadsheet) => {
      const chartWidth = (BAR_WIDTH + BAR_GAP) * spreadsheet.values.length + BAR_GAP;
      const chartHeight = BAR_HEIGHT + BAR_GAP * 2;
      return { chartWidth, chartHeight };
    };
    chartXLabels = (spreadsheet, x, y, groupId, backgroundColor) => {
      return spreadsheet.labels?.map((label, index) => {
        return newTextElement({
          groupIds: [groupId],
          backgroundColor,
          ...commonProps,
          text: label.length > 8 ? `${label.slice(0, 5)}...` : label,
          x: x + index * (BAR_WIDTH + BAR_GAP) + BAR_GAP * 2,
          y: y + BAR_GAP / 2,
          width: BAR_WIDTH,
          angle: 5.87,
          fontSize: 16,
          textAlign: "center",
          verticalAlign: "top"
        });
      }) || [];
    };
    chartYLabels = (spreadsheet, x, y, groupId, backgroundColor) => {
      const minYLabel = newTextElement({
        groupIds: [groupId],
        backgroundColor,
        ...commonProps,
        x: x - BAR_GAP,
        y: y - BAR_GAP,
        text: "0",
        textAlign: "right"
      });
      const maxYLabel = newTextElement({
        groupIds: [groupId],
        backgroundColor,
        ...commonProps,
        x: x - BAR_GAP,
        y: y - BAR_HEIGHT - minYLabel.height / 2,
        text: Math.max(...spreadsheet.values).toLocaleString(),
        textAlign: "right"
      });
      return [minYLabel, maxYLabel];
    };
    chartLines = (spreadsheet, x, y, groupId, backgroundColor) => {
      const { chartWidth, chartHeight } = getChartDimensions(spreadsheet);
      const xLine = newLinearElement({
        backgroundColor,
        groupIds: [groupId],
        ...commonProps,
        type: "line",
        x,
        y,
        width: chartWidth,
        points: [pointFrom(0, 0), pointFrom(chartWidth, 0)]
      });
      const yLine = newLinearElement({
        backgroundColor,
        groupIds: [groupId],
        ...commonProps,
        type: "line",
        x,
        y,
        height: chartHeight,
        points: [pointFrom(0, 0), pointFrom(0, -chartHeight)]
      });
      const maxLine = newLinearElement({
        backgroundColor,
        groupIds: [groupId],
        ...commonProps,
        type: "line",
        x,
        y: y - BAR_HEIGHT - BAR_GAP,
        strokeStyle: "dotted",
        width: chartWidth,
        opacity: GRID_OPACITY,
        points: [pointFrom(0, 0), pointFrom(chartWidth, 0)]
      });
      return [xLine, yLine, maxLine];
    };
    chartBaseElements = (spreadsheet, x, y, groupId, backgroundColor, debug) => {
      const { chartWidth, chartHeight } = getChartDimensions(spreadsheet);
      const title = spreadsheet.title ? newTextElement({
        backgroundColor,
        groupIds: [groupId],
        ...commonProps,
        text: spreadsheet.title,
        x: x + chartWidth / 2,
        y: y - BAR_HEIGHT - BAR_GAP * 2 - DEFAULT_FONT_SIZE,
        roundness: null,
        textAlign: "center"
      }) : null;
      const debugRect = debug ? newElement({
        backgroundColor,
        groupIds: [groupId],
        ...commonProps,
        type: "rectangle",
        x,
        y: y - chartHeight,
        width: chartWidth,
        height: chartHeight,
        strokeColor: COLOR_PALETTE.black,
        fillStyle: "solid",
        opacity: 6
      }) : null;
      return [
        ...debugRect ? [debugRect] : [],
        ...title ? [title] : [],
        ...chartXLabels(spreadsheet, x, y, groupId, backgroundColor),
        ...chartYLabels(spreadsheet, x, y, groupId, backgroundColor),
        ...chartLines(spreadsheet, x, y, groupId, backgroundColor)
      ];
    };
    chartTypeBar = (spreadsheet, x, y) => {
      const max = Math.max(...spreadsheet.values);
      const groupId = randomId();
      const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];
      const bars = spreadsheet.values.map((value, index) => {
        const barHeight = value / max * BAR_HEIGHT;
        return newElement({
          backgroundColor,
          groupIds: [groupId],
          ...commonProps,
          type: "rectangle",
          x: x + index * (BAR_WIDTH + BAR_GAP) + BAR_GAP,
          y: y - barHeight - BAR_GAP,
          width: BAR_WIDTH,
          height: barHeight
        });
      });
      return [
        ...bars,
        ...chartBaseElements(
          spreadsheet,
          x,
          y,
          groupId,
          backgroundColor,
          define_import_meta_env_default.DEV
        )
      ];
    };
    chartTypeLine = (spreadsheet, x, y) => {
      const max = Math.max(...spreadsheet.values);
      const groupId = randomId();
      const backgroundColor = bgColors[Math.floor(Math.random() * bgColors.length)];
      let index = 0;
      const points = [];
      for (const value of spreadsheet.values) {
        const cx = index * (BAR_WIDTH + BAR_GAP);
        const cy = -(value / max) * BAR_HEIGHT;
        points.push([cx, cy]);
        index++;
      }
      const maxX = Math.max(...points.map((element) => element[0]));
      const maxY = Math.max(...points.map((element) => element[1]));
      const minX = Math.min(...points.map((element) => element[0]));
      const minY = Math.min(...points.map((element) => element[1]));
      const line = newLinearElement({
        backgroundColor,
        groupIds: [groupId],
        ...commonProps,
        type: "line",
        x: x + BAR_GAP + BAR_WIDTH / 2,
        y: y - BAR_GAP,
        height: maxY - minY,
        width: maxX - minX,
        strokeWidth: 2,
        points
      });
      const dots = spreadsheet.values.map((value, index2) => {
        const cx = index2 * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;
        const cy = -(value / max) * BAR_HEIGHT + BAR_GAP / 2;
        return newElement({
          backgroundColor,
          groupIds: [groupId],
          ...commonProps,
          fillStyle: "solid",
          strokeWidth: 2,
          type: "ellipse",
          x: x + cx + BAR_WIDTH / 2,
          y: y + cy - BAR_GAP * 2,
          width: BAR_GAP,
          height: BAR_GAP
        });
      });
      const lines = spreadsheet.values.map((value, index2) => {
        const cx = index2 * (BAR_WIDTH + BAR_GAP) + BAR_GAP / 2;
        const cy = value / max * BAR_HEIGHT + BAR_GAP / 2 + BAR_GAP;
        return newLinearElement({
          backgroundColor,
          groupIds: [groupId],
          ...commonProps,
          type: "line",
          x: x + cx + BAR_WIDTH / 2 + BAR_GAP / 2,
          y: y - cy,
          height: cy,
          strokeStyle: "dotted",
          opacity: GRID_OPACITY,
          points: [pointFrom(0, 0), pointFrom(0, cy)]
        });
      });
      return [
        ...chartBaseElements(
          spreadsheet,
          x,
          y,
          groupId,
          backgroundColor,
          define_import_meta_env_default.DEV
        ),
        line,
        ...lines,
        ...dots
      ];
    };
    renderSpreadsheet = (chartType, spreadsheet, x, y) => {
      if (chartType === "line") {
        return chartTypeLine(spreadsheet, x, y);
      }
      return chartTypeBar(spreadsheet, x, y);
    };
  }
});

// clipboard.ts
function parseHTMLTree(el) {
  let result = [];
  for (const node of el.childNodes) {
    if (node.nodeType === 3) {
      const text = node.textContent?.trim();
      if (text) {
        result.push({ type: "text", value: text });
      }
    } else if (node instanceof HTMLImageElement) {
      const url = node.getAttribute("src");
      if (url && url.startsWith("http")) {
        result.push({ type: "imageUrl", value: url });
      }
    } else {
      result = result.concat(parseHTMLTree(node));
    }
  }
  return result;
}
var probablySupportsClipboardReadText, probablySupportsClipboardWriteText, probablySupportsClipboardBlob, clipboardContainsElements, createPasteEvent, serializeAsClipboardJSON, copyToClipboard, parsePotentialSpreadsheet, maybeParseHTMLPaste, readSystemClipboard, parseClipboardEvent, parseClipboard, copyBlobToClipboardAsPng, copyTextToSystemClipboard, copyTextViaExecCommand;
var init_clipboard = __esm({
  "clipboard.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_charts();
    init_constants();
    init_typeChecks();
    init_newElement();
    init_mutateElement();
    init_frame();
    init_utils2();
    probablySupportsClipboardReadText = "clipboard" in navigator && "readText" in navigator.clipboard;
    probablySupportsClipboardWriteText = "clipboard" in navigator && "writeText" in navigator.clipboard;
    probablySupportsClipboardBlob = "clipboard" in navigator && "write" in navigator.clipboard && "ClipboardItem" in window && "toBlob" in HTMLCanvasElement.prototype;
    clipboardContainsElements = (contents) => {
      if ([
        EXPORT_DATA_TYPES.excalidraw,
        EXPORT_DATA_TYPES.excalidrawClipboard,
        EXPORT_DATA_TYPES.excalidrawClipboardWithAPI
      ].includes(contents?.type) && Array.isArray(contents.elements)) {
        return true;
      }
      return false;
    };
    createPasteEvent = ({
      types,
      files
    }) => {
      if (!types && !files) {
        console.warn("createPasteEvent: no types or files provided");
      }
      const event = new ClipboardEvent("paste", {
        clipboardData: new DataTransfer()
      });
      if (types) {
        for (const [type, value] of Object.entries(types)) {
          try {
            event.clipboardData?.setData(type, value);
            if (event.clipboardData?.getData(type) !== value) {
              throw new Error(`Failed to set "${type}" as clipboardData item`);
            }
          } catch (error) {
            throw new Error(error.message);
          }
        }
      }
      if (files) {
        let idx = -1;
        for (const file2 of files) {
          idx++;
          try {
            event.clipboardData?.items.add(file2);
            if (event.clipboardData?.files[idx] !== file2) {
              throw new Error(
                `Failed to set file "${file2.name}" as clipboardData item`
              );
            }
          } catch (error) {
            throw new Error(error.message);
          }
        }
      }
      return event;
    };
    serializeAsClipboardJSON = ({
      elements,
      files
    }) => {
      const elementsMap = arrayToMap(elements);
      const framesToCopy = new Set(
        elements.filter((element) => isFrameLikeElement(element))
      );
      let foundFile = false;
      const _files = elements.reduce((acc, element) => {
        if (isInitializedImageElement(element)) {
          foundFile = true;
          if (files && files[element.fileId]) {
            acc[element.fileId] = files[element.fileId];
          }
        }
        return acc;
      }, {});
      if (foundFile && !files) {
        console.warn(
          "copyToClipboard: attempting to file element(s) without providing associated `files` object."
        );
      }
      const contents = {
        type: EXPORT_DATA_TYPES.excalidrawClipboard,
        elements: elements.map((element) => {
          if (getContainingFrame(element, elementsMap) && !framesToCopy.has(getContainingFrame(element, elementsMap))) {
            const copiedElement = deepCopyElement(element);
            mutateElement(copiedElement, {
              frameId: null
            });
            return copiedElement;
          }
          return element;
        }),
        files: files ? _files : void 0
      };
      return JSON.stringify(contents);
    };
    copyToClipboard = async (elements, files, clipboardEvent) => {
      await copyTextToSystemClipboard(
        serializeAsClipboardJSON({ elements, files }),
        clipboardEvent
      );
    };
    parsePotentialSpreadsheet = (text) => {
      const result = tryParseSpreadsheet(text);
      if (result.type === VALID_SPREADSHEET) {
        return { spreadsheet: result.spreadsheet };
      }
      return null;
    };
    maybeParseHTMLPaste = (event) => {
      const html = event.clipboardData?.getData("text/html");
      if (!html) {
        return null;
      }
      try {
        const doc = new DOMParser().parseFromString(html, "text/html");
        const content = parseHTMLTree(doc.body);
        if (content.length) {
          return { type: "mixedContent", value: content };
        }
      } catch (error) {
        console.error(`error in parseHTMLFromPaste: ${error.message}`);
      }
      return null;
    };
    readSystemClipboard = async () => {
      const types = {};
      try {
        if (navigator.clipboard?.readText) {
          return { "text/plain": await navigator.clipboard?.readText() };
        }
      } catch (error) {
        if (navigator.clipboard?.read) {
          console.warn(
            `navigator.clipboard.readText() failed (${error.message}). Failling back to navigator.clipboard.read()`
          );
        } else {
          throw error;
        }
      }
      let clipboardItems;
      try {
        clipboardItems = await navigator.clipboard?.read();
      } catch (error) {
        if (error.name === "DataError") {
          console.warn(
            `navigator.clipboard.read() error, clipboard is probably empty: ${error.message}`
          );
          return types;
        }
        throw error;
      }
      for (const item of clipboardItems) {
        for (const type of item.types) {
          if (!isMemberOf(ALLOWED_PASTE_MIME_TYPES, type)) {
            continue;
          }
          try {
            types[type] = await (await item.getType(type)).text();
          } catch (error) {
            console.warn(
              `Cannot retrieve ${type} from clipboardItem: ${error.message}`
            );
          }
        }
      }
      if (Object.keys(types).length === 0) {
        console.warn("No clipboard data found from clipboard.read().");
        return types;
      }
      return types;
    };
    parseClipboardEvent = async (event, isPlainPaste = false) => {
      try {
        const mixedContent = !isPlainPaste && event && maybeParseHTMLPaste(event);
        if (mixedContent) {
          if (mixedContent.value.every((item) => item.type === "text")) {
            return {
              type: "text",
              value: event.clipboardData?.getData("text/plain") || mixedContent.value.map((item) => item.value).join("\n").trim()
            };
          }
          return mixedContent;
        }
        const text = event.clipboardData?.getData("text/plain");
        return { type: "text", value: (text || "").trim() };
      } catch {
        return { type: "text", value: "" };
      }
    };
    parseClipboard = async (event, isPlainPaste = false) => {
      const parsedEventData = await parseClipboardEvent(event, isPlainPaste);
      if (parsedEventData.type === "mixedContent") {
        return {
          mixedContent: parsedEventData.value
        };
      }
      try {
        const spreadsheetResult = !isPlainPaste && parsePotentialSpreadsheet(parsedEventData.value);
        if (spreadsheetResult) {
          return spreadsheetResult;
        }
      } catch (error) {
        console.error(error);
      }
      try {
        const systemClipboardData = JSON.parse(parsedEventData.value);
        const programmaticAPI = systemClipboardData.type === EXPORT_DATA_TYPES.excalidrawClipboardWithAPI;
        if (clipboardContainsElements(systemClipboardData)) {
          return {
            elements: systemClipboardData.elements,
            files: systemClipboardData.files,
            text: isPlainPaste ? JSON.stringify(systemClipboardData.elements, null, 2) : void 0,
            programmaticAPI
          };
        }
      } catch {
      }
      return { text: parsedEventData.value };
    };
    copyBlobToClipboardAsPng = async (blob) => {
      try {
        await navigator.clipboard.write([
          new window.ClipboardItem({
            [MIME_TYPES.png]: blob
          })
        ]);
      } catch (error) {
        if (isPromiseLike(blob)) {
          await navigator.clipboard.write([
            new window.ClipboardItem({
              [MIME_TYPES.png]: await blob
            })
          ]);
        } else {
          throw error;
        }
      }
    };
    copyTextToSystemClipboard = async (text, clipboardEvent) => {
      if (probablySupportsClipboardWriteText) {
        try {
          await navigator.clipboard.writeText(text || "");
          return;
        } catch (error) {
          console.error(error);
        }
      }
      try {
        if (clipboardEvent) {
          clipboardEvent.clipboardData?.setData("text/plain", text || "");
          if (clipboardEvent.clipboardData?.getData("text/plain") !== text) {
            throw new Error("Failed to setData on clipboardEvent");
          }
          return;
        }
      } catch (error) {
        console.error(error);
      }
      if (!copyTextViaExecCommand(text)) {
        throw new Error("Error copying to clipboard.");
      }
    };
    copyTextViaExecCommand = (text) => {
      if (!text) {
        text = " ";
      }
      const isRTL2 = document.documentElement.getAttribute("dir") === "rtl";
      const textarea = document.createElement("textarea");
      textarea.style.border = "0";
      textarea.style.padding = "0";
      textarea.style.margin = "0";
      textarea.style.position = "absolute";
      textarea.style[isRTL2 ? "right" : "left"] = "-9999px";
      const yPosition = window.pageYOffset || document.documentElement.scrollTop;
      textarea.style.top = `${yPosition}px`;
      textarea.style.fontSize = "12pt";
      textarea.setAttribute("readonly", "");
      textarea.value = text;
      document.body.appendChild(textarea);
      let success = false;
      try {
        textarea.select();
        textarea.setSelectionRange(0, textarea.value.length);
        success = document.execCommand("copy");
      } catch (error) {
        console.error(error);
      }
      textarea.remove();
      return success;
    };
  }
});

// ../utils/export.ts
var exportToCanvas2, exportToBlob, exportToSvg2, exportToClipboard;
var init_export2 = __esm({
  "../utils/export.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_export();
    init_appState();
    init_restore();
    init_constants();
    init_image();
    init_json();
    init_clipboard();
    exportToCanvas2 = ({
      elements,
      appState,
      files,
      maxWidthOrHeight,
      getDimensions,
      exportPadding,
      exportingFrame
    }) => {
      const { elements: restoredElements, appState: restoredAppState } = restore(
        { elements, appState },
        null,
        null
      );
      const { exportBackground, viewBackgroundColor } = restoredAppState;
      return exportToCanvas(
        restoredElements,
        { ...restoredAppState, offsetTop: 0, offsetLeft: 0, width: 0, height: 0 },
        files || {},
        { exportBackground, exportPadding, viewBackgroundColor, exportingFrame },
        (width, height) => {
          const canvas2 = document.createElement("canvas");
          if (maxWidthOrHeight) {
            if (typeof getDimensions === "function") {
              console.warn(
                "`getDimensions()` is ignored when `maxWidthOrHeight` is supplied."
              );
            }
            const max = Math.max(width, height);
            const scale = maxWidthOrHeight < max ? maxWidthOrHeight / max : appState?.exportScale ?? 1;
            canvas2.width = width * scale;
            canvas2.height = height * scale;
            return {
              canvas: canvas2,
              scale
            };
          }
          const ret = getDimensions?.(width, height) || { width, height };
          canvas2.width = ret.width;
          canvas2.height = ret.height;
          return {
            canvas: canvas2,
            scale: ret.scale ?? 1
          };
        }
      );
    };
    exportToBlob = async (opts) => {
      let { mimeType = MIME_TYPES.png, quality } = opts;
      if (mimeType === MIME_TYPES.png && typeof quality === "number") {
        console.warn(`"quality" will be ignored for "${MIME_TYPES.png}" mimeType`);
      }
      if (mimeType === "image/jpg") {
        mimeType = MIME_TYPES.jpg;
      }
      if (mimeType === MIME_TYPES.jpg && !opts.appState?.exportBackground) {
        console.warn(
          `Defaulting "exportBackground" to "true" for "${MIME_TYPES.jpg}" mimeType`
        );
        opts = {
          ...opts,
          appState: { ...opts.appState, exportBackground: true }
        };
      }
      const canvas2 = await exportToCanvas2(opts);
      quality = quality ? quality : /image\/jpe?g/.test(mimeType) ? 0.92 : 0.8;
      return new Promise((resolve, reject) => {
        canvas2.toBlob(
          async (blob) => {
            if (!blob) {
              return reject(new Error("couldn't export to blob"));
            }
            if (blob && mimeType === MIME_TYPES.png && opts.appState?.exportEmbedScene) {
              blob = await encodePngMetadata({
                blob,
                metadata: serializeAsJSON(
                  // NOTE as long as we're using the Scene hack, we need to ensure
                  // we pass the original, uncloned elements when serializing
                  // so that we keep ids stable
                  opts.elements,
                  opts.appState,
                  opts.files || {},
                  "local"
                )
              });
            }
            resolve(blob);
          },
          mimeType,
          quality
        );
      });
    };
    exportToSvg2 = async ({
      elements,
      appState = getDefaultAppState(),
      files = {},
      exportPadding,
      renderEmbeddables,
      exportingFrame,
      skipInliningFonts
    }) => {
      const { elements: restoredElements, appState: restoredAppState } = restore(
        { elements, appState },
        null,
        null
      );
      const exportAppState = {
        ...restoredAppState,
        exportPadding
      };
      return exportToSvg(restoredElements, exportAppState, files, {
        exportingFrame,
        renderEmbeddables,
        skipInliningFonts
      });
    };
    exportToClipboard = async (opts) => {
      if (opts.type === "svg") {
        const svg = await exportToSvg2(opts);
        await copyTextToSystemClipboard(svg.outerHTML);
      } else if (opts.type === "png") {
        await copyBlobToClipboardAsPng(exportToBlob(opts));
      } else if (opts.type === "json") {
        await copyToClipboard(opts.elements, opts.files);
      } else {
        throw new Error("Invalid export type");
      }
    };
  }
});

// ../utils/withinBounds.ts
var getNonLinearElementRelativePoints, getElementRelativePoints, getMinMaxPoints, getRotatedBBox, isElementInsideBBox, elementPartiallyOverlapsWithOrContainsBBox, elementsOverlappingBBox;
var init_withinBounds = __esm({
  "../utils/withinBounds.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_typeChecks();
    init_bounds();
    init_utils2();
    init_math();
    getNonLinearElementRelativePoints = (element) => {
      if (element.type === "diamond") {
        return [
          pointFrom(element.width / 2, 0),
          pointFrom(element.width, element.height / 2),
          pointFrom(element.width / 2, element.height),
          pointFrom(0, element.height / 2)
        ];
      }
      return [
        pointFrom(0, 0),
        pointFrom(0 + element.width, 0),
        pointFrom(0 + element.width, element.height),
        pointFrom(0, element.height)
      ];
    };
    getElementRelativePoints = (element) => {
      if (isLinearElement(element) || isFreeDrawElement(element)) {
        return element.points;
      }
      return getNonLinearElementRelativePoints(element);
    };
    getMinMaxPoints = (points) => {
      const ret = points.reduce(
        (limits, [x, y]) => {
          limits.minY = Math.min(limits.minY, y);
          limits.minX = Math.min(limits.minX, x);
          limits.maxX = Math.max(limits.maxX, x);
          limits.maxY = Math.max(limits.maxY, y);
          return limits;
        },
        {
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity,
          cx: 0,
          cy: 0
        }
      );
      ret.cx = (ret.maxX + ret.minX) / 2;
      ret.cy = (ret.maxY + ret.minY) / 2;
      return ret;
    };
    getRotatedBBox = (element) => {
      const points = getElementRelativePoints(element);
      const { cx, cy } = getMinMaxPoints(points);
      const centerPoint = pointFrom(cx, cy);
      const rotatedPoints = points.map(
        (p) => pointRotateRads(p, centerPoint, element.angle)
      );
      const { minX, minY, maxX, maxY } = getMinMaxPoints(rotatedPoints);
      return [
        minX + element.x,
        minY + element.y,
        maxX + element.x,
        maxY + element.y
      ];
    };
    isElementInsideBBox = (element, bbox, eitherDirection = false) => {
      const elementBBox = getRotatedBBox(element);
      const elementInsideBbox = bbox[0] <= elementBBox[0] && bbox[2] >= elementBBox[2] && bbox[1] <= elementBBox[1] && bbox[3] >= elementBBox[3];
      if (!eitherDirection) {
        return elementInsideBbox;
      }
      if (elementInsideBbox) {
        return true;
      }
      return elementBBox[0] <= bbox[0] && elementBBox[2] >= bbox[2] && elementBBox[1] <= bbox[1] && elementBBox[3] >= bbox[3];
    };
    elementPartiallyOverlapsWithOrContainsBBox = (element, bbox) => {
      const elementBBox = getRotatedBBox(element);
      return (rangeIncludesValue(elementBBox[0], rangeInclusive(bbox[0], bbox[2])) || rangeIncludesValue(
        bbox[0],
        rangeInclusive(elementBBox[0], elementBBox[2])
      )) && (rangeIncludesValue(elementBBox[1], rangeInclusive(bbox[1], bbox[3])) || rangeIncludesValue(
        bbox[1],
        rangeInclusive(elementBBox[1], elementBBox[3])
      ));
    };
    elementsOverlappingBBox = ({
      elements,
      bounds,
      type,
      errorMargin = 0
    }) => {
      if (isExcalidrawElement(bounds)) {
        bounds = getElementBounds(bounds, arrayToMap(elements));
      }
      const adjustedBBox = [
        bounds[0] - errorMargin,
        bounds[1] - errorMargin,
        bounds[2] + errorMargin,
        bounds[3] + errorMargin
      ];
      const includedElementSet = /* @__PURE__ */ new Set();
      for (const element of elements) {
        if (includedElementSet.has(element.id)) {
          continue;
        }
        const isOverlaping = type === "overlap" ? elementPartiallyOverlapsWithOrContainsBBox(element, adjustedBBox) : type === "inside" ? isElementInsideBBox(element, adjustedBBox) : isElementInsideBBox(element, adjustedBBox, true);
        if (isOverlaping) {
          includedElementSet.add(element.id);
          if (element.boundElements) {
            for (const boundElement of element.boundElements) {
              includedElementSet.add(boundElement.id);
            }
          }
          if (isTextElement(element) && element.containerId) {
            includedElementSet.add(element.containerId);
          }
          if (isArrowElement(element)) {
            if (element.startBinding) {
              includedElementSet.add(element.startBinding.elementId);
            }
            if (element.endBinding) {
              includedElementSet.add(element.endBinding?.elementId);
            }
          }
        }
      }
      return elements.filter((element) => includedElementSet.has(element.id));
    };
  }
});

// ../utils/bbox.ts
function getBBox(line) {
  return [
    Math.min(line[0][0], line[1][0]),
    Math.min(line[0][1], line[1][1]),
    Math.max(line[0][0], line[1][0]),
    Math.max(line[0][1], line[1][1])
  ];
}
function doBBoxesIntersect(a, b) {
  return a[0] <= b[2] && a[2] >= b[0] && a[1] <= b[3] && a[3] >= b[1];
}
function isPointOnLine(l, p) {
  const p1 = vectorFromPoint(l[1], l[0]);
  const p2 = vectorFromPoint(p, l[0]);
  const r = vectorCross(p1, p2);
  return Math.abs(r) < EPSILON2;
}
function isPointRightOfLine(l, p) {
  const p1 = vectorFromPoint(l[1], l[0]);
  const p2 = vectorFromPoint(p, l[0]);
  return vectorCross(p1, p2) < 0;
}
function isLineSegmentTouchingOrCrossingLine(a, b) {
  return isPointOnLine(a, b[0]) || isPointOnLine(a, b[1]) || (isPointRightOfLine(a, b[0]) ? !isPointRightOfLine(a, b[1]) : isPointRightOfLine(a, b[1]));
}
function doLineSegmentsIntersect(a, b) {
  return doBBoxesIntersect(getBBox(a), getBBox(b)) && isLineSegmentTouchingOrCrossingLine(a, b) && isLineSegmentTouchingOrCrossingLine(b, a);
}
var EPSILON2;
var init_bbox = __esm({
  "../utils/bbox.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_math();
    EPSILON2 = 1e-6;
  }
});

// ../utils/index.ts
var init_utils3 = __esm({
  "../utils/index.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_export2();
    init_withinBounds();
    init_bbox();
    init_bounds();
  }
});

// frame.ts
function isElementIntersectingFrame(element, frame, elementsMap) {
  const frameLineSegments = getElementLineSegments(frame, elementsMap);
  const elementLineSegments = getElementLineSegments(element, elementsMap);
  const intersecting = frameLineSegments.some(
    (frameLineSegment) => elementLineSegments.some(
      (elementLineSegment) => doLineSegmentsIntersect(frameLineSegment, elementLineSegment)
    )
  );
  return intersecting;
}
var bindElementsToFramesAfterDuplication, getElementsCompletelyInFrame, isElementContainingFrame, elementsAreInFrameBounds, elementOverlapsWithFrame, isCursorInFrame, groupByFrameLikes, getFrameChildren, getFrameLikeElements, getRootElements, getElementsInResizingFrame, getElementsInNewFrame, getContainingFrame, filterElementsEligibleAsFrameChildren, addElementsToFrame, removeElementsFromFrame, removeAllElementsFromFrame, replaceAllElementsInFrame, updateFrameMembershipOfSelectedElements, omitGroupsContainingFrameLikes, getTargetFrame, isElementInFrame, getFrameLikeTitle, getElementsOverlappingFrame;
var init_frame = __esm({
  "frame.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_element();
    init_textElement();
    init_utils2();
    init_mutateElement();
    init_scene();
    init_groups();
    init_bounds();
    init_utils3();
    init_typeChecks();
    init_math();
    bindElementsToFramesAfterDuplication = (nextElements, oldElements, oldIdToDuplicatedId) => {
      const nextElementMap = arrayToMap(nextElements);
      for (const element of oldElements) {
        if (element.frameId) {
          const nextElementId = oldIdToDuplicatedId.get(element.id);
          const nextFrameId = oldIdToDuplicatedId.get(element.frameId);
          if (nextElementId) {
            const nextElement = nextElementMap.get(nextElementId);
            if (nextElement) {
              mutateElement(
                nextElement,
                {
                  frameId: nextFrameId ?? element.frameId
                },
                false
              );
            }
          }
        }
      }
    };
    getElementsCompletelyInFrame = (elements, frame, elementsMap) => omitGroupsContainingFrameLikes(
      getElementsWithinSelection(elements, frame, elementsMap, false)
    ).filter(
      (element) => !isFrameLikeElement(element) && !element.frameId || element.frameId === frame.id
    );
    isElementContainingFrame = (elements, element, frame, elementsMap) => {
      return getElementsWithinSelection(elements, element, elementsMap).some(
        (e) => e.id === frame.id
      );
    };
    elementsAreInFrameBounds = (elements, frame, elementsMap) => {
      const [frameX1, frameY1, frameX2, frameY2] = getElementAbsoluteCoords(
        frame,
        elementsMap
      );
      const [elementX1, elementY1, elementX2, elementY2] = getCommonBounds(elements);
      return frameX1 <= elementX1 && frameY1 <= elementY1 && frameX2 >= elementX2 && frameY2 >= elementY2;
    };
    elementOverlapsWithFrame = (element, frame, elementsMap) => {
      return elementsAreInFrameBounds([element], frame, elementsMap) || isElementIntersectingFrame(element, frame, elementsMap) || isElementContainingFrame([frame], element, frame, elementsMap);
    };
    isCursorInFrame = (cursorCoords, frame, elementsMap) => {
      const [fx1, fy1, fx2, fy2] = getElementAbsoluteCoords(frame, elementsMap);
      return isPointWithinBounds(
        pointFrom(fx1, fy1),
        pointFrom(cursorCoords.x, cursorCoords.y),
        pointFrom(fx2, fy2)
      );
    };
    groupByFrameLikes = (elements) => {
      const frameElementsMap = /* @__PURE__ */ new Map();
      for (const element of elements) {
        const frameId = isFrameLikeElement(element) ? element.id : element.frameId;
        if (frameId && !frameElementsMap.has(frameId)) {
          frameElementsMap.set(frameId, getFrameChildren(elements, frameId));
        }
      }
      return frameElementsMap;
    };
    getFrameChildren = (allElements, frameId) => {
      const frameChildren = [];
      for (const element of allElements.values()) {
        if (element.frameId === frameId) {
          frameChildren.push(element);
        }
      }
      return frameChildren;
    };
    getFrameLikeElements = (allElements) => {
      return allElements.filter(
        (element) => isFrameLikeElement(element)
      );
    };
    getRootElements = (allElements) => {
      const frameElements = arrayToMap(getFrameLikeElements(allElements));
      return allElements.filter(
        (element) => frameElements.has(element.id) || !element.frameId || !frameElements.has(element.frameId)
      );
    };
    getElementsInResizingFrame = (allElements, frame, appState, elementsMap) => {
      const prevElementsInFrame = getFrameChildren(allElements, frame.id);
      const nextElementsInFrame = new Set(prevElementsInFrame);
      const elementsCompletelyInFrame = /* @__PURE__ */ new Set([
        ...getElementsCompletelyInFrame(allElements, frame, elementsMap),
        ...prevElementsInFrame.filter(
          (element) => isElementContainingFrame(allElements, element, frame, elementsMap)
        )
      ]);
      const elementsNotCompletelyInFrame = prevElementsInFrame.filter(
        (element) => !elementsCompletelyInFrame.has(element)
      );
      const groupsToKeep = new Set(
        Array.from(elementsCompletelyInFrame).flatMap(
          (element) => element.groupIds
        )
      );
      for (const element of elementsNotCompletelyInFrame) {
        if (!isElementIntersectingFrame(element, frame, elementsMap)) {
          if (element.groupIds.length === 0) {
            nextElementsInFrame.delete(element);
          }
        } else if (element.groupIds.length > 0) {
          for (const id of element.groupIds) {
            groupsToKeep.add(id);
          }
        }
      }
      for (const element of elementsNotCompletelyInFrame) {
        if (element.groupIds.length > 0) {
          let shouldRemoveElement = true;
          for (const id of element.groupIds) {
            if (groupsToKeep.has(id)) {
              shouldRemoveElement = false;
            }
          }
          if (shouldRemoveElement) {
            nextElementsInFrame.delete(element);
          }
        }
      }
      const individualElementsCompletelyInFrame = Array.from(
        elementsCompletelyInFrame
      ).filter((element) => element.groupIds.length === 0);
      for (const element of individualElementsCompletelyInFrame) {
        nextElementsInFrame.add(element);
      }
      const newGroupElementsCompletelyInFrame = Array.from(
        elementsCompletelyInFrame
      ).filter((element) => element.groupIds.length > 0);
      const groupIds = selectGroupsFromGivenElements(
        newGroupElementsCompletelyInFrame,
        appState
      );
      for (const [id, isSelected] of Object.entries(groupIds)) {
        if (isSelected) {
          const elementsInGroup = getElementsInGroup(allElements, id);
          if (elementsAreInFrameBounds(elementsInGroup, frame, elementsMap)) {
            for (const element of elementsInGroup) {
              nextElementsInFrame.add(element);
            }
          }
        }
      }
      return [...nextElementsInFrame].filter((element) => {
        return !(isTextElement(element) && element.containerId);
      });
    };
    getElementsInNewFrame = (elements, frame, elementsMap) => {
      return omitGroupsContainingFrameLikes(
        elements,
        getElementsCompletelyInFrame(elements, frame, elementsMap)
      );
    };
    getContainingFrame = (element, elementsMap) => {
      if (!element.frameId) {
        return null;
      }
      return elementsMap.get(element.frameId) || null;
    };
    filterElementsEligibleAsFrameChildren = (elements, frame) => {
      const otherFrames = /* @__PURE__ */ new Set();
      const elementsMap = arrayToMap(elements);
      elements = omitGroupsContainingFrameLikes(elements);
      for (const element of elements) {
        if (isFrameLikeElement(element) && element.id !== frame.id) {
          otherFrames.add(element.id);
        }
      }
      const processedGroups = /* @__PURE__ */ new Set();
      const eligibleElements = [];
      for (const element of elements) {
        if (isFrameLikeElement(element) || element.frameId && otherFrames.has(element.frameId)) {
          continue;
        }
        if (element.groupIds.length) {
          const shallowestGroupId = element.groupIds.at(-1);
          if (!processedGroups.has(shallowestGroupId)) {
            processedGroups.add(shallowestGroupId);
            const groupElements = getElementsInGroup(elements, shallowestGroupId);
            if (groupElements.some(
              (el) => elementOverlapsWithFrame(el, frame, elementsMap)
            )) {
              for (const child of groupElements) {
                eligibleElements.push(child);
              }
            }
          }
        } else {
          const overlaps = elementOverlapsWithFrame(element, frame, elementsMap);
          if (overlaps) {
            eligibleElements.push(element);
          }
        }
      }
      return eligibleElements;
    };
    addElementsToFrame = (allElements, elementsToAdd, frame) => {
      const elementsMap = arrayToMap(allElements);
      const currTargetFrameChildrenMap = /* @__PURE__ */ new Map();
      for (const element of allElements.values()) {
        if (element.frameId === frame.id) {
          currTargetFrameChildrenMap.set(element.id, true);
        }
      }
      const suppliedElementsToAddSet = new Set(elementsToAdd.map((el) => el.id));
      const finalElementsToAdd = [];
      const otherFrames = /* @__PURE__ */ new Set();
      for (const element of elementsToAdd) {
        if (isFrameLikeElement(element) && element.id !== frame.id) {
          otherFrames.add(element.id);
        }
      }
      for (const element of omitGroupsContainingFrameLikes(
        allElements,
        elementsToAdd
      )) {
        if (isFrameLikeElement(element) || element.frameId && otherFrames.has(element.frameId)) {
          continue;
        }
        if (!currTargetFrameChildrenMap.has(element.id)) {
          finalElementsToAdd.push(element);
        }
        const boundTextElement = getBoundTextElement(element, elementsMap);
        if (boundTextElement && !suppliedElementsToAddSet.has(boundTextElement.id) && !currTargetFrameChildrenMap.has(boundTextElement.id)) {
          finalElementsToAdd.push(boundTextElement);
        }
      }
      for (const element of finalElementsToAdd) {
        mutateElement(
          element,
          {
            frameId: frame.id
          },
          false
        );
      }
      return allElements;
    };
    removeElementsFromFrame = (elementsToRemove, elementsMap) => {
      const _elementsToRemove = /* @__PURE__ */ new Map();
      const toRemoveElementsByFrame = /* @__PURE__ */ new Map();
      for (const element of elementsToRemove) {
        if (element.frameId) {
          _elementsToRemove.set(element.id, element);
          const arr = toRemoveElementsByFrame.get(element.frameId) || [];
          arr.push(element);
          const boundTextElement = getBoundTextElement(element, elementsMap);
          if (boundTextElement) {
            _elementsToRemove.set(boundTextElement.id, boundTextElement);
            arr.push(boundTextElement);
          }
          toRemoveElementsByFrame.set(element.frameId, arr);
        }
      }
      for (const [, element] of _elementsToRemove) {
        mutateElement(
          element,
          {
            frameId: null
          },
          false
        );
      }
    };
    removeAllElementsFromFrame = (allElements, frame) => {
      const elementsInFrame = getFrameChildren(allElements, frame.id);
      removeElementsFromFrame(elementsInFrame, arrayToMap(allElements));
      return allElements;
    };
    replaceAllElementsInFrame = (allElements, nextElementsInFrame, frame, app) => {
      return addElementsToFrame(
        removeAllElementsFromFrame(allElements, frame),
        nextElementsInFrame,
        frame
      ).slice();
    };
    updateFrameMembershipOfSelectedElements = (allElements, appState, app) => {
      const selectedElements = app.scene.getSelectedElements({
        selectedElementIds: appState.selectedElementIds,
        // supplying elements explicitly in case we're passed non-state elements
        elements: allElements
      });
      const elementsToFilter = new Set(selectedElements);
      if (appState.editingGroupId) {
        for (const element of selectedElements) {
          if (element.groupIds.length === 0) {
            elementsToFilter.add(element);
          } else {
            element.groupIds.flatMap((gid) => getElementsInGroup(allElements, gid)).forEach((element2) => elementsToFilter.add(element2));
          }
        }
      }
      const elementsToRemove = /* @__PURE__ */ new Set();
      const elementsMap = arrayToMap(allElements);
      elementsToFilter.forEach((element) => {
        if (element.frameId && !isFrameLikeElement(element) && !isElementInFrame(element, elementsMap, appState)) {
          elementsToRemove.add(element);
        }
      });
      if (elementsToRemove.size > 0) {
        removeElementsFromFrame(elementsToRemove, elementsMap);
      }
      return allElements;
    };
    omitGroupsContainingFrameLikes = (allElements, selectedElements) => {
      const uniqueGroupIds = /* @__PURE__ */ new Set();
      const elements = selectedElements || allElements;
      for (const el of elements.values()) {
        const topMostGroupId = el.groupIds[el.groupIds.length - 1];
        if (topMostGroupId) {
          uniqueGroupIds.add(topMostGroupId);
        }
      }
      const rejectedGroupIds = /* @__PURE__ */ new Set();
      for (const groupId of uniqueGroupIds) {
        if (getElementsInGroup(allElements, groupId).some(
          (el) => isFrameLikeElement(el)
        )) {
          rejectedGroupIds.add(groupId);
        }
      }
      const ret = [];
      for (const element of elements.values()) {
        if (!rejectedGroupIds.has(element.groupIds[element.groupIds.length - 1])) {
          ret.push(element);
        }
      }
      return ret;
    };
    getTargetFrame = (element, elementsMap, appState) => {
      const _element = isTextElement(element) ? getContainerElement(element, elementsMap) || element : element;
      return appState.selectedElementIds[_element.id] && appState.selectedElementsAreBeingDragged ? appState.frameToHighlight : getContainingFrame(_element, elementsMap);
    };
    isElementInFrame = (element, allElementsMap, appState) => {
      const frame = getTargetFrame(element, allElementsMap, appState);
      const _element = isTextElement(element) ? getContainerElement(element, allElementsMap) || element : element;
      if (frame) {
        if (!appState.selectedElementIds[element.id] || !appState.selectedElementsAreBeingDragged) {
          return true;
        }
        if (_element.groupIds.length === 0) {
          return elementOverlapsWithFrame(_element, frame, allElementsMap);
        }
        const allElementsInGroup = new Set(
          _element.groupIds.flatMap(
            (gid) => getElementsInGroup(allElementsMap, gid)
          )
        );
        if (appState.editingGroupId && appState.selectedElementsAreBeingDragged) {
          const selectedElements = new Set(
            getSelectedElements(allElementsMap, appState)
          );
          const editingGroupOverlapsFrame = appState.frameToHighlight !== null;
          if (editingGroupOverlapsFrame) {
            return true;
          }
          selectedElements.forEach((selectedElement) => {
            allElementsInGroup.delete(selectedElement);
          });
        }
        for (const elementInGroup of allElementsInGroup) {
          if (isFrameLikeElement(elementInGroup)) {
            return false;
          }
        }
        for (const elementInGroup of allElementsInGroup) {
          if (elementOverlapsWithFrame(elementInGroup, frame, allElementsMap)) {
            return true;
          }
        }
      }
      return false;
    };
    getFrameLikeTitle = (element) => {
      return element.name === null ? isFrameElement(element) ? "Frame" : "AI Frame" : element.name;
    };
    getElementsOverlappingFrame = (elements, frame) => {
      return elementsOverlappingBBox({
        elements,
        bounds: frame,
        type: "overlap"
      }).filter((el) => !el.frameId || el.frameId === frame.id);
    };
  }
});

// renderer/renderElement.ts
import rough2 from "roughjs/bin/rough";
import { getStroke } from "perfect-freehand";
function generateFreeDrawShape(element) {
  const svgPathData = getFreeDrawSvgPath(element);
  const path = new Path2D(svgPathData);
  pathsCache.set(element, path);
  return path;
}
function getFreeDrawPath2D(element) {
  return pathsCache.get(element);
}
function getFreeDrawSvgPath(element) {
  const inputPoints = element.simulatePressure ? element.points : element.points.length ? element.points.map(([x, y], i) => [x, y, element.pressures[i]]) : [[0, 0, 0.5]];
  const options = {
    simulatePressure: element.simulatePressure,
    size: element.strokeWidth * 4.25,
    thinning: 0.6,
    smoothing: 0.5,
    streamline: 0.5,
    easing: (t2) => Math.sin(t2 * Math.PI / 2),
    // https://easings.net/#easeOutSine
    last: !!element.lastCommittedPoint
    // LastCommittedPoint is added on pointerup
  };
  return getSvgPathFromStroke2(getStroke(inputPoints, options));
}
function med(A, B) {
  return [(A[0] + B[0]) / 2, (A[1] + B[1]) / 2];
}
function getSvgPathFromStroke2(points) {
  if (!points.length) {
    return "";
  }
  const max = points.length - 1;
  return points.reduce(
    (acc, point2, i, arr) => {
      if (i === max) {
        acc.push(point2, med(point2, arr[0]), "L", arr[0], "Z");
      } else {
        acc.push(point2, med(point2, arr[i + 1]));
      }
      return acc;
    },
    ["M", points[0], "Q"]
  ).join(" ").replace(TO_FIXED_PRECISION, "$1");
}
var IMAGE_INVERT_FILTER, defaultAppState, isPendingImageElement, shouldResetImageFilter, getCanvasPadding, getRenderOpacity, cappedElementCanvasSize, generateElementCanvas, DEFAULT_LINK_SIZE, IMAGE_PLACEHOLDER_IMG, IMAGE_ERROR_PLACEHOLDER_IMG, drawImagePlaceholder, drawElementOnCanvas, elementWithCanvasCache, generateElementWithCanvas, drawElementFromCanvas, renderSelectionElement, renderElement, pathsCache, TO_FIXED_PRECISION;
var init_renderElement = __esm({
  "renderer/renderElement.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_typeChecks();
    init_bounds();
    init_utils2();
    init_appState();
    init_constants();
    init_textElement();
    init_linearElementEditor();
    init_frame();
    init_ShapeCache();
    init_fonts();
    init_math();
    init_shapes();
    IMAGE_INVERT_FILTER = "invert(100%) hue-rotate(180deg) saturate(1.25)";
    defaultAppState = getDefaultAppState();
    isPendingImageElement = (element, renderConfig) => isInitializedImageElement(element) && !renderConfig.imageCache.has(element.fileId);
    shouldResetImageFilter = (element, renderConfig, appState) => {
      return appState.theme === THEME.DARK && isInitializedImageElement(element) && !isPendingImageElement(element, renderConfig) && renderConfig.imageCache.get(element.fileId)?.mimeType !== MIME_TYPES.svg;
    };
    getCanvasPadding = (element) => {
      switch (element.type) {
        case "freedraw":
          return element.strokeWidth * 12;
        case "text":
          return element.fontSize / 2;
        default:
          return 20;
      }
    };
    getRenderOpacity = (element, containingFrame, elementsPendingErasure, pendingNodes) => {
      let opacity = (containingFrame?.opacity ?? 100) * element.opacity / 1e4;
      if (elementsPendingErasure.has(element.id) || pendingNodes && pendingNodes.some((node) => node.id === element.id) || containingFrame && elementsPendingErasure.has(containingFrame.id)) {
        opacity *= ELEMENT_READY_TO_ERASE_OPACITY / 100;
      }
      return opacity;
    };
    cappedElementCanvasSize = (element, elementsMap, zoom) => {
      const AREA_LIMIT = 16777216;
      const WIDTH_HEIGHT_LIMIT = 32767;
      const padding = getCanvasPadding(element);
      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
      const elementWidth = isLinearElement(element) || isFreeDrawElement(element) ? distance(x1, x2) : element.width;
      const elementHeight = isLinearElement(element) || isFreeDrawElement(element) ? distance(y1, y2) : element.height;
      let width = elementWidth * window.devicePixelRatio + padding * 2;
      let height = elementHeight * window.devicePixelRatio + padding * 2;
      let scale = zoom.value;
      if (width * scale > WIDTH_HEIGHT_LIMIT || height * scale > WIDTH_HEIGHT_LIMIT) {
        scale = Math.min(WIDTH_HEIGHT_LIMIT / width, WIDTH_HEIGHT_LIMIT / height);
      }
      if (width * height * scale * scale > AREA_LIMIT) {
        scale = Math.sqrt(AREA_LIMIT / (width * height));
      }
      width = Math.floor(width * scale);
      height = Math.floor(height * scale);
      return { width, height, scale };
    };
    generateElementCanvas = (element, elementsMap, zoom, renderConfig, appState) => {
      const canvas2 = document.createElement("canvas");
      const context = canvas2.getContext("2d");
      const padding = getCanvasPadding(element);
      const { width, height, scale } = cappedElementCanvasSize(
        element,
        elementsMap,
        zoom
      );
      if (!width || !height) {
        return null;
      }
      canvas2.width = width;
      canvas2.height = height;
      let canvasOffsetX = -100;
      let canvasOffsetY = 0;
      if (isLinearElement(element) || isFreeDrawElement(element)) {
        const [x1, y1] = getElementAbsoluteCoords(element, elementsMap);
        canvasOffsetX = element.x > x1 ? distance(element.x, x1) * window.devicePixelRatio * scale : 0;
        canvasOffsetY = element.y > y1 ? distance(element.y, y1) * window.devicePixelRatio * scale : 0;
        context.translate(canvasOffsetX, canvasOffsetY);
      }
      context.save();
      context.translate(padding * scale, padding * scale);
      context.scale(
        window.devicePixelRatio * scale,
        window.devicePixelRatio * scale
      );
      const rc = rough2.canvas(canvas2);
      if (shouldResetImageFilter(element, renderConfig, appState)) {
        context.filter = IMAGE_INVERT_FILTER;
      }
      drawElementOnCanvas(element, rc, context, renderConfig, appState);
      context.restore();
      const boundTextElement = getBoundTextElement(element, elementsMap);
      const boundTextCanvas = document.createElement("canvas");
      const boundTextCanvasContext = boundTextCanvas.getContext("2d");
      if (isArrowElement(element) && boundTextElement) {
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
        const maxDim = Math.max(distance(x1, x2), distance(y1, y2));
        boundTextCanvas.width = maxDim * window.devicePixelRatio * scale + padding * scale * 10;
        boundTextCanvas.height = maxDim * window.devicePixelRatio * scale + padding * scale * 10;
        boundTextCanvasContext.translate(
          boundTextCanvas.width / 2,
          boundTextCanvas.height / 2
        );
        boundTextCanvasContext.rotate(element.angle);
        boundTextCanvasContext.drawImage(
          canvas2,
          -canvas2.width / 2,
          -canvas2.height / 2,
          canvas2.width,
          canvas2.height
        );
        const [, , , , boundTextCx, boundTextCy] = getElementAbsoluteCoords(
          boundTextElement,
          elementsMap
        );
        boundTextCanvasContext.rotate(-element.angle);
        const offsetX = (boundTextCanvas.width - canvas2.width) / 2;
        const offsetY = (boundTextCanvas.height - canvas2.height) / 2;
        const shiftX = boundTextCanvas.width / 2 - (boundTextCx - x1) * window.devicePixelRatio * scale - offsetX - padding * scale;
        const shiftY = boundTextCanvas.height / 2 - (boundTextCy - y1) * window.devicePixelRatio * scale - offsetY - padding * scale;
        boundTextCanvasContext.translate(-shiftX, -shiftY);
        boundTextCanvasContext.clearRect(
          -(boundTextElement.width / 2 + BOUND_TEXT_PADDING) * window.devicePixelRatio * scale,
          -(boundTextElement.height / 2 + BOUND_TEXT_PADDING) * window.devicePixelRatio * scale,
          (boundTextElement.width + BOUND_TEXT_PADDING * 2) * window.devicePixelRatio * scale,
          (boundTextElement.height + BOUND_TEXT_PADDING * 2) * window.devicePixelRatio * scale
        );
      }
      return {
        element,
        canvas: canvas2,
        theme: appState.theme,
        scale,
        zoomValue: zoom.value,
        canvasOffsetX,
        canvasOffsetY,
        boundTextElementVersion: getBoundTextElement(element, elementsMap)?.version || null,
        containingFrameOpacity: getContainingFrame(element, elementsMap)?.opacity || 100,
        boundTextCanvas,
        angle: element.angle
      };
    };
    DEFAULT_LINK_SIZE = 14;
    IMAGE_PLACEHOLDER_IMG = document.createElement("img");
    IMAGE_PLACEHOLDER_IMG.src = `data:${MIME_TYPES.svg},${encodeURIComponent(
      `<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="image" class="svg-inline--fa fa-image fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="#888" d="M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48zM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56zM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48z"></path></svg>`
    )}`;
    IMAGE_ERROR_PLACEHOLDER_IMG = document.createElement("img");
    IMAGE_ERROR_PLACEHOLDER_IMG.src = `data:${MIME_TYPES.svg},${encodeURIComponent(
      `<svg viewBox="0 0 668 668" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2"><path d="M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48ZM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56ZM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48Z" style="fill:#888;fill-rule:nonzero" transform="matrix(.81709 0 0 .81709 124.825 145.825)"/><path d="M256 8C119.034 8 8 119.033 8 256c0 136.967 111.034 248 248 248s248-111.034 248-248S392.967 8 256 8Zm130.108 117.892c65.448 65.448 70 165.481 20.677 235.637L150.47 105.216c70.204-49.356 170.226-44.735 235.638 20.676ZM125.892 386.108c-65.448-65.448-70-165.481-20.677-235.637L361.53 406.784c-70.203 49.356-170.226 44.736-235.638-20.676Z" style="fill:#888;fill-rule:nonzero" transform="matrix(.30366 0 0 .30366 506.822 60.065)"/></svg>`
    )}`;
    drawImagePlaceholder = (element, context) => {
      context.fillStyle = "#E7E7E7";
      context.fillRect(0, 0, element.width, element.height);
      const imageMinWidthOrHeight = Math.min(element.width, element.height);
      const size = Math.min(
        imageMinWidthOrHeight,
        Math.min(imageMinWidthOrHeight * 0.4, 100)
      );
      context.drawImage(
        element.status === "error" ? IMAGE_ERROR_PLACEHOLDER_IMG : IMAGE_PLACEHOLDER_IMG,
        element.width / 2 - size / 2,
        element.height / 2 - size / 2,
        size,
        size
      );
    };
    drawElementOnCanvas = (element, rc, context, renderConfig, appState) => {
      switch (element.type) {
        case "rectangle":
        case "iframe":
        case "embeddable":
        case "diamond":
        case "ellipse": {
          context.lineJoin = "round";
          context.lineCap = "round";
          rc.draw(ShapeCache.get(element));
          break;
        }
        case "arrow":
        case "line": {
          context.lineJoin = "round";
          context.lineCap = "round";
          ShapeCache.get(element).forEach((shape) => {
            rc.draw(shape);
          });
          break;
        }
        case "freedraw": {
          context.save();
          context.fillStyle = element.strokeColor;
          const path = getFreeDrawPath2D(element);
          const fillShape = ShapeCache.get(element);
          if (fillShape) {
            rc.draw(fillShape);
          }
          context.fillStyle = element.strokeColor;
          context.fill(path);
          context.restore();
          break;
        }
        case "image": {
          const img = isInitializedImageElement(element) ? renderConfig.imageCache.get(element.fileId)?.image : void 0;
          if (img != null && !(img instanceof Promise)) {
            if (element.roundness && context.roundRect) {
              context.beginPath();
              context.roundRect(
                0,
                0,
                element.width,
                element.height,
                getCornerRadius(Math.min(element.width, element.height), element)
              );
              context.clip();
            }
            context.drawImage(
              img,
              0,
              0,
              element.width,
              element.height
            );
          } else {
            drawImagePlaceholder(element, context);
          }
          break;
        }
        default: {
          if (isTextElement(element)) {
            const rtl = isRTL(element.text);
            const shouldTemporarilyAttach = rtl && !context.canvas.isConnected;
            if (shouldTemporarilyAttach) {
              document.body.appendChild(context.canvas);
            }
            context.canvas.setAttribute("dir", rtl ? "rtl" : "ltr");
            context.save();
            context.font = getFontString(element);
            context.fillStyle = element.strokeColor;
            context.textAlign = element.textAlign;
            const lines = element.text.replace(/\r\n?/g, "\n").split("\n");
            const horizontalOffset = element.textAlign === "center" ? element.width / 2 : element.textAlign === "right" ? element.width : 0;
            const lineHeightPx = getLineHeightInPx(
              element.fontSize,
              element.lineHeight
            );
            const verticalOffset = getVerticalOffset(
              element.fontFamily,
              element.fontSize,
              lineHeightPx
            );
            for (let index = 0; index < lines.length; index++) {
              context.fillText(
                lines[index],
                horizontalOffset,
                index * lineHeightPx + verticalOffset
              );
            }
            context.restore();
            if (shouldTemporarilyAttach) {
              context.canvas.remove();
            }
          } else {
            throw new Error(`Unimplemented type ${element.type}`);
          }
        }
      }
    };
    elementWithCanvasCache = /* @__PURE__ */ new WeakMap();
    generateElementWithCanvas = (element, elementsMap, renderConfig, appState) => {
      const zoom = renderConfig ? appState.zoom : defaultAppState.zoom;
      const prevElementWithCanvas = elementWithCanvasCache.get(element);
      const shouldRegenerateBecauseZoom = prevElementWithCanvas && prevElementWithCanvas.zoomValue !== zoom.value && !appState?.shouldCacheIgnoreZoom;
      const boundTextElement = getBoundTextElement(element, elementsMap);
      const boundTextElementVersion = boundTextElement?.version || null;
      const containingFrameOpacity = getContainingFrame(element, elementsMap)?.opacity || 100;
      if (!prevElementWithCanvas || shouldRegenerateBecauseZoom || prevElementWithCanvas.theme !== appState.theme || prevElementWithCanvas.boundTextElementVersion !== boundTextElementVersion || prevElementWithCanvas.containingFrameOpacity !== containingFrameOpacity || // since we rotate the canvas when copying from cached canvas, we don't
      // regenerate the cached canvas. But we need to in case of labels which are
      // cached alongside the arrow, and we want the labels to remain unrotated
      // with respect to the arrow.
      isArrowElement(element) && boundTextElement && element.angle !== prevElementWithCanvas.angle) {
        const elementWithCanvas = generateElementCanvas(
          element,
          elementsMap,
          zoom,
          renderConfig,
          appState
        );
        if (!elementWithCanvas) {
          return null;
        }
        elementWithCanvasCache.set(element, elementWithCanvas);
        return elementWithCanvas;
      }
      return prevElementWithCanvas;
    };
    drawElementFromCanvas = (elementWithCanvas, context, renderConfig, appState, allElementsMap) => {
      const element = elementWithCanvas.element;
      const padding = getCanvasPadding(element);
      const zoom = elementWithCanvas.scale;
      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, allElementsMap);
      const cx = ((x1 + x2) / 2 + appState.scrollX) * window.devicePixelRatio;
      const cy = ((y1 + y2) / 2 + appState.scrollY) * window.devicePixelRatio;
      context.save();
      context.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);
      const boundTextElement = getBoundTextElement(element, allElementsMap);
      if (isArrowElement(element) && boundTextElement) {
        const offsetX = (elementWithCanvas.boundTextCanvas.width - elementWithCanvas.canvas.width) / 2;
        const offsetY = (elementWithCanvas.boundTextCanvas.height - elementWithCanvas.canvas.height) / 2;
        context.translate(cx, cy);
        context.drawImage(
          elementWithCanvas.boundTextCanvas,
          -(x2 - x1) / 2 * window.devicePixelRatio - offsetX / zoom - padding,
          -(y2 - y1) / 2 * window.devicePixelRatio - offsetY / zoom - padding,
          elementWithCanvas.boundTextCanvas.width / zoom,
          elementWithCanvas.boundTextCanvas.height / zoom
        );
      } else {
        context.translate(cx, cy);
        context.rotate(element.angle);
        if ("scale" in elementWithCanvas.element && !isPendingImageElement(element, renderConfig)) {
          context.scale(
            elementWithCanvas.element.scale[0],
            elementWithCanvas.element.scale[1]
          );
        }
        context.translate(-cx, -cy);
        context.drawImage(
          elementWithCanvas.canvas,
          (x1 + appState.scrollX) * window.devicePixelRatio - padding * elementWithCanvas.scale / elementWithCanvas.scale,
          (y1 + appState.scrollY) * window.devicePixelRatio - padding * elementWithCanvas.scale / elementWithCanvas.scale,
          elementWithCanvas.canvas.width / elementWithCanvas.scale,
          elementWithCanvas.canvas.height / elementWithCanvas.scale
        );
        if (define_import_meta_env_default.VITE_APP_DEBUG_ENABLE_TEXT_CONTAINER_BOUNDING_BOX === "true" && hasBoundTextElement(element)) {
          const textElement = getBoundTextElement(
            element,
            allElementsMap
          );
          const coords = getContainerCoords(element);
          context.strokeStyle = "#c92a2a";
          context.lineWidth = 3;
          context.strokeRect(
            (coords.x + appState.scrollX) * window.devicePixelRatio,
            (coords.y + appState.scrollY) * window.devicePixelRatio,
            getBoundTextMaxWidth(element, textElement) * window.devicePixelRatio,
            getBoundTextMaxHeight(element, textElement) * window.devicePixelRatio
          );
        }
      }
      context.restore();
    };
    renderSelectionElement = (element, context, appState, selectionColor) => {
      context.save();
      context.translate(element.x + appState.scrollX, element.y + appState.scrollY);
      context.fillStyle = "rgba(0, 0, 200, 0.04)";
      const offset2 = 0.5 / appState.zoom.value;
      context.fillRect(offset2, offset2, element.width, element.height);
      context.lineWidth = 1 / appState.zoom.value;
      context.strokeStyle = selectionColor;
      context.strokeRect(offset2, offset2, element.width, element.height);
      context.restore();
    };
    renderElement = (element, elementsMap, allElementsMap, rc, context, renderConfig, appState) => {
      context.globalAlpha = getRenderOpacity(
        element,
        getContainingFrame(element, elementsMap),
        renderConfig.elementsPendingErasure,
        renderConfig.pendingFlowchartNodes
      );
      switch (element.type) {
        case "magicframe":
        case "frame": {
          if (appState.frameRendering.enabled && appState.frameRendering.outline) {
            context.save();
            context.translate(
              element.x + appState.scrollX,
              element.y + appState.scrollY
            );
            context.fillStyle = "rgba(0, 0, 200, 0.04)";
            context.lineWidth = FRAME_STYLE.strokeWidth / appState.zoom.value;
            context.strokeStyle = FRAME_STYLE.strokeColor;
            if (isMagicFrameElement(element)) {
              context.strokeStyle = appState.theme === THEME.LIGHT ? "#7affd7" : "#1d8264";
            }
            if (FRAME_STYLE.radius && context.roundRect) {
              context.beginPath();
              context.roundRect(
                0,
                0,
                element.width,
                element.height,
                FRAME_STYLE.radius / appState.zoom.value
              );
              context.stroke();
              context.closePath();
            } else {
              context.strokeRect(0, 0, element.width, element.height);
            }
            context.restore();
          }
          break;
        }
        case "freedraw": {
          ShapeCache.generateElementShape(element, null);
          if (renderConfig.isExporting) {
            const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
            const cx = (x1 + x2) / 2 + appState.scrollX;
            const cy = (y1 + y2) / 2 + appState.scrollY;
            const shiftX = (x2 - x1) / 2 - (element.x - x1);
            const shiftY = (y2 - y1) / 2 - (element.y - y1);
            context.save();
            context.translate(cx, cy);
            context.rotate(element.angle);
            context.translate(-shiftX, -shiftY);
            drawElementOnCanvas(element, rc, context, renderConfig, appState);
            context.restore();
          } else {
            const elementWithCanvas = generateElementWithCanvas(
              element,
              allElementsMap,
              renderConfig,
              appState
            );
            if (!elementWithCanvas) {
              return;
            }
            drawElementFromCanvas(
              elementWithCanvas,
              context,
              renderConfig,
              appState,
              allElementsMap
            );
          }
          break;
        }
        case "rectangle":
        case "diamond":
        case "ellipse":
        case "line":
        case "arrow":
        case "image":
        case "text":
        case "iframe":
        case "embeddable": {
          ShapeCache.generateElementShape(element, renderConfig);
          if (renderConfig.isExporting) {
            const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
            const cx = (x1 + x2) / 2 + appState.scrollX;
            const cy = (y1 + y2) / 2 + appState.scrollY;
            let shiftX = (x2 - x1) / 2 - (element.x - x1);
            let shiftY = (y2 - y1) / 2 - (element.y - y1);
            if (isTextElement(element)) {
              const container = getContainerElement(element, elementsMap);
              if (isArrowElement(container)) {
                const boundTextCoords = LinearElementEditor.getBoundTextElementPosition(
                  container,
                  element,
                  elementsMap
                );
                shiftX = (x2 - x1) / 2 - (boundTextCoords.x - x1);
                shiftY = (y2 - y1) / 2 - (boundTextCoords.y - y1);
              }
            }
            context.save();
            context.translate(cx, cy);
            if (shouldResetImageFilter(element, renderConfig, appState)) {
              context.filter = "none";
            }
            const boundTextElement = getBoundTextElement(element, elementsMap);
            if (isArrowElement(element) && boundTextElement) {
              const tempCanvas = document.createElement("canvas");
              const tempCanvasContext = tempCanvas.getContext("2d");
              const maxDim = Math.max(distance(x1, x2), distance(y1, y2));
              const padding = getCanvasPadding(element);
              tempCanvas.width = maxDim * appState.exportScale + padding * 10 * appState.exportScale;
              tempCanvas.height = maxDim * appState.exportScale + padding * 10 * appState.exportScale;
              tempCanvasContext.translate(
                tempCanvas.width / 2,
                tempCanvas.height / 2
              );
              tempCanvasContext.scale(appState.exportScale, appState.exportScale);
              shiftX = element.width / 2 - (element.x - x1);
              shiftY = element.height / 2 - (element.y - y1);
              tempCanvasContext.rotate(element.angle);
              const tempRc = rough2.canvas(tempCanvas);
              tempCanvasContext.translate(-shiftX, -shiftY);
              drawElementOnCanvas(
                element,
                tempRc,
                tempCanvasContext,
                renderConfig,
                appState
              );
              tempCanvasContext.translate(shiftX, shiftY);
              tempCanvasContext.rotate(-element.angle);
              const [, , , , boundTextCx, boundTextCy] = getElementAbsoluteCoords(
                boundTextElement,
                elementsMap
              );
              const boundTextShiftX = (x1 + x2) / 2 - boundTextCx;
              const boundTextShiftY = (y1 + y2) / 2 - boundTextCy;
              tempCanvasContext.translate(-boundTextShiftX, -boundTextShiftY);
              tempCanvasContext.clearRect(
                -boundTextElement.width / 2,
                -boundTextElement.height / 2,
                boundTextElement.width,
                boundTextElement.height
              );
              context.scale(1 / appState.exportScale, 1 / appState.exportScale);
              context.drawImage(
                tempCanvas,
                -tempCanvas.width / 2,
                -tempCanvas.height / 2,
                tempCanvas.width,
                tempCanvas.height
              );
            } else {
              context.rotate(element.angle);
              if (element.type === "image") {
                context.scale(element.scale[0], element.scale[1]);
              }
              context.translate(-shiftX, -shiftY);
              drawElementOnCanvas(element, rc, context, renderConfig, appState);
            }
            context.restore();
          } else {
            const elementWithCanvas = generateElementWithCanvas(
              element,
              allElementsMap,
              renderConfig,
              appState
            );
            if (!elementWithCanvas) {
              return;
            }
            const currentImageSmoothingStatus = context.imageSmoothingEnabled;
            if (
              // do not disable smoothing during zoom as blurry shapes look better
              // on low resolution (while still zooming in) than sharp ones
              !appState?.shouldCacheIgnoreZoom && // angle is 0 -> always disable smoothing
              (!element.angle || // or check if angle is a right angle in which case we can still
              // disable smoothing without adversely affecting the result
              // We need less-than comparison because of FP artihmetic
              isRightAngleRads(element.angle))
            ) {
              context.imageSmoothingEnabled = false;
            }
            drawElementFromCanvas(
              elementWithCanvas,
              context,
              renderConfig,
              appState,
              allElementsMap
            );
            context.imageSmoothingEnabled = currentImageSmoothingStatus;
          }
          break;
        }
        default: {
          throw new Error(`Unimplemented type ${element.type}`);
        }
      }
      context.globalAlpha = 1;
    };
    pathsCache = /* @__PURE__ */ new WeakMap([]);
    TO_FIXED_PRECISION = /(\s?[A-Z]?,?-?[0-9]*\.[0-9]{0,2})(([0-9]|e|-)*)/g;
  }
});

// scene/comparisons.ts
var hasBackground, hasStrokeColor, hasStrokeWidth, hasStrokeStyle, canChangeRoundness, toolIsArrow, canHaveArrowheads, getElementAtPosition;
var init_comparisons = __esm({
  "scene/comparisons.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_typeChecks();
    hasBackground = (type) => type === "rectangle" || type === "iframe" || type === "embeddable" || type === "ellipse" || type === "diamond" || type === "line" || type === "freedraw";
    hasStrokeColor = (type) => type !== "image" && type !== "frame" && type !== "magicframe";
    hasStrokeWidth = (type) => type === "rectangle" || type === "iframe" || type === "embeddable" || type === "ellipse" || type === "diamond" || type === "freedraw" || type === "arrow" || type === "line";
    hasStrokeStyle = (type) => type === "rectangle" || type === "iframe" || type === "embeddable" || type === "ellipse" || type === "diamond" || type === "arrow" || type === "line";
    canChangeRoundness = (type) => type === "rectangle" || type === "iframe" || type === "embeddable" || type === "line" || type === "diamond" || type === "image";
    toolIsArrow = (type) => type === "arrow";
    canHaveArrowheads = (type) => type === "arrow";
    getElementAtPosition = (elements, isAtPositionFn) => {
      let hitElement = null;
      for (let index = elements.length - 1; index >= 0; --index) {
        const element = elements[index];
        if (element.isDeleted) {
          continue;
        }
        if (isAtPositionFn(element)) {
          hitElement = element;
          break;
        }
      }
      return hitElement;
    };
  }
});

// scene/Shape.ts
import { simplify } from "points-on-curve";
function adjustRoughness(element) {
  const roughness = element.roughness;
  const maxSize = Math.max(element.width, element.height);
  const minSize = Math.min(element.width, element.height);
  if (
    // both sides relatively big
    minSize >= 20 && maxSize >= 50 || // is round & both sides above 15px
    minSize >= 15 && !!element.roundness && canChangeRoundness(element.type) || // relatively long linear element
    isLinearElement(element) && maxSize >= 50
  ) {
    return roughness;
  }
  return Math.min(roughness / (maxSize < 10 ? 3 : 2), 2.5);
}
var getDashArrayDashed, getDashArrayDotted, generateRoughOptions, modifyIframeLikeForRoughOptions, getArrowheadShapes, _generateElementShape, generateElbowArrowShape;
var init_Shape = __esm({
  "scene/Shape.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_element();
    init_renderElement();
    init_utils2();
    init_constants();
    init_typeChecks();
    init_comparisons();
    init_math();
    init_shapes();
    getDashArrayDashed = (strokeWidth) => [8, 8 + strokeWidth];
    getDashArrayDotted = (strokeWidth) => [1.5, 6 + strokeWidth];
    generateRoughOptions = (element, continuousPath = false) => {
      const options = {
        seed: element.seed,
        strokeLineDash: element.strokeStyle === "dashed" ? getDashArrayDashed(element.strokeWidth) : element.strokeStyle === "dotted" ? getDashArrayDotted(element.strokeWidth) : void 0,
        // for non-solid strokes, disable multiStroke because it tends to make
        // dashes/dots overlay each other
        disableMultiStroke: element.strokeStyle !== "solid",
        // for non-solid strokes, increase the width a bit to make it visually
        // similar to solid strokes, because we're also disabling multiStroke
        strokeWidth: element.strokeStyle !== "solid" ? element.strokeWidth + 0.5 : element.strokeWidth,
        // when increasing strokeWidth, we must explicitly set fillWeight and
        // hachureGap because if not specified, roughjs uses strokeWidth to
        // calculate them (and we don't want the fills to be modified)
        fillWeight: element.strokeWidth / 2,
        hachureGap: element.strokeWidth * 4,
        roughness: adjustRoughness(element),
        stroke: element.strokeColor,
        preserveVertices: continuousPath || element.roughness < ROUGHNESS.cartoonist
      };
      switch (element.type) {
        case "rectangle":
        case "iframe":
        case "embeddable":
        case "diamond":
        case "ellipse": {
          options.fillStyle = element.fillStyle;
          options.fill = isTransparent(element.backgroundColor) ? void 0 : element.backgroundColor;
          if (element.type === "ellipse") {
            options.curveFitting = 1;
          }
          return options;
        }
        case "line":
        case "freedraw": {
          if (isPathALoop(element.points)) {
            options.fillStyle = element.fillStyle;
            options.fill = element.backgroundColor === "transparent" ? void 0 : element.backgroundColor;
          }
          return options;
        }
        case "arrow":
          return options;
        default: {
          throw new Error(`Unimplemented type ${element.type}`);
        }
      }
    };
    modifyIframeLikeForRoughOptions = (element, isExporting, embedsValidationStatus) => {
      if (isIframeLikeElement(element) && (isExporting || isEmbeddableElement(element) && embedsValidationStatus?.get(element.id) !== true) && isTransparent(element.backgroundColor) && isTransparent(element.strokeColor)) {
        return {
          ...element,
          roughness: 0,
          backgroundColor: "#d3d3d3",
          fillStyle: "solid"
        };
      } else if (isIframeElement(element)) {
        return {
          ...element,
          strokeColor: isTransparent(element.strokeColor) ? "#000000" : element.strokeColor,
          backgroundColor: isTransparent(element.backgroundColor) ? "#f4f4f6" : element.backgroundColor
        };
      }
      return element;
    };
    getArrowheadShapes = (element, shape, position, arrowhead, generator, options, canvasBackgroundColor) => {
      const arrowheadPoints = getArrowheadPoints(
        element,
        shape,
        position,
        arrowhead
      );
      if (arrowheadPoints === null) {
        return [];
      }
      switch (arrowhead) {
        case "dot":
        case "circle":
        case "circle_outline": {
          const [x, y, diameter] = arrowheadPoints;
          delete options.strokeLineDash;
          return [
            generator.circle(x, y, diameter, {
              ...options,
              fill: arrowhead === "circle_outline" ? canvasBackgroundColor : element.strokeColor,
              fillStyle: "solid",
              stroke: element.strokeColor,
              roughness: Math.min(0.5, options.roughness || 0)
            })
          ];
        }
        case "triangle":
        case "triangle_outline": {
          const [x, y, x2, y2, x3, y3] = arrowheadPoints;
          delete options.strokeLineDash;
          return [
            generator.polygon(
              [
                [x, y],
                [x2, y2],
                [x3, y3],
                [x, y]
              ],
              {
                ...options,
                fill: arrowhead === "triangle_outline" ? canvasBackgroundColor : element.strokeColor,
                fillStyle: "solid",
                roughness: Math.min(1, options.roughness || 0)
              }
            )
          ];
        }
        case "diamond":
        case "diamond_outline": {
          const [x, y, x2, y2, x3, y3, x4, y4] = arrowheadPoints;
          delete options.strokeLineDash;
          return [
            generator.polygon(
              [
                [x, y],
                [x2, y2],
                [x3, y3],
                [x4, y4],
                [x, y]
              ],
              {
                ...options,
                fill: arrowhead === "diamond_outline" ? canvasBackgroundColor : element.strokeColor,
                fillStyle: "solid",
                roughness: Math.min(1, options.roughness || 0)
              }
            )
          ];
        }
        case "bar":
        case "arrow":
        default: {
          const [x2, y2, x3, y3, x4, y4] = arrowheadPoints;
          if (element.strokeStyle === "dotted") {
            const dash = getDashArrayDotted(element.strokeWidth - 1);
            options.strokeLineDash = [dash[0], dash[1] - 1];
          } else {
            delete options.strokeLineDash;
          }
          options.roughness = Math.min(1, options.roughness || 0);
          return [
            generator.line(x3, y3, x2, y2, options),
            generator.line(x4, y4, x2, y2, options)
          ];
        }
      }
    };
    _generateElementShape = (element, generator, {
      isExporting,
      canvasBackgroundColor,
      embedsValidationStatus
    }) => {
      switch (element.type) {
        case "rectangle":
        case "iframe":
        case "embeddable": {
          let shape;
          if (element.roundness) {
            const w = element.width;
            const h = element.height;
            const r = getCornerRadius(Math.min(w, h), element);
            shape = generator.path(
              `M ${r} 0 L ${w - r} 0 Q ${w} 0, ${w} ${r} L ${w} ${h - r} Q ${w} ${h}, ${w - r} ${h} L ${r} ${h} Q 0 ${h}, 0 ${h - r} L 0 ${r} Q 0 0, ${r} 0`,
              generateRoughOptions(
                modifyIframeLikeForRoughOptions(
                  element,
                  isExporting,
                  embedsValidationStatus
                ),
                true
              )
            );
          } else {
            shape = generator.rectangle(
              0,
              0,
              element.width,
              element.height,
              generateRoughOptions(
                modifyIframeLikeForRoughOptions(
                  element,
                  isExporting,
                  embedsValidationStatus
                ),
                false
              )
            );
          }
          return shape;
        }
        case "diamond": {
          let shape;
          const [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY] = getDiamondPoints(element);
          if (element.roundness) {
            const verticalRadius = getCornerRadius(Math.abs(topX - leftX), element);
            const horizontalRadius = getCornerRadius(
              Math.abs(rightY - topY),
              element
            );
            shape = generator.path(
              `M ${topX + verticalRadius} ${topY + horizontalRadius} L ${rightX - verticalRadius} ${rightY - horizontalRadius}
            C ${rightX} ${rightY}, ${rightX} ${rightY}, ${rightX - verticalRadius} ${rightY + horizontalRadius}
            L ${bottomX + verticalRadius} ${bottomY - horizontalRadius}
            C ${bottomX} ${bottomY}, ${bottomX} ${bottomY}, ${bottomX - verticalRadius} ${bottomY - horizontalRadius}
            L ${leftX + verticalRadius} ${leftY + horizontalRadius}
            C ${leftX} ${leftY}, ${leftX} ${leftY}, ${leftX + verticalRadius} ${leftY - horizontalRadius}
            L ${topX - verticalRadius} ${topY + horizontalRadius}
            C ${topX} ${topY}, ${topX} ${topY}, ${topX + verticalRadius} ${topY + horizontalRadius}`,
              generateRoughOptions(element, true)
            );
          } else {
            shape = generator.polygon(
              [
                [topX, topY],
                [rightX, rightY],
                [bottomX, bottomY],
                [leftX, leftY]
              ],
              generateRoughOptions(element)
            );
          }
          return shape;
        }
        case "ellipse": {
          const shape = generator.ellipse(
            element.width / 2,
            element.height / 2,
            element.width,
            element.height,
            generateRoughOptions(element)
          );
          return shape;
        }
        case "line":
        case "arrow": {
          let shape;
          const options = generateRoughOptions(element);
          const points = element.points.length ? element.points : [pointFrom(0, 0)];
          if (isElbowArrow(element)) {
            shape = [
              generator.path(
                generateElbowArrowShape(points, 16),
                generateRoughOptions(element, true)
              )
            ];
          } else if (!element.roundness) {
            if (options.fill) {
              shape = [
                generator.polygon(points, options)
              ];
            } else {
              shape = [
                generator.linearPath(points, options)
              ];
            }
          } else {
            shape = [generator.curve(points, options)];
          }
          if (element.type === "arrow") {
            const { startArrowhead = null, endArrowhead = "arrow" } = element;
            if (startArrowhead !== null) {
              const shapes = getArrowheadShapes(
                element,
                shape,
                "start",
                startArrowhead,
                generator,
                options,
                canvasBackgroundColor
              );
              shape.push(...shapes);
            }
            if (endArrowhead !== null) {
              if (endArrowhead === void 0) {
              }
              const shapes = getArrowheadShapes(
                element,
                shape,
                "end",
                endArrowhead,
                generator,
                options,
                canvasBackgroundColor
              );
              shape.push(...shapes);
            }
          }
          return shape;
        }
        case "freedraw": {
          let shape;
          generateFreeDrawShape(element);
          if (isPathALoop(element.points)) {
            const simplifiedPoints = simplify(element.points, 0.75);
            shape = generator.curve(simplifiedPoints, {
              ...generateRoughOptions(element),
              stroke: "none"
            });
          } else {
            shape = null;
          }
          return shape;
        }
        case "frame":
        case "magicframe":
        case "text":
        case "image": {
          const shape = null;
          return shape;
        }
        default: {
          assertNever(
            element,
            `generateElementShape(): Unimplemented type ${element?.type}`
          );
          return null;
        }
      }
    };
    generateElbowArrowShape = (points, radius) => {
      const subpoints = [];
      for (let i = 1; i < points.length - 1; i += 1) {
        const prev = points[i - 1];
        const next = points[i + 1];
        const corner = Math.min(
          radius,
          pointDistance(points[i], next) / 2,
          pointDistance(points[i], prev) / 2
        );
        if (prev[0] < points[i][0] && prev[1] === points[i][1]) {
          subpoints.push([points[i][0] - corner, points[i][1]]);
        } else if (prev[0] === points[i][0] && prev[1] < points[i][1]) {
          subpoints.push([points[i][0], points[i][1] - corner]);
        } else if (prev[0] > points[i][0] && prev[1] === points[i][1]) {
          subpoints.push([points[i][0] + corner, points[i][1]]);
        } else {
          subpoints.push([points[i][0], points[i][1] + corner]);
        }
        subpoints.push(points[i]);
        if (next[0] < points[i][0] && next[1] === points[i][1]) {
          subpoints.push([points[i][0] - corner, points[i][1]]);
        } else if (next[0] === points[i][0] && next[1] < points[i][1]) {
          subpoints.push([points[i][0], points[i][1] - corner]);
        } else if (next[0] > points[i][0] && next[1] === points[i][1]) {
          subpoints.push([points[i][0] + corner, points[i][1]]);
        } else {
          subpoints.push([points[i][0], points[i][1] + corner]);
        }
      }
      const d = [`M ${points[0][0]} ${points[0][1]}`];
      for (let i = 0; i < subpoints.length; i += 3) {
        d.push(`L ${subpoints[i][0]} ${subpoints[i][1]}`);
        d.push(
          `Q ${subpoints[i + 1][0]} ${subpoints[i + 1][1]}, ${subpoints[i + 2][0]} ${subpoints[i + 2][1]}`
        );
      }
      d.push(`L ${points[points.length - 1][0]} ${points[points.length - 1][1]}`);
      return d.join(" ");
    };
  }
});

// element/bounds.ts
import rough3 from "roughjs/bin/rough";
var ElementBounds, getElementAbsoluteCoords, getElementLineSegments, getDiamondPoints, getCurvePathOps2, getBezierValueForT, solveQuadratic, getCubicBezierCurveBound, getMinMaxXYFromCurvePathOps, getBoundsFromPoints, getFreeDrawElementAbsoluteCoords, getArrowheadSize, getArrowheadAngle, getArrowheadPoints, generateLinearElementShape, getLinearElementRotatedBounds, getElementBounds, getCommonBounds, getDraggedElementsBounds, getResizedElementAbsoluteCoords, getElementPointsCoords, getClosestElementBounds, getCommonBoundingBox, getVisibleSceneBounds, getCenterForBounds;
var init_bounds = __esm({
  "element/bounds.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_Shape();
    init_typeChecks();
    init_points();
    init_textElement();
    init_linearElementEditor();
    init_ShapeCache();
    init_utils2();
    init_math();
    ElementBounds = class _ElementBounds {
      static boundsCache = /* @__PURE__ */ new WeakMap();
      static getBounds(element, elementsMap) {
        const cachedBounds = _ElementBounds.boundsCache.get(element);
        if (cachedBounds?.version && cachedBounds.version === element.version && // we don't invalidate cache when we update containers and not labels,
        // which is causing problems down the line. Fix TBA.
        !isBoundToContainer(element)) {
          return cachedBounds.bounds;
        }
        const bounds = _ElementBounds.calculateBounds(element, elementsMap);
        _ElementBounds.boundsCache.set(element, {
          version: element.version,
          bounds
        });
        return bounds;
      }
      static calculateBounds(element, elementsMap) {
        let bounds;
        const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(
          element,
          elementsMap
        );
        if (isFreeDrawElement(element)) {
          const [minX, minY, maxX, maxY] = getBoundsFromPoints(
            element.points.map(
              ([x, y]) => pointRotateRads(
                pointFrom(x, y),
                pointFrom(cx - element.x, cy - element.y),
                element.angle
              )
            )
          );
          return [
            minX + element.x,
            minY + element.y,
            maxX + element.x,
            maxY + element.y
          ];
        } else if (isLinearElement(element)) {
          bounds = getLinearElementRotatedBounds(element, cx, cy, elementsMap);
        } else if (element.type === "diamond") {
          const [x11, y11] = pointRotateRads(
            pointFrom(cx, y1),
            pointFrom(cx, cy),
            element.angle
          );
          const [x12, y12] = pointRotateRads(
            pointFrom(cx, y2),
            pointFrom(cx, cy),
            element.angle
          );
          const [x22, y22] = pointRotateRads(
            pointFrom(x1, cy),
            pointFrom(cx, cy),
            element.angle
          );
          const [x21, y21] = pointRotateRads(
            pointFrom(x2, cy),
            pointFrom(cx, cy),
            element.angle
          );
          const minX = Math.min(x11, x12, x22, x21);
          const minY = Math.min(y11, y12, y22, y21);
          const maxX = Math.max(x11, x12, x22, x21);
          const maxY = Math.max(y11, y12, y22, y21);
          bounds = [minX, minY, maxX, maxY];
        } else if (element.type === "ellipse") {
          const w = (x2 - x1) / 2;
          const h = (y2 - y1) / 2;
          const cos = Math.cos(element.angle);
          const sin = Math.sin(element.angle);
          const ww = Math.hypot(w * cos, h * sin);
          const hh = Math.hypot(h * cos, w * sin);
          bounds = [cx - ww, cy - hh, cx + ww, cy + hh];
        } else {
          const [x11, y11] = pointRotateRads(
            pointFrom(x1, y1),
            pointFrom(cx, cy),
            element.angle
          );
          const [x12, y12] = pointRotateRads(
            pointFrom(x1, y2),
            pointFrom(cx, cy),
            element.angle
          );
          const [x22, y22] = pointRotateRads(
            pointFrom(x2, y2),
            pointFrom(cx, cy),
            element.angle
          );
          const [x21, y21] = pointRotateRads(
            pointFrom(x2, y1),
            pointFrom(cx, cy),
            element.angle
          );
          const minX = Math.min(x11, x12, x22, x21);
          const minY = Math.min(y11, y12, y22, y21);
          const maxX = Math.max(x11, x12, x22, x21);
          const maxY = Math.max(y11, y12, y22, y21);
          bounds = [minX, minY, maxX, maxY];
        }
        return bounds;
      }
    };
    getElementAbsoluteCoords = (element, elementsMap, includeBoundText = false) => {
      if (isFreeDrawElement(element)) {
        return getFreeDrawElementAbsoluteCoords(element);
      } else if (isLinearElement(element)) {
        return LinearElementEditor.getElementAbsoluteCoords(
          element,
          elementsMap,
          includeBoundText
        );
      } else if (isTextElement(element)) {
        const container = elementsMap ? getContainerElement(element, elementsMap) : null;
        if (isArrowElement(container)) {
          const { x, y } = LinearElementEditor.getBoundTextElementPosition(
            container,
            element,
            elementsMap
          );
          return [
            x,
            y,
            x + element.width,
            y + element.height,
            x + element.width / 2,
            y + element.height / 2
          ];
        }
      }
      return [
        element.x,
        element.y,
        element.x + element.width,
        element.y + element.height,
        element.x + element.width / 2,
        element.y + element.height / 2
      ];
    };
    getElementLineSegments = (element, elementsMap) => {
      const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(
        element,
        elementsMap
      );
      const center = pointFrom(cx, cy);
      if (isLinearElement(element) || isFreeDrawElement(element)) {
        const segments = [];
        let i = 0;
        while (i < element.points.length - 1) {
          segments.push(
            lineSegment(
              pointRotateRads(
                pointFrom(
                  element.points[i][0] + element.x,
                  element.points[i][1] + element.y
                ),
                center,
                element.angle
              ),
              pointRotateRads(
                pointFrom(
                  element.points[i + 1][0] + element.x,
                  element.points[i + 1][1] + element.y
                ),
                center,
                element.angle
              )
            )
          );
          i++;
        }
        return segments;
      }
      const [nw, ne, sw, se, n, s, w, e] = [
        [x1, y1],
        [x2, y1],
        [x1, y2],
        [x2, y2],
        [cx, y1],
        [cx, y2],
        [x1, cy],
        [x2, cy]
      ].map((point2) => pointRotateRads(point2, center, element.angle));
      if (element.type === "diamond") {
        return [
          lineSegment(n, w),
          lineSegment(n, e),
          lineSegment(s, w),
          lineSegment(s, e)
        ];
      }
      if (element.type === "ellipse") {
        return [
          lineSegment(n, w),
          lineSegment(n, e),
          lineSegment(s, w),
          lineSegment(s, e),
          lineSegment(n, w),
          lineSegment(n, e),
          lineSegment(s, w),
          lineSegment(s, e)
        ];
      }
      return [
        lineSegment(nw, ne),
        lineSegment(sw, se),
        lineSegment(nw, sw),
        lineSegment(ne, se),
        lineSegment(nw, e),
        lineSegment(sw, e),
        lineSegment(ne, w),
        lineSegment(se, w)
      ];
    };
    getDiamondPoints = (element) => {
      const topX = Math.floor(element.width / 2) + 1;
      const topY = 0;
      const rightX = element.width;
      const rightY = Math.floor(element.height / 2) + 1;
      const bottomX = topX;
      const bottomY = element.height;
      const leftX = 0;
      const leftY = rightY;
      return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];
    };
    getCurvePathOps2 = (shape) => {
      for (const set of shape.sets) {
        if (set.type === "path") {
          return set.ops;
        }
      }
      return shape.sets[0].ops;
    };
    getBezierValueForT = (t2, p0, p1, p2, p3) => {
      const oneMinusT = 1 - t2;
      return Math.pow(oneMinusT, 3) * p0 + 3 * Math.pow(oneMinusT, 2) * t2 * p1 + 3 * oneMinusT * Math.pow(t2, 2) * p2 + Math.pow(t2, 3) * p3;
    };
    solveQuadratic = (p0, p1, p2, p3) => {
      const i = p1 - p0;
      const j = p2 - p1;
      const k = p3 - p2;
      const a = 3 * i - 6 * j + 3 * k;
      const b = 6 * j - 6 * i;
      const c = 3 * i;
      const sqrtPart = b * b - 4 * a * c;
      const hasSolution = sqrtPart >= 0;
      if (!hasSolution) {
        return false;
      }
      let s1 = null;
      let s2 = null;
      let t1 = Infinity;
      let t2 = Infinity;
      if (a === 0) {
        t1 = t2 = -c / b;
      } else {
        t1 = (-b + Math.sqrt(sqrtPart)) / (2 * a);
        t2 = (-b - Math.sqrt(sqrtPart)) / (2 * a);
      }
      if (t1 >= 0 && t1 <= 1) {
        s1 = getBezierValueForT(t1, p0, p1, p2, p3);
      }
      if (t2 >= 0 && t2 <= 1) {
        s2 = getBezierValueForT(t2, p0, p1, p2, p3);
      }
      return [s1, s2];
    };
    getCubicBezierCurveBound = (p0, p1, p2, p3) => {
      const solX = solveQuadratic(p0[0], p1[0], p2[0], p3[0]);
      const solY = solveQuadratic(p0[1], p1[1], p2[1], p3[1]);
      let minX = Math.min(p0[0], p3[0]);
      let maxX = Math.max(p0[0], p3[0]);
      if (solX) {
        const xs = solX.filter((x) => x !== null);
        minX = Math.min(minX, ...xs);
        maxX = Math.max(maxX, ...xs);
      }
      let minY = Math.min(p0[1], p3[1]);
      let maxY = Math.max(p0[1], p3[1]);
      if (solY) {
        const ys = solY.filter((y) => y !== null);
        minY = Math.min(minY, ...ys);
        maxY = Math.max(maxY, ...ys);
      }
      return [minX, minY, maxX, maxY];
    };
    getMinMaxXYFromCurvePathOps = (ops, transformXY) => {
      let currentP = pointFrom(0, 0);
      const { minX, minY, maxX, maxY } = ops.reduce(
        (limits, { op, data }) => {
          if (op === "move") {
            const p = pointFromArray(data);
            invariant(p != null, "Op data is not a point");
            currentP = p;
          } else if (op === "bcurveTo") {
            const _p1 = pointFrom(data[0], data[1]);
            const _p2 = pointFrom(data[2], data[3]);
            const _p3 = pointFrom(data[4], data[5]);
            const p1 = transformXY ? transformXY(_p1) : _p1;
            const p2 = transformXY ? transformXY(_p2) : _p2;
            const p3 = transformXY ? transformXY(_p3) : _p3;
            const p0 = transformXY ? transformXY(currentP) : currentP;
            currentP = _p3;
            const [minX2, minY2, maxX2, maxY2] = getCubicBezierCurveBound(
              p0,
              p1,
              p2,
              p3
            );
            limits.minX = Math.min(limits.minX, minX2);
            limits.minY = Math.min(limits.minY, minY2);
            limits.maxX = Math.max(limits.maxX, maxX2);
            limits.maxY = Math.max(limits.maxY, maxY2);
          } else if (op === "lineTo") {
          } else if (op === "qcurveTo") {
          }
          return limits;
        },
        { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity }
      );
      return [minX, minY, maxX, maxY];
    };
    getBoundsFromPoints = (points) => {
      let minX = Infinity;
      let minY = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      for (const [x, y] of points) {
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
      }
      return [minX, minY, maxX, maxY];
    };
    getFreeDrawElementAbsoluteCoords = (element) => {
      const [minX, minY, maxX, maxY] = getBoundsFromPoints(element.points);
      const x1 = minX + element.x;
      const y1 = minY + element.y;
      const x2 = maxX + element.x;
      const y2 = maxY + element.y;
      return [x1, y1, x2, y2, (x1 + x2) / 2, (y1 + y2) / 2];
    };
    getArrowheadSize = (arrowhead) => {
      switch (arrowhead) {
        case "arrow":
          return 25;
        case "diamond":
        case "diamond_outline":
          return 12;
        default:
          return 15;
      }
    };
    getArrowheadAngle = (arrowhead) => {
      switch (arrowhead) {
        case "bar":
          return 90;
        case "arrow":
          return 20;
        default:
          return 25;
      }
    };
    getArrowheadPoints = (element, shape, position, arrowhead) => {
      const ops = getCurvePathOps2(shape[0]);
      if (ops.length < 1) {
        return null;
      }
      const index = position === "start" ? 1 : ops.length - 1;
      const data = ops[index].data;
      invariant(data.length === 6, "Op data length is not 6");
      const p3 = pointFrom(data[4], data[5]);
      const p2 = pointFrom(data[2], data[3]);
      const p1 = pointFrom(data[0], data[1]);
      const prevOp = ops[index - 1];
      let p0 = pointFrom(0, 0);
      if (prevOp.op === "move") {
        const p = pointFromArray(prevOp.data);
        invariant(p != null, "Op data is not a point");
        p0 = p;
      } else if (prevOp.op === "bcurveTo") {
        p0 = pointFrom(prevOp.data[4], prevOp.data[5]);
      }
      const equation2 = (t2, idx) => Math.pow(1 - t2, 3) * p3[idx] + 3 * t2 * Math.pow(1 - t2, 2) * p2[idx] + 3 * Math.pow(t2, 2) * (1 - t2) * p1[idx] + p0[idx] * Math.pow(t2, 3);
      const [x2, y2] = position === "start" ? p0 : p3;
      const [x1, y1] = [equation2(0.3, 0), equation2(0.3, 1)];
      const distance3 = Math.hypot(x2 - x1, y2 - y1);
      const nx = (x2 - x1) / distance3;
      const ny = (y2 - y1) / distance3;
      const size = getArrowheadSize(arrowhead);
      let length = 0;
      {
        const [cx, cy] = position === "end" ? element.points[element.points.length - 1] : element.points[0];
        const [px, py] = element.points.length > 1 ? position === "end" ? element.points[element.points.length - 2] : element.points[1] : [0, 0];
        length = Math.hypot(cx - px, cy - py);
      }
      const lengthMultiplier = arrowhead === "diamond" || arrowhead === "diamond_outline" ? 0.25 : 0.5;
      const minSize = Math.min(size, length * lengthMultiplier);
      const xs = x2 - nx * minSize;
      const ys = y2 - ny * minSize;
      if (arrowhead === "dot" || arrowhead === "circle" || arrowhead === "circle_outline") {
        const diameter = Math.hypot(ys - y2, xs - x2) + element.strokeWidth - 2;
        return [x2, y2, diameter];
      }
      const angle = getArrowheadAngle(arrowhead);
      const [x3, y3] = pointRotateRads(
        pointFrom(xs, ys),
        pointFrom(x2, y2),
        -angle * Math.PI / 180
      );
      const [x4, y4] = pointRotateRads(
        pointFrom(xs, ys),
        pointFrom(x2, y2),
        degreesToRadians(angle)
      );
      if (arrowhead === "diamond" || arrowhead === "diamond_outline") {
        let ox;
        let oy;
        if (position === "start") {
          const [px, py] = element.points.length > 1 ? element.points[1] : [0, 0];
          [ox, oy] = pointRotateRads(
            pointFrom(x2 + minSize * 2, y2),
            pointFrom(x2, y2),
            Math.atan2(py - y2, px - x2)
          );
        } else {
          const [px, py] = element.points.length > 1 ? element.points[element.points.length - 2] : [0, 0];
          [ox, oy] = pointRotateRads(
            pointFrom(x2 - minSize * 2, y2),
            pointFrom(x2, y2),
            Math.atan2(y2 - py, x2 - px)
          );
        }
        return [x2, y2, x3, y3, ox, oy, x4, y4];
      }
      return [x2, y2, x3, y3, x4, y4];
    };
    generateLinearElementShape = (element) => {
      const generator = rough3.generator();
      const options = generateRoughOptions(element);
      const method = (() => {
        if (element.roundness) {
          return "curve";
        }
        if (options.fill) {
          return "polygon";
        }
        return "linearPath";
      })();
      return generator[method](
        element.points,
        options
      );
    };
    getLinearElementRotatedBounds = (element, cx, cy, elementsMap) => {
      const boundTextElement = getBoundTextElement(element, elementsMap);
      if (element.points.length < 2) {
        const [pointX, pointY] = element.points[0];
        const [x, y] = pointRotateRads(
          pointFrom(element.x + pointX, element.y + pointY),
          pointFrom(cx, cy),
          element.angle
        );
        let coords2 = [x, y, x, y];
        if (boundTextElement) {
          const coordsWithBoundText = LinearElementEditor.getMinMaxXYWithBoundText(
            element,
            elementsMap,
            [x, y, x, y],
            boundTextElement
          );
          coords2 = [
            coordsWithBoundText[0],
            coordsWithBoundText[1],
            coordsWithBoundText[2],
            coordsWithBoundText[3]
          ];
        }
        return coords2;
      }
      const cachedShape = ShapeCache.get(element)?.[0];
      const shape = cachedShape ?? generateLinearElementShape(element);
      const ops = getCurvePathOps2(shape);
      const transformXY = ([x, y]) => pointRotateRads(
        pointFrom(element.x + x, element.y + y),
        pointFrom(cx, cy),
        element.angle
      );
      const res = getMinMaxXYFromCurvePathOps(ops, transformXY);
      let coords = [res[0], res[1], res[2], res[3]];
      if (boundTextElement) {
        const coordsWithBoundText = LinearElementEditor.getMinMaxXYWithBoundText(
          element,
          elementsMap,
          coords,
          boundTextElement
        );
        coords = [
          coordsWithBoundText[0],
          coordsWithBoundText[1],
          coordsWithBoundText[2],
          coordsWithBoundText[3]
        ];
      }
      return coords;
    };
    getElementBounds = (element, elementsMap) => {
      return ElementBounds.getBounds(element, elementsMap);
    };
    getCommonBounds = (elements, elementsMap) => {
      if (!elements.length) {
        return [0, 0, 0, 0];
      }
      let minX = Infinity;
      let maxX = -Infinity;
      let minY = Infinity;
      let maxY = -Infinity;
      const _elementsMap = elementsMap || arrayToMap(elements);
      elements.forEach((element) => {
        const [x1, y1, x2, y2] = getElementBounds(element, _elementsMap);
        minX = Math.min(minX, x1);
        minY = Math.min(minY, y1);
        maxX = Math.max(maxX, x2);
        maxY = Math.max(maxY, y2);
      });
      return [minX, minY, maxX, maxY];
    };
    getDraggedElementsBounds = (elements, dragOffset) => {
      const [minX, minY, maxX, maxY] = getCommonBounds(elements);
      return [
        minX + dragOffset.x,
        minY + dragOffset.y,
        maxX + dragOffset.x,
        maxY + dragOffset.y
      ];
    };
    getResizedElementAbsoluteCoords = (element, nextWidth, nextHeight, normalizePoints) => {
      if (!(isLinearElement(element) || isFreeDrawElement(element))) {
        return [
          element.x,
          element.y,
          element.x + nextWidth,
          element.y + nextHeight
        ];
      }
      const points = rescalePoints(
        0,
        nextWidth,
        rescalePoints(1, nextHeight, element.points, normalizePoints),
        normalizePoints
      );
      let bounds;
      if (isFreeDrawElement(element)) {
        bounds = getBoundsFromPoints(points);
      } else {
        const gen = rough3.generator();
        const curve2 = !element.roundness ? gen.linearPath(
          points,
          generateRoughOptions(element)
        ) : gen.curve(points, generateRoughOptions(element));
        const ops = getCurvePathOps2(curve2);
        bounds = getMinMaxXYFromCurvePathOps(ops);
      }
      const [minX, minY, maxX, maxY] = bounds;
      return [
        minX + element.x,
        minY + element.y,
        maxX + element.x,
        maxY + element.y
      ];
    };
    getElementPointsCoords = (element, points) => {
      const gen = rough3.generator();
      const curve2 = element.roundness == null ? gen.linearPath(
        points,
        generateRoughOptions(element)
      ) : gen.curve(points, generateRoughOptions(element));
      const ops = getCurvePathOps2(curve2);
      const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);
      return [
        minX + element.x,
        minY + element.y,
        maxX + element.x,
        maxY + element.y
      ];
    };
    getClosestElementBounds = (elements, from3) => {
      if (!elements.length) {
        return [0, 0, 0, 0];
      }
      let minDistance = Infinity;
      let closestElement = elements[0];
      const elementsMap = arrayToMap(elements);
      elements.forEach((element) => {
        const [x1, y1, x2, y2] = getElementBounds(element, elementsMap);
        const distance3 = pointDistance(
          pointFrom((x1 + x2) / 2, (y1 + y2) / 2),
          pointFrom(from3.x, from3.y)
        );
        if (distance3 < minDistance) {
          minDistance = distance3;
          closestElement = element;
        }
      });
      return getElementBounds(closestElement, elementsMap);
    };
    getCommonBoundingBox = (elements) => {
      const [minX, minY, maxX, maxY] = getCommonBounds(elements);
      return {
        minX,
        minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY,
        midX: (minX + maxX) / 2,
        midY: (minY + maxY) / 2
      };
    };
    getVisibleSceneBounds = ({
      scrollX,
      scrollY,
      width,
      height,
      zoom
    }) => {
      return [
        -scrollX,
        -scrollY,
        -scrollX + width / zoom.value,
        -scrollY + height / zoom.value
      ];
    };
    getCenterForBounds = (bounds) => pointFrom(
      bounds[0] + (bounds[2] - bounds[0]) / 2,
      bounds[1] + (bounds[3] - bounds[1]) / 2
    );
  }
});

// binaryheap.ts
var BinaryHeap;
var init_binaryheap = __esm({
  "binaryheap.ts"() {
    "use strict";
    init_define_import_meta_env();
    BinaryHeap = class {
      constructor(scoreFunction) {
        this.scoreFunction = scoreFunction;
      }
      content = [];
      sinkDown(idx) {
        const node = this.content[idx];
        while (idx > 0) {
          const parentN = (idx + 1 >> 1) - 1;
          const parent = this.content[parentN];
          if (this.scoreFunction(node) < this.scoreFunction(parent)) {
            this.content[parentN] = node;
            this.content[idx] = parent;
            idx = parentN;
          } else {
            break;
          }
        }
      }
      bubbleUp(idx) {
        const length = this.content.length;
        const node = this.content[idx];
        const score = this.scoreFunction(node);
        while (true) {
          const child2N = idx + 1 << 1;
          const child1N = child2N - 1;
          let swap = null;
          let child1Score = 0;
          if (child1N < length) {
            const child1 = this.content[child1N];
            child1Score = this.scoreFunction(child1);
            if (child1Score < score) {
              swap = child1N;
            }
          }
          if (child2N < length) {
            const child2 = this.content[child2N];
            const child2Score = this.scoreFunction(child2);
            if (child2Score < (swap === null ? score : child1Score)) {
              swap = child2N;
            }
          }
          if (swap !== null) {
            this.content[idx] = this.content[swap];
            this.content[swap] = node;
            idx = swap;
          } else {
            break;
          }
        }
      }
      push(node) {
        this.content.push(node);
        this.sinkDown(this.content.length - 1);
      }
      pop() {
        if (this.content.length === 0) {
          return null;
        }
        const result = this.content[0];
        const end = this.content.pop();
        if (this.content.length > 0) {
          this.content[0] = end;
          this.bubbleUp(0);
        }
        return result;
      }
      remove(node) {
        if (this.content.length === 0) {
          return;
        }
        const i = this.content.indexOf(node);
        const end = this.content.pop();
        if (i < this.content.length) {
          this.content[i] = end;
          if (this.scoreFunction(end) < this.scoreFunction(node)) {
            this.sinkDown(i);
          } else {
            this.bubbleUp(i);
          }
        }
      }
      size() {
        return this.content.length;
      }
      rescoreElement(node) {
        this.sinkDown(this.content.indexOf(node));
      }
    };
  }
});

// element/routing.ts
var BASE_PADDING, mutateElbowArrow, updateElbowArrow, offsetFromHeading, astar, pathTo, m_dist, generateDynamicAABBs, calculateGrid, getDonglePosition, estimateSegmentCount, getNeighbors, gridNodeFromAddr, pointToGridNode, commonAABB, getBindableElementForId, normalizedArrowElementUpdate, simplifyElbowArrowPoints, neighborIndexToHeading, getGlobalPoint, getSnapPoint, getBindPointHeading, getHoveredElements, gridAddressesEqual;
var init_routing = __esm({
  "element/routing.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_math();
    init_binaryheap();
    init_points();
    init_shapes();
    init_utils2();
    init_binding();
    init_heading();
    init_mutateElement();
    init_typeChecks();
    BASE_PADDING = 40;
    mutateElbowArrow = (arrow, elementsMap, nextPoints, offset2, otherUpdates, options) => {
      const update = updateElbowArrow(
        arrow,
        elementsMap,
        nextPoints,
        offset2,
        options
      );
      if (update) {
        mutateElement(
          arrow,
          {
            ...otherUpdates,
            ...update,
            angle: 0
          },
          options?.informMutation
        );
      } else {
        console.error("Elbow arrow cannot find a route");
      }
    };
    updateElbowArrow = (arrow, elementsMap, nextPoints, offset2, options) => {
      const origStartGlobalPoint = pointTranslate(
        pointTranslate(
          nextPoints[0],
          vector(arrow.x, arrow.y)
        ),
        offset2
      );
      const origEndGlobalPoint = pointTranslate(
        pointTranslate(
          nextPoints[nextPoints.length - 1],
          vector(arrow.x, arrow.y)
        ),
        offset2
      );
      const startElement = arrow.startBinding && getBindableElementForId(arrow.startBinding.elementId, elementsMap);
      const endElement = arrow.endBinding && getBindableElementForId(arrow.endBinding.elementId, elementsMap);
      const [hoveredStartElement, hoveredEndElement] = options?.isDragging ? getHoveredElements(origStartGlobalPoint, origEndGlobalPoint, elementsMap) : [startElement, endElement];
      const startGlobalPoint = getGlobalPoint(
        arrow.startBinding?.fixedPoint,
        origStartGlobalPoint,
        origEndGlobalPoint,
        elementsMap,
        startElement,
        hoveredStartElement,
        options?.isDragging
      );
      const endGlobalPoint = getGlobalPoint(
        arrow.endBinding?.fixedPoint,
        origEndGlobalPoint,
        origStartGlobalPoint,
        elementsMap,
        endElement,
        hoveredEndElement,
        options?.isDragging
      );
      const startHeading = getBindPointHeading(
        startGlobalPoint,
        endGlobalPoint,
        elementsMap,
        hoveredStartElement,
        origStartGlobalPoint
      );
      const endHeading = getBindPointHeading(
        endGlobalPoint,
        startGlobalPoint,
        elementsMap,
        hoveredEndElement,
        origEndGlobalPoint
      );
      const startPointBounds = [
        startGlobalPoint[0] - 2,
        startGlobalPoint[1] - 2,
        startGlobalPoint[0] + 2,
        startGlobalPoint[1] + 2
      ];
      const endPointBounds = [
        endGlobalPoint[0] - 2,
        endGlobalPoint[1] - 2,
        endGlobalPoint[0] + 2,
        endGlobalPoint[1] + 2
      ];
      const startElementBounds = hoveredStartElement ? aabbForElement(
        hoveredStartElement,
        offsetFromHeading(
          startHeading,
          arrow.startArrowhead ? FIXED_BINDING_DISTANCE * 6 : FIXED_BINDING_DISTANCE * 2,
          1
        )
      ) : startPointBounds;
      const endElementBounds = hoveredEndElement ? aabbForElement(
        hoveredEndElement,
        offsetFromHeading(
          endHeading,
          arrow.endArrowhead ? FIXED_BINDING_DISTANCE * 6 : FIXED_BINDING_DISTANCE * 2,
          1
        )
      ) : endPointBounds;
      const boundsOverlap = pointInsideBounds(
        startGlobalPoint,
        hoveredEndElement ? aabbForElement(
          hoveredEndElement,
          offsetFromHeading(endHeading, BASE_PADDING, BASE_PADDING)
        ) : endPointBounds
      ) || pointInsideBounds(
        endGlobalPoint,
        hoveredStartElement ? aabbForElement(
          hoveredStartElement,
          offsetFromHeading(startHeading, BASE_PADDING, BASE_PADDING)
        ) : startPointBounds
      );
      const commonBounds = commonAABB(
        boundsOverlap ? [startPointBounds, endPointBounds] : [startElementBounds, endElementBounds]
      );
      const dynamicAABBs = generateDynamicAABBs(
        boundsOverlap ? startPointBounds : startElementBounds,
        boundsOverlap ? endPointBounds : endElementBounds,
        commonBounds,
        boundsOverlap ? offsetFromHeading(
          startHeading,
          !hoveredStartElement && !hoveredEndElement ? 0 : BASE_PADDING,
          0
        ) : offsetFromHeading(
          startHeading,
          !hoveredStartElement && !hoveredEndElement ? 0 : BASE_PADDING - (arrow.startArrowhead ? FIXED_BINDING_DISTANCE * 6 : FIXED_BINDING_DISTANCE * 2),
          BASE_PADDING
        ),
        boundsOverlap ? offsetFromHeading(
          endHeading,
          !hoveredStartElement && !hoveredEndElement ? 0 : BASE_PADDING,
          0
        ) : offsetFromHeading(
          endHeading,
          !hoveredStartElement && !hoveredEndElement ? 0 : BASE_PADDING - (arrow.endArrowhead ? FIXED_BINDING_DISTANCE * 6 : FIXED_BINDING_DISTANCE * 2),
          BASE_PADDING
        ),
        boundsOverlap,
        hoveredStartElement && aabbForElement(hoveredStartElement),
        hoveredEndElement && aabbForElement(hoveredEndElement)
      );
      const startDonglePosition = getDonglePosition(
        dynamicAABBs[0],
        startHeading,
        startGlobalPoint
      );
      const endDonglePosition = getDonglePosition(
        dynamicAABBs[1],
        endHeading,
        endGlobalPoint
      );
      const grid = calculateGrid(
        dynamicAABBs,
        startDonglePosition ? startDonglePosition : startGlobalPoint,
        startHeading,
        endDonglePosition ? endDonglePosition : endGlobalPoint,
        endHeading,
        commonBounds
      );
      const startDongle = startDonglePosition && pointToGridNode(startDonglePosition, grid);
      const endDongle = endDonglePosition && pointToGridNode(endDonglePosition, grid);
      const endNode = pointToGridNode(endGlobalPoint, grid);
      if (endNode && hoveredEndElement) {
        endNode.closed = true;
      }
      const startNode = pointToGridNode(startGlobalPoint, grid);
      if (startNode && arrow.startBinding) {
        startNode.closed = true;
      }
      const dongleOverlap = startDongle && endDongle && (pointInsideBounds(startDongle.pos, dynamicAABBs[1]) || pointInsideBounds(endDongle.pos, dynamicAABBs[0]));
      const path = astar(
        startDongle ? startDongle : startNode,
        endDongle ? endDongle : endNode,
        grid,
        startHeading ? startHeading : HEADING_RIGHT,
        endHeading ? endHeading : HEADING_RIGHT,
        dongleOverlap ? [] : dynamicAABBs
      );
      if (path) {
        const points = path.map((node) => [
          node.pos[0],
          node.pos[1]
        ]);
        startDongle && points.unshift(startGlobalPoint);
        endDongle && points.push(endGlobalPoint);
        return normalizedArrowElementUpdate(simplifyElbowArrowPoints(points), 0, 0);
      }
      return null;
    };
    offsetFromHeading = (heading, head, side) => {
      switch (heading) {
        case HEADING_UP:
          return [head, side, side, side];
        case HEADING_RIGHT:
          return [side, head, side, side];
        case HEADING_DOWN:
          return [side, side, head, side];
      }
      return [side, side, side, head];
    };
    astar = (start2, end, grid, startHeading, endHeading, aabbs) => {
      const bendMultiplier = m_dist(start2.pos, end.pos);
      const open = new BinaryHeap((node) => node.f);
      open.push(start2);
      while (open.size() > 0) {
        const current = open.pop();
        if (!current || current.closed) {
          continue;
        }
        if (current === end) {
          return pathTo(start2, current);
        }
        current.closed = true;
        const neighbors = getNeighbors(current.addr, grid);
        for (let i = 0; i < 4; i++) {
          const neighbor = neighbors[i];
          if (!neighbor || neighbor.closed) {
            continue;
          }
          const neighborHalfPoint = pointScaleFromOrigin(
            neighbor.pos,
            current.pos,
            0.5
          );
          if (isAnyTrue(
            ...aabbs.map((aabb) => pointInsideBounds(neighborHalfPoint, aabb))
          )) {
            continue;
          }
          const neighborHeading = neighborIndexToHeading(i);
          const previousDirection = current.parent ? vectorToHeading(vectorFromPoint(current.pos, current.parent.pos)) : startHeading;
          const reverseHeading = flipHeading(previousDirection);
          const neighborIsReverseRoute = compareHeading(reverseHeading, neighborHeading) || gridAddressesEqual(start2.addr, neighbor.addr) && compareHeading(neighborHeading, startHeading) || gridAddressesEqual(end.addr, neighbor.addr) && compareHeading(neighborHeading, endHeading);
          if (neighborIsReverseRoute) {
            continue;
          }
          const directionChange = previousDirection !== neighborHeading;
          const gScore = current.g + m_dist(neighbor.pos, current.pos) + (directionChange ? Math.pow(bendMultiplier, 3) : 0);
          const beenVisited = neighbor.visited;
          if (!beenVisited || gScore < neighbor.g) {
            const estBendCount = estimateSegmentCount(
              neighbor,
              end,
              neighborHeading,
              endHeading
            );
            neighbor.visited = true;
            neighbor.parent = current;
            neighbor.h = m_dist(end.pos, neighbor.pos) + estBendCount * Math.pow(bendMultiplier, 2);
            neighbor.g = gScore;
            neighbor.f = neighbor.g + neighbor.h;
            if (!beenVisited) {
              open.push(neighbor);
            } else {
              open.rescoreElement(neighbor);
            }
          }
        }
      }
      return null;
    };
    pathTo = (start2, node) => {
      let curr = node;
      const path = [];
      while (curr.parent) {
        path.unshift(curr);
        curr = curr.parent;
      }
      path.unshift(start2);
      return path;
    };
    m_dist = (a, b) => Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);
    generateDynamicAABBs = (a, b, common, startDifference, endDifference, disableSideHack, startElementBounds, endElementBounds) => {
      const startEl = startElementBounds ?? a;
      const endEl = endElementBounds ?? b;
      const [startUp, startRight, startDown, startLeft] = startDifference ?? [
        0,
        0,
        0,
        0
      ];
      const [endUp, endRight, endDown, endLeft] = endDifference ?? [0, 0, 0, 0];
      const first = [
        a[0] > b[2] ? a[1] > b[3] || a[3] < b[1] ? Math.min((startEl[0] + endEl[2]) / 2, a[0] - startLeft) : (startEl[0] + endEl[2]) / 2 : a[0] > b[0] ? a[0] - startLeft : common[0] - startLeft,
        a[1] > b[3] ? a[0] > b[2] || a[2] < b[0] ? Math.min((startEl[1] + endEl[3]) / 2, a[1] - startUp) : (startEl[1] + endEl[3]) / 2 : a[1] > b[1] ? a[1] - startUp : common[1] - startUp,
        a[2] < b[0] ? a[1] > b[3] || a[3] < b[1] ? Math.max((startEl[2] + endEl[0]) / 2, a[2] + startRight) : (startEl[2] + endEl[0]) / 2 : a[2] < b[2] ? a[2] + startRight : common[2] + startRight,
        a[3] < b[1] ? a[0] > b[2] || a[2] < b[0] ? Math.max((startEl[3] + endEl[1]) / 2, a[3] + startDown) : (startEl[3] + endEl[1]) / 2 : a[3] < b[3] ? a[3] + startDown : common[3] + startDown
      ];
      const second = [
        b[0] > a[2] ? b[1] > a[3] || b[3] < a[1] ? Math.min((endEl[0] + startEl[2]) / 2, b[0] - endLeft) : (endEl[0] + startEl[2]) / 2 : b[0] > a[0] ? b[0] - endLeft : common[0] - endLeft,
        b[1] > a[3] ? b[0] > a[2] || b[2] < a[0] ? Math.min((endEl[1] + startEl[3]) / 2, b[1] - endUp) : (endEl[1] + startEl[3]) / 2 : b[1] > a[1] ? b[1] - endUp : common[1] - endUp,
        b[2] < a[0] ? b[1] > a[3] || b[3] < a[1] ? Math.max((endEl[2] + startEl[0]) / 2, b[2] + endRight) : (endEl[2] + startEl[0]) / 2 : b[2] < a[2] ? b[2] + endRight : common[2] + endRight,
        b[3] < a[1] ? b[0] > a[2] || b[2] < a[0] ? Math.max((endEl[3] + startEl[1]) / 2, b[3] + endDown) : (endEl[3] + startEl[1]) / 2 : b[3] < a[3] ? b[3] + endDown : common[3] + endDown
      ];
      const c = commonAABB([first, second]);
      if (!disableSideHack && first[2] - first[0] + second[2] - second[0] > c[2] - c[0] + 1e-11 && first[3] - first[1] + second[3] - second[1] > c[3] - c[1] + 1e-11) {
        const [endCenterX, endCenterY] = [
          (second[0] + second[2]) / 2,
          (second[1] + second[3]) / 2
        ];
        if (b[0] > a[2] && a[1] > b[3]) {
          const cX = first[2] + (second[0] - first[2]) / 2;
          const cY = second[3] + (first[1] - second[3]) / 2;
          if (vectorCross(
            vector(a[2] - endCenterX, a[1] - endCenterY),
            vector(a[0] - endCenterX, a[3] - endCenterY)
          ) > 0) {
            return [
              [first[0], first[1], cX, first[3]],
              [cX, second[1], second[2], second[3]]
            ];
          }
          return [
            [first[0], cY, first[2], first[3]],
            [second[0], second[1], second[2], cY]
          ];
        } else if (a[2] < b[0] && a[3] < b[1]) {
          const cX = first[2] + (second[0] - first[2]) / 2;
          const cY = first[3] + (second[1] - first[3]) / 2;
          if (vectorCross(
            vector(a[0] - endCenterX, a[1] - endCenterY),
            vector(a[2] - endCenterX, a[3] - endCenterY)
          ) > 0) {
            return [
              [first[0], first[1], first[2], cY],
              [second[0], cY, second[2], second[3]]
            ];
          }
          return [
            [first[0], first[1], cX, first[3]],
            [cX, second[1], second[2], second[3]]
          ];
        } else if (a[0] > b[2] && a[3] < b[1]) {
          const cX = second[2] + (first[0] - second[2]) / 2;
          const cY = first[3] + (second[1] - first[3]) / 2;
          if (vectorCross(
            vector(a[2] - endCenterX, a[1] - endCenterY),
            vector(a[0] - endCenterX, a[3] - endCenterY)
          ) > 0) {
            return [
              [cX, first[1], first[2], first[3]],
              [second[0], second[1], cX, second[3]]
            ];
          }
          return [
            [first[0], first[1], first[2], cY],
            [second[0], cY, second[2], second[3]]
          ];
        } else if (a[0] > b[2] && a[1] > b[3]) {
          const cX = second[2] + (first[0] - second[2]) / 2;
          const cY = second[3] + (first[1] - second[3]) / 2;
          if (vectorCross(
            vector(a[0] - endCenterX, a[1] - endCenterY),
            vector(a[2] - endCenterX, a[3] - endCenterY)
          ) > 0) {
            return [
              [cX, first[1], first[2], first[3]],
              [second[0], second[1], cX, second[3]]
            ];
          }
          return [
            [first[0], cY, first[2], first[3]],
            [second[0], second[1], second[2], cY]
          ];
        }
      }
      return [first, second];
    };
    calculateGrid = (aabbs, start2, startHeading, end, endHeading, common) => {
      const horizontal = /* @__PURE__ */ new Set();
      const vertical = /* @__PURE__ */ new Set();
      if (startHeading === HEADING_LEFT || startHeading === HEADING_RIGHT) {
        vertical.add(start2[1]);
      } else {
        horizontal.add(start2[0]);
      }
      if (endHeading === HEADING_LEFT || endHeading === HEADING_RIGHT) {
        vertical.add(end[1]);
      } else {
        horizontal.add(end[0]);
      }
      aabbs.forEach((aabb) => {
        horizontal.add(aabb[0]);
        horizontal.add(aabb[2]);
        vertical.add(aabb[1]);
        vertical.add(aabb[3]);
      });
      horizontal.add(common[0]);
      horizontal.add(common[2]);
      vertical.add(common[1]);
      vertical.add(common[3]);
      const _vertical = Array.from(vertical).sort((a, b) => a - b);
      const _horizontal = Array.from(horizontal).sort((a, b) => a - b);
      return {
        row: _vertical.length,
        col: _horizontal.length,
        data: _vertical.flatMap(
          (y, row) => _horizontal.map(
            (x, col) => ({
              f: 0,
              g: 0,
              h: 0,
              closed: false,
              visited: false,
              parent: null,
              addr: [col, row],
              pos: [x, y]
            })
          )
        )
      };
    };
    getDonglePosition = (bounds, heading, p) => {
      switch (heading) {
        case HEADING_UP:
          return pointFrom(p[0], bounds[1]);
        case HEADING_RIGHT:
          return pointFrom(bounds[2], p[1]);
        case HEADING_DOWN:
          return pointFrom(p[0], bounds[3]);
      }
      return pointFrom(bounds[0], p[1]);
    };
    estimateSegmentCount = (start2, end, startHeading, endHeading) => {
      if (endHeading === HEADING_RIGHT) {
        switch (startHeading) {
          case HEADING_RIGHT: {
            if (start2.pos[0] >= end.pos[0]) {
              return 4;
            }
            if (start2.pos[1] === end.pos[1]) {
              return 0;
            }
            return 2;
          }
          case HEADING_UP:
            if (start2.pos[1] > end.pos[1] && start2.pos[0] < end.pos[0]) {
              return 1;
            }
            return 3;
          case HEADING_DOWN:
            if (start2.pos[1] < end.pos[1] && start2.pos[0] < end.pos[0]) {
              return 1;
            }
            return 3;
          case HEADING_LEFT:
            if (start2.pos[1] === end.pos[1]) {
              return 4;
            }
            return 2;
        }
      } else if (endHeading === HEADING_LEFT) {
        switch (startHeading) {
          case HEADING_RIGHT:
            if (start2.pos[1] === end.pos[1]) {
              return 4;
            }
            return 2;
          case HEADING_UP:
            if (start2.pos[1] > end.pos[1] && start2.pos[0] > end.pos[0]) {
              return 1;
            }
            return 3;
          case HEADING_DOWN:
            if (start2.pos[1] < end.pos[1] && start2.pos[0] > end.pos[0]) {
              return 1;
            }
            return 3;
          case HEADING_LEFT:
            if (start2.pos[0] <= end.pos[0]) {
              return 4;
            }
            if (start2.pos[1] === end.pos[1]) {
              return 0;
            }
            return 2;
        }
      } else if (endHeading === HEADING_UP) {
        switch (startHeading) {
          case HEADING_RIGHT:
            if (start2.pos[1] > end.pos[1] && start2.pos[0] < end.pos[0]) {
              return 1;
            }
            return 3;
          case HEADING_UP:
            if (start2.pos[1] >= end.pos[1]) {
              return 4;
            }
            if (start2.pos[0] === end.pos[0]) {
              return 0;
            }
            return 2;
          case HEADING_DOWN:
            if (start2.pos[0] === end.pos[0]) {
              return 4;
            }
            return 2;
          case HEADING_LEFT:
            if (start2.pos[1] > end.pos[1] && start2.pos[0] > end.pos[0]) {
              return 1;
            }
            return 3;
        }
      } else if (endHeading === HEADING_DOWN) {
        switch (startHeading) {
          case HEADING_RIGHT:
            if (start2.pos[1] < end.pos[1] && start2.pos[0] < end.pos[0]) {
              return 1;
            }
            return 3;
          case HEADING_UP:
            if (start2.pos[0] === end.pos[0]) {
              return 4;
            }
            return 2;
          case HEADING_DOWN:
            if (start2.pos[1] <= end.pos[1]) {
              return 4;
            }
            if (start2.pos[0] === end.pos[0]) {
              return 0;
            }
            return 2;
          case HEADING_LEFT:
            if (start2.pos[1] < end.pos[1] && start2.pos[0] > end.pos[0]) {
              return 1;
            }
            return 3;
        }
      }
      return 0;
    };
    getNeighbors = ([col, row], grid) => [
      gridNodeFromAddr([col, row - 1], grid),
      gridNodeFromAddr([col + 1, row], grid),
      gridNodeFromAddr([col, row + 1], grid),
      gridNodeFromAddr([col - 1, row], grid)
    ];
    gridNodeFromAddr = ([col, row], grid) => {
      if (col < 0 || col >= grid.col || row < 0 || row >= grid.row) {
        return null;
      }
      return grid.data[row * grid.col + col] ?? null;
    };
    pointToGridNode = (point2, grid) => {
      for (let col = 0; col < grid.col; col++) {
        for (let row = 0; row < grid.row; row++) {
          const candidate = gridNodeFromAddr([col, row], grid);
          if (candidate && point2[0] === candidate.pos[0] && point2[1] === candidate.pos[1]) {
            return candidate;
          }
        }
      }
      return null;
    };
    commonAABB = (aabbs) => [
      Math.min(...aabbs.map((aabb) => aabb[0])),
      Math.min(...aabbs.map((aabb) => aabb[1])),
      Math.max(...aabbs.map((aabb) => aabb[2])),
      Math.max(...aabbs.map((aabb) => aabb[3]))
    ];
    getBindableElementForId = (id, elementsMap) => {
      const element = elementsMap.get(id);
      if (element && isBindableElement(element)) {
        return element;
      }
      return null;
    };
    normalizedArrowElementUpdate = (global, externalOffsetX, externalOffsetY) => {
      const offsetX = global[0][0];
      const offsetY = global[0][1];
      const points = global.map(
        (p) => pointTranslate(
          p,
          vectorScale(vectorFromPoint(global[0]), -1)
        )
      );
      return {
        points,
        x: offsetX + (externalOffsetX ?? 0),
        y: offsetY + (externalOffsetY ?? 0),
        ...getSizeFromPoints(points)
      };
    };
    simplifyElbowArrowPoints = (points) => points.slice(2).reduce(
      (result, p) => compareHeading(
        vectorToHeading(
          vectorFromPoint(
            result[result.length - 1],
            result[result.length - 2]
          )
        ),
        vectorToHeading(vectorFromPoint(p, result[result.length - 1]))
      ) ? [...result.slice(0, -1), p] : [...result, p],
      [points[0] ?? [0, 0], points[1] ?? [1, 0]]
    );
    neighborIndexToHeading = (idx) => {
      switch (idx) {
        case 0:
          return HEADING_UP;
        case 1:
          return HEADING_RIGHT;
        case 2:
          return HEADING_DOWN;
      }
      return HEADING_LEFT;
    };
    getGlobalPoint = (fixedPointRatio, initialPoint, otherPoint, elementsMap, boundElement, hoveredElement, isDragging) => {
      if (isDragging) {
        if (hoveredElement) {
          const snapPoint = getSnapPoint(
            initialPoint,
            otherPoint,
            hoveredElement,
            elementsMap
          );
          return snapToMid(hoveredElement, snapPoint);
        }
        return initialPoint;
      }
      if (boundElement) {
        const fixedGlobalPoint = getGlobalFixedPointForBindableElement(
          fixedPointRatio || [0, 0],
          boundElement
        );
        return Math.abs(
          distanceToBindableElement(boundElement, fixedGlobalPoint, elementsMap) - FIXED_BINDING_DISTANCE
        ) > 0.01 ? getSnapPoint(initialPoint, otherPoint, boundElement, elementsMap) : fixedGlobalPoint;
      }
      return initialPoint;
    };
    getSnapPoint = (p, otherPoint, element, elementsMap) => bindPointToSnapToElementOutline(
      isRectanguloidElement(element) ? avoidRectangularCorner(element, p) : p,
      otherPoint,
      element,
      elementsMap
    );
    getBindPointHeading = (p, otherPoint, elementsMap, hoveredElement, origPoint) => getHeadingForElbowArrowSnap(
      p,
      otherPoint,
      hoveredElement,
      hoveredElement && aabbForElement(
        hoveredElement,
        Array(4).fill(
          distanceToBindableElement(hoveredElement, p, elementsMap)
        )
      ),
      elementsMap,
      origPoint
    );
    getHoveredElements = (origStartGlobalPoint, origEndGlobalPoint, elementsMap) => {
      const nonDeletedSceneElementsMap = toBrandedType(
        new Map([...elementsMap].filter((el) => !el[1].isDeleted))
      );
      const elements = Array.from(elementsMap.values());
      return [
        getHoveredElementForBinding(
          tupleToCoors(origStartGlobalPoint),
          elements,
          nonDeletedSceneElementsMap,
          true
        ),
        getHoveredElementForBinding(
          tupleToCoors(origEndGlobalPoint),
          elements,
          nonDeletedSceneElementsMap,
          true
        )
      ];
    };
    gridAddressesEqual = (a, b) => a[0] === b[0] && a[1] === b[1];
  }
});

// snapping.ts
var SNAP_DISTANCE, VISIBLE_GAPS_LIMIT_PER_AXIS, getSnapDistance, SnapCache, isGridModeEnabled, isSnappingEnabled, areRoughlyEqual, getElementsCorners, getReferenceElements, getVisibleGaps, getGapSnaps, getReferenceSnapPoints, getPointSnaps, snapDraggedElements, round2, dedupePoints, createPointSnapLines, dedupeGapSnapLines, createGapSnapLines, snapResizingElements, snapNewElement, getSnapLinesAtPointer, isActiveToolNonLinearSnappable, getGridPoint;
var init_snapping = __esm({
  "snapping.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_math();
    init_constants();
    init_bounds();
    init_typeChecks();
    init_groups();
    init_keys();
    init_selection();
    SNAP_DISTANCE = 8;
    VISIBLE_GAPS_LIMIT_PER_AXIS = 99999;
    getSnapDistance = (zoomValue) => {
      return SNAP_DISTANCE / zoomValue;
    };
    SnapCache = class _SnapCache {
      static referenceSnapPoints = null;
      static visibleGaps = null;
      static setReferenceSnapPoints = (snapPoints) => {
        _SnapCache.referenceSnapPoints = snapPoints;
      };
      static getReferenceSnapPoints = () => {
        return _SnapCache.referenceSnapPoints;
      };
      static setVisibleGaps = (gaps) => {
        _SnapCache.visibleGaps = gaps;
      };
      static getVisibleGaps = () => {
        return _SnapCache.visibleGaps;
      };
      static destroy = () => {
        _SnapCache.referenceSnapPoints = null;
        _SnapCache.visibleGaps = null;
      };
    };
    isGridModeEnabled = (app) => app.props.gridModeEnabled ?? app.state.gridModeEnabled;
    isSnappingEnabled = ({
      event,
      app,
      selectedElements
    }) => {
      if (event) {
        return app.state.objectsSnapModeEnabled && !event[KEYS.CTRL_OR_CMD] || !app.state.objectsSnapModeEnabled && event[KEYS.CTRL_OR_CMD] && !isGridModeEnabled(app);
      }
      if (selectedElements.length === 1 && selectedElements[0].type === "arrow") {
        return false;
      }
      return app.state.objectsSnapModeEnabled;
    };
    areRoughlyEqual = (a, b, precision = 0.01) => {
      return Math.abs(a - b) <= precision;
    };
    getElementsCorners = (elements, elementsMap, {
      omitCenter,
      boundingBoxCorners,
      dragOffset
    } = {
      omitCenter: false,
      boundingBoxCorners: false
    }) => {
      let result = [];
      if (elements.length === 1) {
        const element = elements[0];
        let [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(
          element,
          elementsMap
        );
        if (dragOffset) {
          x1 += dragOffset.x;
          x2 += dragOffset.x;
          cx += dragOffset.x;
          y1 += dragOffset.y;
          y2 += dragOffset.y;
          cy += dragOffset.y;
        }
        const halfWidth = (x2 - x1) / 2;
        const halfHeight = (y2 - y1) / 2;
        if ((element.type === "diamond" || element.type === "ellipse") && !boundingBoxCorners) {
          const leftMid = pointRotateRads(
            pointFrom(x1, y1 + halfHeight),
            pointFrom(cx, cy),
            element.angle
          );
          const topMid = pointRotateRads(
            pointFrom(x1 + halfWidth, y1),
            pointFrom(cx, cy),
            element.angle
          );
          const rightMid = pointRotateRads(
            pointFrom(x2, y1 + halfHeight),
            pointFrom(cx, cy),
            element.angle
          );
          const bottomMid = pointRotateRads(
            pointFrom(x1 + halfWidth, y2),
            pointFrom(cx, cy),
            element.angle
          );
          const center = pointFrom(cx, cy);
          result = omitCenter ? [leftMid, topMid, rightMid, bottomMid] : [leftMid, topMid, rightMid, bottomMid, center];
        } else {
          const topLeft = pointRotateRads(
            pointFrom(x1, y1),
            pointFrom(cx, cy),
            element.angle
          );
          const topRight = pointRotateRads(
            pointFrom(x2, y1),
            pointFrom(cx, cy),
            element.angle
          );
          const bottomLeft = pointRotateRads(
            pointFrom(x1, y2),
            pointFrom(cx, cy),
            element.angle
          );
          const bottomRight = pointRotateRads(
            pointFrom(x2, y2),
            pointFrom(cx, cy),
            element.angle
          );
          const center = pointFrom(cx, cy);
          result = omitCenter ? [topLeft, topRight, bottomLeft, bottomRight] : [topLeft, topRight, bottomLeft, bottomRight, center];
        }
      } else if (elements.length > 1) {
        const [minX, minY, maxX, maxY] = getDraggedElementsBounds(
          elements,
          dragOffset ?? { x: 0, y: 0 }
        );
        const width = maxX - minX;
        const height = maxY - minY;
        const topLeft = pointFrom(minX, minY);
        const topRight = pointFrom(maxX, minY);
        const bottomLeft = pointFrom(minX, maxY);
        const bottomRight = pointFrom(maxX, maxY);
        const center = pointFrom(minX + width / 2, minY + height / 2);
        result = omitCenter ? [topLeft, topRight, bottomLeft, bottomRight] : [topLeft, topRight, bottomLeft, bottomRight, center];
      }
      return result.map((p) => pointFrom(round2(p[0]), round2(p[1])));
    };
    getReferenceElements = (elements, selectedElements, appState, elementsMap) => {
      const selectedFrames = selectedElements.filter((element) => isFrameLikeElement(element)).map((frame) => frame.id);
      return getVisibleAndNonSelectedElements(
        elements,
        selectedElements,
        appState,
        elementsMap
      ).filter(
        (element) => !(element.frameId && selectedFrames.includes(element.frameId))
      );
    };
    getVisibleGaps = (elements, selectedElements, appState, elementsMap) => {
      const referenceElements = getReferenceElements(
        elements,
        selectedElements,
        appState,
        elementsMap
      );
      const referenceBounds = getMaximumGroups(referenceElements, elementsMap).filter(
        (elementsGroup) => !(elementsGroup.length === 1 && isBoundToContainer(elementsGroup[0]))
      ).map(
        (group) => getCommonBounds(group).map(
          (bound) => round2(bound)
        )
      );
      const horizontallySorted = referenceBounds.sort((a, b) => a[0] - b[0]);
      const horizontalGaps = [];
      let c = 0;
      horizontal:
        for (let i = 0; i < horizontallySorted.length; i++) {
          const startBounds = horizontallySorted[i];
          for (let j = i + 1; j < horizontallySorted.length; j++) {
            if (++c > VISIBLE_GAPS_LIMIT_PER_AXIS) {
              break horizontal;
            }
            const endBounds = horizontallySorted[j];
            const [, startMinY, startMaxX, startMaxY] = startBounds;
            const [endMinX, endMinY, , endMaxY] = endBounds;
            if (startMaxX < endMinX && rangesOverlap(
              rangeInclusive(startMinY, startMaxY),
              rangeInclusive(endMinY, endMaxY)
            )) {
              horizontalGaps.push({
                startBounds,
                endBounds,
                startSide: [
                  pointFrom(startMaxX, startMinY),
                  pointFrom(startMaxX, startMaxY)
                ],
                endSide: [pointFrom(endMinX, endMinY), pointFrom(endMinX, endMaxY)],
                length: endMinX - startMaxX,
                overlap: rangeIntersection(
                  rangeInclusive(startMinY, startMaxY),
                  rangeInclusive(endMinY, endMaxY)
                )
              });
            }
          }
        }
      const verticallySorted = referenceBounds.sort((a, b) => a[1] - b[1]);
      const verticalGaps = [];
      c = 0;
      vertical:
        for (let i = 0; i < verticallySorted.length; i++) {
          const startBounds = verticallySorted[i];
          for (let j = i + 1; j < verticallySorted.length; j++) {
            if (++c > VISIBLE_GAPS_LIMIT_PER_AXIS) {
              break vertical;
            }
            const endBounds = verticallySorted[j];
            const [startMinX, , startMaxX, startMaxY] = startBounds;
            const [endMinX, endMinY, endMaxX] = endBounds;
            if (startMaxY < endMinY && rangesOverlap(
              rangeInclusive(startMinX, startMaxX),
              rangeInclusive(endMinX, endMaxX)
            )) {
              verticalGaps.push({
                startBounds,
                endBounds,
                startSide: [
                  pointFrom(startMinX, startMaxY),
                  pointFrom(startMaxX, startMaxY)
                ],
                endSide: [pointFrom(endMinX, endMinY), pointFrom(endMaxX, endMinY)],
                length: endMinY - startMaxY,
                overlap: rangeIntersection(
                  rangeInclusive(startMinX, startMaxX),
                  rangeInclusive(endMinX, endMaxX)
                )
              });
            }
          }
        }
      return {
        horizontalGaps,
        verticalGaps
      };
    };
    getGapSnaps = (selectedElements, dragOffset, app, event, nearestSnapsX, nearestSnapsY, minOffset) => {
      if (!isSnappingEnabled({ app, event, selectedElements })) {
        return [];
      }
      if (selectedElements.length === 0) {
        return [];
      }
      const visibleGaps = SnapCache.getVisibleGaps();
      if (visibleGaps) {
        const { horizontalGaps, verticalGaps } = visibleGaps;
        const [minX, minY, maxX, maxY] = getDraggedElementsBounds(
          selectedElements,
          dragOffset
        ).map((bound) => round2(bound));
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        for (const gap of horizontalGaps) {
          if (!rangesOverlap(rangeInclusive(minY, maxY), gap.overlap)) {
            continue;
          }
          const gapMidX = gap.startSide[0][0] + gap.length / 2;
          const centerOffset = round2(gapMidX - centerX);
          const gapIsLargerThanSelection = gap.length > maxX - minX;
          if (gapIsLargerThanSelection && Math.abs(centerOffset) <= minOffset.x) {
            if (Math.abs(centerOffset) < minOffset.x) {
              nearestSnapsX.length = 0;
            }
            minOffset.x = Math.abs(centerOffset);
            const snap = {
              type: "gap",
              direction: "center_horizontal",
              gap,
              offset: centerOffset
            };
            nearestSnapsX.push(snap);
            continue;
          }
          const [, , endMaxX] = gap.endBounds;
          const distanceToEndElementX = minX - endMaxX;
          const sideOffsetRight = round2(gap.length - distanceToEndElementX);
          if (Math.abs(sideOffsetRight) <= minOffset.x) {
            if (Math.abs(sideOffsetRight) < minOffset.x) {
              nearestSnapsX.length = 0;
            }
            minOffset.x = Math.abs(sideOffsetRight);
            const snap = {
              type: "gap",
              direction: "side_right",
              gap,
              offset: sideOffsetRight
            };
            nearestSnapsX.push(snap);
            continue;
          }
          const [startMinX, , ,] = gap.startBounds;
          const distanceToStartElementX = startMinX - maxX;
          const sideOffsetLeft = round2(distanceToStartElementX - gap.length);
          if (Math.abs(sideOffsetLeft) <= minOffset.x) {
            if (Math.abs(sideOffsetLeft) < minOffset.x) {
              nearestSnapsX.length = 0;
            }
            minOffset.x = Math.abs(sideOffsetLeft);
            const snap = {
              type: "gap",
              direction: "side_left",
              gap,
              offset: sideOffsetLeft
            };
            nearestSnapsX.push(snap);
            continue;
          }
        }
        for (const gap of verticalGaps) {
          if (!rangesOverlap(rangeInclusive(minX, maxX), gap.overlap)) {
            continue;
          }
          const gapMidY = gap.startSide[0][1] + gap.length / 2;
          const centerOffset = round2(gapMidY - centerY);
          const gapIsLargerThanSelection = gap.length > maxY - minY;
          if (gapIsLargerThanSelection && Math.abs(centerOffset) <= minOffset.y) {
            if (Math.abs(centerOffset) < minOffset.y) {
              nearestSnapsY.length = 0;
            }
            minOffset.y = Math.abs(centerOffset);
            const snap = {
              type: "gap",
              direction: "center_vertical",
              gap,
              offset: centerOffset
            };
            nearestSnapsY.push(snap);
            continue;
          }
          const [, startMinY, ,] = gap.startBounds;
          const distanceToStartElementY = startMinY - maxY;
          const sideOffsetTop = round2(distanceToStartElementY - gap.length);
          if (Math.abs(sideOffsetTop) <= minOffset.y) {
            if (Math.abs(sideOffsetTop) < minOffset.y) {
              nearestSnapsY.length = 0;
            }
            minOffset.y = Math.abs(sideOffsetTop);
            const snap = {
              type: "gap",
              direction: "side_top",
              gap,
              offset: sideOffsetTop
            };
            nearestSnapsY.push(snap);
            continue;
          }
          const [, , , endMaxY] = gap.endBounds;
          const distanceToEndElementY = round2(minY - endMaxY);
          const sideOffsetBottom = gap.length - distanceToEndElementY;
          if (Math.abs(sideOffsetBottom) <= minOffset.y) {
            if (Math.abs(sideOffsetBottom) < minOffset.y) {
              nearestSnapsY.length = 0;
            }
            minOffset.y = Math.abs(sideOffsetBottom);
            const snap = {
              type: "gap",
              direction: "side_bottom",
              gap,
              offset: sideOffsetBottom
            };
            nearestSnapsY.push(snap);
            continue;
          }
        }
      }
    };
    getReferenceSnapPoints = (elements, selectedElements, appState, elementsMap) => {
      const referenceElements = getReferenceElements(
        elements,
        selectedElements,
        appState,
        elementsMap
      );
      return getMaximumGroups(referenceElements, elementsMap).filter(
        (elementsGroup) => !(elementsGroup.length === 1 && isBoundToContainer(elementsGroup[0]))
      ).flatMap((elementGroup) => getElementsCorners(elementGroup, elementsMap));
    };
    getPointSnaps = (selectedElements, selectionSnapPoints, app, event, nearestSnapsX, nearestSnapsY, minOffset) => {
      if (!isSnappingEnabled({ app, event, selectedElements }) || selectedElements.length === 0 && selectionSnapPoints.length === 0) {
        return [];
      }
      const referenceSnapPoints = SnapCache.getReferenceSnapPoints();
      if (referenceSnapPoints) {
        for (const thisSnapPoint of selectionSnapPoints) {
          for (const otherSnapPoint of referenceSnapPoints) {
            const offsetX = otherSnapPoint[0] - thisSnapPoint[0];
            const offsetY = otherSnapPoint[1] - thisSnapPoint[1];
            if (Math.abs(offsetX) <= minOffset.x) {
              if (Math.abs(offsetX) < minOffset.x) {
                nearestSnapsX.length = 0;
              }
              nearestSnapsX.push({
                type: "point",
                points: [thisSnapPoint, otherSnapPoint],
                offset: offsetX
              });
              minOffset.x = Math.abs(offsetX);
            }
            if (Math.abs(offsetY) <= minOffset.y) {
              if (Math.abs(offsetY) < minOffset.y) {
                nearestSnapsY.length = 0;
              }
              nearestSnapsY.push({
                type: "point",
                points: [thisSnapPoint, otherSnapPoint],
                offset: offsetY
              });
              minOffset.y = Math.abs(offsetY);
            }
          }
        }
      }
    };
    snapDraggedElements = (elements, dragOffset, app, event, elementsMap) => {
      const appState = app.state;
      const selectedElements = getSelectedElements(elements, appState);
      if (!isSnappingEnabled({ app, event, selectedElements }) || selectedElements.length === 0) {
        return {
          snapOffset: {
            x: 0,
            y: 0
          },
          snapLines: []
        };
      }
      dragOffset.x = round2(dragOffset.x);
      dragOffset.y = round2(dragOffset.y);
      const nearestSnapsX = [];
      const nearestSnapsY = [];
      const snapDistance = getSnapDistance(appState.zoom.value);
      const minOffset = {
        x: snapDistance,
        y: snapDistance
      };
      const selectionPoints = getElementsCorners(selectedElements, elementsMap, {
        dragOffset
      });
      getPointSnaps(
        selectedElements,
        selectionPoints,
        app,
        event,
        nearestSnapsX,
        nearestSnapsY,
        minOffset
      );
      getGapSnaps(
        selectedElements,
        dragOffset,
        app,
        event,
        nearestSnapsX,
        nearestSnapsY,
        minOffset
      );
      const snapOffset = {
        x: nearestSnapsX[0]?.offset ?? 0,
        y: nearestSnapsY[0]?.offset ?? 0
      };
      minOffset.x = 0;
      minOffset.y = 0;
      nearestSnapsX.length = 0;
      nearestSnapsY.length = 0;
      const newDragOffset = {
        x: round2(dragOffset.x + snapOffset.x),
        y: round2(dragOffset.y + snapOffset.y)
      };
      getPointSnaps(
        selectedElements,
        getElementsCorners(selectedElements, elementsMap, {
          dragOffset: newDragOffset
        }),
        app,
        event,
        nearestSnapsX,
        nearestSnapsY,
        minOffset
      );
      getGapSnaps(
        selectedElements,
        newDragOffset,
        app,
        event,
        nearestSnapsX,
        nearestSnapsY,
        minOffset
      );
      const pointSnapLines = createPointSnapLines(nearestSnapsX, nearestSnapsY);
      const gapSnapLines = createGapSnapLines(
        selectedElements,
        newDragOffset,
        [...nearestSnapsX, ...nearestSnapsY].filter(
          (snap) => snap.type === "gap"
        )
      );
      return {
        snapOffset,
        snapLines: [...pointSnapLines, ...gapSnapLines]
      };
    };
    round2 = (x) => {
      const decimalPlaces = 6;
      return Math.round(x * 10 ** decimalPlaces) / 10 ** decimalPlaces;
    };
    dedupePoints = (points) => {
      const map = /* @__PURE__ */ new Map();
      for (const point2 of points) {
        const key = point2.join(",");
        if (!map.has(key)) {
          map.set(key, point2);
        }
      }
      return Array.from(map.values());
    };
    createPointSnapLines = (nearestSnapsX, nearestSnapsY) => {
      const snapsX = {};
      const snapsY = {};
      if (nearestSnapsX.length > 0) {
        for (const snap of nearestSnapsX) {
          if (snap.type === "point") {
            const key = round2(snap.points[0][0]);
            if (!snapsX[key]) {
              snapsX[key] = [];
            }
            snapsX[key].push(
              ...snap.points.map(
                (p) => pointFrom(round2(p[0]), round2(p[1]))
              )
            );
          }
        }
      }
      if (nearestSnapsY.length > 0) {
        for (const snap of nearestSnapsY) {
          if (snap.type === "point") {
            const key = round2(snap.points[0][1]);
            if (!snapsY[key]) {
              snapsY[key] = [];
            }
            snapsY[key].push(
              ...snap.points.map(
                (p) => pointFrom(round2(p[0]), round2(p[1]))
              )
            );
          }
        }
      }
      return Object.entries(snapsX).map(([key, points]) => {
        return {
          type: "points",
          points: dedupePoints(
            points.map((p) => {
              return pointFrom(Number(key), p[1]);
            }).sort((a, b) => a[1] - b[1])
          )
        };
      }).concat(
        Object.entries(snapsY).map(([key, points]) => {
          return {
            type: "points",
            points: dedupePoints(
              points.map((p) => {
                return pointFrom(p[0], Number(key));
              }).sort((a, b) => a[0] - b[0])
            )
          };
        })
      );
    };
    dedupeGapSnapLines = (gapSnapLines) => {
      const map = /* @__PURE__ */ new Map();
      for (const gapSnapLine of gapSnapLines) {
        const key = gapSnapLine.points.flat().map((point2) => [round2(point2)]).join(",");
        if (!map.has(key)) {
          map.set(key, gapSnapLine);
        }
      }
      return Array.from(map.values());
    };
    createGapSnapLines = (selectedElements, dragOffset, gapSnaps) => {
      const [minX, minY, maxX, maxY] = getDraggedElementsBounds(
        selectedElements,
        dragOffset
      );
      const gapSnapLines = [];
      for (const gapSnap of gapSnaps) {
        const [startMinX, startMinY, startMaxX, startMaxY] = gapSnap.gap.startBounds;
        const [endMinX, endMinY, endMaxX, endMaxY] = gapSnap.gap.endBounds;
        const verticalIntersection = rangeIntersection(
          rangeInclusive(minY, maxY),
          gapSnap.gap.overlap
        );
        const horizontalGapIntersection = rangeIntersection(
          rangeInclusive(minX, maxX),
          gapSnap.gap.overlap
        );
        switch (gapSnap.direction) {
          case "center_horizontal": {
            if (verticalIntersection) {
              const gapLineY = (verticalIntersection[0] + verticalIntersection[1]) / 2;
              gapSnapLines.push(
                {
                  type: "gap",
                  direction: "horizontal",
                  points: [
                    pointFrom(gapSnap.gap.startSide[0][0], gapLineY),
                    pointFrom(minX, gapLineY)
                  ]
                },
                {
                  type: "gap",
                  direction: "horizontal",
                  points: [
                    pointFrom(maxX, gapLineY),
                    pointFrom(gapSnap.gap.endSide[0][0], gapLineY)
                  ]
                }
              );
            }
            break;
          }
          case "center_vertical": {
            if (horizontalGapIntersection) {
              const gapLineX = (horizontalGapIntersection[0] + horizontalGapIntersection[1]) / 2;
              gapSnapLines.push(
                {
                  type: "gap",
                  direction: "vertical",
                  points: [
                    pointFrom(gapLineX, gapSnap.gap.startSide[0][1]),
                    pointFrom(gapLineX, minY)
                  ]
                },
                {
                  type: "gap",
                  direction: "vertical",
                  points: [
                    pointFrom(gapLineX, maxY),
                    pointFrom(gapLineX, gapSnap.gap.endSide[0][1])
                  ]
                }
              );
            }
            break;
          }
          case "side_right": {
            if (verticalIntersection) {
              const gapLineY = (verticalIntersection[0] + verticalIntersection[1]) / 2;
              gapSnapLines.push(
                {
                  type: "gap",
                  direction: "horizontal",
                  points: [
                    pointFrom(startMaxX, gapLineY),
                    pointFrom(endMinX, gapLineY)
                  ]
                },
                {
                  type: "gap",
                  direction: "horizontal",
                  points: [pointFrom(endMaxX, gapLineY), pointFrom(minX, gapLineY)]
                }
              );
            }
            break;
          }
          case "side_left": {
            if (verticalIntersection) {
              const gapLineY = (verticalIntersection[0] + verticalIntersection[1]) / 2;
              gapSnapLines.push(
                {
                  type: "gap",
                  direction: "horizontal",
                  points: [
                    pointFrom(maxX, gapLineY),
                    pointFrom(startMinX, gapLineY)
                  ]
                },
                {
                  type: "gap",
                  direction: "horizontal",
                  points: [
                    pointFrom(startMaxX, gapLineY),
                    pointFrom(endMinX, gapLineY)
                  ]
                }
              );
            }
            break;
          }
          case "side_top": {
            if (horizontalGapIntersection) {
              const gapLineX = (horizontalGapIntersection[0] + horizontalGapIntersection[1]) / 2;
              gapSnapLines.push(
                {
                  type: "gap",
                  direction: "vertical",
                  points: [
                    pointFrom(gapLineX, maxY),
                    pointFrom(gapLineX, startMinY)
                  ]
                },
                {
                  type: "gap",
                  direction: "vertical",
                  points: [
                    pointFrom(gapLineX, startMaxY),
                    pointFrom(gapLineX, endMinY)
                  ]
                }
              );
            }
            break;
          }
          case "side_bottom": {
            if (horizontalGapIntersection) {
              const gapLineX = (horizontalGapIntersection[0] + horizontalGapIntersection[1]) / 2;
              gapSnapLines.push(
                {
                  type: "gap",
                  direction: "vertical",
                  points: [
                    pointFrom(gapLineX, startMaxY),
                    pointFrom(gapLineX, endMinY)
                  ]
                },
                {
                  type: "gap",
                  direction: "vertical",
                  points: [pointFrom(gapLineX, endMaxY), pointFrom(gapLineX, minY)]
                }
              );
            }
            break;
          }
        }
      }
      return dedupeGapSnapLines(
        gapSnapLines.map((gapSnapLine) => {
          return {
            ...gapSnapLine,
            points: gapSnapLine.points.map(
              (p) => pointFrom(round2(p[0]), round2(p[1]))
            )
          };
        })
      );
    };
    snapResizingElements = (selectedElements, selectedOriginalElements, app, event, dragOffset, transformHandle) => {
      if (!isSnappingEnabled({ event, selectedElements, app }) || selectedElements.length === 0 || selectedElements.length === 1 && !areRoughlyEqual(selectedElements[0].angle, 0)) {
        return {
          snapOffset: { x: 0, y: 0 },
          snapLines: []
        };
      }
      let [minX, minY, maxX, maxY] = getCommonBounds(selectedOriginalElements);
      if (transformHandle) {
        if (transformHandle.includes("e")) {
          maxX += dragOffset.x;
        } else if (transformHandle.includes("w")) {
          minX += dragOffset.x;
        }
        if (transformHandle.includes("n")) {
          minY += dragOffset.y;
        } else if (transformHandle.includes("s")) {
          maxY += dragOffset.y;
        }
      }
      const selectionSnapPoints = [];
      if (transformHandle) {
        switch (transformHandle) {
          case "e": {
            selectionSnapPoints.push(pointFrom(maxX, minY), pointFrom(maxX, maxY));
            break;
          }
          case "w": {
            selectionSnapPoints.push(pointFrom(minX, minY), pointFrom(minX, maxY));
            break;
          }
          case "n": {
            selectionSnapPoints.push(pointFrom(minX, minY), pointFrom(maxX, minY));
            break;
          }
          case "s": {
            selectionSnapPoints.push(pointFrom(minX, maxY), pointFrom(maxX, maxY));
            break;
          }
          case "ne": {
            selectionSnapPoints.push(pointFrom(maxX, minY));
            break;
          }
          case "nw": {
            selectionSnapPoints.push(pointFrom(minX, minY));
            break;
          }
          case "se": {
            selectionSnapPoints.push(pointFrom(maxX, maxY));
            break;
          }
          case "sw": {
            selectionSnapPoints.push(pointFrom(minX, maxY));
            break;
          }
        }
      }
      const snapDistance = getSnapDistance(app.state.zoom.value);
      const minOffset = {
        x: snapDistance,
        y: snapDistance
      };
      const nearestSnapsX = [];
      const nearestSnapsY = [];
      getPointSnaps(
        selectedOriginalElements,
        selectionSnapPoints,
        app,
        event,
        nearestSnapsX,
        nearestSnapsY,
        minOffset
      );
      const snapOffset = {
        x: nearestSnapsX[0]?.offset ?? 0,
        y: nearestSnapsY[0]?.offset ?? 0
      };
      minOffset.x = 0;
      minOffset.y = 0;
      nearestSnapsX.length = 0;
      nearestSnapsY.length = 0;
      const [x1, y1, x2, y2] = getCommonBounds(selectedElements).map(
        (bound) => round2(bound)
      );
      const corners = [
        pointFrom(x1, y1),
        pointFrom(x1, y2),
        pointFrom(x2, y1),
        pointFrom(x2, y2)
      ];
      getPointSnaps(
        selectedElements,
        corners,
        app,
        event,
        nearestSnapsX,
        nearestSnapsY,
        minOffset
      );
      const pointSnapLines = createPointSnapLines(nearestSnapsX, nearestSnapsY);
      return {
        snapOffset,
        snapLines: pointSnapLines
      };
    };
    snapNewElement = (newElement2, app, event, origin, dragOffset, elementsMap) => {
      if (!isSnappingEnabled({ event, selectedElements: [newElement2], app })) {
        return {
          snapOffset: { x: 0, y: 0 },
          snapLines: []
        };
      }
      const selectionSnapPoints = [
        pointFrom(origin.x + dragOffset.x, origin.y + dragOffset.y)
      ];
      const snapDistance = getSnapDistance(app.state.zoom.value);
      const minOffset = {
        x: snapDistance,
        y: snapDistance
      };
      const nearestSnapsX = [];
      const nearestSnapsY = [];
      getPointSnaps(
        [newElement2],
        selectionSnapPoints,
        app,
        event,
        nearestSnapsX,
        nearestSnapsY,
        minOffset
      );
      const snapOffset = {
        x: nearestSnapsX[0]?.offset ?? 0,
        y: nearestSnapsY[0]?.offset ?? 0
      };
      minOffset.x = 0;
      minOffset.y = 0;
      nearestSnapsX.length = 0;
      nearestSnapsY.length = 0;
      const corners = getElementsCorners([newElement2], elementsMap, {
        boundingBoxCorners: true,
        omitCenter: true
      });
      getPointSnaps(
        [newElement2],
        corners,
        app,
        event,
        nearestSnapsX,
        nearestSnapsY,
        minOffset
      );
      const pointSnapLines = createPointSnapLines(nearestSnapsX, nearestSnapsY);
      return {
        snapOffset,
        snapLines: pointSnapLines
      };
    };
    getSnapLinesAtPointer = (elements, app, pointer, event, elementsMap) => {
      if (!isSnappingEnabled({ event, selectedElements: [], app })) {
        return {
          originOffset: { x: 0, y: 0 },
          snapLines: []
        };
      }
      const referenceElements = getVisibleAndNonSelectedElements(
        elements,
        [],
        app.state,
        elementsMap
      );
      const snapDistance = getSnapDistance(app.state.zoom.value);
      const minOffset = {
        x: snapDistance,
        y: snapDistance
      };
      const horizontalSnapLines = [];
      const verticalSnapLines = [];
      for (const referenceElement of referenceElements) {
        const corners = getElementsCorners([referenceElement], elementsMap);
        for (const corner of corners) {
          const offsetX = corner[0] - pointer.x;
          if (Math.abs(offsetX) <= Math.abs(minOffset.x)) {
            if (Math.abs(offsetX) < Math.abs(minOffset.x)) {
              verticalSnapLines.length = 0;
            }
            verticalSnapLines.push({
              type: "pointer",
              points: [corner, pointFrom(corner[0], pointer.y)],
              direction: "vertical"
            });
            minOffset.x = offsetX;
          }
          const offsetY = corner[1] - pointer.y;
          if (Math.abs(offsetY) <= Math.abs(minOffset.y)) {
            if (Math.abs(offsetY) < Math.abs(minOffset.y)) {
              horizontalSnapLines.length = 0;
            }
            horizontalSnapLines.push({
              type: "pointer",
              points: [corner, pointFrom(pointer.x, corner[1])],
              direction: "horizontal"
            });
            minOffset.y = offsetY;
          }
        }
      }
      return {
        originOffset: {
          x: verticalSnapLines.length > 0 ? verticalSnapLines[0].points[0][0] - pointer.x : 0,
          y: horizontalSnapLines.length > 0 ? horizontalSnapLines[0].points[0][1] - pointer.y : 0
        },
        snapLines: [...verticalSnapLines, ...horizontalSnapLines]
      };
    };
    isActiveToolNonLinearSnappable = (activeToolType) => {
      return activeToolType === TOOL_TYPE.rectangle || activeToolType === TOOL_TYPE.ellipse || activeToolType === TOOL_TYPE.diamond || activeToolType === TOOL_TYPE.frame || activeToolType === TOOL_TYPE.magicframe || activeToolType === TOOL_TYPE.image || activeToolType === TOOL_TYPE.text;
    };
    getGridPoint = (x, y, gridSize) => {
      if (gridSize) {
        return [
          Math.round(x / gridSize) * gridSize,
          Math.round(y / gridSize) * gridSize
        ];
      }
      return [x, y];
    };
  }
});

// element/linearElementEditor.ts
var editorMidPointsCache, LinearElementEditor, normalizeSelectedPoints;
var init_linearElementEditor = __esm({
  "element/linearElementEditor.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_element();
    init_bounds();
    init_mutateElement();
    init_binding();
    init_utils2();
    init_typeChecks();
    init_keys();
    init_textElement();
    init_constants();
    init_ShapeCache();
    init_routing();
    init_math();
    init_shapes();
    init_snapping();
    editorMidPointsCache = { version: null, points: [], zoom: null };
    LinearElementEditor = class _LinearElementEditor {
      elementId;
      /** indices */
      selectedPointsIndices;
      pointerDownState;
      /** whether you're dragging a point */
      isDragging;
      lastUncommittedPoint;
      pointerOffset;
      startBindingElement;
      endBindingElement;
      hoverPointIndex;
      segmentMidPointHoveredCoords;
      elbowed;
      constructor(element) {
        this.elementId = element.id;
        if (!pointsEqual(element.points[0], pointFrom(0, 0))) {
          console.error("Linear element is not normalized", Error().stack);
        }
        this.selectedPointsIndices = null;
        this.lastUncommittedPoint = null;
        this.isDragging = false;
        this.pointerOffset = { x: 0, y: 0 };
        this.startBindingElement = "keep";
        this.endBindingElement = "keep";
        this.pointerDownState = {
          prevSelectedPointsIndices: null,
          lastClickedPoint: -1,
          lastClickedIsEndPoint: false,
          origin: null,
          segmentMidpoint: {
            value: null,
            index: null,
            added: false
          }
        };
        this.hoverPointIndex = -1;
        this.segmentMidPointHoveredCoords = null;
        this.elbowed = isElbowArrow(element) && element.elbowed;
      }
      // ---------------------------------------------------------------------------
      // static methods
      // ---------------------------------------------------------------------------
      static POINT_HANDLE_SIZE = 10;
      /**
       * @param id the `elementId` from the instance of this class (so that we can
       *  statically guarantee this method returns an ExcalidrawLinearElement)
       */
      static getElement(id, elementsMap) {
        const element = elementsMap.get(id);
        if (element) {
          return element;
        }
        return null;
      }
      static handleBoxSelection(event, appState, setState, elementsMap) {
        if (!appState.editingLinearElement || !appState.selectionElement) {
          return false;
        }
        const { editingLinearElement } = appState;
        const { selectedPointsIndices, elementId } = editingLinearElement;
        const element = _LinearElementEditor.getElement(elementId, elementsMap);
        if (!element) {
          return false;
        }
        const [selectionX1, selectionY1, selectionX2, selectionY2] = getElementAbsoluteCoords(appState.selectionElement, elementsMap);
        const pointsSceneCoords = _LinearElementEditor.getPointsGlobalCoordinates(
          element,
          elementsMap
        );
        const nextSelectedPoints = pointsSceneCoords.reduce((acc, point2, index) => {
          if (point2[0] >= selectionX1 && point2[0] <= selectionX2 && point2[1] >= selectionY1 && point2[1] <= selectionY2 || event.shiftKey && selectedPointsIndices?.includes(index)) {
            acc.push(index);
          }
          return acc;
        }, []).filter((index) => {
          if (isElbowArrow(element) && index !== 0 && index !== element.points.length - 1) {
            return false;
          }
          return true;
        });
        setState({
          editingLinearElement: {
            ...editingLinearElement,
            selectedPointsIndices: nextSelectedPoints.length ? nextSelectedPoints : null
          }
        });
      }
      /** @returns whether point was dragged */
      static handlePointDragging(event, app, scenePointerX, scenePointerY, maybeSuggestBinding, linearElementEditor, scene) {
        if (!linearElementEditor) {
          return false;
        }
        const { elementId } = linearElementEditor;
        const elementsMap = scene.getNonDeletedElementsMap();
        const element = _LinearElementEditor.getElement(elementId, elementsMap);
        if (!element) {
          return false;
        }
        if (isElbowArrow(element) && !linearElementEditor.pointerDownState.lastClickedIsEndPoint && linearElementEditor.pointerDownState.lastClickedPoint !== 0) {
          return false;
        }
        const selectedPointsIndices = isElbowArrow(element) ? linearElementEditor.selectedPointsIndices?.reduce(
          (startEnd, index) => index === 0 ? [0, startEnd[1]] : [startEnd[0], element.points.length - 1],
          [false, false]
        ).filter(
          (idx) => typeof idx === "number"
        ) : linearElementEditor.selectedPointsIndices;
        const lastClickedPoint = isElbowArrow(element) ? linearElementEditor.pointerDownState.lastClickedPoint > 0 ? element.points.length - 1 : 0 : linearElementEditor.pointerDownState.lastClickedPoint;
        const draggingPoint = element.points[lastClickedPoint];
        if (selectedPointsIndices && draggingPoint) {
          if (shouldRotateWithDiscreteAngle(event) && selectedPointsIndices.length === 1 && element.points.length > 1) {
            const selectedIndex = selectedPointsIndices[0];
            const referencePoint = element.points[selectedIndex === 0 ? 1 : selectedIndex - 1];
            const [width, height] = _LinearElementEditor._getShiftLockedDelta(
              element,
              elementsMap,
              referencePoint,
              pointFrom(scenePointerX, scenePointerY),
              event[KEYS.CTRL_OR_CMD] ? null : app.getEffectiveGridSize()
            );
            _LinearElementEditor.movePoints(
              element,
              [
                {
                  index: selectedIndex,
                  point: pointFrom(
                    width + referencePoint[0],
                    height + referencePoint[1]
                  ),
                  isDragging: selectedIndex === lastClickedPoint
                }
              ],
              elementsMap
            );
          } else {
            const newDraggingPointPosition = _LinearElementEditor.createPointAt(
              element,
              elementsMap,
              scenePointerX - linearElementEditor.pointerOffset.x,
              scenePointerY - linearElementEditor.pointerOffset.y,
              event[KEYS.CTRL_OR_CMD] ? null : app.getEffectiveGridSize()
            );
            const deltaX = newDraggingPointPosition[0] - draggingPoint[0];
            const deltaY = newDraggingPointPosition[1] - draggingPoint[1];
            _LinearElementEditor.movePoints(
              element,
              selectedPointsIndices.map((pointIndex) => {
                const newPointPosition = pointIndex === lastClickedPoint ? _LinearElementEditor.createPointAt(
                  element,
                  elementsMap,
                  scenePointerX - linearElementEditor.pointerOffset.x,
                  scenePointerY - linearElementEditor.pointerOffset.y,
                  event[KEYS.CTRL_OR_CMD] ? null : app.getEffectiveGridSize()
                ) : pointFrom(
                  element.points[pointIndex][0] + deltaX,
                  element.points[pointIndex][1] + deltaY
                );
                return {
                  index: pointIndex,
                  point: newPointPosition,
                  isDragging: pointIndex === lastClickedPoint
                };
              }),
              elementsMap
            );
          }
          const boundTextElement = getBoundTextElement(element, elementsMap);
          if (boundTextElement) {
            handleBindTextResize(element, elementsMap, false);
          }
          if (isBindingElement(element, false)) {
            const coords = [];
            const firstSelectedIndex = selectedPointsIndices[0];
            if (firstSelectedIndex === 0) {
              coords.push(
                tupleToCoors(
                  _LinearElementEditor.getPointGlobalCoordinates(
                    element,
                    element.points[0],
                    elementsMap
                  )
                )
              );
            }
            const lastSelectedIndex = selectedPointsIndices[selectedPointsIndices.length - 1];
            if (lastSelectedIndex === element.points.length - 1) {
              coords.push(
                tupleToCoors(
                  _LinearElementEditor.getPointGlobalCoordinates(
                    element,
                    element.points[lastSelectedIndex],
                    elementsMap
                  )
                )
              );
            }
            if (coords.length) {
              maybeSuggestBinding(element, coords);
            }
          }
          return true;
        }
        return false;
      }
      static handlePointerUp(event, editingLinearElement, appState, scene) {
        const elementsMap = scene.getNonDeletedElementsMap();
        const elements = scene.getNonDeletedElements();
        const { elementId, selectedPointsIndices, isDragging, pointerDownState } = editingLinearElement;
        const element = _LinearElementEditor.getElement(elementId, elementsMap);
        if (!element) {
          return editingLinearElement;
        }
        const bindings = {};
        if (isDragging && selectedPointsIndices) {
          for (const selectedPoint of selectedPointsIndices) {
            if (selectedPoint === 0 || selectedPoint === element.points.length - 1) {
              if (isPathALoop(element.points, appState.zoom.value)) {
                _LinearElementEditor.movePoints(
                  element,
                  [
                    {
                      index: selectedPoint,
                      point: selectedPoint === 0 ? element.points[element.points.length - 1] : element.points[0]
                    }
                  ],
                  elementsMap
                );
              }
              const bindingElement = isBindingEnabled(appState) ? getHoveredElementForBinding(
                tupleToCoors(
                  _LinearElementEditor.getPointAtIndexGlobalCoordinates(
                    element,
                    selectedPoint,
                    elementsMap
                  )
                ),
                elements,
                elementsMap
              ) : null;
              bindings[selectedPoint === 0 ? "startBindingElement" : "endBindingElement"] = bindingElement;
            }
          }
        }
        return {
          ...editingLinearElement,
          ...bindings,
          // if clicking without previously dragging a point(s), and not holding
          // shift, deselect all points except the one clicked. If holding shift,
          // toggle the point.
          selectedPointsIndices: isDragging || event.shiftKey ? !isDragging && event.shiftKey && pointerDownState.prevSelectedPointsIndices?.includes(
            pointerDownState.lastClickedPoint
          ) ? selectedPointsIndices && selectedPointsIndices.filter(
            (pointIndex) => pointIndex !== pointerDownState.lastClickedPoint
          ) : selectedPointsIndices : selectedPointsIndices?.includes(pointerDownState.lastClickedPoint) ? [pointerDownState.lastClickedPoint] : selectedPointsIndices,
          isDragging: false,
          pointerOffset: { x: 0, y: 0 }
        };
      }
      static getEditorMidPoints = (element, elementsMap, appState) => {
        const boundText = getBoundTextElement(element, elementsMap);
        if (!appState.editingLinearElement && element.points.length > 2 && !boundText) {
          return [];
        }
        if (editorMidPointsCache.version === element.version && editorMidPointsCache.zoom === appState.zoom.value) {
          return editorMidPointsCache.points;
        }
        _LinearElementEditor.updateEditorMidPointsCache(
          element,
          elementsMap,
          appState
        );
        return editorMidPointsCache.points;
      };
      static updateEditorMidPointsCache = (element, elementsMap, appState) => {
        const points = _LinearElementEditor.getPointsGlobalCoordinates(
          element,
          elementsMap
        );
        let index = 0;
        const midpoints = [];
        while (index < points.length - 1) {
          if (_LinearElementEditor.isSegmentTooShort(
            element,
            element.points[index],
            element.points[index + 1],
            appState.zoom
          )) {
            midpoints.push(null);
            index++;
            continue;
          }
          const segmentMidPoint = _LinearElementEditor.getSegmentMidPoint(
            element,
            points[index],
            points[index + 1],
            index + 1,
            elementsMap
          );
          midpoints.push(segmentMidPoint);
          index++;
        }
        editorMidPointsCache.points = midpoints;
        editorMidPointsCache.version = element.version;
        editorMidPointsCache.zoom = appState.zoom.value;
      };
      static getSegmentMidpointHitCoords = (linearElementEditor, scenePointer, appState, elementsMap) => {
        const { elementId } = linearElementEditor;
        const element = _LinearElementEditor.getElement(elementId, elementsMap);
        if (!element) {
          return null;
        }
        const clickedPointIndex = _LinearElementEditor.getPointIndexUnderCursor(
          element,
          elementsMap,
          appState.zoom,
          scenePointer.x,
          scenePointer.y
        );
        if (clickedPointIndex >= 0) {
          return null;
        }
        const points = _LinearElementEditor.getPointsGlobalCoordinates(
          element,
          elementsMap
        );
        if (points.length >= 3 && !appState.editingLinearElement) {
          return null;
        }
        const threshold = _LinearElementEditor.POINT_HANDLE_SIZE / appState.zoom.value;
        const existingSegmentMidpointHitCoords = linearElementEditor.segmentMidPointHoveredCoords;
        if (existingSegmentMidpointHitCoords) {
          const distance3 = pointDistance(
            pointFrom(
              existingSegmentMidpointHitCoords[0],
              existingSegmentMidpointHitCoords[1]
            ),
            pointFrom(scenePointer.x, scenePointer.y)
          );
          if (distance3 <= threshold) {
            return existingSegmentMidpointHitCoords;
          }
        }
        let index = 0;
        const midPoints = _LinearElementEditor.getEditorMidPoints(element, elementsMap, appState);
        while (index < midPoints.length) {
          if (midPoints[index] !== null) {
            const distance3 = pointDistance(
              pointFrom(midPoints[index][0], midPoints[index][1]),
              pointFrom(scenePointer.x, scenePointer.y)
            );
            if (distance3 <= threshold) {
              return midPoints[index];
            }
          }
          index++;
        }
        return null;
      };
      static isSegmentTooShort(element, startPoint, endPoint, zoom) {
        let distance3 = pointDistance(
          pointFrom(startPoint[0], startPoint[1]),
          pointFrom(endPoint[0], endPoint[1])
        );
        if (element.points.length > 2 && element.roundness) {
          distance3 = getBezierCurveLength(element, endPoint);
        }
        return distance3 * zoom.value < _LinearElementEditor.POINT_HANDLE_SIZE * 4;
      }
      static getSegmentMidPoint(element, startPoint, endPoint, endPointIndex, elementsMap) {
        let segmentMidPoint = pointCenter(startPoint, endPoint);
        if (element.points.length > 2 && element.roundness) {
          const controlPoints = getControlPointsForBezierCurve(
            element,
            element.points[endPointIndex]
          );
          if (controlPoints) {
            const t2 = mapIntervalToBezierT(
              element,
              element.points[endPointIndex],
              0.5
            );
            segmentMidPoint = _LinearElementEditor.getPointGlobalCoordinates(
              element,
              getBezierXY(
                controlPoints[0],
                controlPoints[1],
                controlPoints[2],
                controlPoints[3],
                t2
              ),
              elementsMap
            );
          }
        }
        return segmentMidPoint;
      }
      static getSegmentMidPointIndex(linearElementEditor, appState, midPoint, elementsMap) {
        const element = _LinearElementEditor.getElement(
          linearElementEditor.elementId,
          elementsMap
        );
        if (!element) {
          return -1;
        }
        const midPoints = _LinearElementEditor.getEditorMidPoints(
          element,
          elementsMap,
          appState
        );
        let index = 0;
        while (index < midPoints.length) {
          if (_LinearElementEditor.arePointsEqual(midPoint, midPoints[index])) {
            return index + 1;
          }
          index++;
        }
        return -1;
      }
      static handlePointerDown(event, app, store, scenePointer, linearElementEditor, scene) {
        const appState = app.state;
        const elementsMap = scene.getNonDeletedElementsMap();
        const elements = scene.getNonDeletedElements();
        const ret = {
          didAddPoint: false,
          hitElement: null,
          linearElementEditor: null
        };
        if (!linearElementEditor) {
          return ret;
        }
        const { elementId } = linearElementEditor;
        const element = _LinearElementEditor.getElement(elementId, elementsMap);
        if (!element) {
          return ret;
        }
        const segmentMidpoint = _LinearElementEditor.getSegmentMidpointHitCoords(
          linearElementEditor,
          scenePointer,
          appState,
          elementsMap
        );
        let segmentMidpointIndex = null;
        if (segmentMidpoint) {
          segmentMidpointIndex = _LinearElementEditor.getSegmentMidPointIndex(
            linearElementEditor,
            appState,
            segmentMidpoint,
            elementsMap
          );
        }
        if (event.altKey && appState.editingLinearElement) {
          if (linearElementEditor.lastUncommittedPoint == null && !isElbowArrow(element)) {
            mutateElement(element, {
              points: [
                ...element.points,
                _LinearElementEditor.createPointAt(
                  element,
                  elementsMap,
                  scenePointer.x,
                  scenePointer.y,
                  event[KEYS.CTRL_OR_CMD] ? null : app.getEffectiveGridSize()
                )
              ]
            });
            ret.didAddPoint = true;
          }
          store.shouldCaptureIncrement();
          ret.linearElementEditor = {
            ...linearElementEditor,
            pointerDownState: {
              prevSelectedPointsIndices: linearElementEditor.selectedPointsIndices,
              lastClickedPoint: -1,
              lastClickedIsEndPoint: false,
              origin: { x: scenePointer.x, y: scenePointer.y },
              segmentMidpoint: {
                value: segmentMidpoint,
                index: segmentMidpointIndex,
                added: false
              }
            },
            selectedPointsIndices: [element.points.length - 1],
            lastUncommittedPoint: null,
            endBindingElement: getHoveredElementForBinding(
              scenePointer,
              elements,
              elementsMap
            )
          };
          ret.didAddPoint = true;
          return ret;
        }
        const clickedPointIndex = _LinearElementEditor.getPointIndexUnderCursor(
          element,
          elementsMap,
          appState.zoom,
          scenePointer.x,
          scenePointer.y
        );
        if (clickedPointIndex >= 0 || segmentMidpoint) {
          ret.hitElement = element;
        } else {
          const { startBindingElement, endBindingElement } = linearElementEditor;
          if (isBindingEnabled(appState) && isBindingElement(element)) {
            bindOrUnbindLinearElement(
              element,
              startBindingElement,
              endBindingElement,
              elementsMap,
              scene
            );
          }
        }
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        const targetPoint = clickedPointIndex > -1 && pointRotateRads(
          pointFrom(
            element.x + element.points[clickedPointIndex][0],
            element.y + element.points[clickedPointIndex][1]
          ),
          pointFrom(cx, cy),
          element.angle
        );
        const nextSelectedPointsIndices = clickedPointIndex > -1 || event.shiftKey ? event.shiftKey || linearElementEditor.selectedPointsIndices?.includes(clickedPointIndex) ? normalizeSelectedPoints([
          ...linearElementEditor.selectedPointsIndices || [],
          clickedPointIndex
        ]) : [clickedPointIndex] : null;
        ret.linearElementEditor = {
          ...linearElementEditor,
          pointerDownState: {
            prevSelectedPointsIndices: linearElementEditor.selectedPointsIndices,
            lastClickedPoint: clickedPointIndex,
            lastClickedIsEndPoint: clickedPointIndex === element.points.length - 1,
            origin: { x: scenePointer.x, y: scenePointer.y },
            segmentMidpoint: {
              value: segmentMidpoint,
              index: segmentMidpointIndex,
              added: false
            }
          },
          selectedPointsIndices: nextSelectedPointsIndices,
          pointerOffset: targetPoint ? {
            x: scenePointer.x - targetPoint[0],
            y: scenePointer.y - targetPoint[1]
          } : { x: 0, y: 0 }
        };
        return ret;
      }
      static arePointsEqual(point1, point2) {
        if (!point1 && !point2) {
          return true;
        }
        if (!point1 || !point2) {
          return false;
        }
        return pointsEqual(point1, point2);
      }
      static handlePointerMove(event, scenePointerX, scenePointerY, app, elementsMap) {
        const appState = app.state;
        if (!appState.editingLinearElement) {
          return null;
        }
        const { elementId, lastUncommittedPoint } = appState.editingLinearElement;
        const element = _LinearElementEditor.getElement(elementId, elementsMap);
        if (!element) {
          return appState.editingLinearElement;
        }
        const { points } = element;
        const lastPoint = points[points.length - 1];
        if (!event.altKey) {
          if (lastPoint === lastUncommittedPoint) {
            _LinearElementEditor.deletePoints(
              element,
              [points.length - 1],
              elementsMap
            );
          }
          return {
            ...appState.editingLinearElement,
            lastUncommittedPoint: null
          };
        }
        let newPoint;
        if (shouldRotateWithDiscreteAngle(event) && points.length >= 2) {
          const lastCommittedPoint = points[points.length - 2];
          const [width, height] = _LinearElementEditor._getShiftLockedDelta(
            element,
            elementsMap,
            lastCommittedPoint,
            pointFrom(scenePointerX, scenePointerY),
            event[KEYS.CTRL_OR_CMD] ? null : app.getEffectiveGridSize()
          );
          newPoint = pointFrom(
            width + lastCommittedPoint[0],
            height + lastCommittedPoint[1]
          );
        } else {
          newPoint = _LinearElementEditor.createPointAt(
            element,
            elementsMap,
            scenePointerX - appState.editingLinearElement.pointerOffset.x,
            scenePointerY - appState.editingLinearElement.pointerOffset.y,
            event[KEYS.CTRL_OR_CMD] || isElbowArrow(element) ? null : app.getEffectiveGridSize()
          );
        }
        if (lastPoint === lastUncommittedPoint) {
          _LinearElementEditor.movePoints(
            element,
            [
              {
                index: element.points.length - 1,
                point: newPoint
              }
            ],
            elementsMap
          );
        } else {
          _LinearElementEditor.addPoints(
            element,
            [{ point: newPoint }],
            elementsMap
          );
        }
        return {
          ...appState.editingLinearElement,
          lastUncommittedPoint: element.points[element.points.length - 1]
        };
      }
      /** scene coords */
      static getPointGlobalCoordinates(element, p, elementsMap) {
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        const { x, y } = element;
        return pointRotateRads(
          pointFrom(x + p[0], y + p[1]),
          pointFrom(cx, cy),
          element.angle
        );
      }
      /** scene coords */
      static getPointsGlobalCoordinates(element, elementsMap) {
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        return element.points.map((p) => {
          const { x, y } = element;
          return pointRotateRads(
            pointFrom(x + p[0], y + p[1]),
            pointFrom(cx, cy),
            element.angle
          );
        });
      }
      static getPointAtIndexGlobalCoordinates(element, indexMaybeFromEnd, elementsMap) {
        const index = indexMaybeFromEnd < 0 ? element.points.length + indexMaybeFromEnd : indexMaybeFromEnd;
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        const p = element.points[index];
        const { x, y } = element;
        return p ? pointRotateRads(
          pointFrom(x + p[0], y + p[1]),
          pointFrom(cx, cy),
          element.angle
        ) : pointRotateRads(pointFrom(x, y), pointFrom(cx, cy), element.angle);
      }
      static pointFromAbsoluteCoords(element, absoluteCoords, elementsMap) {
        if (isElbowArrow(element)) {
          return pointFrom(
            absoluteCoords[0] - element.x,
            absoluteCoords[1] - element.y
          );
        }
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        const [x, y] = pointRotateRads(
          pointFrom(absoluteCoords[0], absoluteCoords[1]),
          pointFrom(cx, cy),
          -element.angle
        );
        return pointFrom(x - element.x, y - element.y);
      }
      static getPointIndexUnderCursor(element, elementsMap, zoom, x, y) {
        const pointHandles = _LinearElementEditor.getPointsGlobalCoordinates(
          element,
          elementsMap
        );
        let idx = pointHandles.length;
        while (--idx > -1) {
          const p = pointHandles[idx];
          if (pointDistance(pointFrom(x, y), pointFrom(p[0], p[1])) * zoom.value < // +1px to account for outline stroke
          _LinearElementEditor.POINT_HANDLE_SIZE + 1) {
            return idx;
          }
        }
        return -1;
      }
      static createPointAt(element, elementsMap, scenePointerX, scenePointerY, gridSize) {
        const pointerOnGrid = getGridPoint(scenePointerX, scenePointerY, gridSize);
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        const [rotatedX, rotatedY] = pointRotateRads(
          pointFrom(pointerOnGrid[0], pointerOnGrid[1]),
          pointFrom(cx, cy),
          -element.angle
        );
        return pointFrom(rotatedX - element.x, rotatedY - element.y);
      }
      /**
       * Normalizes line points so that the start point is at [0,0]. This is
       * expected in various parts of the codebase. Also returns new x/y to account
       * for the potential normalization.
       */
      static getNormalizedPoints(element) {
        const { points } = element;
        const offsetX = points[0][0];
        const offsetY = points[0][1];
        return {
          points: points.map((p) => {
            return pointFrom(p[0] - offsetX, p[1] - offsetY);
          }),
          x: element.x + offsetX,
          y: element.y + offsetY
        };
      }
      // element-mutating methods
      // ---------------------------------------------------------------------------
      static normalizePoints(element) {
        mutateElement(element, _LinearElementEditor.getNormalizedPoints(element));
      }
      static duplicateSelectedPoints(appState, elementsMap) {
        invariant(
          appState.editingLinearElement,
          "Not currently editing a linear element"
        );
        const { selectedPointsIndices, elementId } = appState.editingLinearElement;
        const element = _LinearElementEditor.getElement(elementId, elementsMap);
        invariant(
          element,
          "The linear element does not exist in the provided Scene"
        );
        invariant(
          selectedPointsIndices != null,
          "There are no selected points to duplicate"
        );
        const { points } = element;
        const nextSelectedIndices = [];
        let pointAddedToEnd = false;
        let indexCursor = -1;
        const nextPoints = points.reduce((acc, p, index) => {
          ++indexCursor;
          acc.push(p);
          const isSelected = selectedPointsIndices.includes(index);
          if (isSelected) {
            const nextPoint = points[index + 1];
            if (!nextPoint) {
              pointAddedToEnd = true;
            }
            acc.push(
              nextPoint ? pointFrom((p[0] + nextPoint[0]) / 2, (p[1] + nextPoint[1]) / 2) : pointFrom(p[0], p[1])
            );
            nextSelectedIndices.push(indexCursor + 1);
            ++indexCursor;
          }
          return acc;
        }, []);
        mutateElement(element, { points: nextPoints });
        if (pointAddedToEnd) {
          const lastPoint = element.points[element.points.length - 1];
          _LinearElementEditor.movePoints(
            element,
            [
              {
                index: element.points.length - 1,
                point: pointFrom(lastPoint[0] + 30, lastPoint[1] + 30)
              }
            ],
            elementsMap
          );
        }
        return {
          ...appState,
          editingLinearElement: {
            ...appState.editingLinearElement,
            selectedPointsIndices: nextSelectedIndices
          }
        };
      }
      static deletePoints(element, pointIndices, elementsMap) {
        let offsetX = 0;
        let offsetY = 0;
        const isDeletingOriginPoint = pointIndices.includes(0);
        if (isDeletingOriginPoint) {
          const firstNonDeletedPoint = element.points.find((point2, idx) => {
            return !pointIndices.includes(idx);
          });
          if (firstNonDeletedPoint) {
            offsetX = firstNonDeletedPoint[0];
            offsetY = firstNonDeletedPoint[1];
          }
        }
        const nextPoints = element.points.reduce((acc, p, idx) => {
          if (!pointIndices.includes(idx)) {
            acc.push(
              !acc.length ? pointFrom(0, 0) : pointFrom(p[0] - offsetX, p[1] - offsetY)
            );
          }
          return acc;
        }, []);
        _LinearElementEditor._updatePoints(
          element,
          nextPoints,
          offsetX,
          offsetY,
          elementsMap
        );
      }
      static addPoints(element, targetPoints, elementsMap) {
        const offsetX = 0;
        const offsetY = 0;
        const nextPoints = [...element.points, ...targetPoints.map((x) => x.point)];
        _LinearElementEditor._updatePoints(
          element,
          nextPoints,
          offsetX,
          offsetY,
          elementsMap
        );
      }
      static movePoints(element, targetPoints, elementsMap, otherUpdates, options) {
        const { points } = element;
        let offsetX = 0;
        let offsetY = 0;
        const selectedOriginPoint = targetPoints.find(({ index }) => index === 0);
        if (selectedOriginPoint) {
          offsetX = selectedOriginPoint.point[0] + points[selectedOriginPoint.index][0];
          offsetY = selectedOriginPoint.point[1] + points[selectedOriginPoint.index][1];
        }
        const nextPoints = points.map((p, idx) => {
          const selectedPointData = targetPoints.find((t2) => t2.index === idx);
          if (selectedPointData) {
            if (selectedPointData.index === 0) {
              return p;
            }
            const deltaX = selectedPointData.point[0] - points[selectedPointData.index][0];
            const deltaY = selectedPointData.point[1] - points[selectedPointData.index][1];
            return pointFrom(p[0] + deltaX - offsetX, p[1] + deltaY - offsetY);
          }
          return offsetX || offsetY ? pointFrom(p[0] - offsetX, p[1] - offsetY) : p;
        });
        _LinearElementEditor._updatePoints(
          element,
          nextPoints,
          offsetX,
          offsetY,
          elementsMap,
          otherUpdates,
          {
            isDragging: targetPoints.reduce(
              (dragging, targetPoint) => dragging || targetPoint.isDragging === true,
              false
            ),
            changedElements: options?.changedElements
          }
        );
      }
      static shouldAddMidpoint(linearElementEditor, pointerCoords, appState, elementsMap) {
        const element = _LinearElementEditor.getElement(
          linearElementEditor.elementId,
          elementsMap
        );
        if (element && isElbowArrow(element)) {
          return false;
        }
        if (!element) {
          return false;
        }
        const { segmentMidpoint } = linearElementEditor.pointerDownState;
        if (segmentMidpoint.added || segmentMidpoint.value === null || segmentMidpoint.index === null || linearElementEditor.pointerDownState.origin === null) {
          return false;
        }
        const origin = linearElementEditor.pointerDownState.origin;
        const dist = pointDistance(
          pointFrom(origin.x, origin.y),
          pointFrom(pointerCoords.x, pointerCoords.y)
        );
        if (!appState.editingLinearElement && dist < DRAGGING_THRESHOLD / appState.zoom.value) {
          return false;
        }
        return true;
      }
      static addMidpoint(linearElementEditor, pointerCoords, app, snapToGrid, elementsMap) {
        const element = _LinearElementEditor.getElement(
          linearElementEditor.elementId,
          elementsMap
        );
        if (!element) {
          return;
        }
        const { segmentMidpoint } = linearElementEditor.pointerDownState;
        const ret = {
          pointerDownState: linearElementEditor.pointerDownState,
          selectedPointsIndices: linearElementEditor.selectedPointsIndices
        };
        const midpoint = _LinearElementEditor.createPointAt(
          element,
          elementsMap,
          pointerCoords.x,
          pointerCoords.y,
          snapToGrid && !isElbowArrow(element) ? app.getEffectiveGridSize() : null
        );
        const points = [
          ...element.points.slice(0, segmentMidpoint.index),
          midpoint,
          ...element.points.slice(segmentMidpoint.index)
        ];
        mutateElement(element, {
          points
        });
        ret.pointerDownState = {
          ...linearElementEditor.pointerDownState,
          segmentMidpoint: {
            ...linearElementEditor.pointerDownState.segmentMidpoint,
            added: true
          },
          lastClickedPoint: segmentMidpoint.index
        };
        ret.selectedPointsIndices = [segmentMidpoint.index];
        return ret;
      }
      static _updatePoints(element, nextPoints, offsetX, offsetY, elementsMap, otherUpdates, options) {
        if (isElbowArrow(element)) {
          const bindings = {};
          if (otherUpdates?.startBinding !== void 0) {
            bindings.startBinding = otherUpdates.startBinding !== null && isFixedPointBinding(otherUpdates.startBinding) ? otherUpdates.startBinding : null;
          }
          if (otherUpdates?.endBinding !== void 0) {
            bindings.endBinding = otherUpdates.endBinding !== null && isFixedPointBinding(otherUpdates.endBinding) ? otherUpdates.endBinding : null;
          }
          const mergedElementsMap = options?.changedElements ? toBrandedType(
            new Map([...elementsMap, ...options.changedElements])
          ) : elementsMap;
          mutateElbowArrow(
            element,
            mergedElementsMap,
            nextPoints,
            vector(offsetX, offsetY),
            bindings,
            {
              isDragging: options?.isDragging
            }
          );
        } else {
          const nextCoords = getElementPointsCoords(element, nextPoints);
          const prevCoords = getElementPointsCoords(element, element.points);
          const nextCenterX = (nextCoords[0] + nextCoords[2]) / 2;
          const nextCenterY = (nextCoords[1] + nextCoords[3]) / 2;
          const prevCenterX = (prevCoords[0] + prevCoords[2]) / 2;
          const prevCenterY = (prevCoords[1] + prevCoords[3]) / 2;
          const dX = prevCenterX - nextCenterX;
          const dY = prevCenterY - nextCenterY;
          const rotated = pointRotateRads(
            pointFrom(offsetX, offsetY),
            pointFrom(dX, dY),
            element.angle
          );
          mutateElement(element, {
            ...otherUpdates,
            points: nextPoints,
            x: element.x + rotated[0],
            y: element.y + rotated[1]
          });
        }
      }
      static _getShiftLockedDelta(element, elementsMap, referencePoint, scenePointer, gridSize) {
        const referencePointCoords = _LinearElementEditor.getPointGlobalCoordinates(
          element,
          referencePoint,
          elementsMap
        );
        if (isElbowArrow(element)) {
          return [
            scenePointer[0] - referencePointCoords[0],
            scenePointer[1] - referencePointCoords[1]
          ];
        }
        const [gridX, gridY] = getGridPoint(
          scenePointer[0],
          scenePointer[1],
          gridSize
        );
        const { width, height } = getLockedLinearCursorAlignSize(
          referencePointCoords[0],
          referencePointCoords[1],
          gridX,
          gridY
        );
        return pointRotateRads(
          pointFrom(width, height),
          pointFrom(0, 0),
          -element.angle
        );
      }
      static getBoundTextElementPosition = (element, boundTextElement, elementsMap) => {
        const points = _LinearElementEditor.getPointsGlobalCoordinates(
          element,
          elementsMap
        );
        if (points.length < 2) {
          mutateElement(boundTextElement, { isDeleted: true });
        }
        let x = 0;
        let y = 0;
        if (element.points.length % 2 === 1) {
          const index = Math.floor(element.points.length / 2);
          const midPoint = _LinearElementEditor.getPointGlobalCoordinates(
            element,
            element.points[index],
            elementsMap
          );
          x = midPoint[0] - boundTextElement.width / 2;
          y = midPoint[1] - boundTextElement.height / 2;
        } else {
          const index = element.points.length / 2 - 1;
          let midSegmentMidpoint = editorMidPointsCache.points[index];
          if (element.points.length === 2) {
            midSegmentMidpoint = pointCenter(points[0], points[1]);
          }
          if (!midSegmentMidpoint || editorMidPointsCache.version !== element.version) {
            midSegmentMidpoint = _LinearElementEditor.getSegmentMidPoint(
              element,
              points[index],
              points[index + 1],
              index + 1,
              elementsMap
            );
          }
          x = midSegmentMidpoint[0] - boundTextElement.width / 2;
          y = midSegmentMidpoint[1] - boundTextElement.height / 2;
        }
        return { x, y };
      };
      static getMinMaxXYWithBoundText = (element, elementsMap, elementBounds, boundTextElement) => {
        let [x1, y1, x2, y2] = elementBounds;
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        const { x: boundTextX1, y: boundTextY1 } = _LinearElementEditor.getBoundTextElementPosition(
          element,
          boundTextElement,
          elementsMap
        );
        const boundTextX2 = boundTextX1 + boundTextElement.width;
        const boundTextY2 = boundTextY1 + boundTextElement.height;
        const centerPoint = pointFrom(cx, cy);
        const topLeftRotatedPoint = pointRotateRads(
          pointFrom(x1, y1),
          centerPoint,
          element.angle
        );
        const topRightRotatedPoint = pointRotateRads(
          pointFrom(x2, y1),
          centerPoint,
          element.angle
        );
        const counterRotateBoundTextTopLeft = pointRotateRads(
          pointFrom(boundTextX1, boundTextY1),
          centerPoint,
          -element.angle
        );
        const counterRotateBoundTextTopRight = pointRotateRads(
          pointFrom(boundTextX2, boundTextY1),
          centerPoint,
          -element.angle
        );
        const counterRotateBoundTextBottomLeft = pointRotateRads(
          pointFrom(boundTextX1, boundTextY2),
          centerPoint,
          -element.angle
        );
        const counterRotateBoundTextBottomRight = pointRotateRads(
          pointFrom(boundTextX2, boundTextY2),
          centerPoint,
          -element.angle
        );
        if (topLeftRotatedPoint[0] < topRightRotatedPoint[0] && topLeftRotatedPoint[1] >= topRightRotatedPoint[1]) {
          x1 = Math.min(x1, counterRotateBoundTextBottomLeft[0]);
          x2 = Math.max(
            x2,
            Math.max(
              counterRotateBoundTextTopRight[0],
              counterRotateBoundTextBottomRight[0]
            )
          );
          y1 = Math.min(y1, counterRotateBoundTextTopLeft[1]);
          y2 = Math.max(y2, counterRotateBoundTextBottomRight[1]);
        } else if (topLeftRotatedPoint[0] >= topRightRotatedPoint[0] && topLeftRotatedPoint[1] > topRightRotatedPoint[1]) {
          x1 = Math.min(x1, counterRotateBoundTextBottomRight[0]);
          x2 = Math.max(
            x2,
            Math.max(
              counterRotateBoundTextTopLeft[0],
              counterRotateBoundTextTopRight[0]
            )
          );
          y1 = Math.min(y1, counterRotateBoundTextBottomLeft[1]);
          y2 = Math.max(y2, counterRotateBoundTextTopRight[1]);
        } else if (topLeftRotatedPoint[0] >= topRightRotatedPoint[0]) {
          x1 = Math.min(x1, counterRotateBoundTextTopRight[0]);
          x2 = Math.max(x2, counterRotateBoundTextBottomLeft[0]);
          y1 = Math.min(y1, counterRotateBoundTextBottomRight[1]);
          y2 = Math.max(y2, counterRotateBoundTextTopLeft[1]);
        } else if (topLeftRotatedPoint[1] <= topRightRotatedPoint[1]) {
          x1 = Math.min(
            x1,
            Math.min(
              counterRotateBoundTextTopRight[0],
              counterRotateBoundTextTopLeft[0]
            )
          );
          x2 = Math.max(x2, counterRotateBoundTextBottomRight[0]);
          y1 = Math.min(y1, counterRotateBoundTextTopRight[1]);
          y2 = Math.max(y2, counterRotateBoundTextBottomLeft[1]);
        }
        return [x1, y1, x2, y2, cx, cy];
      };
      static getElementAbsoluteCoords = (element, elementsMap, includeBoundText = false) => {
        let coords;
        let x1;
        let y1;
        let x2;
        let y2;
        if (element.points.length < 2 || !ShapeCache.get(element)) {
          const { minX, minY, maxX, maxY } = element.points.reduce(
            (limits, [x, y]) => {
              limits.minY = Math.min(limits.minY, y);
              limits.minX = Math.min(limits.minX, x);
              limits.maxX = Math.max(limits.maxX, x);
              limits.maxY = Math.max(limits.maxY, y);
              return limits;
            },
            { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity }
          );
          x1 = minX + element.x;
          y1 = minY + element.y;
          x2 = maxX + element.x;
          y2 = maxY + element.y;
        } else {
          const shape = ShapeCache.generateElementShape(element, null);
          const ops = getCurvePathOps2(shape[0]);
          const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);
          x1 = minX + element.x;
          y1 = minY + element.y;
          x2 = maxX + element.x;
          y2 = maxY + element.y;
        }
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        coords = [x1, y1, x2, y2, cx, cy];
        if (!includeBoundText) {
          return coords;
        }
        const boundTextElement = getBoundTextElement(element, elementsMap);
        if (boundTextElement) {
          coords = _LinearElementEditor.getMinMaxXYWithBoundText(
            element,
            elementsMap,
            [x1, y1, x2, y2],
            boundTextElement
          );
        }
        return coords;
      };
    };
    normalizeSelectedPoints = (points) => {
      let nextPoints = [
        ...new Set(points.filter((p) => p !== null && p !== -1))
      ];
      nextPoints = nextPoints.sort((a, b) => a - b);
      return nextPoints.length ? nextPoints : null;
    };
  }
});

// element/containerCache.ts
var originalContainerCache, updateOriginalContainerCache, resetOriginalContainerCache, getOriginalContainerHeightFromCache;
var init_containerCache = __esm({
  "element/containerCache.ts"() {
    "use strict";
    init_define_import_meta_env();
    originalContainerCache = {};
    updateOriginalContainerCache = (id, height) => {
      const data = originalContainerCache[id] || (originalContainerCache[id] = { height });
      data.height = height;
      return data;
    };
    resetOriginalContainerCache = (id) => {
      if (originalContainerCache[id]) {
        delete originalContainerCache[id];
      }
    };
    getOriginalContainerHeightFromCache = (id) => {
      return originalContainerCache[id]?.height ?? null;
    };
  }
});

// element/textElement.ts
var normalizeText, splitIntoLines, redrawTextBoundingBox, bindTextToShapeAfterDuplication, handleBindTextResize, computeBoundTextPosition, measureText, detectLineHeight, getLineHeightInPx, getApproxMinLineHeight, canvas, getLineWidth, getTextWidth, getTextHeight, parseTokens, wrapText, charWidth, DUMMY_TEXT, getApproxMinLineWidth, getMaxCharWidth, getBoundTextElementId, getBoundTextElement, getContainerElement, getContainerCenter, getContainerCoords, getTextElementAngle, shouldAllowVerticalAlign, suppportsHorizontalAlign, VALID_CONTAINER_TYPES, isValidTextContainer, computeContainerDimensionForBoundText, getBoundTextMaxWidth, getBoundTextMaxHeight, isMeasureTextSupported, getMinTextElementWidth, getTextFromElements;
var init_textElement = __esm({
  "element/textElement.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_utils2();
    init_mutateElement();
    init_constants();
    init_element();
    init_typeChecks();
    init_linearElementEditor();
    init_containerCache();
    normalizeText = (text) => {
      return normalizeEOL(text).replace(/\t/g, "        ");
    };
    splitIntoLines = (text) => {
      return normalizeText(text).split("\n");
    };
    redrawTextBoundingBox = (textElement, container, elementsMap, informMutation = true) => {
      let maxWidth = void 0;
      const boundTextUpdates = {
        x: textElement.x,
        y: textElement.y,
        text: textElement.text,
        width: textElement.width,
        height: textElement.height,
        angle: container?.angle ?? textElement.angle
      };
      boundTextUpdates.text = textElement.text;
      if (container || !textElement.autoResize) {
        maxWidth = container ? getBoundTextMaxWidth(container, textElement) : textElement.width;
        boundTextUpdates.text = wrapText(
          textElement.originalText,
          getFontString(textElement),
          maxWidth
        );
      }
      const metrics = measureText(
        boundTextUpdates.text,
        getFontString(textElement),
        textElement.lineHeight
      );
      if (textElement.autoResize) {
        boundTextUpdates.width = metrics.width;
      }
      boundTextUpdates.height = metrics.height;
      if (container) {
        const maxContainerHeight = getBoundTextMaxHeight(
          container,
          textElement
        );
        const maxContainerWidth = getBoundTextMaxWidth(container, textElement);
        if (!isArrowElement(container) && metrics.height > maxContainerHeight) {
          const nextHeight = computeContainerDimensionForBoundText(
            metrics.height,
            container.type
          );
          mutateElement(container, { height: nextHeight }, informMutation);
          updateOriginalContainerCache(container.id, nextHeight);
        }
        if (metrics.width > maxContainerWidth) {
          const nextWidth = computeContainerDimensionForBoundText(
            metrics.width,
            container.type
          );
          mutateElement(container, { width: nextWidth }, informMutation);
        }
        const updatedTextElement = {
          ...textElement,
          ...boundTextUpdates
        };
        const { x, y } = computeBoundTextPosition(
          container,
          updatedTextElement,
          elementsMap
        );
        boundTextUpdates.x = x;
        boundTextUpdates.y = y;
      }
      mutateElement(textElement, boundTextUpdates, informMutation);
    };
    bindTextToShapeAfterDuplication = (newElements, oldElements, oldIdToDuplicatedId) => {
      const newElementsMap = arrayToMap(newElements);
      oldElements.forEach((element) => {
        const newElementId = oldIdToDuplicatedId.get(element.id);
        const boundTextElementId = getBoundTextElementId(element);
        if (boundTextElementId) {
          const newTextElementId = oldIdToDuplicatedId.get(boundTextElementId);
          if (newTextElementId) {
            const newContainer = newElementsMap.get(newElementId);
            if (newContainer) {
              mutateElement(newContainer, {
                boundElements: (element.boundElements || []).filter(
                  (boundElement) => boundElement.id !== newTextElementId && boundElement.id !== boundTextElementId
                ).concat({
                  type: "text",
                  id: newTextElementId
                })
              });
            }
            const newTextElement2 = newElementsMap.get(newTextElementId);
            if (newTextElement2 && isTextElement(newTextElement2)) {
              mutateElement(newTextElement2, {
                containerId: newContainer ? newElementId : null
              });
            }
          }
        }
      });
    };
    handleBindTextResize = (container, elementsMap, transformHandleType, shouldMaintainAspectRatio2 = false) => {
      const boundTextElementId = getBoundTextElementId(container);
      if (!boundTextElementId) {
        return;
      }
      resetOriginalContainerCache(container.id);
      const textElement = getBoundTextElement(container, elementsMap);
      if (textElement && textElement.text) {
        if (!container) {
          return;
        }
        let text = textElement.text;
        let nextHeight = textElement.height;
        let nextWidth = textElement.width;
        const maxWidth = getBoundTextMaxWidth(container, textElement);
        const maxHeight = getBoundTextMaxHeight(container, textElement);
        let containerHeight = container.height;
        if (shouldMaintainAspectRatio2 || transformHandleType !== "n" && transformHandleType !== "s") {
          if (text) {
            text = wrapText(
              textElement.originalText,
              getFontString(textElement),
              maxWidth
            );
          }
          const metrics = measureText(
            text,
            getFontString(textElement),
            textElement.lineHeight
          );
          nextHeight = metrics.height;
          nextWidth = metrics.width;
        }
        if (nextHeight > maxHeight) {
          containerHeight = computeContainerDimensionForBoundText(
            nextHeight,
            container.type
          );
          const diff = containerHeight - container.height;
          const updatedY = !isArrowElement(container) && (transformHandleType === "ne" || transformHandleType === "nw" || transformHandleType === "n") ? container.y - diff : container.y;
          mutateElement(container, {
            height: containerHeight,
            y: updatedY
          });
        }
        mutateElement(textElement, {
          text,
          width: nextWidth,
          height: nextHeight
        });
        if (!isArrowElement(container)) {
          mutateElement(
            textElement,
            computeBoundTextPosition(container, textElement, elementsMap)
          );
        }
      }
    };
    computeBoundTextPosition = (container, boundTextElement, elementsMap) => {
      if (isArrowElement(container)) {
        return LinearElementEditor.getBoundTextElementPosition(
          container,
          boundTextElement,
          elementsMap
        );
      }
      const containerCoords = getContainerCoords(container);
      const maxContainerHeight = getBoundTextMaxHeight(container, boundTextElement);
      const maxContainerWidth = getBoundTextMaxWidth(container, boundTextElement);
      let x;
      let y;
      if (boundTextElement.verticalAlign === VERTICAL_ALIGN.TOP) {
        y = containerCoords.y;
      } else if (boundTextElement.verticalAlign === VERTICAL_ALIGN.BOTTOM) {
        y = containerCoords.y + (maxContainerHeight - boundTextElement.height);
      } else {
        y = containerCoords.y + (maxContainerHeight / 2 - boundTextElement.height / 2);
      }
      if (boundTextElement.textAlign === TEXT_ALIGN.LEFT) {
        x = containerCoords.x;
      } else if (boundTextElement.textAlign === TEXT_ALIGN.RIGHT) {
        x = containerCoords.x + (maxContainerWidth - boundTextElement.width);
      } else {
        x = containerCoords.x + (maxContainerWidth / 2 - boundTextElement.width / 2);
      }
      return { x, y };
    };
    measureText = (text, font, lineHeight, forceAdvanceWidth) => {
      const _text = text.split("\n").map((x) => x || " ").join("\n");
      const fontSize = parseFloat(font);
      const height = getTextHeight(_text, fontSize, lineHeight);
      const width = getTextWidth(_text, font, forceAdvanceWidth);
      return { width, height };
    };
    detectLineHeight = (textElement) => {
      const lineCount = splitIntoLines(textElement.text).length;
      return textElement.height / lineCount / textElement.fontSize;
    };
    getLineHeightInPx = (fontSize, lineHeight) => {
      return fontSize * lineHeight;
    };
    getApproxMinLineHeight = (fontSize, lineHeight) => {
      return getLineHeightInPx(fontSize, lineHeight) + BOUND_TEXT_PADDING * 2;
    };
    getLineWidth = (text, font, forceAdvanceWidth) => {
      if (!canvas) {
        canvas = document.createElement("canvas");
      }
      const canvas2dContext = canvas.getContext("2d");
      canvas2dContext.font = font;
      const metrics = canvas2dContext.measureText(text);
      const advanceWidth = metrics.width;
      if (!forceAdvanceWidth && window.TextMetrics && "actualBoundingBoxLeft" in window.TextMetrics.prototype && "actualBoundingBoxRight" in window.TextMetrics.prototype) {
        const actualWidth = Math.abs(metrics.actualBoundingBoxLeft) + Math.abs(metrics.actualBoundingBoxRight);
        return Math.max(actualWidth, advanceWidth);
      }
      if (isTestEnv()) {
        return advanceWidth * 10;
      }
      return advanceWidth;
    };
    getTextWidth = (text, font, forceAdvanceWidth) => {
      const lines = splitIntoLines(text);
      let width = 0;
      lines.forEach((line) => {
        width = Math.max(width, getLineWidth(line, font, forceAdvanceWidth));
      });
      return width;
    };
    getTextHeight = (text, fontSize, lineHeight) => {
      const lineCount = splitIntoLines(text).length;
      return getLineHeightInPx(fontSize, lineHeight) * lineCount;
    };
    parseTokens = (text) => {
      const words = text.split("-");
      if (words.length > 1) {
        words.forEach((word, index) => {
          if (index !== words.length - 1) {
            words[index] = word += "-";
          }
        });
      }
      return words.join(" ").split(" ");
    };
    wrapText = (text, font, maxWidth) => {
      if (!Number.isFinite(maxWidth) || maxWidth < 0) {
        return text;
      }
      const lines = [];
      const originalLines = text.split("\n");
      const spaceAdvanceWidth = getLineWidth(" ", font, true);
      let currentLine = "";
      let currentLineWidthTillNow = 0;
      const push = (str) => {
        if (str.trim()) {
          lines.push(str);
        }
      };
      const resetParams = () => {
        currentLine = "";
        currentLineWidthTillNow = 0;
      };
      for (const originalLine of originalLines) {
        const currentLineWidth = getLineWidth(originalLine, font, true);
        if (currentLineWidth <= maxWidth) {
          lines.push(originalLine);
          continue;
        }
        const words = parseTokens(originalLine);
        resetParams();
        let index = 0;
        while (index < words.length) {
          const currentWordWidth = getLineWidth(words[index], font, true);
          if (currentWordWidth === maxWidth) {
            push(words[index]);
            index++;
          } else if (currentWordWidth > maxWidth) {
            push(currentLine);
            resetParams();
            while (words[index].length > 0) {
              const currentChar = String.fromCodePoint(
                words[index].codePointAt(0)
              );
              const line = currentLine + currentChar;
              const lineAdvanceWidth = getLineWidth(line, font, true);
              const charAdvanceWidth = charWidth.calculate(currentChar, font);
              currentLineWidthTillNow = lineAdvanceWidth;
              words[index] = words[index].slice(currentChar.length);
              if (currentLineWidthTillNow >= maxWidth) {
                push(currentLine);
                currentLine = currentChar;
                currentLineWidthTillNow = charAdvanceWidth;
              } else {
                currentLine = line;
              }
            }
            if (currentLineWidthTillNow + spaceAdvanceWidth >= maxWidth) {
              push(currentLine);
              resetParams();
            } else if (!currentLine.endsWith("-")) {
              currentLine += " ";
              currentLineWidthTillNow += spaceAdvanceWidth;
            }
            index++;
          } else {
            while (currentLineWidthTillNow < maxWidth && index < words.length) {
              const word = words[index];
              currentLineWidthTillNow = getLineWidth(
                currentLine + word,
                font,
                true
              );
              if (currentLineWidthTillNow > maxWidth) {
                push(currentLine);
                resetParams();
                break;
              }
              index++;
              const shouldAppendSpace = !word.endsWith("-");
              currentLine += word;
              if (shouldAppendSpace) {
                currentLine += " ";
              }
              if (currentLineWidthTillNow + spaceAdvanceWidth >= maxWidth) {
                if (shouldAppendSpace) {
                  lines.push(currentLine.slice(0, -1));
                } else {
                  lines.push(currentLine);
                }
                resetParams();
                break;
              }
            }
          }
        }
        if (currentLine.slice(-1) === " ") {
          currentLine = currentLine.slice(0, -1);
          push(currentLine);
        }
      }
      return lines.join("\n");
    };
    charWidth = /* @__PURE__ */ (() => {
      const cachedCharWidth = {};
      const calculate = (char, font) => {
        const ascii = char.charCodeAt(0);
        if (!cachedCharWidth[font]) {
          cachedCharWidth[font] = [];
        }
        if (!cachedCharWidth[font][ascii]) {
          const width = getLineWidth(char, font, true);
          cachedCharWidth[font][ascii] = width;
        }
        return cachedCharWidth[font][ascii];
      };
      const getCache = (font) => {
        return cachedCharWidth[font];
      };
      return {
        calculate,
        getCache
      };
    })();
    DUMMY_TEXT = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".toLocaleUpperCase();
    getApproxMinLineWidth = (font, lineHeight) => {
      const maxCharWidth = getMaxCharWidth(font);
      if (maxCharWidth === 0) {
        return measureText(DUMMY_TEXT.split("").join("\n"), font, lineHeight).width + BOUND_TEXT_PADDING * 2;
      }
      return maxCharWidth + BOUND_TEXT_PADDING * 2;
    };
    getMaxCharWidth = (font) => {
      const cache = charWidth.getCache(font);
      if (!cache) {
        return 0;
      }
      const cacheWithOutEmpty = cache.filter((val) => val !== void 0);
      return Math.max(...cacheWithOutEmpty);
    };
    getBoundTextElementId = (container) => {
      return container?.boundElements?.length ? container?.boundElements?.find((ele) => ele.type === "text")?.id || null : null;
    };
    getBoundTextElement = (element, elementsMap) => {
      if (!element) {
        return null;
      }
      const boundTextElementId = getBoundTextElementId(element);
      if (boundTextElementId) {
        return elementsMap.get(boundTextElementId) || null;
      }
      return null;
    };
    getContainerElement = (element, elementsMap) => {
      if (!element) {
        return null;
      }
      if (element.containerId) {
        return elementsMap.get(element.containerId) || null;
      }
      return null;
    };
    getContainerCenter = (container, appState, elementsMap) => {
      if (!isArrowElement(container)) {
        return {
          x: container.x + container.width / 2,
          y: container.y + container.height / 2
        };
      }
      const points = LinearElementEditor.getPointsGlobalCoordinates(
        container,
        elementsMap
      );
      if (points.length % 2 === 1) {
        const index2 = Math.floor(container.points.length / 2);
        const midPoint = LinearElementEditor.getPointGlobalCoordinates(
          container,
          container.points[index2],
          elementsMap
        );
        return { x: midPoint[0], y: midPoint[1] };
      }
      const index = container.points.length / 2 - 1;
      let midSegmentMidpoint = LinearElementEditor.getEditorMidPoints(
        container,
        elementsMap,
        appState
      )[index];
      if (!midSegmentMidpoint) {
        midSegmentMidpoint = LinearElementEditor.getSegmentMidPoint(
          container,
          points[index],
          points[index + 1],
          index + 1,
          elementsMap
        );
      }
      return { x: midSegmentMidpoint[0], y: midSegmentMidpoint[1] };
    };
    getContainerCoords = (container) => {
      let offsetX = BOUND_TEXT_PADDING;
      let offsetY = BOUND_TEXT_PADDING;
      if (container.type === "ellipse") {
        offsetX += container.width / 2 * (1 - Math.sqrt(2) / 2);
        offsetY += container.height / 2 * (1 - Math.sqrt(2) / 2);
      }
      if (container.type === "diamond") {
        offsetX += container.width / 4;
        offsetY += container.height / 4;
      }
      return {
        x: container.x + offsetX,
        y: container.y + offsetY
      };
    };
    getTextElementAngle = (textElement, container) => {
      if (!container || isArrowElement(container)) {
        return textElement.angle;
      }
      return container.angle;
    };
    shouldAllowVerticalAlign = (selectedElements, elementsMap) => {
      return selectedElements.some((element) => {
        if (isBoundToContainer(element)) {
          const container = getContainerElement(element, elementsMap);
          if (isArrowElement(container)) {
            return false;
          }
          return true;
        }
        return false;
      });
    };
    suppportsHorizontalAlign = (selectedElements, elementsMap) => {
      return selectedElements.some((element) => {
        if (isBoundToContainer(element)) {
          const container = getContainerElement(element, elementsMap);
          if (isArrowElement(container)) {
            return false;
          }
          return true;
        }
        return isTextElement(element);
      });
    };
    VALID_CONTAINER_TYPES = /* @__PURE__ */ new Set([
      "rectangle",
      "ellipse",
      "diamond",
      "arrow"
    ]);
    isValidTextContainer = (element) => VALID_CONTAINER_TYPES.has(element.type);
    computeContainerDimensionForBoundText = (dimension, containerType) => {
      dimension = Math.ceil(dimension);
      const padding = BOUND_TEXT_PADDING * 2;
      if (containerType === "ellipse") {
        return Math.round((dimension + padding) / Math.sqrt(2) * 2);
      }
      if (containerType === "arrow") {
        return dimension + padding * 8;
      }
      if (containerType === "diamond") {
        return 2 * (dimension + padding);
      }
      return dimension + padding;
    };
    getBoundTextMaxWidth = (container, boundTextElement) => {
      const { width } = container;
      if (isArrowElement(container)) {
        const minWidth = (boundTextElement?.fontSize ?? DEFAULT_FONT_SIZE) * ARROW_LABEL_FONT_SIZE_TO_MIN_WIDTH_RATIO;
        return Math.max(ARROW_LABEL_WIDTH_FRACTION * width, minWidth);
      }
      if (container.type === "ellipse") {
        return Math.round(width / 2 * Math.sqrt(2)) - BOUND_TEXT_PADDING * 2;
      }
      if (container.type === "diamond") {
        return Math.round(width / 2) - BOUND_TEXT_PADDING * 2;
      }
      return width - BOUND_TEXT_PADDING * 2;
    };
    getBoundTextMaxHeight = (container, boundTextElement) => {
      const { height } = container;
      if (isArrowElement(container)) {
        const containerHeight = height - BOUND_TEXT_PADDING * 8 * 2;
        if (containerHeight <= 0) {
          return boundTextElement.height;
        }
        return height;
      }
      if (container.type === "ellipse") {
        return Math.round(height / 2 * Math.sqrt(2)) - BOUND_TEXT_PADDING * 2;
      }
      if (container.type === "diamond") {
        return Math.round(height / 2) - BOUND_TEXT_PADDING * 2;
      }
      return height - BOUND_TEXT_PADDING * 2;
    };
    isMeasureTextSupported = () => {
      const width = getTextWidth(
        DUMMY_TEXT,
        getFontString({
          fontSize: DEFAULT_FONT_SIZE,
          fontFamily: DEFAULT_FONT_FAMILY
        })
      );
      return width > 0;
    };
    getMinTextElementWidth = (font, lineHeight) => {
      return measureText("", font, lineHeight).width + BOUND_TEXT_PADDING * 2;
    };
    getTextFromElements = (elements, separator = "\n\n") => {
      const text = elements.reduce((acc, element) => {
        if (isTextElement(element)) {
          acc.push(element.text);
        }
        return acc;
      }, []).join(separator);
      return text;
    };
  }
});

// fractionalIndex.ts
import { generateNKeysBetween } from "fractional-indexing";
var validateFractionalIndices, orderByFractionalIndex, syncMovedIndices, syncInvalidIndices, getMovedIndicesGroups, getInvalidIndicesGroups, isValidFractionalIndex, generateIndices, isOrderedElement;
var init_fractionalIndex = __esm({
  "fractionalIndex.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_mutateElement();
    init_errors();
    init_typeChecks();
    init_textElement();
    init_utils2();
    validateFractionalIndices = (elements, {
      shouldThrow = false,
      includeBoundTextValidation = false,
      ignoreLogs,
      reconciliationContext
    }) => {
      const errorMessages = [];
      const stringifyElement = (element) => `${element?.index}:${element?.id}:${element?.type}:${element?.isDeleted}:${element?.version}:${element?.versionNonce}`;
      const indices = elements.map((x) => x.index);
      for (const [i, index] of indices.entries()) {
        const predecessorIndex = indices[i - 1];
        const successorIndex = indices[i + 1];
        if (!isValidFractionalIndex(index, predecessorIndex, successorIndex)) {
          errorMessages.push(
            `Fractional indices invariant has been compromised: "${stringifyElement(
              elements[i - 1]
            )}", "${stringifyElement(elements[i])}", "${stringifyElement(
              elements[i + 1]
            )}"`
          );
        }
        if (includeBoundTextValidation && hasBoundTextElement(elements[i])) {
          const container = elements[i];
          const text = getBoundTextElement(container, arrayToMap(elements));
          if (text && text.index <= container.index) {
            errorMessages.push(
              `Fractional indices invariant for bound elements has been compromised: "${stringifyElement(
                text
              )}", "${stringifyElement(container)}"`
            );
          }
        }
      }
      if (errorMessages.length) {
        const error = new InvalidFractionalIndexError();
        const additionalContext = [];
        if (reconciliationContext) {
          additionalContext.push("Additional reconciliation context:");
          additionalContext.push(
            reconciliationContext.localElements.map((x) => stringifyElement(x))
          );
          additionalContext.push(
            reconciliationContext.remoteElements.map((x) => stringifyElement(x))
          );
        }
        if (!ignoreLogs) {
          console.error(
            errorMessages.join("\n\n"),
            error.stack,
            elements.map((x) => stringifyElement(x)),
            ...additionalContext
          );
        }
        if (shouldThrow) {
          throw error;
        }
      }
    };
    orderByFractionalIndex = (elements) => {
      return elements.sort((a, b) => {
        if (isOrderedElement(a) && isOrderedElement(b)) {
          if (a.index < b.index) {
            return -1;
          } else if (a.index > b.index) {
            return 1;
          }
          return a.id < b.id ? -1 : 1;
        }
        return 1;
      });
    };
    syncMovedIndices = (elements, movedElements) => {
      try {
        const indicesGroups = getMovedIndicesGroups(elements, movedElements);
        const elementsUpdates = generateIndices(elements, indicesGroups);
        const elementsCandidates = elements.map(
          (x) => elementsUpdates.has(x) ? { ...x, ...elementsUpdates.get(x) } : x
        );
        validateFractionalIndices(
          elementsCandidates,
          // we don't autofix invalid bound text indices, hence don't include it in the validation
          {
            includeBoundTextValidation: false,
            shouldThrow: true,
            ignoreLogs: true
          }
        );
        for (const [element, update] of elementsUpdates) {
          mutateElement(element, update, false);
        }
      } catch (e) {
        syncInvalidIndices(elements);
      }
      return elements;
    };
    syncInvalidIndices = (elements) => {
      const indicesGroups = getInvalidIndicesGroups(elements);
      const elementsUpdates = generateIndices(elements, indicesGroups);
      for (const [element, update] of elementsUpdates) {
        mutateElement(element, update, false);
      }
      return elements;
    };
    getMovedIndicesGroups = (elements, movedElements) => {
      const indicesGroups = [];
      let i = 0;
      while (i < elements.length) {
        if (movedElements.has(elements[i].id)) {
          const indicesGroup = [i - 1, i];
          while (++i < elements.length) {
            if (!movedElements.has(elements[i].id)) {
              break;
            }
            indicesGroup.push(i);
          }
          indicesGroup.push(i);
          indicesGroups.push(indicesGroup);
        } else {
          i++;
        }
      }
      return indicesGroups;
    };
    getInvalidIndicesGroups = (elements) => {
      const indicesGroups = [];
      let lowerBound = void 0;
      let upperBound = void 0;
      let lowerBoundIndex = -1;
      let upperBoundIndex = 0;
      const getLowerBound = (index) => {
        const lowerBound2 = elements[lowerBoundIndex] ? elements[lowerBoundIndex].index : void 0;
        const candidate = elements[index - 1]?.index;
        if (!lowerBound2 && candidate || // first lowerBound
        lowerBound2 && candidate && candidate > lowerBound2) {
          return [candidate, index - 1];
        }
        return [lowerBound2, lowerBoundIndex];
      };
      const getUpperBound = (index) => {
        const upperBound2 = elements[upperBoundIndex] ? elements[upperBoundIndex].index : void 0;
        if (upperBound2 && index < upperBoundIndex) {
          return [upperBound2, upperBoundIndex];
        }
        let i2 = upperBoundIndex;
        while (++i2 < elements.length) {
          const candidate = elements[i2]?.index;
          if (!upperBound2 && candidate || // first upperBound
          upperBound2 && candidate && candidate > upperBound2) {
            return [candidate, i2];
          }
        }
        return [void 0, i2];
      };
      let i = 0;
      while (i < elements.length) {
        const current = elements[i].index;
        [lowerBound, lowerBoundIndex] = getLowerBound(i);
        [upperBound, upperBoundIndex] = getUpperBound(i);
        if (!isValidFractionalIndex(current, lowerBound, upperBound)) {
          const indicesGroup = [lowerBoundIndex, i];
          while (++i < elements.length) {
            const current2 = elements[i].index;
            const [nextLowerBound, nextLowerBoundIndex] = getLowerBound(i);
            const [nextUpperBound, nextUpperBoundIndex] = getUpperBound(i);
            if (isValidFractionalIndex(current2, nextLowerBound, nextUpperBound)) {
              break;
            }
            [lowerBound, lowerBoundIndex] = [nextLowerBound, nextLowerBoundIndex];
            [upperBound, upperBoundIndex] = [nextUpperBound, nextUpperBoundIndex];
            indicesGroup.push(i);
          }
          indicesGroup.push(upperBoundIndex);
          indicesGroups.push(indicesGroup);
        } else {
          i++;
        }
      }
      return indicesGroups;
    };
    isValidFractionalIndex = (index, predecessor, successor) => {
      if (!index) {
        return false;
      }
      if (predecessor && successor) {
        return predecessor < index && index < successor;
      }
      if (!predecessor && successor) {
        return index < successor;
      }
      if (predecessor && !successor) {
        return predecessor < index;
      }
      return !!index;
    };
    generateIndices = (elements, indicesGroups) => {
      const elementsUpdates = /* @__PURE__ */ new Map();
      for (const indices of indicesGroups) {
        const lowerBoundIndex = indices.shift();
        const upperBoundIndex = indices.pop();
        const fractionalIndices = generateNKeysBetween(
          elements[lowerBoundIndex]?.index,
          elements[upperBoundIndex]?.index,
          indices.length
        );
        for (let i = 0; i < indices.length; i++) {
          const element = elements[indices[i]];
          elementsUpdates.set(element, {
            index: fractionalIndices[i]
          });
        }
      }
      return elementsUpdates;
    };
    isOrderedElement = (element) => {
      if (element.index) {
        return true;
      }
      return false;
    };
  }
});

// scene/Scene.ts
import throttle from "lodash.throttle";
var getNonDeletedElements3, validateIndicesThrottled, hashSelectionOpts, isIdKey, Scene, Scene_default;
var init_Scene = __esm({
  "scene/Scene.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_element();
    init_typeChecks();
    init_selection();
    init_random();
    init_fractionalIndex();
    init_utils2();
    init_utils2();
    init_constants();
    getNonDeletedElements3 = (allElements) => {
      const elementsMap = /* @__PURE__ */ new Map();
      const elements = [];
      for (const element of allElements) {
        if (!element.isDeleted) {
          elements.push(element);
          elementsMap.set(
            element.id,
            element
          );
        }
      }
      return { elementsMap, elements };
    };
    validateIndicesThrottled = throttle(
      (elements) => {
        if (define_import_meta_env_default.DEV || define_import_meta_env_default.MODE === ENV.TEST || window?.DEBUG_FRACTIONAL_INDICES) {
          validateFractionalIndices(elements, {
            // throw only in dev & test, to remain functional on `DEBUG_FRACTIONAL_INDICES`
            shouldThrow: define_import_meta_env_default.DEV || define_import_meta_env_default.MODE === ENV.TEST,
            includeBoundTextValidation: true
          });
        }
      },
      1e3 * 60,
      { leading: true, trailing: false }
    );
    hashSelectionOpts = (opts) => {
      const keys = ["includeBoundTextElement", "includeElementsInFrames"];
      let hash = "";
      for (const key of keys) {
        hash += `${key}:${opts[key] ? "1" : "0"}`;
      }
      return hash;
    };
    isIdKey = (elementKey) => {
      if (typeof elementKey === "string") {
        return true;
      }
      return false;
    };
    Scene = class _Scene {
      // ---------------------------------------------------------------------------
      // static methods/props
      // ---------------------------------------------------------------------------
      static sceneMapByElement = /* @__PURE__ */ new WeakMap();
      static sceneMapById = /* @__PURE__ */ new Map();
      static mapElementToScene(elementKey, scene) {
        if (isIdKey(elementKey)) {
          this.sceneMapById.set(elementKey, scene);
        } else {
          this.sceneMapByElement.set(elementKey, scene);
          this.sceneMapById.set(elementKey.id, scene);
        }
      }
      /**
       * @deprecated pass down `app.scene` and use it directly
       */
      static getScene(elementKey) {
        if (isIdKey(elementKey)) {
          return this.sceneMapById.get(elementKey) || null;
        }
        return this.sceneMapByElement.get(elementKey) || null;
      }
      // ---------------------------------------------------------------------------
      // instance methods/props
      // ---------------------------------------------------------------------------
      callbacks = /* @__PURE__ */ new Set();
      nonDeletedElements = [];
      nonDeletedElementsMap = toBrandedType(
        /* @__PURE__ */ new Map()
      );
      // ideally all elements within the scene should be wrapped around with `Ordered` type, but right now there is no real benefit doing so
      elements = [];
      nonDeletedFramesLikes = [];
      frames = [];
      elementsMap = toBrandedType(/* @__PURE__ */ new Map());
      selectedElementsCache = {
        selectedElementIds: null,
        elements: null,
        cache: /* @__PURE__ */ new Map()
      };
      /**
       * Random integer regenerated each scene update.
       *
       * Does not relate to elements versions, it's only a renderer
       * cache-invalidation nonce at the moment.
       */
      sceneNonce;
      getSceneNonce() {
        return this.sceneNonce;
      }
      getNonDeletedElementsMap() {
        return this.nonDeletedElementsMap;
      }
      getElementsIncludingDeleted() {
        return this.elements;
      }
      getElementsMapIncludingDeleted() {
        return this.elementsMap;
      }
      getNonDeletedElements() {
        return this.nonDeletedElements;
      }
      getFramesIncludingDeleted() {
        return this.frames;
      }
      getSelectedElements(opts) {
        const hash = hashSelectionOpts(opts);
        const elements = opts?.elements || this.nonDeletedElements;
        if (this.selectedElementsCache.elements === elements && this.selectedElementsCache.selectedElementIds === opts.selectedElementIds) {
          const cached = this.selectedElementsCache.cache.get(hash);
          if (cached) {
            return cached;
          }
        } else if (opts?.elements == null) {
          this.selectedElementsCache.cache.clear();
        }
        const selectedElements = getSelectedElements(
          elements,
          { selectedElementIds: opts.selectedElementIds },
          opts
        );
        if (opts?.elements == null) {
          this.selectedElementsCache.selectedElementIds = opts.selectedElementIds;
          this.selectedElementsCache.elements = this.nonDeletedElements;
          this.selectedElementsCache.cache.set(hash, selectedElements);
        }
        return selectedElements;
      }
      getNonDeletedFramesLikes() {
        return this.nonDeletedFramesLikes;
      }
      getElement(id) {
        return this.elementsMap.get(id) || null;
      }
      getNonDeletedElement(id) {
        const element = this.getElement(id);
        if (element && isNonDeletedElement(element)) {
          return element;
        }
        return null;
      }
      /**
       * A utility method to help with updating all scene elements, with the added
       * performance optimization of not renewing the array if no change is made.
       *
       * Maps all current excalidraw elements, invoking the callback for each
       * element. The callback should either return a new mapped element, or the
       * original element if no changes are made. If no changes are made to any
       * element, this results in a no-op. Otherwise, the newly mapped elements
       * are set as the next scene's elements.
       *
       * @returns whether a change was made
       */
      mapElements(iteratee) {
        let didChange = false;
        const newElements = this.elements.map((element) => {
          const nextElement = iteratee(element);
          if (nextElement !== element) {
            didChange = true;
          }
          return nextElement;
        });
        if (didChange) {
          this.replaceAllElements(newElements);
        }
        return didChange;
      }
      replaceAllElements(nextElements) {
        const _nextElements = (
          // ts doesn't like `Array.isArray` of `instanceof Map`
          nextElements instanceof Array ? nextElements : Array.from(nextElements.values())
        );
        const nextFrameLikes = [];
        validateIndicesThrottled(_nextElements);
        this.elements = syncInvalidIndices(_nextElements);
        this.elementsMap.clear();
        this.elements.forEach((element) => {
          if (isFrameLikeElement(element)) {
            nextFrameLikes.push(element);
          }
          this.elementsMap.set(element.id, element);
          _Scene.mapElementToScene(element, this);
        });
        const nonDeletedElements = getNonDeletedElements3(this.elements);
        this.nonDeletedElements = nonDeletedElements.elements;
        this.nonDeletedElementsMap = nonDeletedElements.elementsMap;
        this.frames = nextFrameLikes;
        this.nonDeletedFramesLikes = getNonDeletedElements3(this.frames).elements;
        this.triggerUpdate();
      }
      triggerUpdate() {
        this.sceneNonce = randomInteger();
        for (const callback of Array.from(this.callbacks)) {
          callback();
        }
      }
      onUpdate(cb) {
        if (this.callbacks.has(cb)) {
          throw new Error();
        }
        this.callbacks.add(cb);
        return () => {
          if (!this.callbacks.has(cb)) {
            throw new Error();
          }
          this.callbacks.delete(cb);
        };
      }
      destroy() {
        this.elements = [];
        this.nonDeletedElements = [];
        this.nonDeletedFramesLikes = [];
        this.frames = [];
        this.elementsMap.clear();
        this.selectedElementsCache.selectedElementIds = null;
        this.selectedElementsCache.elements = null;
        this.selectedElementsCache.cache.clear();
        _Scene.sceneMapById.forEach((scene, elementKey) => {
          if (scene === this) {
            _Scene.sceneMapById.delete(elementKey);
          }
        });
        this.callbacks.clear();
      }
      insertElementAtIndex(element, index) {
        if (!Number.isFinite(index) || index < 0) {
          throw new Error(
            "insertElementAtIndex can only be called with index >= 0"
          );
        }
        const nextElements = [
          ...this.elements.slice(0, index),
          element,
          ...this.elements.slice(index)
        ];
        syncMovedIndices(nextElements, arrayToMap([element]));
        this.replaceAllElements(nextElements);
      }
      insertElementsAtIndex(elements, index) {
        if (!elements.length) {
          return;
        }
        if (!Number.isFinite(index) || index < 0) {
          throw new Error(
            "insertElementAtIndex can only be called with index >= 0"
          );
        }
        const nextElements = [
          ...this.elements.slice(0, index),
          ...elements,
          ...this.elements.slice(index)
        ];
        syncMovedIndices(nextElements, arrayToMap(elements));
        this.replaceAllElements(nextElements);
      }
      insertElement = (element) => {
        const index = element.frameId ? this.getElementIndex(element.frameId) : this.elements.length;
        this.insertElementAtIndex(element, index);
      };
      insertElements = (elements) => {
        if (!elements.length) {
          return;
        }
        const index = elements[0]?.frameId ? this.getElementIndex(elements[0].frameId) : this.elements.length;
        this.insertElementsAtIndex(elements, index);
      };
      getElementIndex(elementId) {
        return this.elements.findIndex((element) => element.id === elementId);
      }
      getContainerElement = (element) => {
        if (!element) {
          return null;
        }
        if (element.containerId) {
          return this.getElement(element.containerId) || null;
        }
        return null;
      };
    };
    Scene_default = Scene;
  }
});

// element/mutateElement.ts
var mutateElement, newElementWith, bumpVersion;
var init_mutateElement = __esm({
  "element/mutateElement.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_Scene();
    init_points();
    init_random();
    init_utils2();
    init_ShapeCache();
    mutateElement = (element, updates, informMutation = true) => {
      let didChange = false;
      const { points, fileId } = updates;
      if (typeof points !== "undefined") {
        updates = { ...getSizeFromPoints(points), ...updates };
      }
      for (const key in updates) {
        const value = updates[key];
        if (typeof value !== "undefined") {
          if (element[key] === value && // if object, always update because its attrs could have changed
          // (except for specific keys we handle below)
          (typeof value !== "object" || value === null || key === "groupIds" || key === "scale")) {
            continue;
          }
          if (key === "scale") {
            const prevScale = element[key];
            const nextScale = value;
            if (prevScale[0] === nextScale[0] && prevScale[1] === nextScale[1]) {
              continue;
            }
          } else if (key === "points") {
            const prevPoints = element[key];
            const nextPoints = value;
            if (prevPoints.length === nextPoints.length) {
              let didChangePoints = false;
              let index = prevPoints.length;
              while (--index) {
                const prevPoint = prevPoints[index];
                const nextPoint = nextPoints[index];
                if (prevPoint[0] !== nextPoint[0] || prevPoint[1] !== nextPoint[1]) {
                  didChangePoints = true;
                  break;
                }
              }
              if (!didChangePoints) {
                continue;
              }
            }
          }
          element[key] = value;
          didChange = true;
        }
      }
      if (!didChange) {
        return element;
      }
      if (typeof updates.height !== "undefined" || typeof updates.width !== "undefined" || typeof fileId != "undefined" || typeof points !== "undefined") {
        ShapeCache.delete(element);
      }
      element.version++;
      element.versionNonce = randomInteger();
      element.updated = getUpdatedTimestamp();
      if (informMutation) {
        Scene_default.getScene(element)?.triggerUpdate();
      }
      return element;
    };
    newElementWith = (element, updates, force = false) => {
      let didChange = false;
      for (const key in updates) {
        const value = updates[key];
        if (typeof value !== "undefined") {
          if (element[key] === value && // if object, always update because its attrs could have changed
          (typeof value !== "object" || value === null)) {
            continue;
          }
          didChange = true;
        }
      }
      if (!didChange && !force) {
        return element;
      }
      return {
        ...element,
        ...updates,
        updated: getUpdatedTimestamp(),
        version: element.version + 1,
        versionNonce: randomInteger()
      };
    };
    bumpVersion = (element, version) => {
      element.version = (version ?? element.version) + 1;
      element.versionNonce = randomInteger();
      element.updated = getUpdatedTimestamp();
      return element;
    };
  }
});

// element/sizeHelpers.ts
var isInvisiblySmallElement, isElementInViewport, isElementCompletelyInViewport, getPerfectElementSize, getLockedLinearCursorAlignSize, getNormalizedDimensions;
var init_sizeHelpers = __esm({
  "element/sizeHelpers.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_mutateElement();
    init_typeChecks();
    init_constants();
    init_bounds();
    init_utils2();
    isInvisiblySmallElement = (element) => {
      if (isLinearElement(element) || isFreeDrawElement(element)) {
        return element.points.length < 2;
      }
      return element.width === 0 && element.height === 0;
    };
    isElementInViewport = (element, width, height, viewTransformations, elementsMap) => {
      const [x1, y1, x2, y2] = getElementBounds(element, elementsMap);
      const topLeftSceneCoords = viewportCoordsToSceneCoords(
        {
          clientX: viewTransformations.offsetLeft,
          clientY: viewTransformations.offsetTop
        },
        viewTransformations
      );
      const bottomRightSceneCoords = viewportCoordsToSceneCoords(
        {
          clientX: viewTransformations.offsetLeft + width,
          clientY: viewTransformations.offsetTop + height
        },
        viewTransformations
      );
      return topLeftSceneCoords.x <= x2 && topLeftSceneCoords.y <= y2 && bottomRightSceneCoords.x >= x1 && bottomRightSceneCoords.y >= y1;
    };
    isElementCompletelyInViewport = (elements, width, height, viewTransformations, elementsMap, padding) => {
      const [x1, y1, x2, y2] = getCommonBounds(elements, elementsMap);
      const topLeftSceneCoords = viewportCoordsToSceneCoords(
        {
          clientX: viewTransformations.offsetLeft + (padding?.left || 0),
          clientY: viewTransformations.offsetTop + (padding?.top || 0)
        },
        viewTransformations
      );
      const bottomRightSceneCoords = viewportCoordsToSceneCoords(
        {
          clientX: viewTransformations.offsetLeft + width - (padding?.right || 0),
          clientY: viewTransformations.offsetTop + height - (padding?.bottom || 0)
        },
        viewTransformations
      );
      return x1 >= topLeftSceneCoords.x && y1 >= topLeftSceneCoords.y && x2 <= bottomRightSceneCoords.x && y2 <= bottomRightSceneCoords.y;
    };
    getPerfectElementSize = (elementType, width, height) => {
      const absWidth = Math.abs(width);
      const absHeight = Math.abs(height);
      if (elementType === "line" || elementType === "arrow" || elementType === "freedraw") {
        const lockedAngle = Math.round(Math.atan(absHeight / absWidth) / SHIFT_LOCKING_ANGLE) * SHIFT_LOCKING_ANGLE;
        if (lockedAngle === 0) {
          height = 0;
        } else if (lockedAngle === Math.PI / 2) {
          width = 0;
        } else {
          height = absWidth * Math.tan(lockedAngle) * Math.sign(height) || height;
        }
      } else if (elementType !== "selection") {
        height = absWidth * Math.sign(height);
      }
      return { width, height };
    };
    getLockedLinearCursorAlignSize = (originX, originY, x, y) => {
      let width = x - originX;
      let height = y - originY;
      const lockedAngle = Math.round(Math.atan(height / width) / SHIFT_LOCKING_ANGLE) * SHIFT_LOCKING_ANGLE;
      if (lockedAngle === 0) {
        height = 0;
      } else if (lockedAngle === Math.PI / 2) {
        width = 0;
      } else {
        const a1 = Math.tan(lockedAngle);
        const b1 = -1;
        const c1 = originY - a1 * originX;
        const a2 = -1 / a1;
        const b2 = -1;
        const c2 = y - a2 * x;
        const intersectX = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);
        const intersectY = (c1 * a2 - c2 * a1) / (a1 * b2 - a2 * b1);
        width = intersectX - originX;
        height = intersectY - originY;
      }
      return { width, height };
    };
    getNormalizedDimensions = (element) => {
      const ret = {
        width: element.width,
        height: element.height,
        x: element.x,
        y: element.y
      };
      if (element.width < 0) {
        const nextWidth = Math.abs(element.width);
        ret.width = nextWidth;
        ret.x = element.x - nextWidth;
      }
      if (element.height < 0) {
        const nextHeight = Math.abs(element.height);
        ret.height = nextHeight;
        ret.y = element.y - nextHeight;
      }
      return ret;
    };
  }
});

// element/transformHandles.ts
var transformHandleSizes, ROTATION_RESIZE_HANDLE_GAP, DEFAULT_OMIT_SIDES, OMIT_SIDES_FOR_LINE_SLASH, OMIT_SIDES_FOR_LINE_BACKSLASH, generateTransformHandle, canResizeFromSides, getOmitSidesForDevice, getTransformHandlesFromCoords, getTransformHandles, shouldShowBoundingBox;
var init_transformHandles = __esm({
  "element/transformHandles.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_bounds();
    init_typeChecks();
    init_constants();
    init_math();
    transformHandleSizes = {
      mouse: 8,
      pen: 16,
      touch: 28
    };
    ROTATION_RESIZE_HANDLE_GAP = 16;
    DEFAULT_OMIT_SIDES = {
      e: true,
      s: true,
      n: true,
      w: true
    };
    OMIT_SIDES_FOR_LINE_SLASH = {
      e: true,
      s: true,
      n: true,
      w: true,
      nw: true,
      se: true
    };
    OMIT_SIDES_FOR_LINE_BACKSLASH = {
      e: true,
      s: true,
      n: true,
      w: true
    };
    generateTransformHandle = (x, y, width, height, cx, cy, angle) => {
      const [xx, yy] = pointRotateRads(
        pointFrom(x + width / 2, y + height / 2),
        pointFrom(cx, cy),
        angle
      );
      return [xx - width / 2, yy - height / 2, width, height];
    };
    canResizeFromSides = (device) => {
      if (device.viewport.isMobile) {
        return false;
      }
      if (device.isTouchScreen && (isAndroid || isIOS)) {
        return false;
      }
      return true;
    };
    getOmitSidesForDevice = (device) => {
      if (canResizeFromSides(device)) {
        return DEFAULT_OMIT_SIDES;
      }
      return {};
    };
    getTransformHandlesFromCoords = ([x1, y1, x2, y2, cx, cy], angle, zoom, pointerType, omitSides = {}, margin = 4) => {
      const size = transformHandleSizes[pointerType];
      const handleWidth = size / zoom.value;
      const handleHeight = size / zoom.value;
      const handleMarginX = size / zoom.value;
      const handleMarginY = size / zoom.value;
      const width = x2 - x1;
      const height = y2 - y1;
      const dashedLineMargin = margin / zoom.value;
      const centeringOffset = (size - DEFAULT_TRANSFORM_HANDLE_SPACING * 2) / (2 * zoom.value);
      const transformHandles = {
        nw: omitSides.nw ? void 0 : generateTransformHandle(
          x1 - dashedLineMargin - handleMarginX + centeringOffset,
          y1 - dashedLineMargin - handleMarginY + centeringOffset,
          handleWidth,
          handleHeight,
          cx,
          cy,
          angle
        ),
        ne: omitSides.ne ? void 0 : generateTransformHandle(
          x2 + dashedLineMargin - centeringOffset,
          y1 - dashedLineMargin - handleMarginY + centeringOffset,
          handleWidth,
          handleHeight,
          cx,
          cy,
          angle
        ),
        sw: omitSides.sw ? void 0 : generateTransformHandle(
          x1 - dashedLineMargin - handleMarginX + centeringOffset,
          y2 + dashedLineMargin - centeringOffset,
          handleWidth,
          handleHeight,
          cx,
          cy,
          angle
        ),
        se: omitSides.se ? void 0 : generateTransformHandle(
          x2 + dashedLineMargin - centeringOffset,
          y2 + dashedLineMargin - centeringOffset,
          handleWidth,
          handleHeight,
          cx,
          cy,
          angle
        ),
        rotation: omitSides.rotation ? void 0 : generateTransformHandle(
          x1 + width / 2 - handleWidth / 2,
          y1 - dashedLineMargin - handleMarginY + centeringOffset - ROTATION_RESIZE_HANDLE_GAP / zoom.value,
          handleWidth,
          handleHeight,
          cx,
          cy,
          angle
        )
      };
      const minimumSizeForEightHandles = 5 * transformHandleSizes.mouse / zoom.value;
      if (Math.abs(width) > minimumSizeForEightHandles) {
        if (!omitSides.n) {
          transformHandles.n = generateTransformHandle(
            x1 + width / 2 - handleWidth / 2,
            y1 - dashedLineMargin - handleMarginY + centeringOffset,
            handleWidth,
            handleHeight,
            cx,
            cy,
            angle
          );
        }
        if (!omitSides.s) {
          transformHandles.s = generateTransformHandle(
            x1 + width / 2 - handleWidth / 2,
            y2 + dashedLineMargin - centeringOffset,
            handleWidth,
            handleHeight,
            cx,
            cy,
            angle
          );
        }
      }
      if (Math.abs(height) > minimumSizeForEightHandles) {
        if (!omitSides.w) {
          transformHandles.w = generateTransformHandle(
            x1 - dashedLineMargin - handleMarginX + centeringOffset,
            y1 + height / 2 - handleHeight / 2,
            handleWidth,
            handleHeight,
            cx,
            cy,
            angle
          );
        }
        if (!omitSides.e) {
          transformHandles.e = generateTransformHandle(
            x2 + dashedLineMargin - centeringOffset,
            y1 + height / 2 - handleHeight / 2,
            handleWidth,
            handleHeight,
            cx,
            cy,
            angle
          );
        }
      }
      return transformHandles;
    };
    getTransformHandles = (element, zoom, elementsMap, pointerType = "mouse", omitSides = DEFAULT_OMIT_SIDES) => {
      if (element.locked || // Elbow arrows cannot be rotated
      isElbowArrow(element)) {
        return {};
      }
      if (element.type === "freedraw" || isLinearElement(element)) {
        if (element.points.length === 2) {
          const [, p1] = element.points;
          if (p1[0] === 0 || p1[1] === 0) {
            omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;
          } else if (p1[0] > 0 && p1[1] < 0) {
            omitSides = OMIT_SIDES_FOR_LINE_SLASH;
          } else if (p1[0] > 0 && p1[1] > 0) {
            omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;
          } else if (p1[0] < 0 && p1[1] > 0) {
            omitSides = OMIT_SIDES_FOR_LINE_SLASH;
          } else if (p1[0] < 0 && p1[1] < 0) {
            omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;
          }
        }
      } else if (isFrameLikeElement(element)) {
        omitSides = {
          ...omitSides,
          rotation: true
        };
      }
      const dashedLineMargin = isLinearElement(element) ? DEFAULT_TRANSFORM_HANDLE_SPACING + 8 : DEFAULT_TRANSFORM_HANDLE_SPACING;
      return getTransformHandlesFromCoords(
        getElementAbsoluteCoords(element, elementsMap, true),
        element.angle,
        zoom,
        pointerType,
        omitSides,
        dashedLineMargin
      );
    };
    shouldShowBoundingBox = (elements, appState) => {
      if (appState.editingLinearElement) {
        return false;
      }
      if (elements.length > 1) {
        return true;
      }
      const element = elements[0];
      if (isElbowArrow(element)) {
        return false;
      }
      if (!isLinearElement(element)) {
        return true;
      }
      return element.points.length > 2;
    };
  }
});

// element/resizeTest.ts
var isInsideTransformHandle, resizeTest, getElementWithTransformHandleType, getTransformHandleTypeFromCoords, RESIZE_CURSORS, rotateResizeCursor, getCursorForResizingElement, getSelectionBorders;
var init_resizeTest = __esm({
  "element/resizeTest.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_transformHandles();
    init_bounds();
    init_constants();
    init_typeChecks();
    init_math();
    isInsideTransformHandle = (transformHandle, x, y) => x >= transformHandle[0] && x <= transformHandle[0] + transformHandle[2] && y >= transformHandle[1] && y <= transformHandle[1] + transformHandle[3];
    resizeTest = (element, elementsMap, appState, x, y, zoom, pointerType, device) => {
      if (!appState.selectedElementIds[element.id]) {
        return false;
      }
      const { rotation: rotationTransformHandle, ...transformHandles } = getTransformHandles(
        element,
        zoom,
        elementsMap,
        pointerType,
        getOmitSidesForDevice(device)
      );
      if (rotationTransformHandle && isInsideTransformHandle(rotationTransformHandle, x, y)) {
        return "rotation";
      }
      const filter = Object.keys(transformHandles).filter((key) => {
        const transformHandle = transformHandles[key];
        if (!transformHandle) {
          return false;
        }
        return isInsideTransformHandle(transformHandle, x, y);
      });
      if (filter.length > 0) {
        return filter[0];
      }
      if (canResizeFromSides(device)) {
        const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(
          element,
          elementsMap
        );
        if (!(isLinearElement(element) && element.points.length <= 2)) {
          const SPACING = SIDE_RESIZING_THRESHOLD / zoom.value;
          const sides = getSelectionBorders(
            pointFrom(x1 - SPACING, y1 - SPACING),
            pointFrom(x2 + SPACING, y2 + SPACING),
            pointFrom(cx, cy),
            element.angle
          );
          for (const [dir, side] of Object.entries(sides)) {
            if (pointOnLineSegment(
              pointFrom(x, y),
              side,
              SPACING
            )) {
              return dir;
            }
          }
        }
      }
      return false;
    };
    getElementWithTransformHandleType = (elements, appState, scenePointerX, scenePointerY, zoom, pointerType, elementsMap, device) => {
      return elements.reduce((result, element) => {
        if (result) {
          return result;
        }
        const transformHandleType = resizeTest(
          element,
          elementsMap,
          appState,
          scenePointerX,
          scenePointerY,
          zoom,
          pointerType,
          device
        );
        return transformHandleType ? { element, transformHandleType } : null;
      }, null);
    };
    getTransformHandleTypeFromCoords = ([x1, y1, x2, y2], scenePointerX, scenePointerY, zoom, pointerType, device) => {
      const transformHandles = getTransformHandlesFromCoords(
        [x1, y1, x2, y2, (x1 + x2) / 2, (y1 + y2) / 2],
        0,
        zoom,
        pointerType,
        getOmitSidesForDevice(device)
      );
      const found = Object.keys(transformHandles).find((key) => {
        const transformHandle = transformHandles[key];
        return transformHandle && isInsideTransformHandle(transformHandle, scenePointerX, scenePointerY);
      });
      if (found) {
        return found;
      }
      if (canResizeFromSides(device)) {
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        const SPACING = SIDE_RESIZING_THRESHOLD / zoom.value;
        const sides = getSelectionBorders(
          pointFrom(x1 - SPACING, y1 - SPACING),
          pointFrom(x2 + SPACING, y2 + SPACING),
          pointFrom(cx, cy),
          0
        );
        for (const [dir, side] of Object.entries(sides)) {
          if (pointOnLineSegment(
            pointFrom(scenePointerX, scenePointerY),
            side,
            SPACING
          )) {
            return dir;
          }
        }
      }
      return false;
    };
    RESIZE_CURSORS = ["ns", "nesw", "ew", "nwse"];
    rotateResizeCursor = (cursor, angle) => {
      const index = RESIZE_CURSORS.indexOf(cursor);
      if (index >= 0) {
        const a = Math.round(angle / (Math.PI / 4));
        cursor = RESIZE_CURSORS[(index + a) % RESIZE_CURSORS.length];
      }
      return cursor;
    };
    getCursorForResizingElement = (resizingElement) => {
      const { element, transformHandleType } = resizingElement;
      const shouldSwapCursors = element && Math.sign(element.height) * Math.sign(element.width) === -1;
      let cursor = null;
      switch (transformHandleType) {
        case "n":
        case "s":
          cursor = "ns";
          break;
        case "w":
        case "e":
          cursor = "ew";
          break;
        case "nw":
        case "se":
          if (shouldSwapCursors) {
            cursor = "nesw";
          } else {
            cursor = "nwse";
          }
          break;
        case "ne":
        case "sw":
          if (shouldSwapCursors) {
            cursor = "nwse";
          } else {
            cursor = "nesw";
          }
          break;
        case "rotation":
          return "grab";
      }
      if (cursor && element) {
        cursor = rotateResizeCursor(cursor, element.angle);
      }
      return cursor ? `${cursor}-resize` : "";
    };
    getSelectionBorders = ([x1, y1], [x2, y2], center, angle) => {
      const topLeft = pointRotateRads(pointFrom(x1, y1), center, angle);
      const topRight = pointRotateRads(pointFrom(x2, y1), center, angle);
      const bottomLeft = pointRotateRads(pointFrom(x1, y2), center, angle);
      const bottomRight = pointRotateRads(pointFrom(x2, y2), center, angle);
      return {
        n: [topLeft, topRight],
        e: [topRight, bottomRight],
        s: [bottomRight, bottomLeft],
        w: [bottomLeft, topLeft]
      };
    };
  }
});

// element/resizeElements.ts
var transformElements, rotateSingleElement, rescalePointsInElement, measureFontSizeFromWidth, resizeSingleTextElement, resizeSingleElement, resizeMultipleElements, rotateMultipleElements, getResizeOffsetXY, getResizeArrowDirection;
var init_resizeElements = __esm({
  "element/resizeElements.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_constants();
    init_points();
    init_bounds();
    init_typeChecks();
    init_mutateElement();
    init_utils2();
    init_binding();
    init_Scene();
    init_textElement();
    init_linearElementEditor();
    init_groups();
    init_routing();
    init_math();
    transformElements = (originalElements, transformHandleType, selectedElements, elementsMap, shouldRotateWithDiscreteAngle2, shouldResizeFromCenter2, shouldMaintainAspectRatio2, pointerX, pointerY, centerX, centerY) => {
      if (selectedElements.length === 1) {
        const [element] = selectedElements;
        if (transformHandleType === "rotation") {
          if (!isElbowArrow(element)) {
            rotateSingleElement(
              element,
              elementsMap,
              pointerX,
              pointerY,
              shouldRotateWithDiscreteAngle2
            );
            updateBoundElements(element, elementsMap);
          }
        } else if (isTextElement(element) && transformHandleType) {
          resizeSingleTextElement(
            originalElements,
            element,
            elementsMap,
            transformHandleType,
            shouldResizeFromCenter2,
            pointerX,
            pointerY
          );
          updateBoundElements(element, elementsMap);
        } else if (transformHandleType) {
          resizeSingleElement(
            originalElements,
            shouldMaintainAspectRatio2,
            element,
            elementsMap,
            transformHandleType,
            shouldResizeFromCenter2,
            pointerX,
            pointerY
          );
        }
        return true;
      } else if (selectedElements.length > 1) {
        if (transformHandleType === "rotation") {
          rotateMultipleElements(
            originalElements,
            selectedElements,
            elementsMap,
            pointerX,
            pointerY,
            shouldRotateWithDiscreteAngle2,
            centerX,
            centerY
          );
          return true;
        } else if (transformHandleType) {
          resizeMultipleElements(
            originalElements,
            selectedElements,
            elementsMap,
            transformHandleType,
            shouldResizeFromCenter2,
            shouldMaintainAspectRatio2,
            pointerX,
            pointerY
          );
          return true;
        }
      }
      return false;
    };
    rotateSingleElement = (element, elementsMap, pointerX, pointerY, shouldRotateWithDiscreteAngle2) => {
      const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
      const cx = (x1 + x2) / 2;
      const cy = (y1 + y2) / 2;
      let angle;
      if (isFrameLikeElement(element)) {
        angle = 0;
      } else {
        angle = 5 * Math.PI / 2 + Math.atan2(pointerY - cy, pointerX - cx);
        if (shouldRotateWithDiscreteAngle2) {
          angle = angle + SHIFT_LOCKING_ANGLE / 2;
          angle = angle - angle % SHIFT_LOCKING_ANGLE;
        }
        angle = normalizeRadians(angle);
      }
      const boundTextElementId = getBoundTextElementId(element);
      mutateElement(element, { angle });
      if (boundTextElementId) {
        const textElement = Scene_default.getScene(element)?.getElement(
          boundTextElementId
        );
        if (textElement && !isArrowElement(element)) {
          mutateElement(textElement, { angle });
        }
      }
    };
    rescalePointsInElement = (element, width, height, normalizePoints) => isLinearElement(element) || isFreeDrawElement(element) ? {
      points: rescalePoints(
        0,
        width,
        rescalePoints(1, height, element.points, normalizePoints),
        normalizePoints
      )
    } : {};
    measureFontSizeFromWidth = (element, elementsMap, nextWidth) => {
      let width = element.width;
      const hasContainer = isBoundToContainer(element);
      if (hasContainer) {
        const container = getContainerElement(element, elementsMap);
        if (container) {
          width = getBoundTextMaxWidth(container, element);
        }
      }
      const nextFontSize = element.fontSize * (nextWidth / width);
      if (nextFontSize < MIN_FONT_SIZE) {
        return null;
      }
      return {
        size: nextFontSize
      };
    };
    resizeSingleTextElement = (originalElements, element, elementsMap, transformHandleType, shouldResizeFromCenter2, pointerX, pointerY) => {
      const [x1, y1, x2, y2, cx, cy] = getElementAbsoluteCoords(
        element,
        elementsMap
      );
      const [rotatedX, rotatedY] = pointRotateRads(
        pointFrom(pointerX, pointerY),
        pointFrom(cx, cy),
        -element.angle
      );
      let scaleX = 0;
      let scaleY = 0;
      if (transformHandleType !== "e" && transformHandleType !== "w") {
        if (transformHandleType.includes("e")) {
          scaleX = (rotatedX - x1) / (x2 - x1);
        }
        if (transformHandleType.includes("w")) {
          scaleX = (x2 - rotatedX) / (x2 - x1);
        }
        if (transformHandleType.includes("n")) {
          scaleY = (y2 - rotatedY) / (y2 - y1);
        }
        if (transformHandleType.includes("s")) {
          scaleY = (rotatedY - y1) / (y2 - y1);
        }
      }
      const scale = Math.max(scaleX, scaleY);
      if (scale > 0) {
        const nextWidth = element.width * scale;
        const nextHeight = element.height * scale;
        const metrics = measureFontSizeFromWidth(element, elementsMap, nextWidth);
        if (metrics === null) {
          return;
        }
        const startTopLeft = [x1, y1];
        const startBottomRight = [x2, y2];
        const startCenter = [cx, cy];
        let newTopLeft = pointFrom(x1, y1);
        if (["n", "w", "nw"].includes(transformHandleType)) {
          newTopLeft = pointFrom(
            startBottomRight[0] - Math.abs(nextWidth),
            startBottomRight[1] - Math.abs(nextHeight)
          );
        }
        if (transformHandleType === "ne") {
          const bottomLeft = [startTopLeft[0], startBottomRight[1]];
          newTopLeft = pointFrom(
            bottomLeft[0],
            bottomLeft[1] - Math.abs(nextHeight)
          );
        }
        if (transformHandleType === "sw") {
          const topRight = [startBottomRight[0], startTopLeft[1]];
          newTopLeft = pointFrom(
            topRight[0] - Math.abs(nextWidth),
            topRight[1]
          );
        }
        if (["s", "n"].includes(transformHandleType)) {
          newTopLeft[0] = startCenter[0] - nextWidth / 2;
        }
        if (["e", "w"].includes(transformHandleType)) {
          newTopLeft[1] = startCenter[1] - nextHeight / 2;
        }
        if (shouldResizeFromCenter2) {
          newTopLeft[0] = startCenter[0] - Math.abs(nextWidth) / 2;
          newTopLeft[1] = startCenter[1] - Math.abs(nextHeight) / 2;
        }
        const angle = element.angle;
        const rotatedTopLeft = pointRotateRads(
          newTopLeft,
          pointFrom(cx, cy),
          angle
        );
        const newCenter = pointFrom(
          newTopLeft[0] + Math.abs(nextWidth) / 2,
          newTopLeft[1] + Math.abs(nextHeight) / 2
        );
        const rotatedNewCenter = pointRotateRads(
          newCenter,
          pointFrom(cx, cy),
          angle
        );
        newTopLeft = pointRotateRads(
          rotatedTopLeft,
          rotatedNewCenter,
          -angle
        );
        const [nextX, nextY] = newTopLeft;
        mutateElement(element, {
          fontSize: metrics.size,
          width: nextWidth,
          height: nextHeight,
          x: nextX,
          y: nextY
        });
      }
      if (transformHandleType === "e" || transformHandleType === "w") {
        const stateAtResizeStart = originalElements.get(element.id);
        const [x12, y12, x22, y22] = getResizedElementAbsoluteCoords(
          stateAtResizeStart,
          stateAtResizeStart.width,
          stateAtResizeStart.height,
          true
        );
        const startTopLeft = pointFrom(x12, y12);
        const startBottomRight = pointFrom(x22, y22);
        const startCenter = pointCenter(startTopLeft, startBottomRight);
        const rotatedPointer = pointRotateRads(
          pointFrom(pointerX, pointerY),
          startCenter,
          -stateAtResizeStart.angle
        );
        const [esx1, , esx2] = getResizedElementAbsoluteCoords(
          element,
          element.width,
          element.height,
          true
        );
        const boundsCurrentWidth = esx2 - esx1;
        const atStartBoundsWidth = startBottomRight[0] - startTopLeft[0];
        const minWidth = getMinTextElementWidth(
          getFontString({
            fontSize: element.fontSize,
            fontFamily: element.fontFamily
          }),
          element.lineHeight
        );
        let scaleX2 = atStartBoundsWidth / boundsCurrentWidth;
        if (transformHandleType.includes("e")) {
          scaleX2 = (rotatedPointer[0] - startTopLeft[0]) / boundsCurrentWidth;
        }
        if (transformHandleType.includes("w")) {
          scaleX2 = (startBottomRight[0] - rotatedPointer[0]) / boundsCurrentWidth;
        }
        const newWidth = element.width * scaleX2 < minWidth ? minWidth : element.width * scaleX2;
        const text = wrapText(
          element.originalText,
          getFontString(element),
          Math.abs(newWidth)
        );
        const metrics = measureText(
          text,
          getFontString(element),
          element.lineHeight
        );
        const eleNewHeight = metrics.height;
        const [newBoundsX1, newBoundsY1, newBoundsX2, newBoundsY2] = getResizedElementAbsoluteCoords(
          stateAtResizeStart,
          newWidth,
          eleNewHeight,
          true
        );
        const newBoundsWidth = newBoundsX2 - newBoundsX1;
        const newBoundsHeight = newBoundsY2 - newBoundsY1;
        let newTopLeft = [...startTopLeft];
        if (["n", "w", "nw"].includes(transformHandleType)) {
          newTopLeft = [
            startBottomRight[0] - Math.abs(newBoundsWidth),
            startTopLeft[1]
          ];
        }
        const angle = stateAtResizeStart.angle;
        const rotatedTopLeft = pointRotateRads(
          pointFromPair(newTopLeft),
          startCenter,
          angle
        );
        const newCenter = pointFrom(
          newTopLeft[0] + Math.abs(newBoundsWidth) / 2,
          newTopLeft[1] + Math.abs(newBoundsHeight) / 2
        );
        const rotatedNewCenter = pointRotateRads(newCenter, startCenter, angle);
        newTopLeft = pointRotateRads(
          rotatedTopLeft,
          rotatedNewCenter,
          -angle
        );
        const resizedElement = {
          width: Math.abs(newWidth),
          height: Math.abs(metrics.height),
          x: newTopLeft[0],
          y: newTopLeft[1],
          text,
          autoResize: false
        };
        mutateElement(element, resizedElement);
      }
    };
    resizeSingleElement = (originalElements, shouldMaintainAspectRatio2, element, elementsMap, transformHandleDirection, shouldResizeFromCenter2, pointerX, pointerY) => {
      const stateAtResizeStart = originalElements.get(element.id);
      const [x1, y1, x2, y2] = getResizedElementAbsoluteCoords(
        stateAtResizeStart,
        stateAtResizeStart.width,
        stateAtResizeStart.height,
        true
      );
      const startTopLeft = pointFrom(x1, y1);
      const startBottomRight = pointFrom(x2, y2);
      const startCenter = pointCenter(startTopLeft, startBottomRight);
      const rotatedPointer = pointRotateRads(
        pointFrom(pointerX, pointerY),
        startCenter,
        -stateAtResizeStart.angle
      );
      const [esx1, esy1, esx2, esy2] = getResizedElementAbsoluteCoords(
        element,
        element.width,
        element.height,
        true
      );
      const boundsCurrentWidth = esx2 - esx1;
      const boundsCurrentHeight = esy2 - esy1;
      const atStartBoundsWidth = startBottomRight[0] - startTopLeft[0];
      const atStartBoundsHeight = startBottomRight[1] - startTopLeft[1];
      let scaleX = atStartBoundsWidth / boundsCurrentWidth;
      let scaleY = atStartBoundsHeight / boundsCurrentHeight;
      let boundTextFont = {};
      const boundTextElement = getBoundTextElement(element, elementsMap);
      if (transformHandleDirection.includes("e")) {
        scaleX = (rotatedPointer[0] - startTopLeft[0]) / boundsCurrentWidth;
      }
      if (transformHandleDirection.includes("s")) {
        scaleY = (rotatedPointer[1] - startTopLeft[1]) / boundsCurrentHeight;
      }
      if (transformHandleDirection.includes("w")) {
        scaleX = (startBottomRight[0] - rotatedPointer[0]) / boundsCurrentWidth;
      }
      if (transformHandleDirection.includes("n")) {
        scaleY = (startBottomRight[1] - rotatedPointer[1]) / boundsCurrentHeight;
      }
      const eleInitialWidth = stateAtResizeStart.width;
      const eleInitialHeight = stateAtResizeStart.height;
      let eleNewWidth = element.width * scaleX;
      let eleNewHeight = element.height * scaleY;
      if (shouldResizeFromCenter2) {
        eleNewWidth = 2 * eleNewWidth - eleInitialWidth;
        eleNewHeight = 2 * eleNewHeight - eleInitialHeight;
      }
      if (shouldMaintainAspectRatio2) {
        const widthRatio = Math.abs(eleNewWidth) / eleInitialWidth;
        const heightRatio = Math.abs(eleNewHeight) / eleInitialHeight;
        if (transformHandleDirection.length === 1) {
          eleNewHeight *= widthRatio;
          eleNewWidth *= heightRatio;
        }
        if (transformHandleDirection.length === 2) {
          const ratio = Math.max(widthRatio, heightRatio);
          eleNewWidth = eleInitialWidth * ratio * Math.sign(eleNewWidth);
          eleNewHeight = eleInitialHeight * ratio * Math.sign(eleNewHeight);
        }
      }
      if (boundTextElement) {
        const stateOfBoundTextElementAtResize = originalElements.get(
          boundTextElement.id
        );
        if (stateOfBoundTextElementAtResize) {
          boundTextFont = {
            fontSize: stateOfBoundTextElementAtResize.fontSize
          };
        }
        if (shouldMaintainAspectRatio2) {
          const updatedElement = {
            ...element,
            width: eleNewWidth,
            height: eleNewHeight
          };
          const nextFont = measureFontSizeFromWidth(
            boundTextElement,
            elementsMap,
            getBoundTextMaxWidth(updatedElement, boundTextElement)
          );
          if (nextFont === null) {
            return;
          }
          boundTextFont = {
            fontSize: nextFont.size
          };
        } else {
          const minWidth = getApproxMinLineWidth(
            getFontString(boundTextElement),
            boundTextElement.lineHeight
          );
          const minHeight = getApproxMinLineHeight(
            boundTextElement.fontSize,
            boundTextElement.lineHeight
          );
          eleNewWidth = Math.max(eleNewWidth, minWidth);
          eleNewHeight = Math.max(eleNewHeight, minHeight);
        }
      }
      const [newBoundsX1, newBoundsY1, newBoundsX2, newBoundsY2] = getResizedElementAbsoluteCoords(
        stateAtResizeStart,
        eleNewWidth,
        eleNewHeight,
        true
      );
      const newBoundsWidth = newBoundsX2 - newBoundsX1;
      const newBoundsHeight = newBoundsY2 - newBoundsY1;
      let newTopLeft = [...startTopLeft];
      if (["n", "w", "nw"].includes(transformHandleDirection)) {
        newTopLeft = [
          startBottomRight[0] - Math.abs(newBoundsWidth),
          startBottomRight[1] - Math.abs(newBoundsHeight)
        ];
      }
      if (transformHandleDirection === "ne") {
        const bottomLeft = [startTopLeft[0], startBottomRight[1]];
        newTopLeft = [bottomLeft[0], bottomLeft[1] - Math.abs(newBoundsHeight)];
      }
      if (transformHandleDirection === "sw") {
        const topRight = [startBottomRight[0], startTopLeft[1]];
        newTopLeft = [topRight[0] - Math.abs(newBoundsWidth), topRight[1]];
      }
      if (shouldMaintainAspectRatio2) {
        if (["s", "n"].includes(transformHandleDirection)) {
          newTopLeft[0] = startCenter[0] - newBoundsWidth / 2;
        }
        if (["e", "w"].includes(transformHandleDirection)) {
          newTopLeft[1] = startCenter[1] - newBoundsHeight / 2;
        }
      }
      const flipX = eleNewWidth < 0;
      const flipY = eleNewHeight < 0;
      if (flipX) {
        if (transformHandleDirection.includes("e")) {
          newTopLeft[0] -= Math.abs(newBoundsWidth);
        }
        if (transformHandleDirection.includes("w")) {
          newTopLeft[0] += Math.abs(newBoundsWidth);
        }
      }
      if (flipY) {
        if (transformHandleDirection.includes("s")) {
          newTopLeft[1] -= Math.abs(newBoundsHeight);
        }
        if (transformHandleDirection.includes("n")) {
          newTopLeft[1] += Math.abs(newBoundsHeight);
        }
      }
      if (shouldResizeFromCenter2) {
        newTopLeft[0] = startCenter[0] - Math.abs(newBoundsWidth) / 2;
        newTopLeft[1] = startCenter[1] - Math.abs(newBoundsHeight) / 2;
      }
      const angle = stateAtResizeStart.angle;
      const rotatedTopLeft = pointRotateRads(
        pointFromPair(newTopLeft),
        startCenter,
        angle
      );
      const newCenter = pointFrom(
        newTopLeft[0] + Math.abs(newBoundsWidth) / 2,
        newTopLeft[1] + Math.abs(newBoundsHeight) / 2
      );
      const rotatedNewCenter = pointRotateRads(newCenter, startCenter, angle);
      newTopLeft = pointRotateRads(
        rotatedTopLeft,
        rotatedNewCenter,
        -angle
      );
      const newOrigin2 = [...newTopLeft];
      const linearElementXOffset = stateAtResizeStart.x - newBoundsX1;
      const linearElementYOffset = stateAtResizeStart.y - newBoundsY1;
      newOrigin2[0] += linearElementXOffset;
      newOrigin2[1] += linearElementYOffset;
      const nextX = newOrigin2[0];
      const nextY = newOrigin2[1];
      let rescaledElementPointsY;
      let rescaledPoints;
      if (isLinearElement(element) || isFreeDrawElement(element)) {
        rescaledElementPointsY = rescalePoints(
          1,
          eleNewHeight,
          stateAtResizeStart.points,
          true
        );
        rescaledPoints = rescalePoints(
          0,
          eleNewWidth,
          rescaledElementPointsY,
          true
        );
      }
      const resizedElement = {
        width: Math.abs(eleNewWidth),
        height: Math.abs(eleNewHeight),
        x: nextX,
        y: nextY,
        points: rescaledPoints
      };
      if ("scale" in element && "scale" in stateAtResizeStart) {
        mutateElement(element, {
          scale: [
            // defaulting because scaleX/Y can be 0/-0
            (Math.sign(newBoundsX2 - stateAtResizeStart.x) || stateAtResizeStart.scale[0]) * stateAtResizeStart.scale[0],
            (Math.sign(newBoundsY2 - stateAtResizeStart.y) || stateAtResizeStart.scale[1]) * stateAtResizeStart.scale[1]
          ]
        });
      }
      if (isArrowElement(element) && boundTextElement && shouldMaintainAspectRatio2) {
        const fontSize = resizedElement.width / element.width * boundTextElement.fontSize;
        if (fontSize < MIN_FONT_SIZE) {
          return;
        }
        boundTextFont.fontSize = fontSize;
      }
      if (resizedElement.width !== 0 && resizedElement.height !== 0 && Number.isFinite(resizedElement.x) && Number.isFinite(resizedElement.y)) {
        mutateElement(element, resizedElement);
        updateBoundElements(element, elementsMap, {
          oldSize: {
            width: stateAtResizeStart.width,
            height: stateAtResizeStart.height
          }
        });
        if (boundTextElement && boundTextFont != null) {
          mutateElement(boundTextElement, {
            fontSize: boundTextFont.fontSize
          });
        }
        handleBindTextResize(
          element,
          elementsMap,
          transformHandleDirection,
          shouldMaintainAspectRatio2
        );
      }
    };
    resizeMultipleElements = (originalElements, selectedElements, elementsMap, transformHandleType, shouldResizeFromCenter2, shouldMaintainAspectRatio2, pointerX, pointerY) => {
      const targetElements = selectedElements.reduce(
        (acc, element) => {
          const origElement = originalElements.get(element.id);
          if (origElement) {
            acc.push({ orig: origElement, latest: element });
          }
          return acc;
        },
        []
      );
      const boundTextElements = targetElements.reduce((acc, { orig }) => {
        if (!isLinearElement(orig)) {
          return acc;
        }
        const textId = getBoundTextElementId(orig);
        if (!textId) {
          return acc;
        }
        const text = originalElements.get(textId) ?? null;
        if (!isBoundToContainer(text)) {
          return acc;
        }
        const xy = LinearElementEditor.getBoundTextElementPosition(
          orig,
          text,
          elementsMap
        );
        return [...acc, { ...text, ...xy }];
      }, []);
      const { minX, minY, maxX, maxY, midX, midY } = getCommonBoundingBox(
        targetElements.map(({ orig }) => orig).concat(boundTextElements)
      );
      const width = maxX - minX;
      const height = maxY - minY;
      const direction = transformHandleType;
      const anchorsMap = {
        ne: pointFrom(minX, maxY),
        se: pointFrom(minX, minY),
        sw: pointFrom(maxX, minY),
        nw: pointFrom(maxX, maxY),
        e: pointFrom(minX, minY + height / 2),
        w: pointFrom(maxX, minY + height / 2),
        n: pointFrom(minX + width / 2, maxY),
        s: pointFrom(minX + width / 2, minY)
      };
      const [anchorX, anchorY] = shouldResizeFromCenter2 ? pointFrom(midX, midY) : anchorsMap[direction];
      const resizeFromCenterScale = shouldResizeFromCenter2 ? 2 : 1;
      const scale = Math.max(
        Math.abs(pointerX - anchorX) / width || 0,
        Math.abs(pointerY - anchorY) / height || 0
      ) * resizeFromCenterScale;
      if (scale === 0) {
        return;
      }
      let scaleX = direction.includes("e") || direction.includes("w") ? Math.abs(pointerX - anchorX) / width * resizeFromCenterScale : 1;
      let scaleY = direction.includes("n") || direction.includes("s") ? Math.abs(pointerY - anchorY) / height * resizeFromCenterScale : 1;
      const keepAspectRatio = shouldMaintainAspectRatio2 || targetElements.some(
        (item) => item.latest.angle !== 0 || isTextElement(item.latest) || isInGroup(item.latest)
      );
      if (keepAspectRatio) {
        scaleX = scale;
        scaleY = scale;
      }
      const flipConditionsMap = {
        ne: [pointerX < anchorX, pointerY > anchorY],
        se: [pointerX < anchorX, pointerY < anchorY],
        sw: [pointerX > anchorX, pointerY < anchorY],
        nw: [pointerX > anchorX, pointerY > anchorY],
        // e.g. when resizing from the "e" side, we do not need to consider changes in the `y` direction
        //      and therefore, we do not need to flip in the `y` direction at all
        e: [pointerX < anchorX, false],
        w: [pointerX > anchorX, false],
        n: [false, pointerY > anchorY],
        s: [false, pointerY < anchorY]
      };
      const [flipFactorX, flipFactorY] = flipConditionsMap[direction].map(
        (condition) => condition ? -1 : 1
      );
      const isFlippedByX = flipFactorX < 0;
      const isFlippedByY = flipFactorY < 0;
      const elementsAndUpdates = [];
      for (const { orig, latest } of targetElements) {
        if (isTextElement(orig) && isBoundToContainer(orig)) {
          continue;
        }
        const width2 = orig.width * scaleX;
        const height2 = orig.height * scaleY;
        const angle = normalizeRadians(
          orig.angle * flipFactorX * flipFactorY
        );
        const isLinearOrFreeDraw = isLinearElement(orig) || isFreeDrawElement(orig);
        const offsetX = orig.x - anchorX;
        const offsetY = orig.y - anchorY;
        const shiftX = isFlippedByX && !isLinearOrFreeDraw ? width2 : 0;
        const shiftY = isFlippedByY && !isLinearOrFreeDraw ? height2 : 0;
        const x = anchorX + flipFactorX * (offsetX * scaleX + shiftX);
        const y = anchorY + flipFactorY * (offsetY * scaleY + shiftY);
        const rescaledPoints = rescalePointsInElement(
          orig,
          width2 * flipFactorX,
          height2 * flipFactorY,
          false
        );
        const update = {
          x,
          y,
          width: width2,
          height: height2,
          angle,
          ...rescaledPoints
        };
        if (isImageElement(orig)) {
          update.scale = [orig.scale[0] * flipFactorX, orig.scale[1] * flipFactorY];
        }
        if (isTextElement(orig)) {
          const metrics = measureFontSizeFromWidth(orig, elementsMap, width2);
          if (!metrics) {
            return;
          }
          update.fontSize = metrics.size;
        }
        const boundTextElement = originalElements.get(
          getBoundTextElementId(orig) ?? ""
        );
        if (boundTextElement) {
          if (keepAspectRatio) {
            const newFontSize = boundTextElement.fontSize * scale;
            if (newFontSize < MIN_FONT_SIZE) {
              return;
            }
            update.boundTextFontSize = newFontSize;
          } else {
            update.boundTextFontSize = boundTextElement.fontSize;
          }
        }
        elementsAndUpdates.push({
          element: latest,
          update
        });
      }
      const elementsToUpdate = elementsAndUpdates.map(({ element }) => element);
      for (const {
        element,
        update: { boundTextFontSize, ...update }
      } of elementsAndUpdates) {
        const { angle } = update;
        const { width: oldWidth, height: oldHeight } = element;
        mutateElement(element, update, false);
        updateBoundElements(element, elementsMap, {
          simultaneouslyUpdated: elementsToUpdate,
          oldSize: { width: oldWidth, height: oldHeight }
        });
        const boundTextElement = getBoundTextElement(element, elementsMap);
        if (boundTextElement && boundTextFontSize) {
          mutateElement(
            boundTextElement,
            {
              fontSize: boundTextFontSize,
              angle: isLinearElement(element) ? void 0 : angle
            },
            false
          );
          handleBindTextResize(element, elementsMap, transformHandleType, true);
        }
      }
      Scene_default.getScene(elementsAndUpdates[0].element)?.triggerUpdate();
    };
    rotateMultipleElements = (originalElements, elements, elementsMap, pointerX, pointerY, shouldRotateWithDiscreteAngle2, centerX, centerY) => {
      let centerAngle = 5 * Math.PI / 2 + Math.atan2(pointerY - centerY, pointerX - centerX);
      if (shouldRotateWithDiscreteAngle2) {
        centerAngle += SHIFT_LOCKING_ANGLE / 2;
        centerAngle -= centerAngle % SHIFT_LOCKING_ANGLE;
      }
      elements.filter((element) => !isFrameLikeElement(element)).forEach((element) => {
        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
        const cx = (x1 + x2) / 2;
        const cy = (y1 + y2) / 2;
        const origAngle = originalElements.get(element.id)?.angle ?? element.angle;
        const [rotatedCX, rotatedCY] = pointRotateRads(
          pointFrom(cx, cy),
          pointFrom(centerX, centerY),
          centerAngle + origAngle - element.angle
        );
        if (isElbowArrow(element)) {
          const points = getArrowLocalFixedPoints(element, elementsMap);
          mutateElbowArrow(element, elementsMap, points);
        } else {
          mutateElement(
            element,
            {
              x: element.x + (rotatedCX - cx),
              y: element.y + (rotatedCY - cy),
              angle: normalizeRadians(centerAngle + origAngle)
            },
            false
          );
        }
        updateBoundElements(element, elementsMap, {
          simultaneouslyUpdated: elements
        });
        const boundText = getBoundTextElement(element, elementsMap);
        if (boundText && !isArrowElement(element)) {
          mutateElement(
            boundText,
            {
              x: boundText.x + (rotatedCX - cx),
              y: boundText.y + (rotatedCY - cy),
              angle: normalizeRadians(centerAngle + origAngle)
            },
            false
          );
        }
      });
      Scene_default.getScene(elements[0])?.triggerUpdate();
    };
    getResizeOffsetXY = (transformHandleType, selectedElements, elementsMap, x, y) => {
      const [x1, y1, x2, y2] = selectedElements.length === 1 ? getElementAbsoluteCoords(selectedElements[0], elementsMap) : getCommonBounds(selectedElements);
      const cx = (x1 + x2) / 2;
      const cy = (y1 + y2) / 2;
      const angle = selectedElements.length === 1 ? selectedElements[0].angle : 0;
      [x, y] = pointRotateRads(
        pointFrom(x, y),
        pointFrom(cx, cy),
        -angle
      );
      switch (transformHandleType) {
        case "n":
          return pointRotateRads(
            pointFrom(x - (x1 + x2) / 2, y - y1),
            pointFrom(0, 0),
            angle
          );
        case "s":
          return pointRotateRads(
            pointFrom(x - (x1 + x2) / 2, y - y2),
            pointFrom(0, 0),
            angle
          );
        case "w":
          return pointRotateRads(
            pointFrom(x - x1, y - (y1 + y2) / 2),
            pointFrom(0, 0),
            angle
          );
        case "e":
          return pointRotateRads(
            pointFrom(x - x2, y - (y1 + y2) / 2),
            pointFrom(0, 0),
            angle
          );
        case "nw":
          return pointRotateRads(pointFrom(x - x1, y - y1), pointFrom(0, 0), angle);
        case "ne":
          return pointRotateRads(pointFrom(x - x2, y - y1), pointFrom(0, 0), angle);
        case "sw":
          return pointRotateRads(pointFrom(x - x1, y - y2), pointFrom(0, 0), angle);
        case "se":
          return pointRotateRads(pointFrom(x - x2, y - y2), pointFrom(0, 0), angle);
        default:
          return [0, 0];
      }
    };
    getResizeArrowDirection = (transformHandleType, element) => {
      const [, [px, py]] = element.points;
      const isResizeEnd = transformHandleType === "nw" && (px < 0 || py < 0) || transformHandleType === "ne" && px >= 0 || transformHandleType === "sw" && px <= 0 || transformHandleType === "se" && (px > 0 || py > 0);
      return isResizeEnd ? "end" : "origin";
    };
  }
});

// element/dragElements.ts
var dragSelectedElements, calculateOffset, updateElementCoords, getDragOffsetXY, dragNewElement;
var init_dragElements = __esm({
  "element/dragElements.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_binding();
    init_bounds();
    init_mutateElement();
    init_sizeHelpers();
    init_textElement();
    init_typeChecks();
    init_utils2();
    init_constants();
    init_snapping();
    dragSelectedElements = (pointerDownState, _selectedElements, offset2, scene, snapOffset, gridSize) => {
      if (_selectedElements.length === 1 && isElbowArrow(_selectedElements[0]) && (_selectedElements[0].startBinding || _selectedElements[0].endBinding)) {
        return;
      }
      const selectedElements = _selectedElements.filter(
        (el) => !(isElbowArrow(el) && el.startBinding && el.endBinding)
      );
      const elementsToUpdate = new Set(
        selectedElements
      );
      const frames = selectedElements.filter((e) => isFrameLikeElement(e)).map((f) => f.id);
      if (frames.length > 0) {
        for (const element of scene.getNonDeletedElements()) {
          if (element.frameId !== null && frames.includes(element.frameId)) {
            elementsToUpdate.add(element);
          }
        }
      }
      const commonBounds = getCommonBounds(
        Array.from(elementsToUpdate).map(
          (el) => pointerDownState.originalElements.get(el.id) ?? el
        )
      );
      const adjustedOffset = calculateOffset(
        commonBounds,
        offset2,
        snapOffset,
        gridSize
      );
      elementsToUpdate.forEach((element) => {
        updateElementCoords(pointerDownState, element, adjustedOffset);
        if (
          // skip arrow labels since we calculate its position during render
          !isArrowElement(element)
        ) {
          const textElement = getBoundTextElement(
            element,
            scene.getNonDeletedElementsMap()
          );
          if (textElement) {
            updateElementCoords(pointerDownState, textElement, adjustedOffset);
          }
        }
        updateBoundElements(element, scene.getElementsMapIncludingDeleted(), {
          simultaneouslyUpdated: Array.from(elementsToUpdate)
        });
      });
    };
    calculateOffset = (commonBounds, dragOffset, snapOffset, gridSize) => {
      const [x, y] = commonBounds;
      let nextX = x + dragOffset.x + snapOffset.x;
      let nextY = y + dragOffset.y + snapOffset.y;
      if (snapOffset.x === 0 || snapOffset.y === 0) {
        const [nextGridX, nextGridY] = getGridPoint(
          x + dragOffset.x,
          y + dragOffset.y,
          gridSize
        );
        if (snapOffset.x === 0) {
          nextX = nextGridX;
        }
        if (snapOffset.y === 0) {
          nextY = nextGridY;
        }
      }
      return {
        x: nextX - x,
        y: nextY - y
      };
    };
    updateElementCoords = (pointerDownState, element, dragOffset) => {
      const originalElement = pointerDownState.originalElements.get(element.id) ?? element;
      const nextX = originalElement.x + dragOffset.x;
      const nextY = originalElement.y + dragOffset.y;
      mutateElement(element, {
        x: nextX,
        y: nextY
      });
    };
    getDragOffsetXY = (selectedElements, x, y) => {
      const [x1, y1] = getCommonBounds(selectedElements);
      return [x - x1, y - y1];
    };
    dragNewElement = ({
      newElement: newElement2,
      elementType,
      originX,
      originY,
      x,
      y,
      width,
      height,
      shouldMaintainAspectRatio: shouldMaintainAspectRatio2,
      shouldResizeFromCenter: shouldResizeFromCenter2,
      zoom,
      widthAspectRatio = null,
      originOffset = null,
      informMutation = true
    }) => {
      if (shouldMaintainAspectRatio2 && newElement2.type !== "selection") {
        if (widthAspectRatio) {
          height = width / widthAspectRatio;
        } else {
          if (Math.abs(y - originY) > Math.abs(x - originX)) {
            ({ width, height } = getPerfectElementSize(
              elementType,
              height,
              x < originX ? -width : width
            ));
          } else {
            ({ width, height } = getPerfectElementSize(
              elementType,
              width,
              y < originY ? -height : height
            ));
          }
          if (height < 0) {
            height = -height;
          }
        }
      }
      let newX = x < originX ? originX - width : originX;
      let newY = y < originY ? originY - height : originY;
      if (shouldResizeFromCenter2) {
        width += width;
        height += height;
        newX = originX - width / 2;
        newY = originY - height / 2;
      }
      let textAutoResize = null;
      if (isTextElement(newElement2)) {
        height = newElement2.height;
        const minWidth = getMinTextElementWidth(
          getFontString({
            fontSize: newElement2.fontSize,
            fontFamily: newElement2.fontFamily
          }),
          newElement2.lineHeight
        );
        width = Math.max(width, minWidth);
        if (Math.abs(x - originX) > TEXT_AUTOWRAP_THRESHOLD / zoom) {
          textAutoResize = {
            autoResize: false
          };
        }
        newY = originY;
        if (shouldResizeFromCenter2) {
          newX = originX - width / 2;
        }
      }
      if (width !== 0 && height !== 0) {
        mutateElement(
          newElement2,
          {
            x: newX + (originOffset?.x ?? 0),
            y: newY + (originOffset?.y ?? 0),
            width,
            height,
            ...textAutoResize
          },
          informMutation
        );
      }
    };
  }
});

// element/showSelectedShapeActions.ts
var showSelectedShapeActions;
var init_showSelectedShapeActions = __esm({
  "element/showSelectedShapeActions.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_scene();
    showSelectedShapeActions = (appState, elements) => Boolean(
      !appState.viewModeEnabled && (appState.activeTool.type !== "custom" && (appState.editingTextElement || appState.activeTool.type !== "selection" && appState.activeTool.type !== "eraser" && appState.activeTool.type !== "hand" && appState.activeTool.type !== "laser") || getSelectedElements(elements, appState).length)
    );
  }
});

// element/index.ts
var getSceneVersion, hashElementsVersion, hashString, getVisibleElements, getNonDeletedElements2, isNonDeletedElement, _clearElements, clearElementsForDatabase, clearElementsForExport;
var init_element = __esm({
  "element/index.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_sizeHelpers();
    init_typeChecks();
    init_newElement();
    init_bounds();
    init_transformHandles();
    init_resizeTest();
    init_resizeElements();
    init_dragElements();
    init_typeChecks();
    init_textElement();
    init_sizeHelpers();
    init_showSelectedShapeActions();
    getSceneVersion = (elements) => elements.reduce((acc, el) => acc + el.version, 0);
    hashElementsVersion = (elements) => {
      let hash = 5381;
      for (let i = 0; i < elements.length; i++) {
        hash = (hash << 5) + hash + elements[i].versionNonce;
      }
      return hash >>> 0;
    };
    hashString = (s) => {
      let hash = 5381;
      for (let i = 0; i < s.length; i++) {
        const char = s.charCodeAt(i);
        hash = (hash << 5) + hash + char;
      }
      return hash >>> 0;
    };
    getVisibleElements = (elements) => elements.filter(
      (el) => !el.isDeleted && !isInvisiblySmallElement(el)
    );
    getNonDeletedElements2 = (elements) => elements.filter((element) => !element.isDeleted);
    isNonDeletedElement = (element) => !element.isDeleted;
    _clearElements = (elements) => getNonDeletedElements2(elements).map(
      (element) => isLinearElementType(element.type) ? { ...element, lastCommittedPoint: null } : element
    );
    clearElementsForDatabase = (elements) => _clearElements(elements);
    clearElementsForExport = (elements) => _clearElements(elements);
  }
});

// scene/selection.ts
var excludeElementsInFramesFromSelection, getElementsWithinSelection, getVisibleAndNonSelectedElements, isSomeElementSelected, getCommonAttributeOfSelectedElements, getSelectedElements, getTargetElements, makeNextSelectedElementIds;
var init_selection = __esm({
  "scene/selection.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_element();
    init_typeChecks();
    init_frame();
    init_utils2();
    init_sizeHelpers();
    excludeElementsInFramesFromSelection = (selectedElements) => {
      const framesInSelection = /* @__PURE__ */ new Set();
      selectedElements.forEach((element) => {
        if (isFrameLikeElement(element)) {
          framesInSelection.add(element.id);
        }
      });
      return selectedElements.filter((element) => {
        if (element.frameId && framesInSelection.has(element.frameId)) {
          return false;
        }
        return true;
      });
    };
    getElementsWithinSelection = (elements, selection, elementsMap, excludeElementsInFrames = true) => {
      const [selectionX1, selectionY1, selectionX2, selectionY2] = getElementAbsoluteCoords(selection, elementsMap);
      let elementsInSelection = elements.filter((element) => {
        let [elementX1, elementY1, elementX2, elementY2] = getElementBounds(
          element,
          elementsMap
        );
        const containingFrame = getContainingFrame(element, elementsMap);
        if (containingFrame) {
          const [fx1, fy1, fx2, fy2] = getElementBounds(
            containingFrame,
            elementsMap
          );
          elementX1 = Math.max(fx1, elementX1);
          elementY1 = Math.max(fy1, elementY1);
          elementX2 = Math.min(fx2, elementX2);
          elementY2 = Math.min(fy2, elementY2);
        }
        return element.locked === false && element.type !== "selection" && !isBoundToContainer(element) && selectionX1 <= elementX1 && selectionY1 <= elementY1 && selectionX2 >= elementX2 && selectionY2 >= elementY2;
      });
      elementsInSelection = excludeElementsInFrames ? excludeElementsInFramesFromSelection(elementsInSelection) : elementsInSelection;
      elementsInSelection = elementsInSelection.filter((element) => {
        const containingFrame = getContainingFrame(element, elementsMap);
        if (containingFrame) {
          return elementOverlapsWithFrame(element, containingFrame, elementsMap);
        }
        return true;
      });
      return elementsInSelection;
    };
    getVisibleAndNonSelectedElements = (elements, selectedElements, appState, elementsMap) => {
      const selectedElementsSet = new Set(
        selectedElements.map((element) => element.id)
      );
      return elements.filter((element) => {
        const isVisible = isElementInViewport(
          element,
          appState.width,
          appState.height,
          appState,
          elementsMap
        );
        return !selectedElementsSet.has(element.id) && isVisible;
      });
    };
    isSomeElementSelected = function() {
      let lastElements = null;
      let lastSelectedElementIds = null;
      let isSelected = null;
      const ret = (elements, appState) => {
        if (isSelected != null && elements === lastElements && appState.selectedElementIds === lastSelectedElementIds) {
          return isSelected;
        }
        isSelected = elements.some(
          (element) => appState.selectedElementIds[element.id]
        );
        lastElements = elements;
        lastSelectedElementIds = appState.selectedElementIds;
        return isSelected;
      };
      ret.clearCache = () => {
        lastElements = null;
        lastSelectedElementIds = null;
        isSelected = null;
      };
      return ret;
    }();
    getCommonAttributeOfSelectedElements = (elements, appState, getAttribute) => {
      const attributes = Array.from(
        new Set(
          getSelectedElements(elements, appState).map(
            (element) => getAttribute(element)
          )
        )
      );
      return attributes.length === 1 ? attributes[0] : null;
    };
    getSelectedElements = (elements, appState, opts) => {
      const selectedElements = [];
      for (const element of elements.values()) {
        if (appState.selectedElementIds[element.id]) {
          selectedElements.push(element);
          continue;
        }
        if (opts?.includeBoundTextElement && isBoundToContainer(element) && appState.selectedElementIds[element?.containerId]) {
          selectedElements.push(element);
          continue;
        }
      }
      if (opts?.includeElementsInFrames) {
        const elementsToInclude = [];
        selectedElements.forEach((element) => {
          if (isFrameLikeElement(element)) {
            getFrameChildren(elements, element.id).forEach(
              (e) => elementsToInclude.push(e)
            );
          }
          elementsToInclude.push(element);
        });
        return elementsToInclude;
      }
      return selectedElements;
    };
    getTargetElements = (elements, appState) => appState.editingTextElement ? [appState.editingTextElement] : appState.newElement ? [appState.newElement] : getSelectedElements(elements, appState, {
      includeBoundTextElement: true
    });
    makeNextSelectedElementIds = (nextSelectedElementIds, prevState) => {
      if (isShallowEqual(prevState.selectedElementIds, nextSelectedElementIds)) {
        return prevState.selectedElementIds;
      }
      return nextSelectedElementIds;
    };
  }
});

// scene/scroll.ts
var isOutsideViewPort, centerScrollOn, calculateScrollCenter;
var init_scroll = __esm({
  "scene/scroll.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_element();
    init_utils2();
    isOutsideViewPort = (appState, cords) => {
      const [x1, y1, x2, y2] = cords;
      const { x: viewportX1, y: viewportY1 } = sceneCoordsToViewportCoords(
        { sceneX: x1, sceneY: y1 },
        appState
      );
      const { x: viewportX2, y: viewportY2 } = sceneCoordsToViewportCoords(
        { sceneX: x2, sceneY: y2 },
        appState
      );
      return viewportX2 - viewportX1 > appState.width || viewportY2 - viewportY1 > appState.height;
    };
    centerScrollOn = ({
      scenePoint,
      viewportDimensions,
      zoom,
      offsets
    }) => {
      let scrollX = (viewportDimensions.width - (offsets?.right ?? 0)) / 2 / zoom.value - scenePoint.x;
      scrollX += (offsets?.left ?? 0) / 2 / zoom.value;
      let scrollY = (viewportDimensions.height - (offsets?.bottom ?? 0)) / 2 / zoom.value - scenePoint.y;
      scrollY += (offsets?.top ?? 0) / 2 / zoom.value;
      return {
        scrollX,
        scrollY
      };
    };
    calculateScrollCenter = (elements, appState) => {
      elements = getVisibleElements(elements);
      if (!elements.length) {
        return {
          scrollX: 0,
          scrollY: 0
        };
      }
      let [x1, y1, x2, y2] = getCommonBounds(elements);
      if (isOutsideViewPort(appState, [x1, y1, x2, y2])) {
        [x1, y1, x2, y2] = getClosestElementBounds(
          elements,
          viewportCoordsToSceneCoords(
            { clientX: appState.scrollX, clientY: appState.scrollY },
            appState
          )
        );
      }
      const centerX = (x1 + x2) / 2;
      const centerY = (y1 + y2) / 2;
      return centerScrollOn({
        scenePoint: { x: centerX, y: centerY },
        viewportDimensions: { width: appState.width, height: appState.height },
        zoom: appState.zoom
      });
    };
  }
});

// scene/normalize.ts
var getNormalizedZoom, getNormalizedGridSize, getNormalizedGridStep;
var init_normalize = __esm({
  "scene/normalize.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_math();
    init_constants();
    getNormalizedZoom = (zoom) => {
      return clamp(round(zoom, 6), MIN_ZOOM, MAX_ZOOM);
    };
    getNormalizedGridSize = (gridStep) => {
      return clamp(Math.round(gridStep), 1, 100);
    };
    getNormalizedGridStep = (gridStep) => {
      return clamp(Math.round(gridStep), 1, 100);
    };
  }
});

// scene/index.ts
var init_scene = __esm({
  "scene/index.ts"() {
    "use strict";
    init_define_import_meta_env();
    init_selection();
    init_scroll();
    init_comparisons();
    init_normalize();
  }
});

// index.tsx
init_define_import_meta_env();
import React44, { useEffect as useEffect41 } from "react";

// components/InitializeApp.tsx
init_define_import_meta_env();
import { useEffect as useEffect2, useState as useState2 } from "react";

// components/LoadingMessage.tsx
init_define_import_meta_env();

// i18n.ts
init_define_import_meta_env();
import fallbackLangData from "./en-QJZTDUGK.json";
import percentages from "./percentages-UCQDHIQF.json";

// jotai.ts
init_define_import_meta_env();
import { unstable_createStore, useAtom } from "jotai";
import { useLayoutEffect } from "react";
var jotaiScope = Symbol();
var jotaiStore = unstable_createStore();

// i18n.ts
import { atom, useAtomValue } from "jotai";

// import("./locales/**/*.json") in i18n.ts
var globImport_locales_json = __glob({
  "./locales/ar-SA.json": () => import("./ar-SA-JA6F2FMJ.json"),
  "./locales/az-AZ.json": () => import("./az-AZ-GVIENQVH.json"),
  "./locales/bg-BG.json": () => import("./bg-BG-YFNNHCEP.json"),
  "./locales/bn-BD.json": () => import("./bn-BD-LMEIWSRD.json"),
  "./locales/ca-ES.json": () => import("./ca-ES-C2WGCLOT.json"),
  "./locales/cs-CZ.json": () => import("./cs-CZ-F2NDIQMB.json"),
  "./locales/da-DK.json": () => import("./da-DK-WBEQB3CJ.json"),
  "./locales/de-DE.json": () => import("./de-DE-VEIMCP7R.json"),
  "./locales/el-GR.json": () => import("./el-GR-TKRKG5GQ.json"),
  "./locales/en.json": () => import("./en-QJZTDUGK.json"),
  "./locales/es-ES.json": () => import("./es-ES-TOLWEZNW.json"),
  "./locales/eu-ES.json": () => import("./eu-ES-7CDRJQWJ.json"),
  "./locales/fa-IR.json": () => import("./fa-IR-527E2XGU.json"),
  "./locales/fi-FI.json": () => import("./fi-FI-NLQ7RQGZ.json"),
  "./locales/fr-FR.json": () => import("./fr-FR-KUHO4FLU.json"),
  "./locales/gl-ES.json": () => import("./gl-ES-NEXX3VBB.json"),
  "./locales/he-IL.json": () => import("./he-IL-MED2VGBZ.json"),
  "./locales/hi-IN.json": () => import("./hi-IN-5V633W7V.json"),
  "./locales/hu-HU.json": () => import("./hu-HU-2FOZGVGR.json"),
  "./locales/id-ID.json": () => import("./id-ID-I6BOLXTF.json"),
  "./locales/it-IT.json": () => import("./it-IT-WKPQOK4P.json"),
  "./locales/ja-JP.json": () => import("./ja-JP-VKA4ISRU.json"),
  "./locales/kaa.json": () => import("./kaa-IKPRSBNY.json"),
  "./locales/kab-KAB.json": () => import("./kab-KAB-IE4PHQTZ.json"),
  "./locales/kk-KZ.json": () => import("./kk-KZ-MNJT6XSV.json"),
  "./locales/km-KH.json": () => import("./km-KH-LADGDFXV.json"),
  "./locales/ko-KR.json": () => import("./ko-KR-XD7AVF2F.json"),
  "./locales/ku-TR.json": () => import("./ku-TR-4XBHKDQA.json"),
  "./locales/lt-LT.json": () => import("./lt-LT-QC35R4YH.json"),
  "./locales/lv-LV.json": () => import("./lv-LV-GSD5D3BA.json"),
  "./locales/mr-IN.json": () => import("./mr-IN-KOLSWM7Y.json"),
  "./locales/my-MM.json": () => import("./my-MM-M53KMUET.json"),
  "./locales/nb-NO.json": () => import("./nb-NO-XXC6U37A.json"),
  "./locales/nl-NL.json": () => import("./nl-NL-HCCJQEUO.json"),
  "./locales/nn-NO.json": () => import("./nn-NO-6P7Z2PI2.json"),
  "./locales/oc-FR.json": () => import("./oc-FR-JRJKPLNT.json"),
  "./locales/pa-IN.json": () => import("./pa-IN-LZWLEPIB.json"),
  "./locales/percentages.json": () => import("./percentages-UCQDHIQF.json"),
  "./locales/pl-PL.json": () => import("./pl-PL-3WBLCXI2.json"),
  "./locales/pt-BR.json": () => import("./pt-BR-O3ZPTUNW.json"),
  "./locales/pt-PT.json": () => import("./pt-PT-7AQTSAFO.json"),
  "./locales/ro-RO.json": () => import("./ro-RO-HJ65JYWV.json"),
  "./locales/ru-RU.json": () => import("./ru-RU-P7ROIYNC.json"),
  "./locales/si-LK.json": () => import("./si-LK-7ZSWVION.json"),
  "./locales/sk-SK.json": () => import("./sk-SK-NXVBGLYY.json"),
  "./locales/sl-SI.json": () => import("./sl-SI-VFTWOYNP.json"),
  "./locales/sv-SE.json": () => import("./sv-SE-YONBLQNW.json"),
  "./locales/ta-IN.json": () => import("./ta-IN-BSETPMLX.json"),
  "./locales/th-TH.json": () => import("./th-TH-URTRDITB.json"),
  "./locales/tr-TR.json": () => import("./tr-TR-N5SCAVTB.json"),
  "./locales/uk-UA.json": () => import("./uk-UA-LBCYVSQZ.json"),
  "./locales/vi-VN.json": () => import("./vi-VN-POZWLIUU.json"),
  "./locales/zh-CN.json": () => import("./zh-CN-FUF5V3SC.json"),
  "./locales/zh-HK.json": () => import("./zh-HK-OB4VW42C.json"),
  "./locales/zh-TW.json": () => import("./zh-TW-5JPVKOM7.json")
});

// i18n.ts
var COMPLETION_THRESHOLD = 85;
var defaultLang = { code: "en", label: "English" };
var languages = [
  defaultLang,
  ...[
    { code: "ar-SA", label: "\u0627\u0644\u0639\u0631\u0628\u064A\u0629", rtl: true },
    { code: "bg-BG", label: "\u0411\u044A\u043B\u0433\u0430\u0440\u0441\u043A\u0438" },
    { code: "ca-ES", label: "Catal\xE0" },
    { code: "cs-CZ", label: "\u010Cesky" },
    { code: "de-DE", label: "Deutsch" },
    { code: "el-GR", label: "\u0395\u03BB\u03BB\u03B7\u03BD\u03B9\u03BA\u03AC" },
    { code: "es-ES", label: "Espa\xF1ol" },
    { code: "eu-ES", label: "Euskara" },
    { code: "fa-IR", label: "\u0641\u0627\u0631\u0633\u06CC", rtl: true },
    { code: "fi-FI", label: "Suomi" },
    { code: "fr-FR", label: "Fran\xE7ais" },
    { code: "gl-ES", label: "Galego" },
    { code: "he-IL", label: "\u05E2\u05D1\u05E8\u05D9\u05EA", rtl: true },
    { code: "hi-IN", label: "\u0939\u093F\u0928\u094D\u0926\u0940" },
    { code: "hu-HU", label: "Magyar" },
    { code: "id-ID", label: "Bahasa Indonesia" },
    { code: "it-IT", label: "Italiano" },
    { code: "ja-JP", label: "\u65E5\u672C\u8A9E" },
    { code: "kab-KAB", label: "Taqbaylit" },
    { code: "kk-KZ", label: "\u049A\u0430\u0437\u0430\u049B \u0442\u0456\u043B\u0456" },
    { code: "ko-KR", label: "\uD55C\uAD6D\uC5B4" },
    { code: "ku-TR", label: "Kurd\xEE" },
    { code: "lt-LT", label: "Lietuvi\u0173" },
    { code: "lv-LV", label: "Latvie\u0161u" },
    { code: "my-MM", label: "Burmese" },
    { code: "nb-NO", label: "Norsk bokm\xE5l" },
    { code: "nl-NL", label: "Nederlands" },
    { code: "nn-NO", label: "Norsk nynorsk" },
    { code: "oc-FR", label: "Occitan" },
    { code: "pa-IN", label: "\u0A2A\u0A70\u0A1C\u0A3E\u0A2C\u0A40" },
    { code: "pl-PL", label: "Polski" },
    { code: "pt-BR", label: "Portugu\xEAs Brasileiro" },
    { code: "pt-PT", label: "Portugu\xEAs" },
    { code: "ro-RO", label: "Rom\xE2n\u0103" },
    { code: "ru-RU", label: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439" },
    { code: "sk-SK", label: "Sloven\u010Dina" },
    { code: "sv-SE", label: "Svenska" },
    { code: "sl-SI", label: "Sloven\u0161\u010Dina" },
    { code: "tr-TR", label: "T\xFCrk\xE7e" },
    { code: "uk-UA", label: "\u0423\u043A\u0440\u0430\u0457\u043D\u0441\u044C\u043A\u0430" },
    { code: "zh-CN", label: "\u7B80\u4F53\u4E2D\u6587" },
    { code: "zh-TW", label: "\u7E41\u9AD4\u4E2D\u6587" },
    { code: "vi-VN", label: "Ti\u1EBFng Vi\u1EC7t" },
    { code: "mr-IN", label: "\u092E\u0930\u093E\u0920\u0940" }
  ].filter(
    (lang) => percentages[lang.code] >= COMPLETION_THRESHOLD
  ).sort((left, right) => left.label > right.label ? 1 : -1)
];
var TEST_LANG_CODE = "__test__";
if (define_import_meta_env_default.DEV) {
  languages.unshift(
    { code: TEST_LANG_CODE, label: "test language" },
    {
      code: `${TEST_LANG_CODE}.rtl`,
      label: "\u202Atest language (rtl)\u202C",
      rtl: true
    }
  );
}
var currentLang = defaultLang;
var currentLangData = {};
var setLanguage = async (lang) => {
  currentLang = lang;
  document.documentElement.dir = currentLang.rtl ? "rtl" : "ltr";
  document.documentElement.lang = currentLang.code;
  if (lang.code.startsWith(TEST_LANG_CODE)) {
    currentLangData = {};
  } else {
    try {
      currentLangData = await globImport_locales_json(`./locales/${currentLang.code}.json`);
    } catch (error) {
      console.error(`Failed to load language ${lang.code}:`, error.message);
      currentLangData = fallbackLangData;
    }
  }
  jotaiStore.set(editorLangCodeAtom, lang.code);
};
var getLanguage = () => currentLang;
var findPartsForData = (data, parts) => {
  for (let index = 0; index < parts.length; ++index) {
    const part = parts[index];
    if (data[part] === void 0) {
      return void 0;
    }
    data = data[part];
  }
  if (typeof data !== "string") {
    return void 0;
  }
  return data;
};
var t = (path, replacement, fallback) => {
  if (currentLang.code.startsWith(TEST_LANG_CODE)) {
    const name = replacement ? `${path}(${JSON.stringify(replacement).slice(1, -1)})` : path;
    return `\u202A[[${name}]]\u202C`;
  }
  const parts = path.split(".");
  let translation2 = findPartsForData(currentLangData, parts) || findPartsForData(fallbackLangData, parts) || fallback;
  if (translation2 === void 0) {
    const errorMessage = `Can't find translation for ${path}`;
    if (define_import_meta_env_default.PROD) {
      console.warn(errorMessage);
      return "";
    }
    throw new Error(errorMessage);
  }
  if (replacement) {
    for (const key in replacement) {
      translation2 = translation2.replace(`{{${key}}}`, String(replacement[key]));
    }
  }
  return translation2;
};
var editorLangCodeAtom = atom(defaultLang.code);
var useI18n = () => {
  const langCode = useAtomValue(editorLangCodeAtom, jotaiScope);
  return { t, langCode };
};

// components/LoadingMessage.tsx
import { useState, useEffect } from "react";

// components/Spinner.tsx
init_define_import_meta_env();
import React from "react";
import { jsx } from "react/jsx-runtime";
var Spinner = ({
  size = "1em",
  circleWidth = 8,
  synchronized = false,
  className = ""
}) => {
  const mountTime = React.useRef(Date.now());
  const mountDelay = -(mountTime.current % 1600);
  return /* @__PURE__ */ jsx("div", { className: `Spinner ${className}`, children: /* @__PURE__ */ jsx(
    "svg",
    {
      viewBox: "0 0 100 100",
      style: {
        width: size,
        height: size,
        // fix for remounting causing spinner flicker
        ["--spinner-delay"]: synchronized ? `${mountDelay}ms` : 0
      },
      children: /* @__PURE__ */ jsx(
        "circle",
        {
          cx: "50",
          cy: "50",
          r: 50 - circleWidth / 2,
          strokeWidth: circleWidth,
          fill: "none",
          strokeMiterlimit: "10"
        }
      )
    }
  ) });
};
var Spinner_default = Spinner;

// components/LoadingMessage.tsx
init_constants();
import clsx from "clsx";
import { jsx as jsx2, jsxs } from "react/jsx-runtime";
var LoadingMessage = ({
  delay,
  theme
}) => {
  const [isWaiting, setIsWaiting] = useState(!!delay);
  useEffect(() => {
    if (!delay) {
      return;
    }
    const timer = setTimeout(() => {
      setIsWaiting(false);
    }, delay);
    return () => clearTimeout(timer);
  }, [delay]);
  if (isWaiting) {
    return null;
  }
  return /* @__PURE__ */ jsxs(
    "div",
    {
      className: clsx("LoadingMessage", {
        "LoadingMessage--dark": theme === THEME.DARK
      }),
      children: [
        /* @__PURE__ */ jsx2("div", { children: /* @__PURE__ */ jsx2(Spinner_default, {}) }),
        /* @__PURE__ */ jsx2("div", { className: "LoadingMessage-text", children: t("labels.loadingScene") })
      ]
    }
  );
};

// components/InitializeApp.tsx
import { jsx as jsx3 } from "react/jsx-runtime";
var InitializeApp = (props) => {
  const [loading, setLoading] = useState2(true);
  useEffect2(() => {
    const updateLang = async () => {
      await setLanguage(currentLang2);
      setLoading(false);
    };
    const currentLang2 = languages.find((lang) => lang.code === props.langCode) || defaultLang;
    updateLang();
  }, [props.langCode]);
  return loading ? /* @__PURE__ */ jsx3(LoadingMessage, { theme: props.theme }) : props.children;
};

// components/App.tsx
init_define_import_meta_env();
import React43, { useContext as useContext3 } from "react";
import { flushSync } from "react-dom";
import rough4 from "roughjs/bin/rough";
import clsx56 from "clsx";
import { nanoid as nanoid3 } from "nanoid";

// actions/index.ts
init_define_import_meta_env();

// actions/actionDeleteSelected.tsx
init_define_import_meta_env();
init_scene();
init_keys();

// components/ToolButton.tsx
init_define_import_meta_env();
import React4, { useEffect as useEffect3, useRef, useState as useState3 } from "react";
import clsx3 from "clsx";
init_errors();
init_utils2();
import { jsx as jsx5, jsxs as jsxs3 } from "react/jsx-runtime";
var ToolButton = React4.forwardRef((props, ref) => {
  const { id: excalId } = useExcalidrawContainer();
  const innerRef = React4.useRef(null);
  React4.useImperativeHandle(ref, () => innerRef.current);
  const sizeCn = `ToolIcon_size_${props.size}`;
  const [isLoading, setIsLoading] = useState3(false);
  const isMountedRef = useRef(true);
  const onClick = async (event) => {
    const ret = "onClick" in props && props.onClick?.(event);
    if (isPromiseLike(ret)) {
      try {
        setIsLoading(true);
        await ret;
      } catch (error) {
        if (!(error instanceof AbortError)) {
          throw error;
        } else {
          console.warn(error);
        }
      } finally {
        if (isMountedRef.current) {
          setIsLoading(false);
        }
      }
    }
  };
  useEffect3(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  const lastPointerTypeRef = useRef(null);
  if (props.type === "button" || props.type === "icon" || props.type === "submit") {
    const type = props.type === "icon" ? "button" : props.type;
    return /* @__PURE__ */ jsxs3(
      "button",
      {
        className: clsx3(
          "ToolIcon_type_button",
          sizeCn,
          props.className,
          props.visible && !props.hidden ? "ToolIcon_type_button--show" : "ToolIcon_type_button--hide",
          {
            ToolIcon: !props.hidden,
            "ToolIcon--selected": props.selected,
            "ToolIcon--plain": props.type === "icon"
          }
        ),
        style: props.style,
        "data-testid": props["data-testid"],
        hidden: props.hidden,
        title: props.title,
        "aria-label": props["aria-label"],
        type,
        onClick,
        ref: innerRef,
        disabled: isLoading || props.isLoading || !!props.disabled,
        children: [
          (props.icon || props.label) && /* @__PURE__ */ jsxs3(
            "div",
            {
              className: "ToolIcon__icon",
              "aria-hidden": "true",
              "aria-disabled": !!props.disabled,
              children: [
                props.icon || props.label,
                props.keyBindingLabel && /* @__PURE__ */ jsx5("span", { className: "ToolIcon__keybinding", children: props.keyBindingLabel }),
                props.isLoading && /* @__PURE__ */ jsx5(Spinner_default, {})
              ]
            }
          ),
          props.showAriaLabel && /* @__PURE__ */ jsxs3("div", { className: "ToolIcon__label", children: [
            props["aria-label"],
            " ",
            isLoading && /* @__PURE__ */ jsx5(Spinner_default, {})
          ] }),
          props.children
        ]
      }
    );
  }
  return /* @__PURE__ */ jsxs3(
    "label",
    {
      className: clsx3("ToolIcon", props.className),
      title: props.title,
      onPointerDown: (event) => {
        lastPointerTypeRef.current = event.pointerType || null;
        props.onPointerDown?.({ pointerType: event.pointerType || null });
      },
      onPointerUp: () => {
        requestAnimationFrame(() => {
          lastPointerTypeRef.current = null;
        });
      },
      children: [
        /* @__PURE__ */ jsx5(
          "input",
          {
            className: `ToolIcon_type_radio ${sizeCn}`,
            type: "radio",
            name: props.name,
            "aria-label": props["aria-label"],
            "aria-keyshortcuts": props["aria-keyshortcuts"],
            "data-testid": props["data-testid"],
            id: `${excalId}-${props.id}`,
            onChange: () => {
              props.onChange?.({ pointerType: lastPointerTypeRef.current });
            },
            checked: props.checked,
            ref: innerRef
          }
        ),
        /* @__PURE__ */ jsxs3("div", { className: "ToolIcon__icon", children: [
          props.icon,
          props.keyBindingLabel && /* @__PURE__ */ jsx5("span", { className: "ToolIcon__keybinding", children: props.keyBindingLabel })
        ] })
      ]
    }
  );
});
ToolButton.defaultProps = {
  visible: true,
  className: "",
  size: "medium"
};
ToolButton.displayName = "ToolButton";

// actions/actionDeleteSelected.tsx
init_register();
init_element();
init_mutateElement();
init_groups();
init_linearElementEditor();
init_binding();
init_typeChecks();
init_utils2();
init_icons();
init_store();
init_routing();
import { jsx as jsx6 } from "react/jsx-runtime";
var deleteSelectedElements = (elements, appState, app) => {
  const elementsMap = app.scene.getNonDeletedElementsMap();
  const framesToBeDeleted = new Set(
    getSelectedElements(
      elements.filter((el) => isFrameLikeElement(el)),
      appState
    ).map((el) => el.id)
  );
  return {
    elements: elements.map((el) => {
      if (appState.selectedElementIds[el.id]) {
        if (el.boundElements) {
          el.boundElements.forEach((candidate) => {
            const bound = app.scene.getNonDeletedElementsMap().get(candidate.id);
            if (bound && isElbowArrow(bound)) {
              mutateElement(bound, {
                startBinding: el.id === bound.startBinding?.elementId ? null : bound.startBinding,
                endBinding: el.id === bound.endBinding?.elementId ? null : bound.endBinding
              });
              mutateElbowArrow(bound, elementsMap, bound.points);
            }
          });
        }
        return newElementWith(el, { isDeleted: true });
      }
      if (el.frameId && framesToBeDeleted.has(el.frameId)) {
        return newElementWith(el, { isDeleted: true });
      }
      if (isBoundToContainer(el) && appState.selectedElementIds[el.containerId]) {
        return newElementWith(el, { isDeleted: true });
      }
      return el;
    }),
    appState: {
      ...appState,
      selectedElementIds: {},
      selectedGroupIds: {}
    }
  };
};
var handleGroupEditingState = (appState, elements) => {
  if (appState.editingGroupId) {
    const siblingElements = getElementsInGroup(
      getNonDeletedElements2(elements),
      appState.editingGroupId
    );
    if (siblingElements.length) {
      return {
        ...appState,
        selectedElementIds: { [siblingElements[0].id]: true }
      };
    }
  }
  return appState;
};
var actionDeleteSelected = register({
  name: "deleteSelectedElements",
  label: "labels.delete",
  icon: TrashIcon,
  trackEvent: { category: "element", action: "delete" },
  perform: (elements, appState, formData, app) => {
    if (appState.editingLinearElement) {
      const {
        elementId,
        selectedPointsIndices,
        startBindingElement,
        endBindingElement
      } = appState.editingLinearElement;
      const elementsMap = app.scene.getNonDeletedElementsMap();
      const element = LinearElementEditor.getElement(elementId, elementsMap);
      if (!element) {
        return false;
      }
      if (selectedPointsIndices == null) {
        return false;
      }
      if (element.points.length < 2) {
        const nextElements2 = elements.map((el) => {
          if (el.id === element.id) {
            return newElementWith(el, { isDeleted: true });
          }
          return el;
        });
        const nextAppState2 = handleGroupEditingState(appState, nextElements2);
        return {
          elements: nextElements2,
          appState: {
            ...nextAppState2,
            editingLinearElement: null
          },
          storeAction: StoreAction.CAPTURE
        };
      }
      const binding = {
        startBindingElement: selectedPointsIndices?.includes(0) ? null : startBindingElement,
        endBindingElement: selectedPointsIndices?.includes(
          element.points.length - 1
        ) ? null : endBindingElement
      };
      LinearElementEditor.deletePoints(
        element,
        selectedPointsIndices,
        elementsMap
      );
      return {
        elements,
        appState: {
          ...appState,
          editingLinearElement: {
            ...appState.editingLinearElement,
            ...binding,
            selectedPointsIndices: selectedPointsIndices?.[0] > 0 ? [selectedPointsIndices[0] - 1] : [0]
          }
        },
        storeAction: StoreAction.CAPTURE
      };
    }
    let { elements: nextElements, appState: nextAppState } = deleteSelectedElements(elements, appState, app);
    fixBindingsAfterDeletion(
      nextElements,
      elements.filter(({ id }) => appState.selectedElementIds[id])
    );
    nextAppState = handleGroupEditingState(nextAppState, nextElements);
    return {
      elements: nextElements,
      appState: {
        ...nextAppState,
        activeTool: updateActiveTool(appState, { type: "selection" }),
        multiElement: null,
        activeEmbeddable: null
      },
      storeAction: isSomeElementSelected(
        getNonDeletedElements2(elements),
        appState
      ) ? StoreAction.CAPTURE : StoreAction.NONE
    };
  },
  keyTest: (event, appState, elements) => (event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE) && !event[KEYS.CTRL_OR_CMD],
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ jsx6(
    ToolButton,
    {
      type: "button",
      icon: TrashIcon,
      title: t("labels.delete"),
      "aria-label": t("labels.delete"),
      onClick: () => updateData(null),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});

// actions/actionZindex.tsx
init_define_import_meta_env();

// zindex.ts
init_define_import_meta_env();
init_typeChecks();
init_fractionalIndex();
init_groups();
init_scene();
init_Scene();
init_utils2();
var isOfTargetFrame = (element, frameId) => {
  return element.frameId === frameId || element.id === frameId;
};
var getIndicesToMove = (elements, appState, elementsToBeMoved) => {
  let selectedIndices = [];
  let deletedIndices = [];
  let includeDeletedIndex = null;
  let index = -1;
  const selectedElementIds = arrayToMap(
    elementsToBeMoved ? elementsToBeMoved : getSelectedElements(elements, appState, {
      includeBoundTextElement: true,
      includeElementsInFrames: true
    })
  );
  while (++index < elements.length) {
    const element = elements[index];
    if (selectedElementIds.get(element.id)) {
      if (deletedIndices.length) {
        selectedIndices = selectedIndices.concat(deletedIndices);
        deletedIndices = [];
      }
      selectedIndices.push(index);
      includeDeletedIndex = index + 1;
    } else if (element.isDeleted && includeDeletedIndex === index) {
      includeDeletedIndex = index + 1;
      deletedIndices.push(index);
    } else {
      deletedIndices = [];
    }
  }
  return selectedIndices;
};
var toContiguousGroups = (array) => {
  let cursor = 0;
  return array.reduce((acc, value, index) => {
    if (index > 0 && array[index - 1] !== value - 1) {
      cursor = ++cursor;
    }
    (acc[cursor] || (acc[cursor] = [])).push(value);
    return acc;
  }, []);
};
var getTargetIndexAccountingForBinding = (nextElement, elements, direction) => {
  if ("containerId" in nextElement && nextElement.containerId) {
    const containerElement = Scene_default.getScene(nextElement).getElement(
      nextElement.containerId
    );
    if (containerElement) {
      return direction === "left" ? Math.min(
        elements.indexOf(containerElement),
        elements.indexOf(nextElement)
      ) : Math.max(
        elements.indexOf(containerElement),
        elements.indexOf(nextElement)
      );
    }
  } else {
    const boundElementId = nextElement.boundElements?.find(
      (binding) => binding.type !== "arrow"
    )?.id;
    if (boundElementId) {
      const boundTextElement = Scene_default.getScene(nextElement).getElement(boundElementId);
      if (boundTextElement) {
        return direction === "left" ? Math.min(
          elements.indexOf(boundTextElement),
          elements.indexOf(nextElement)
        ) : Math.max(
          elements.indexOf(boundTextElement),
          elements.indexOf(nextElement)
        );
      }
    }
  }
};
var getContiguousFrameRangeElements = (allElements, frameId) => {
  let rangeStart = -1;
  let rangeEnd = -1;
  allElements.forEach((element, index) => {
    if (isOfTargetFrame(element, frameId)) {
      if (rangeStart === -1) {
        rangeStart = index;
      }
      rangeEnd = index;
    }
  });
  if (rangeStart === -1) {
    return [];
  }
  return allElements.slice(rangeStart, rangeEnd + 1);
};
var getTargetIndex = (appState, elements, boundaryIndex, direction, containingFrame) => {
  const sourceElement = elements[boundaryIndex];
  const indexFilter = (element) => {
    if (element.isDeleted) {
      return false;
    }
    if (containingFrame) {
      return element.frameId === containingFrame;
    }
    if (appState.editingGroupId) {
      return element.groupIds.includes(appState.editingGroupId);
    }
    return true;
  };
  const candidateIndex = direction === "left" ? findLastIndex(
    elements,
    (el) => indexFilter(el),
    Math.max(0, boundaryIndex - 1)
  ) : findIndex(elements, (el) => indexFilter(el), boundaryIndex + 1);
  const nextElement = elements[candidateIndex];
  if (!nextElement) {
    return -1;
  }
  if (appState.editingGroupId) {
    if (
      // candidate element is a sibling in current editing group  return
      sourceElement?.groupIds.join("") === nextElement?.groupIds.join("")
    ) {
      return getTargetIndexAccountingForBinding(nextElement, elements, direction) ?? candidateIndex;
    } else if (!nextElement?.groupIds.includes(appState.editingGroupId)) {
      return -1;
    }
  }
  if (!containingFrame && (nextElement.frameId || isFrameLikeElement(nextElement))) {
    const frameElements = getContiguousFrameRangeElements(
      elements,
      nextElement.frameId || nextElement.id
    );
    return direction === "left" ? elements.indexOf(frameElements[0]) : elements.indexOf(frameElements[frameElements.length - 1]);
  }
  if (!nextElement.groupIds.length) {
    return getTargetIndexAccountingForBinding(nextElement, elements, direction) ?? candidateIndex;
  }
  const siblingGroupId = appState.editingGroupId ? nextElement.groupIds[nextElement.groupIds.indexOf(appState.editingGroupId) - 1] : nextElement.groupIds[nextElement.groupIds.length - 1];
  const elementsInSiblingGroup = getElementsInGroup(elements, siblingGroupId);
  if (elementsInSiblingGroup.length) {
    return direction === "left" ? elements.indexOf(elementsInSiblingGroup[0]) : elements.indexOf(
      elementsInSiblingGroup[elementsInSiblingGroup.length - 1]
    );
  }
  return candidateIndex;
};
var getTargetElementsMap = (elements, indices) => {
  return indices.reduce((acc, index) => {
    const element = elements[index];
    acc.set(element.id, element);
    return acc;
  }, /* @__PURE__ */ new Map());
};
var shiftElementsByOne = (elements, appState, direction) => {
  const indicesToMove = getIndicesToMove(elements, appState);
  const targetElementsMap = getTargetElementsMap(elements, indicesToMove);
  let groupedIndices = toContiguousGroups(indicesToMove);
  if (direction === "right") {
    groupedIndices = groupedIndices.reverse();
  }
  const selectedFrames = new Set(
    indicesToMove.filter((idx) => isFrameLikeElement(elements[idx])).map((idx) => elements[idx].id)
  );
  groupedIndices.forEach((indices, i) => {
    const leadingIndex = indices[0];
    const trailingIndex = indices[indices.length - 1];
    const boundaryIndex = direction === "left" ? leadingIndex : trailingIndex;
    const containingFrame = indices.some((idx) => {
      const el = elements[idx];
      return el.frameId && selectedFrames.has(el.frameId);
    }) ? null : elements[boundaryIndex]?.frameId;
    const targetIndex = getTargetIndex(
      appState,
      elements,
      boundaryIndex,
      direction,
      containingFrame
    );
    if (targetIndex === -1 || boundaryIndex === targetIndex) {
      return;
    }
    const leadingElements = direction === "left" ? elements.slice(0, targetIndex) : elements.slice(0, leadingIndex);
    const targetElements = elements.slice(leadingIndex, trailingIndex + 1);
    const displacedElements = direction === "left" ? elements.slice(targetIndex, leadingIndex) : elements.slice(trailingIndex + 1, targetIndex + 1);
    const trailingElements = direction === "left" ? elements.slice(trailingIndex + 1) : elements.slice(targetIndex + 1);
    elements = direction === "left" ? [
      ...leadingElements,
      ...targetElements,
      ...displacedElements,
      ...trailingElements
    ] : [
      ...leadingElements,
      ...displacedElements,
      ...targetElements,
      ...trailingElements
    ];
  });
  syncMovedIndices(elements, targetElementsMap);
  return elements;
};
var shiftElementsToEnd = (elements, appState, direction, containingFrame, elementsToBeMoved) => {
  const indicesToMove = getIndicesToMove(elements, appState, elementsToBeMoved);
  const targetElementsMap = getTargetElementsMap(elements, indicesToMove);
  const displacedElements = [];
  let leadingIndex;
  let trailingIndex;
  if (direction === "left") {
    if (containingFrame) {
      leadingIndex = findIndex(
        elements,
        (el) => isOfTargetFrame(el, containingFrame)
      );
    } else if (appState.editingGroupId) {
      const groupElements = getElementsInGroup(
        elements,
        appState.editingGroupId
      );
      if (!groupElements.length) {
        return elements;
      }
      leadingIndex = elements.indexOf(groupElements[0]);
    } else {
      leadingIndex = 0;
    }
    trailingIndex = indicesToMove[indicesToMove.length - 1];
  } else {
    if (containingFrame) {
      trailingIndex = findLastIndex(
        elements,
        (el) => isOfTargetFrame(el, containingFrame)
      );
    } else if (appState.editingGroupId) {
      const groupElements = getElementsInGroup(
        elements,
        appState.editingGroupId
      );
      if (!groupElements.length) {
        return elements;
      }
      trailingIndex = elements.indexOf(groupElements[groupElements.length - 1]);
    } else {
      trailingIndex = elements.length - 1;
    }
    leadingIndex = indicesToMove[0];
  }
  if (leadingIndex === -1) {
    leadingIndex = 0;
  }
  for (let index = leadingIndex; index < trailingIndex + 1; index++) {
    if (!indicesToMove.includes(index)) {
      displacedElements.push(elements[index]);
    }
  }
  const targetElements = Array.from(targetElementsMap.values());
  const leadingElements = elements.slice(0, leadingIndex);
  const trailingElements = elements.slice(trailingIndex + 1);
  const nextElements = direction === "left" ? [
    ...leadingElements,
    ...targetElements,
    ...displacedElements,
    ...trailingElements
  ] : [
    ...leadingElements,
    ...displacedElements,
    ...targetElements,
    ...trailingElements
  ];
  syncMovedIndices(nextElements, targetElementsMap);
  return nextElements;
};
function shiftElementsAccountingForFrames(allElements, appState, direction, shiftFunction) {
  const elementsToMove = arrayToMap(
    getSelectedElements(allElements, appState, {
      includeBoundTextElement: true,
      includeElementsInFrames: true
    })
  );
  const frameAwareContiguousElementsToMove = { regularElements: [], frameChildren: /* @__PURE__ */ new Map() };
  const fullySelectedFrames = /* @__PURE__ */ new Set();
  for (const element of allElements) {
    if (elementsToMove.has(element.id) && isFrameLikeElement(element)) {
      fullySelectedFrames.add(element.id);
    }
  }
  for (const element of allElements) {
    if (elementsToMove.has(element.id)) {
      if (isFrameLikeElement(element) || element.frameId && fullySelectedFrames.has(element.frameId)) {
        frameAwareContiguousElementsToMove.regularElements.push(element);
      } else if (!element.frameId) {
        frameAwareContiguousElementsToMove.regularElements.push(element);
      } else {
        const frameChildren = frameAwareContiguousElementsToMove.frameChildren.get(
          element.frameId
        ) || [];
        frameChildren.push(element);
        frameAwareContiguousElementsToMove.frameChildren.set(
          element.frameId,
          frameChildren
        );
      }
    }
  }
  let nextElements = allElements;
  const frameChildrenSets = Array.from(
    frameAwareContiguousElementsToMove.frameChildren.entries()
  );
  for (const [frameId, children] of frameChildrenSets) {
    nextElements = shiftFunction(
      allElements,
      appState,
      direction,
      frameId,
      children
    );
  }
  return shiftFunction(
    nextElements,
    appState,
    direction,
    null,
    frameAwareContiguousElementsToMove.regularElements
  );
}
var moveOneLeft = (allElements, appState) => {
  return shiftElementsByOne(allElements, appState, "left");
};
var moveOneRight = (allElements, appState) => {
  return shiftElementsByOne(allElements, appState, "right");
};
var moveAllLeft = (allElements, appState) => {
  return shiftElementsAccountingForFrames(
    allElements,
    appState,
    "left",
    shiftElementsToEnd
  );
};
var moveAllRight = (allElements, appState) => {
  return shiftElementsAccountingForFrames(
    allElements,
    appState,
    "right",
    shiftElementsToEnd
  );
};

// actions/actionZindex.tsx
init_keys();
init_utils2();
init_register();
init_icons();
init_constants();
init_store();
import { jsx as jsx7 } from "react/jsx-runtime";
var actionSendBackward = register({
  name: "sendBackward",
  label: "labels.sendBackward",
  keywords: ["move down", "zindex", "layer"],
  icon: SendBackwardIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState) => {
    return {
      elements: moveOneLeft(elements, appState),
      appState,
      storeAction: StoreAction.CAPTURE
    };
  },
  keyPriority: 40,
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && !event.shiftKey && event.code === CODES.BRACKET_LEFT,
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ jsx7(
    "button",
    {
      type: "button",
      className: "zIndexButton",
      onClick: () => updateData(null),
      title: `${t("labels.sendBackward")} \u2014 ${getShortcutKey("CtrlOrCmd+[")}`,
      children: SendBackwardIcon
    }
  )
});
var actionBringForward = register({
  name: "bringForward",
  label: "labels.bringForward",
  keywords: ["move up", "zindex", "layer"],
  icon: BringForwardIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState) => {
    return {
      elements: moveOneRight(elements, appState),
      appState,
      storeAction: StoreAction.CAPTURE
    };
  },
  keyPriority: 40,
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && !event.shiftKey && event.code === CODES.BRACKET_RIGHT,
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ jsx7(
    "button",
    {
      type: "button",
      className: "zIndexButton",
      onClick: () => updateData(null),
      title: `${t("labels.bringForward")} \u2014 ${getShortcutKey("CtrlOrCmd+]")}`,
      children: BringForwardIcon
    }
  )
});
var actionSendToBack = register({
  name: "sendToBack",
  label: "labels.sendToBack",
  keywords: ["move down", "zindex", "layer"],
  icon: SendToBackIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState) => {
    return {
      elements: moveAllLeft(elements, appState),
      appState,
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => isDarwin ? event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.BRACKET_LEFT : event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.code === CODES.BRACKET_LEFT,
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ jsx7(
    "button",
    {
      type: "button",
      className: "zIndexButton",
      onClick: () => updateData(null),
      title: `${t("labels.sendToBack")} \u2014 ${isDarwin ? getShortcutKey("CtrlOrCmd+Alt+[") : getShortcutKey("CtrlOrCmd+Shift+[")}`,
      children: SendToBackIcon
    }
  )
});
var actionBringToFront = register({
  name: "bringToFront",
  label: "labels.bringToFront",
  keywords: ["move up", "zindex", "layer"],
  icon: BringToFrontIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState) => {
    return {
      elements: moveAllRight(elements, appState),
      appState,
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => isDarwin ? event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.BRACKET_RIGHT : event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.code === CODES.BRACKET_RIGHT,
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ jsx7(
    "button",
    {
      type: "button",
      className: "zIndexButton",
      onClick: (event) => updateData(null),
      title: `${t("labels.bringToFront")} \u2014 ${isDarwin ? getShortcutKey("CtrlOrCmd+Alt+]") : getShortcutKey("CtrlOrCmd+Shift+]")}`,
      children: BringToFrontIcon
    }
  )
});

// actions/actionSelectAll.ts
init_define_import_meta_env();
init_keys();
init_register();
init_groups();
init_element();
init_typeChecks();
init_linearElementEditor();
init_selection();
init_icons();
init_store();
var actionSelectAll = register({
  name: "selectAll",
  label: "labels.selectAll",
  icon: selectAllIcon,
  trackEvent: { category: "canvas" },
  viewMode: false,
  perform: (elements, appState, value, app) => {
    if (appState.editingLinearElement) {
      return false;
    }
    const selectedElementIds = excludeElementsInFramesFromSelection(
      elements.filter(
        (element) => !element.isDeleted && !(isTextElement(element) && element.containerId) && !element.locked
      )
    ).reduce((map, element) => {
      map[element.id] = true;
      return map;
    }, {});
    return {
      appState: {
        ...appState,
        ...selectGroupsForSelectedElements(
          {
            editingGroupId: null,
            selectedElementIds
          },
          getNonDeletedElements2(elements),
          appState,
          app
        ),
        selectedLinearElement: (
          // single linear element selected
          Object.keys(selectedElementIds).length === 1 && isLinearElement(elements[0]) ? new LinearElementEditor(elements[0]) : null
        )
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.A
});

// actions/actionDuplicateSelection.tsx
init_define_import_meta_env();
init_keys();
init_register();
init_element();
init_scene();
init_utils2();
init_linearElementEditor();
init_groups();
init_binding();
init_constants();
init_textElement();
init_typeChecks();

// element/sortElements.ts
init_define_import_meta_env();
init_utils2();
var normalizeGroupElementOrder = (elements) => {
  const origElements = elements.slice();
  const sortedElements = /* @__PURE__ */ new Set();
  const orderInnerGroups = (elements2) => {
    const firstGroupSig = elements2[0]?.groupIds?.join("");
    const aGroup = [elements2[0]];
    const bGroup = [];
    for (const element of elements2.slice(1)) {
      if (element.groupIds?.join("") === firstGroupSig) {
        aGroup.push(element);
      } else {
        bGroup.push(element);
      }
    }
    return bGroup.length ? [...aGroup, ...orderInnerGroups(bGroup)] : aGroup;
  };
  const groupHandledElements = /* @__PURE__ */ new Map();
  origElements.forEach((element, idx) => {
    if (groupHandledElements.has(element.id)) {
      return;
    }
    if (element.groupIds?.length) {
      const topGroup = element.groupIds[element.groupIds.length - 1];
      const groupElements = origElements.slice(idx).filter((element2) => {
        const ret = element2?.groupIds?.some((id) => id === topGroup);
        if (ret) {
          groupHandledElements.set(element2.id, true);
        }
        return ret;
      });
      for (const elem of orderInnerGroups(groupElements)) {
        sortedElements.add(elem);
      }
    } else {
      sortedElements.add(element);
    }
  });
  if (sortedElements.size !== elements.length) {
    console.error("normalizeGroupElementOrder: lost some elements... bailing!");
    return elements;
  }
  return [...sortedElements];
};
var normalizeBoundElementsOrder = (elements) => {
  const elementsMap = arrayToMapWithIndex(elements);
  const origElements = elements.slice();
  const sortedElements = /* @__PURE__ */ new Set();
  origElements.forEach((element, idx) => {
    if (!element) {
      return;
    }
    if (element.boundElements?.length) {
      sortedElements.add(element);
      origElements[idx] = null;
      element.boundElements.forEach((boundElement) => {
        const child = elementsMap.get(boundElement.id);
        if (child && boundElement.type === "text") {
          sortedElements.add(child[0]);
          origElements[child[1]] = null;
        }
      });
    } else if (element.type === "text" && element.containerId) {
      const parent = elementsMap.get(element.containerId);
      if (!parent?.[0].boundElements?.find((x) => x.id === element.id)) {
        sortedElements.add(element);
        origElements[idx] = null;
      }
    } else {
      sortedElements.add(element);
      origElements[idx] = null;
    }
  });
  if (sortedElements.size !== elements.length) {
    console.error(
      "normalizeBoundElementsOrder: lost some elements... bailing!"
    );
    return elements;
  }
  return [...sortedElements];
};
var normalizeElementOrder = (elements) => {
  const ret = normalizeBoundElementsOrder(normalizeGroupElementOrder(elements));
  return ret;
};

// actions/actionDuplicateSelection.tsx
init_icons();
init_frame();
init_selection();
init_fractionalIndex();
init_store();
import { jsx as jsx8 } from "react/jsx-runtime";
var actionDuplicateSelection = register({
  name: "duplicateSelection",
  label: "labels.duplicateSelection",
  icon: DuplicateIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState, formData, app) => {
    if (appState.editingLinearElement) {
      try {
        const newAppState = LinearElementEditor.duplicateSelectedPoints(
          appState,
          app.scene.getNonDeletedElementsMap()
        );
        return {
          elements,
          appState: newAppState,
          storeAction: StoreAction.CAPTURE
        };
      } catch {
        return false;
      }
    }
    return {
      ...duplicateElements2(elements, appState),
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.D,
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ jsx8(
    ToolButton,
    {
      type: "button",
      icon: DuplicateIcon,
      title: `${t("labels.duplicateSelection")} \u2014 ${getShortcutKey(
        "CtrlOrCmd+D"
      )}`,
      "aria-label": t("labels.duplicateSelection"),
      onClick: () => updateData(null),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});
var duplicateElements2 = (elements, appState) => {
  const sortedElements = normalizeElementOrder(elements);
  const groupIdMap = /* @__PURE__ */ new Map();
  const newElements = [];
  const oldElements = [];
  const oldIdToDuplicatedId = /* @__PURE__ */ new Map();
  const duplicatedElementsMap = /* @__PURE__ */ new Map();
  const duplicateAndOffsetElement = (element) => {
    const newElement2 = duplicateElement(
      appState.editingGroupId,
      groupIdMap,
      element,
      {
        x: element.x + DEFAULT_GRID_SIZE / 2,
        y: element.y + DEFAULT_GRID_SIZE / 2
      }
    );
    duplicatedElementsMap.set(newElement2.id, newElement2);
    oldIdToDuplicatedId.set(element.id, newElement2.id);
    oldElements.push(element);
    newElements.push(newElement2);
    return newElement2;
  };
  const idsOfElementsToDuplicate = arrayToMap(
    getSelectedElements(sortedElements, appState, {
      includeBoundTextElement: true,
      includeElementsInFrames: true
    })
  );
  const processedIds = /* @__PURE__ */ new Map();
  const markAsProcessed = (elements2) => {
    for (const element of elements2) {
      processedIds.set(element.id, true);
    }
    return elements2;
  };
  const elementsWithClones = [];
  let index = -1;
  while (++index < sortedElements.length) {
    const element = sortedElements[index];
    if (processedIds.get(element.id)) {
      continue;
    }
    const boundTextElement = getBoundTextElement(element, arrayToMap(elements));
    const isElementAFrameLike = isFrameLikeElement(element);
    if (idsOfElementsToDuplicate.get(element.id)) {
      if (element.groupIds.length || boundTextElement || isElementAFrameLike) {
        const groupId = getSelectedGroupForElement(appState, element);
        if (groupId) {
          const groupElements = getElementsInGroup(
            sortedElements,
            groupId
          ).flatMap(
            (element2) => isFrameLikeElement(element2) ? [...getFrameChildren(elements, element2.id), element2] : [element2]
          );
          elementsWithClones.push(
            ...markAsProcessed([
              ...groupElements,
              ...groupElements.map(
                (element2) => duplicateAndOffsetElement(element2)
              )
            ])
          );
          continue;
        }
        if (boundTextElement) {
          elementsWithClones.push(
            ...markAsProcessed([
              element,
              boundTextElement,
              duplicateAndOffsetElement(element),
              duplicateAndOffsetElement(boundTextElement)
            ])
          );
          continue;
        }
        if (isElementAFrameLike) {
          const elementsInFrame = getFrameChildren(sortedElements, element.id);
          elementsWithClones.push(
            ...markAsProcessed([
              ...elementsInFrame,
              element,
              ...elementsInFrame.map((e) => duplicateAndOffsetElement(e)),
              duplicateAndOffsetElement(element)
            ])
          );
          continue;
        }
      }
      if (!element.frameId || !idsOfElementsToDuplicate.has(element.frameId)) {
        elementsWithClones.push(
          ...markAsProcessed([element, duplicateAndOffsetElement(element)])
        );
      }
    } else {
      elementsWithClones.push(...markAsProcessed([element]));
    }
  }
  const finalElementsReversed = [];
  const finalElementIds = /* @__PURE__ */ new Map();
  index = elementsWithClones.length;
  while (--index >= 0) {
    const element = elementsWithClones[index];
    if (!finalElementIds.get(element.id)) {
      finalElementIds.set(element.id, true);
      finalElementsReversed.push(element);
    }
  }
  const finalElements = syncMovedIndices(
    finalElementsReversed.reverse(),
    arrayToMap(newElements)
  );
  bindTextToShapeAfterDuplication(
    elementsWithClones,
    oldElements,
    oldIdToDuplicatedId
  );
  fixBindingsAfterDuplication(
    elementsWithClones,
    oldElements,
    oldIdToDuplicatedId
  );
  bindElementsToFramesAfterDuplication(
    finalElements,
    oldElements,
    oldIdToDuplicatedId
  );
  const nextElementsToSelect = excludeElementsInFramesFromSelection(newElements);
  return {
    elements: finalElements,
    appState: {
      ...appState,
      ...selectGroupsForSelectedElements(
        {
          editingGroupId: appState.editingGroupId,
          selectedElementIds: nextElementsToSelect.reduce(
            (acc, element) => {
              if (!isBoundToContainer(element)) {
                acc[element.id] = true;
              }
              return acc;
            },
            {}
          )
        },
        getNonDeletedElements2(finalElements),
        appState,
        null
      )
    }
  };
};

// actions/actionProperties.tsx
init_define_import_meta_env();
init_colors();
import { useEffect as useEffect14, useMemo as useMemo4, useRef as useRef12, useState as useState8 } from "react";

// analytics.ts
init_define_import_meta_env();
var ALLOWED_CATEGORIES_TO_TRACK = /* @__PURE__ */ new Set(["command_palette", "export"]);
var trackEvent = (category, action, label, value) => {
  try {
    if (typeof window === "undefined" || define_import_meta_env_default.VITE_WORKER_ID || define_import_meta_env_default.VITE_APP_ENABLE_TRACKING !== "true") {
      return;
    }
    if (!ALLOWED_CATEGORIES_TO_TRACK.has(category)) {
      return;
    }
    if (define_import_meta_env_default.DEV) {
      return;
    }
    if (!define_import_meta_env_default.PROD) {
      console.info("trackEvent", { category, action, label, value });
    }
    if (window.sa_event) {
      window.sa_event(action, {
        category,
        label,
        value
      });
    }
  } catch (error) {
    console.error("error during analytics", error);
  }
};

// components/ButtonIconSelect.tsx
init_define_import_meta_env();
import clsx5 from "clsx";

// components/ButtonIcon.tsx
init_define_import_meta_env();
import { forwardRef } from "react";
import clsx4 from "clsx";
import { jsx as jsx9 } from "react/jsx-runtime";
var ButtonIcon = forwardRef(
  (props, ref) => {
    const { title, className, testId, active, standalone, icon, onClick } = props;
    return /* @__PURE__ */ jsx9(
      "button",
      {
        type: "button",
        ref,
        title,
        "data-testid": testId,
        className: clsx4(className, { standalone, active }),
        onClick,
        children: icon
      },
      title
    );
  }
);

// components/ButtonIconSelect.tsx
import { jsx as jsx10, jsxs as jsxs4 } from "react/jsx-runtime";
var ButtonIconSelect = (props) => /* @__PURE__ */ jsx10("div", { className: "buttonList", children: props.options.map(
  (option) => props.type === "button" ? /* @__PURE__ */ jsx10(
    ButtonIcon,
    {
      icon: option.icon,
      title: option.text,
      testId: option.testId,
      active: option.active ?? props.value === option.value,
      onClick: (event) => props.onClick(option.value, event)
    },
    option.text
  ) : /* @__PURE__ */ jsxs4(
    "label",
    {
      className: clsx5({ active: props.value === option.value }),
      title: option.text,
      children: [
        /* @__PURE__ */ jsx10(
          "input",
          {
            type: "radio",
            name: props.group,
            onChange: () => props.onChange(option.value),
            checked: props.value === option.value,
            "data-testid": option.testId
          }
        ),
        option.icon
      ]
    },
    option.text
  )
) });

// components/ColorPicker/ColorPicker.tsx
init_define_import_meta_env();
init_utils2();

// components/ColorPicker/TopPicks.tsx
init_define_import_meta_env();
init_colors();
import clsx6 from "clsx";
import { jsx as jsx11 } from "react/jsx-runtime";
var TopPicks = ({
  onChange,
  type,
  activeColor,
  topPicks
}) => {
  let colors;
  if (type === "elementStroke") {
    colors = DEFAULT_ELEMENT_STROKE_PICKS;
  }
  if (type === "elementBackground") {
    colors = DEFAULT_ELEMENT_BACKGROUND_PICKS;
  }
  if (type === "canvasBackground") {
    colors = DEFAULT_CANVAS_BACKGROUND_PICKS;
  }
  if (topPicks) {
    colors = topPicks;
  }
  if (!colors) {
    console.error("Invalid type for TopPicks");
    return null;
  }
  return /* @__PURE__ */ jsx11("div", { className: "color-picker__top-picks", children: colors.map((color) => /* @__PURE__ */ jsx11(
    "button",
    {
      className: clsx6("color-picker__button", {
        active: color === activeColor,
        "is-transparent": color === "transparent" || !color
      }),
      style: { "--swatch-color": color },
      type: "button",
      title: color,
      onClick: () => onChange(color),
      "data-testid": `color-top-pick-${color}`,
      children: /* @__PURE__ */ jsx11("div", { className: "color-picker__button-outline" })
    },
    color
  )) });
};

// components/ButtonSeparator.tsx
init_define_import_meta_env();
import { jsx as jsx12 } from "react/jsx-runtime";
var ButtonSeparator = () => /* @__PURE__ */ jsx12(
  "div",
  {
    style: {
      width: 1,
      height: "1rem",
      backgroundColor: "var(--default-border-color)",
      margin: "0 auto"
    }
  }
);

// components/ColorPicker/Picker.tsx
init_define_import_meta_env();
import React5, { useEffect as useEffect7, useState as useState4 } from "react";

// components/ColorPicker/ShadeList.tsx
init_define_import_meta_env();
import clsx7 from "clsx";
import { useAtom as useAtom2 } from "jotai";
import { useEffect as useEffect4, useRef as useRef2 } from "react";

// components/ColorPicker/colorPickerUtils.ts
init_define_import_meta_env();
init_colors();
import { atom as atom2 } from "jotai";
var getColorNameAndShadeFromColor = ({
  palette: palette2,
  color
}) => {
  for (const [colorName, colorVal] of Object.entries(palette2)) {
    if (Array.isArray(colorVal)) {
      const shade = colorVal.indexOf(color);
      if (shade > -1) {
        return { colorName, shade };
      }
    } else if (colorVal === color) {
      return { colorName, shade: null };
    }
  }
  return null;
};
var colorPickerHotkeyBindings = [
  ["q", "w", "e", "r", "t"],
  ["a", "s", "d", "f", "g"],
  ["z", "x", "c", "v", "b"]
].flat();
var isCustomColor = ({
  color,
  palette: palette2
}) => {
  const paletteValues = Object.values(palette2).flat();
  return !paletteValues.includes(color);
};
var getMostUsedCustomColors = (elements, type, palette2) => {
  const elementColorTypeMap = {
    elementBackground: "backgroundColor",
    elementStroke: "strokeColor"
  };
  const colors = elements.filter((element) => {
    if (element.isDeleted) {
      return false;
    }
    const color = element[elementColorTypeMap[type]];
    return isCustomColor({ color, palette: palette2 });
  });
  const colorCountMap = /* @__PURE__ */ new Map();
  colors.forEach((element) => {
    const color = element[elementColorTypeMap[type]];
    if (colorCountMap.has(color)) {
      colorCountMap.set(color, colorCountMap.get(color) + 1);
    } else {
      colorCountMap.set(color, 1);
    }
  });
  return [...colorCountMap.entries()].sort((a, b) => b[1] - a[1]).map((c) => c[0]).slice(0, MAX_CUSTOM_COLORS_USED_IN_CANVAS);
};
var activeColorPickerSectionAtom = atom2(null);
var calculateContrast = (r, g, b) => {
  const yiq = (r * 299 + g * 587 + b * 114) / 1e3;
  return yiq >= 160 ? "black" : "white";
};
var getContrastYIQ = (bgHex, isCustomColor2) => {
  if (isCustomColor2) {
    const style = new Option().style;
    style.color = bgHex;
    if (style.color) {
      const rgb = style.color.replace(/^(rgb|rgba)\(/, "").replace(/\)$/, "").replace(/\s/g, "").split(",");
      const r2 = parseInt(rgb[0]);
      const g2 = parseInt(rgb[1]);
      const b2 = parseInt(rgb[2]);
      return calculateContrast(r2, g2, b2);
    }
  }
  if (bgHex === "transparent") {
    return "black";
  }
  const r = parseInt(bgHex.substring(1, 3), 16);
  const g = parseInt(bgHex.substring(3, 5), 16);
  const b = parseInt(bgHex.substring(5, 7), 16);
  return calculateContrast(r, g, b);
};

// components/ColorPicker/HotkeyLabel.tsx
init_define_import_meta_env();
import { jsxs as jsxs5 } from "react/jsx-runtime";
var HotkeyLabel = ({
  color,
  keyLabel,
  isCustomColor: isCustomColor2 = false,
  isShade = false
}) => {
  return /* @__PURE__ */ jsxs5(
    "div",
    {
      className: "color-picker__button__hotkey-label",
      style: {
        color: getContrastYIQ(color, isCustomColor2)
      },
      children: [
        isShade && "\u21E7",
        keyLabel
      ]
    }
  );
};
var HotkeyLabel_default = HotkeyLabel;

// components/ColorPicker/ShadeList.tsx
import { jsx as jsx13, jsxs as jsxs6 } from "react/jsx-runtime";
var ShadeList = ({ hex, onChange, palette: palette2 }) => {
  const colorObj = getColorNameAndShadeFromColor({
    color: hex || "transparent",
    palette: palette2
  });
  const [activeColorPickerSection, setActiveColorPickerSection] = useAtom2(
    activeColorPickerSectionAtom
  );
  const btnRef = useRef2(null);
  useEffect4(() => {
    if (btnRef.current && activeColorPickerSection === "shades") {
      btnRef.current.focus();
    }
  }, [colorObj, activeColorPickerSection]);
  if (colorObj) {
    const { colorName, shade } = colorObj;
    const shades = palette2[colorName];
    if (Array.isArray(shades)) {
      return /* @__PURE__ */ jsx13("div", { className: "color-picker-content--default shades", children: shades.map((color, i) => /* @__PURE__ */ jsxs6(
        "button",
        {
          ref: i === shade && activeColorPickerSection === "shades" ? btnRef : void 0,
          tabIndex: -1,
          type: "button",
          className: clsx7(
            "color-picker__button color-picker__button--large",
            { active: i === shade }
          ),
          "aria-label": "Shade",
          title: `${colorName} - ${i + 1}`,
          style: color ? { "--swatch-color": color } : void 0,
          onClick: () => {
            onChange(color);
            setActiveColorPickerSection("shades");
          },
          children: [
            /* @__PURE__ */ jsx13("div", { className: "color-picker__button-outline" }),
            /* @__PURE__ */ jsx13(HotkeyLabel_default, { color, keyLabel: i + 1, isShade: true })
          ]
        },
        i
      )) });
    }
  }
  return /* @__PURE__ */ jsxs6(
    "div",
    {
      className: "color-picker-content--default",
      style: { position: "relative" },
      tabIndex: -1,
      children: [
        /* @__PURE__ */ jsx13(
          "button",
          {
            type: "button",
            tabIndex: -1,
            className: "color-picker__button color-picker__button--large color-picker__button--no-focus-visible"
          }
        ),
        /* @__PURE__ */ jsx13(
          "div",
          {
            tabIndex: -1,
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              textAlign: "center",
              fontSize: "0.75rem"
            },
            children: t("colorPicker.noShades")
          }
        )
      ]
    }
  );
};

// components/ColorPicker/PickerColorList.tsx
init_define_import_meta_env();
import clsx8 from "clsx";
import { useAtom as useAtom3 } from "jotai";
import { useEffect as useEffect5, useRef as useRef3 } from "react";
import { jsx as jsx14, jsxs as jsxs7 } from "react/jsx-runtime";
var PickerColorList = ({
  palette: palette2,
  color,
  onChange,
  label,
  activeShade
}) => {
  const colorObj = getColorNameAndShadeFromColor({
    color: color || "transparent",
    palette: palette2
  });
  const [activeColorPickerSection, setActiveColorPickerSection] = useAtom3(
    activeColorPickerSectionAtom
  );
  const btnRef = useRef3(null);
  useEffect5(() => {
    if (btnRef.current && activeColorPickerSection === "baseColors") {
      btnRef.current.focus();
    }
  }, [colorObj?.colorName, activeColorPickerSection]);
  return /* @__PURE__ */ jsx14("div", { className: "color-picker-content--default", children: Object.entries(palette2).map(([key, value], index) => {
    const color2 = (Array.isArray(value) ? value[activeShade] : value) || "transparent";
    const keybinding = colorPickerHotkeyBindings[index];
    const label2 = t(
      `colors.${key.replace(/\d+/, "")}`,
      null,
      ""
    );
    return /* @__PURE__ */ jsxs7(
      "button",
      {
        ref: colorObj?.colorName === key ? btnRef : void 0,
        tabIndex: -1,
        type: "button",
        className: clsx8(
          "color-picker__button color-picker__button--large",
          {
            active: colorObj?.colorName === key,
            "is-transparent": color2 === "transparent" || !color2
          }
        ),
        onClick: () => {
          onChange(color2);
          setActiveColorPickerSection("baseColors");
        },
        title: `${label2}${color2.startsWith("#") ? ` ${color2}` : ""} \u2014 ${keybinding}`,
        "aria-label": `${label2} \u2014 ${keybinding}`,
        style: color2 ? { "--swatch-color": color2 } : void 0,
        "data-testid": `color-${key}`,
        children: [
          /* @__PURE__ */ jsx14("div", { className: "color-picker__button-outline" }),
          /* @__PURE__ */ jsx14(HotkeyLabel_default, { color: color2, keyLabel: keybinding })
        ]
      },
      key
    );
  }) });
};
var PickerColorList_default = PickerColorList;

// components/ColorPicker/Picker.tsx
import { useAtom as useAtom5 } from "jotai";

// components/ColorPicker/CustomColorList.tsx
init_define_import_meta_env();
import clsx9 from "clsx";
import { useAtom as useAtom4 } from "jotai";
import { useEffect as useEffect6, useRef as useRef4 } from "react";
import { jsx as jsx15, jsxs as jsxs8 } from "react/jsx-runtime";
var CustomColorList = ({
  colors,
  color,
  onChange,
  label
}) => {
  const [activeColorPickerSection, setActiveColorPickerSection] = useAtom4(
    activeColorPickerSectionAtom
  );
  const btnRef = useRef4(null);
  useEffect6(() => {
    if (btnRef.current) {
      btnRef.current.focus();
    }
  }, [color, activeColorPickerSection]);
  return /* @__PURE__ */ jsx15("div", { className: "color-picker-content--default", children: colors.map((c, i) => {
    return /* @__PURE__ */ jsxs8(
      "button",
      {
        ref: color === c ? btnRef : void 0,
        tabIndex: -1,
        type: "button",
        className: clsx9(
          "color-picker__button color-picker__button--large",
          {
            active: color === c,
            "is-transparent": c === "transparent" || !c
          }
        ),
        onClick: () => {
          onChange(c);
          setActiveColorPickerSection("custom");
        },
        title: c,
        "aria-label": label,
        style: { "--swatch-color": c },
        children: [
          /* @__PURE__ */ jsx15("div", { className: "color-picker__button-outline" }),
          /* @__PURE__ */ jsx15(HotkeyLabel_default, { color: c, keyLabel: i + 1, isCustomColor: true })
        ]
      },
      i
    );
  }) });
};

// components/ColorPicker/keyboardNavHandlers.ts
init_define_import_meta_env();
init_keys();
init_colors();
var arrowHandler = (eventKey, currentIndex, length) => {
  const rows = Math.ceil(length / COLORS_PER_ROW);
  currentIndex = currentIndex ?? -1;
  switch (eventKey) {
    case "ArrowLeft": {
      const prevIndex = currentIndex - 1;
      return prevIndex < 0 ? length - 1 : prevIndex;
    }
    case "ArrowRight": {
      return (currentIndex + 1) % length;
    }
    case "ArrowDown": {
      const nextIndex = currentIndex + COLORS_PER_ROW;
      return nextIndex >= length ? currentIndex % COLORS_PER_ROW : nextIndex;
    }
    case "ArrowUp": {
      const prevIndex = currentIndex - COLORS_PER_ROW;
      const newIndex = prevIndex < 0 ? COLORS_PER_ROW * rows + prevIndex : prevIndex;
      return newIndex >= length ? void 0 : newIndex;
    }
  }
};
var hotkeyHandler = ({
  e,
  colorObj,
  onChange,
  palette: palette2,
  customColors,
  setActiveColorPickerSection,
  activeShade
}) => {
  if (colorObj?.shade != null) {
    if (["Digit1", "Digit2", "Digit3", "Digit4", "Digit5"].includes(e.code) && e.shiftKey) {
      const newShade = Number(e.code.slice(-1)) - 1;
      onChange(palette2[colorObj.colorName][newShade]);
      setActiveColorPickerSection("shades");
      return true;
    }
  }
  if (["1", "2", "3", "4", "5"].includes(e.key)) {
    const c = customColors[Number(e.key) - 1];
    if (c) {
      onChange(customColors[Number(e.key) - 1]);
      setActiveColorPickerSection("custom");
      return true;
    }
  }
  if (colorPickerHotkeyBindings.includes(e.key)) {
    const index = colorPickerHotkeyBindings.indexOf(e.key);
    const paletteKey = Object.keys(palette2)[index];
    const paletteValue = palette2[paletteKey];
    const r = Array.isArray(paletteValue) ? paletteValue[activeShade] : paletteValue;
    onChange(r);
    setActiveColorPickerSection("baseColors");
    return true;
  }
  return false;
};
var colorPickerKeyNavHandler = ({
  event,
  activeColorPickerSection,
  palette: palette2,
  color,
  onChange,
  customColors,
  setActiveColorPickerSection,
  updateData,
  activeShade,
  onEyeDropperToggle,
  onEscape
}) => {
  if (event[KEYS.CTRL_OR_CMD]) {
    return false;
  }
  if (event.key === KEYS.ESCAPE) {
    onEscape(event);
    return true;
  }
  if (event.key === KEYS.ALT) {
    onEyeDropperToggle(true);
    return true;
  }
  if (event.key === KEYS.I) {
    onEyeDropperToggle();
    return true;
  }
  const colorObj = getColorNameAndShadeFromColor({ color, palette: palette2 });
  if (event.key === KEYS.TAB) {
    const sectionsMap = {
      custom: !!customColors.length,
      baseColors: true,
      shades: colorObj?.shade != null,
      hex: true
    };
    const sections = Object.entries(sectionsMap).reduce((acc, [key, value]) => {
      if (value) {
        acc.push(key);
      }
      return acc;
    }, []);
    const activeSectionIndex = sections.indexOf(activeColorPickerSection);
    const indexOffset = event.shiftKey ? -1 : 1;
    const nextSectionIndex = activeSectionIndex + indexOffset > sections.length - 1 ? 0 : activeSectionIndex + indexOffset < 0 ? sections.length - 1 : activeSectionIndex + indexOffset;
    const nextSection = sections[nextSectionIndex];
    if (nextSection) {
      setActiveColorPickerSection(nextSection);
    }
    if (nextSection === "custom") {
      onChange(customColors[0]);
    } else if (nextSection === "baseColors") {
      const baseColorName = Object.entries(palette2).find(([name, shades]) => {
        if (Array.isArray(shades)) {
          return shades.includes(color);
        } else if (shades === color) {
          return name;
        }
        return null;
      });
      if (!baseColorName) {
        onChange(COLOR_PALETTE.black);
      }
    }
    event.preventDefault();
    event.stopPropagation();
    return true;
  }
  if (hotkeyHandler({
    e: event,
    colorObj,
    onChange,
    palette: palette2,
    customColors,
    setActiveColorPickerSection,
    activeShade
  })) {
    return true;
  }
  if (activeColorPickerSection === "shades") {
    if (colorObj) {
      const { shade } = colorObj;
      const newShade = arrowHandler(event.key, shade, COLORS_PER_ROW);
      if (newShade !== void 0) {
        onChange(palette2[colorObj.colorName][newShade]);
        return true;
      }
    }
  }
  if (activeColorPickerSection === "baseColors") {
    if (colorObj) {
      const { colorName } = colorObj;
      const colorNames = Object.keys(palette2);
      const indexOfColorName = colorNames.indexOf(colorName);
      const newColorIndex = arrowHandler(
        event.key,
        indexOfColorName,
        colorNames.length
      );
      if (newColorIndex !== void 0) {
        const newColorName = colorNames[newColorIndex];
        const newColorNameValue = palette2[newColorName];
        onChange(
          Array.isArray(newColorNameValue) ? newColorNameValue[activeShade] : newColorNameValue
        );
        return true;
      }
    }
  }
  if (activeColorPickerSection === "custom") {
    const indexOfColor = customColors.indexOf(color);
    const newColorIndex = arrowHandler(
      event.key,
      indexOfColor,
      customColors.length
    );
    if (newColorIndex !== void 0) {
      const newColor = customColors[newColorIndex];
      onChange(newColor);
      return true;
    }
  }
  return false;
};

// components/ColorPicker/PickerHeading.tsx
init_define_import_meta_env();
import { jsx as jsx16 } from "react/jsx-runtime";
var PickerHeading = ({ children }) => /* @__PURE__ */ jsx16("div", { className: "color-picker__heading", children });
var PickerHeading_default = PickerHeading;

// components/ColorPicker/Picker.tsx
init_colors();
init_keys();
init_constants();
import { jsx as jsx17, jsxs as jsxs9 } from "react/jsx-runtime";
var Picker = ({
  color,
  onChange,
  label,
  type,
  elements,
  palette: palette2,
  updateData,
  children,
  onEyeDropperToggle,
  onEscape
}) => {
  const [customColors] = React5.useState(() => {
    if (type === "canvasBackground") {
      return [];
    }
    return getMostUsedCustomColors(elements, type, palette2);
  });
  const [activeColorPickerSection, setActiveColorPickerSection] = useAtom5(
    activeColorPickerSectionAtom
  );
  const colorObj = getColorNameAndShadeFromColor({
    color,
    palette: palette2
  });
  useEffect7(() => {
    if (!activeColorPickerSection) {
      const isCustom = isCustomColor({ color, palette: palette2 });
      const isCustomButNotInList = isCustom && !customColors.includes(color);
      setActiveColorPickerSection(
        isCustomButNotInList ? "hex" : isCustom ? "custom" : colorObj?.shade != null ? "shades" : "baseColors"
      );
    }
  }, [
    activeColorPickerSection,
    color,
    palette2,
    setActiveColorPickerSection,
    colorObj,
    customColors
  ]);
  const [activeShade, setActiveShade] = useState4(
    colorObj?.shade ?? (type === "elementBackground" ? DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX : DEFAULT_ELEMENT_STROKE_COLOR_INDEX)
  );
  useEffect7(() => {
    if (colorObj?.shade != null) {
      setActiveShade(colorObj.shade);
    }
    const keyup = (event) => {
      if (event.key === KEYS.ALT) {
        onEyeDropperToggle(false);
      }
    };
    document.addEventListener("keyup" /* KEYUP */, keyup, { capture: true });
    return () => {
      document.removeEventListener("keyup" /* KEYUP */, keyup, { capture: true });
    };
  }, [colorObj, onEyeDropperToggle]);
  const pickerRef = React5.useRef(null);
  return /* @__PURE__ */ jsx17("div", { role: "dialog", "aria-modal": "true", "aria-label": t("labels.colorPicker"), children: /* @__PURE__ */ jsxs9(
    "div",
    {
      ref: pickerRef,
      onKeyDown: (event) => {
        const handled = colorPickerKeyNavHandler({
          event,
          activeColorPickerSection,
          palette: palette2,
          color,
          onChange,
          onEyeDropperToggle,
          customColors,
          setActiveColorPickerSection,
          updateData,
          activeShade,
          onEscape
        });
        if (handled) {
          event.preventDefault();
          event.stopPropagation();
        }
      },
      className: "color-picker-content properties-content",
      tabIndex: -1,
      children: [
        !!customColors.length && /* @__PURE__ */ jsxs9("div", { children: [
          /* @__PURE__ */ jsx17(PickerHeading_default, { children: t("colorPicker.mostUsedCustomColors") }),
          /* @__PURE__ */ jsx17(
            CustomColorList,
            {
              colors: customColors,
              color,
              label: t("colorPicker.mostUsedCustomColors"),
              onChange
            }
          )
        ] }),
        /* @__PURE__ */ jsxs9("div", { children: [
          /* @__PURE__ */ jsx17(PickerHeading_default, { children: t("colorPicker.colors") }),
          /* @__PURE__ */ jsx17(
            PickerColorList_default,
            {
              color,
              label,
              palette: palette2,
              onChange,
              activeShade
            }
          )
        ] }),
        /* @__PURE__ */ jsxs9("div", { children: [
          /* @__PURE__ */ jsx17(PickerHeading_default, { children: t("colorPicker.shades") }),
          /* @__PURE__ */ jsx17(ShadeList, { hex: color, onChange, palette: palette2 })
        ] }),
        children
      ]
    }
  ) });
};

// components/ColorPicker/ColorPicker.tsx
import * as Popover2 from "@radix-ui/react-popover";
import { useAtom as useAtom7 } from "jotai";
init_colors();
import clsx13 from "clsx";
import { useRef as useRef8 } from "react";

// components/ColorPicker/ColorInput.tsx
init_define_import_meta_env();
import { useCallback, useEffect as useEffect10, useRef as useRef7, useState as useState6 } from "react";
import { useAtom as useAtom6 } from "jotai";
init_icons();
init_keys();

// components/EyeDropper.tsx
init_define_import_meta_env();
init_colors();
init_constants();
import { atom as atom3 } from "jotai";
import { useEffect as useEffect9, useRef as useRef6 } from "react";
import { createPortal } from "react-dom";

// context/ui-appState.ts
init_define_import_meta_env();
import React6 from "react";
var UIAppStateContext = React6.createContext(null);
var useUIAppState = () => React6.useContext(UIAppStateContext);

// hooks/useCreatePortalContainer.ts
init_define_import_meta_env();
import { useState as useState5, useLayoutEffect as useLayoutEffect2 } from "react";
init_constants();
var useCreatePortalContainer = (opts) => {
  const [div, setDiv] = useState5(null);
  const device = useDevice();
  const { theme } = useUIAppState();
  const { container: excalidrawContainer } = useExcalidrawContainer();
  useLayoutEffect2(() => {
    if (div) {
      div.className = "";
      div.classList.add("excalidraw", ...opts?.className?.split(/\s+/) || []);
      div.classList.toggle("excalidraw--mobile", device.editor.isMobile);
      div.classList.toggle("theme--dark", theme === THEME.DARK);
    }
  }, [div, theme, device.editor.isMobile, opts?.className]);
  useLayoutEffect2(() => {
    const container = opts?.parentSelector ? excalidrawContainer?.querySelector(opts.parentSelector) : document.body;
    if (!container) {
      return;
    }
    const div2 = document.createElement("div");
    container.appendChild(div2);
    setDiv(div2);
    return () => {
      container.removeChild(div2);
    };
  }, [excalidrawContainer, opts?.parentSelector]);
  return div;
};

// hooks/useOutsideClick.ts
init_define_import_meta_env();
init_constants();
import { useEffect as useEffect8 } from "react";
function useOutsideClick(ref, callback, isInside) {
  useEffect8(() => {
    function onOutsideClick(event) {
      const _event = event;
      if (!ref.current) {
        return;
      }
      const isInsideOverride = isInside?.(_event, ref.current);
      if (isInsideOverride === true) {
        return;
      } else if (isInsideOverride === false) {
        return callback(_event);
      }
      if (ref.current.contains(_event.target) || // target is detached from DOM (happens when the element is removed
      // on a pointerup event fired *before* this handler's pointerup is
      // dispatched)
      !document.documentElement.contains(_event.target)) {
        return;
      }
      const isClickOnRadixPortal = _event.target.closest("[data-radix-portal]") || // when radix popup is in "modal" mode, it disables pointer events on
      // the `body` element, so the target element is going to be the `html`
      // (note: this won't work if we selectively re-enable pointer events on
      // specific elements as we do with navbar or excalidraw UI elements)
      _event.target === document.documentElement && document.body.style.pointerEvents === "none";
      if (isClickOnRadixPortal) {
        return;
      }
      if (_event.target.closest("[data-prevent-outside-click]")) {
        return;
      }
      callback(_event);
    }
    document.addEventListener("pointerdown" /* POINTER_DOWN */, onOutsideClick);
    document.addEventListener("touchstart" /* TOUCH_START */, onOutsideClick);
    return () => {
      document.removeEventListener("pointerdown" /* POINTER_DOWN */, onOutsideClick);
      document.removeEventListener("touchstart" /* TOUCH_START */, onOutsideClick);
    };
  }, [ref, callback, isInside]);
}

// components/EyeDropper.tsx
init_keys();
init_scene();

// hooks/useStable.ts
init_define_import_meta_env();
import { useRef as useRef5 } from "react";
var useStable = (value) => {
  const ref = useRef5(value);
  Object.assign(ref.current, value);
  return ref.current;
};

// components/EyeDropper.tsx
import { jsx as jsx18 } from "react/jsx-runtime";
var activeEyeDropperAtom = atom3(null);
var EyeDropper = ({ onCancel, onChange, onSelect, colorPickerType }) => {
  const eyeDropperContainer = useCreatePortalContainer({
    className: "excalidraw-eye-dropper-backdrop",
    parentSelector: ".excalidraw-eye-dropper-container"
  });
  const appState = useUIAppState();
  const elements = useExcalidrawElements();
  const app = useApp();
  const selectedElements = getSelectedElements(elements, appState);
  const stableProps = useStable({
    app,
    onCancel,
    onChange,
    onSelect,
    selectedElements
  });
  const { container: excalidrawContainer } = useExcalidrawContainer();
  useEffect9(() => {
    const colorPreviewDiv = ref.current;
    if (!colorPreviewDiv || !app.canvas || !eyeDropperContainer) {
      return;
    }
    let isHoldingPointerDown = false;
    const ctx = app.canvas.getContext("2d");
    const getCurrentColor = ({
      clientX,
      clientY
    }) => {
      const pixel = ctx.getImageData(
        (clientX - appState.offsetLeft) * window.devicePixelRatio,
        (clientY - appState.offsetTop) * window.devicePixelRatio,
        1,
        1
      ).data;
      return rgbToHex(pixel[0], pixel[1], pixel[2]);
    };
    const mouseMoveListener = ({
      clientX,
      clientY,
      altKey
    }) => {
      colorPreviewDiv.style.top = `${clientY + 20}px`;
      colorPreviewDiv.style.left = `${clientX + 20}px`;
      const currentColor = getCurrentColor({ clientX, clientY });
      if (isHoldingPointerDown) {
        stableProps.onChange(
          colorPickerType,
          currentColor,
          stableProps.selectedElements,
          { altKey }
        );
      }
      colorPreviewDiv.style.background = currentColor;
    };
    const onCancel2 = () => {
      stableProps.onCancel();
    };
    const onSelect2 = (color, event) => {
      stableProps.onSelect(color, event);
    };
    const pointerDownListener = (event) => {
      isHoldingPointerDown = true;
      event.stopImmediatePropagation();
    };
    const pointerUpListener = (event) => {
      isHoldingPointerDown = false;
      excalidrawContainer?.focus();
      event.stopImmediatePropagation();
      event.preventDefault();
      onSelect2(getCurrentColor(event), event);
    };
    const keyDownListener = (event) => {
      if (event.key === KEYS.ESCAPE) {
        event.preventDefault();
        event.stopImmediatePropagation();
        onCancel2();
      }
    };
    eyeDropperContainer.tabIndex = -1;
    eyeDropperContainer.focus();
    mouseMoveListener({
      clientX: stableProps.app.lastViewportPosition.x,
      clientY: stableProps.app.lastViewportPosition.y,
      altKey: false
    });
    eyeDropperContainer.addEventListener("keydown" /* KEYDOWN */, keyDownListener);
    eyeDropperContainer.addEventListener(
      "pointerdown" /* POINTER_DOWN */,
      pointerDownListener
    );
    eyeDropperContainer.addEventListener("pointerup" /* POINTER_UP */, pointerUpListener);
    window.addEventListener("pointermove", mouseMoveListener, {
      passive: true
    });
    window.addEventListener("blur" /* BLUR */, onCancel2);
    return () => {
      isHoldingPointerDown = false;
      eyeDropperContainer.removeEventListener("keydown" /* KEYDOWN */, keyDownListener);
      eyeDropperContainer.removeEventListener(
        "pointerdown" /* POINTER_DOWN */,
        pointerDownListener
      );
      eyeDropperContainer.removeEventListener(
        "pointerup" /* POINTER_UP */,
        pointerUpListener
      );
      window.removeEventListener("pointermove", mouseMoveListener);
      window.removeEventListener("blur" /* BLUR */, onCancel2);
    };
  }, [
    stableProps,
    app.canvas,
    eyeDropperContainer,
    colorPickerType,
    excalidrawContainer,
    appState.offsetLeft,
    appState.offsetTop
  ]);
  const ref = useRef6(null);
  useOutsideClick(
    ref,
    () => {
      onCancel();
    },
    (event) => {
      if (event.target.closest(
        ".excalidraw-eye-dropper-trigger, .excalidraw-eye-dropper-backdrop"
      )) {
        return true;
      }
      return false;
    }
  );
  if (!eyeDropperContainer) {
    return null;
  }
  return createPortal(
    /* @__PURE__ */ jsx18("div", { ref, className: "excalidraw-eye-dropper-preview" }),
    eyeDropperContainer
  );
};

// components/ColorPicker/ColorInput.tsx
import clsx10 from "clsx";
init_utils2();
import { Fragment as Fragment2, jsx as jsx19, jsxs as jsxs10 } from "react/jsx-runtime";
var ColorInput = ({
  color,
  onChange,
  label,
  colorPickerType
}) => {
  const device = useDevice();
  const [innerValue, setInnerValue] = useState6(color);
  const [activeSection, setActiveColorPickerSection] = useAtom6(
    activeColorPickerSectionAtom
  );
  useEffect10(() => {
    setInnerValue(color);
  }, [color]);
  const changeColor = useCallback(
    (inputValue) => {
      const value = inputValue.toLowerCase();
      const color2 = getColor(value);
      if (color2) {
        onChange(color2);
      }
      setInnerValue(value);
    },
    [onChange]
  );
  const inputRef = useRef7(null);
  const eyeDropperTriggerRef = useRef7(null);
  useEffect10(() => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  }, [activeSection]);
  const [eyeDropperState, setEyeDropperState] = useAtom6(
    activeEyeDropperAtom,
    jotaiScope
  );
  useEffect10(() => {
    return () => {
      setEyeDropperState(null);
    };
  }, [setEyeDropperState]);
  return /* @__PURE__ */ jsxs10("div", { className: "color-picker__input-label", children: [
    /* @__PURE__ */ jsx19("div", { className: "color-picker__input-hash", children: "#" }),
    /* @__PURE__ */ jsx19(
      "input",
      {
        ref: activeSection === "hex" ? inputRef : void 0,
        style: { border: 0, padding: 0 },
        spellCheck: false,
        className: "color-picker-input",
        "aria-label": label,
        onChange: (event) => {
          changeColor(event.target.value);
        },
        value: (innerValue || "").replace(/^#/, ""),
        onBlur: () => {
          setInnerValue(color);
        },
        tabIndex: -1,
        onFocus: () => setActiveColorPickerSection("hex"),
        onKeyDown: (event) => {
          if (event.key === KEYS.TAB) {
            return;
          } else if (event.key === KEYS.ESCAPE) {
            eyeDropperTriggerRef.current?.focus();
          }
          event.stopPropagation();
        }
      }
    ),
    !device.editor.isMobile && /* @__PURE__ */ jsxs10(Fragment2, { children: [
      /* @__PURE__ */ jsx19(
        "div",
        {
          style: {
            width: "1px",
            height: "1.25rem",
            backgroundColor: "var(--default-border-color)"
          }
        }
      ),
      /* @__PURE__ */ jsx19(
        "div",
        {
          ref: eyeDropperTriggerRef,
          className: clsx10("excalidraw-eye-dropper-trigger", {
            selected: eyeDropperState
          }),
          onClick: () => setEyeDropperState(
            (s) => s ? null : {
              keepOpenOnAlt: false,
              onSelect: (color2) => onChange(color2),
              colorPickerType
            }
          ),
          title: `${t(
            "labels.eyeDropper"
          )} \u2014 ${KEYS.I.toLocaleUpperCase()} or ${getShortcutKey("Alt")} `,
          children: eyeDropperIcon
        }
      )
    ] })
  ] });
};

// components/PropertiesPopover.tsx
init_define_import_meta_env();
import React8 from "react";
import clsx12 from "clsx";
import * as Popover from "@radix-ui/react-popover";

// components/Island.tsx
init_define_import_meta_env();
import React7 from "react";
import clsx11 from "clsx";
import { jsx as jsx20 } from "react/jsx-runtime";
var Island = React7.forwardRef(
  ({ children, padding, className, style }, ref) => /* @__PURE__ */ jsx20(
    "div",
    {
      className: clsx11("Island", className),
      style: { "--padding": padding, ...style },
      ref,
      children
    }
  )
);

// components/PropertiesPopover.tsx
init_utils2();
import { jsx as jsx21, jsxs as jsxs11 } from "react/jsx-runtime";
var PropertiesPopover = React8.forwardRef(
  ({
    className,
    container,
    children,
    style,
    onClose,
    onKeyDown,
    onFocusOutside,
    onPointerLeave,
    onPointerDownOutside
  }, ref) => {
    const device = useDevice();
    return /* @__PURE__ */ jsx21(Popover.Portal, { container, children: /* @__PURE__ */ jsxs11(
      Popover.Content,
      {
        ref,
        className: clsx12("focus-visible-none", className),
        "data-prevent-outside-click": true,
        side: device.editor.isMobile && !device.viewport.isLandscape ? "bottom" : "right",
        align: device.editor.isMobile && !device.viewport.isLandscape ? "center" : "start",
        alignOffset: -16,
        sideOffset: 20,
        style: {
          zIndex: "var(--zIndex-popup)"
        },
        onPointerLeave,
        onKeyDown,
        onFocusOutside,
        onPointerDownOutside,
        onCloseAutoFocus: (e) => {
          e.stopPropagation();
          e.preventDefault();
          if (container && !isInteractive(document.activeElement)) {
            container.focus();
          }
          onClose();
        },
        children: [
          /* @__PURE__ */ jsx21(Island, { padding: 3, style, children }),
          /* @__PURE__ */ jsx21(
            Popover.Arrow,
            {
              width: 20,
              height: 10,
              style: {
                fill: "var(--popup-bg-color)",
                filter: "drop-shadow(rgba(0, 0, 0, 0.05) 0px 3px 2px)"
              }
            }
          )
        ]
      }
    ) });
  }
);

// components/ColorPicker/ColorPicker.tsx
import { jsx as jsx22, jsxs as jsxs12 } from "react/jsx-runtime";
var isValidColor = (color) => {
  const style = new Option().style;
  style.color = color;
  return !!style.color;
};
var getColor = (color) => {
  if (isTransparent(color)) {
    return color;
  }
  return isValidColor(`#${color}`) ? `#${color}` : isValidColor(color) ? color : null;
};
var ColorPickerPopupContent = ({
  type,
  color,
  onChange,
  label,
  elements,
  palette: palette2 = COLOR_PALETTE,
  updateData
}) => {
  const { container } = useExcalidrawContainer();
  const [, setActiveColorPickerSection] = useAtom7(activeColorPickerSectionAtom);
  const [eyeDropperState, setEyeDropperState] = useAtom7(
    activeEyeDropperAtom,
    jotaiScope
  );
  const colorInputJSX = /* @__PURE__ */ jsxs12("div", { children: [
    /* @__PURE__ */ jsx22(PickerHeading_default, { children: t("colorPicker.hexCode") }),
    /* @__PURE__ */ jsx22(
      ColorInput,
      {
        color,
        label,
        onChange: (color2) => {
          onChange(color2);
        },
        colorPickerType: type
      }
    )
  ] });
  const popoverRef = useRef8(null);
  const focusPickerContent = () => {
    popoverRef.current?.querySelector(".color-picker-content")?.focus();
  };
  return /* @__PURE__ */ jsx22(
    PropertiesPopover,
    {
      container,
      style: { maxWidth: "13rem" },
      onFocusOutside: (event) => {
        focusPickerContent();
        event.preventDefault();
      },
      onPointerDownOutside: (event) => {
        if (eyeDropperState) {
          event.preventDefault();
        }
      },
      onClose: () => {
        updateData({ openPopup: null });
        setActiveColorPickerSection(null);
      },
      children: palette2 ? /* @__PURE__ */ jsx22(
        Picker,
        {
          palette: palette2,
          color,
          onChange: (changedColor) => {
            onChange(changedColor);
          },
          onEyeDropperToggle: (force) => {
            setEyeDropperState((state) => {
              if (force) {
                state = state || {
                  keepOpenOnAlt: true,
                  onSelect: onChange,
                  colorPickerType: type
                };
                state.keepOpenOnAlt = true;
                return state;
              }
              return force === false || state ? null : {
                keepOpenOnAlt: false,
                onSelect: onChange,
                colorPickerType: type
              };
            });
          },
          onEscape: (event) => {
            if (eyeDropperState) {
              setEyeDropperState(null);
            } else {
              updateData({ openPopup: null });
            }
          },
          label,
          type,
          elements,
          updateData,
          children: colorInputJSX
        }
      ) : colorInputJSX
    }
  );
};
var ColorPickerTrigger = ({
  label,
  color,
  type
}) => {
  return /* @__PURE__ */ jsx22(
    Popover2.Trigger,
    {
      type: "button",
      className: clsx13("color-picker__button active-color properties-trigger", {
        "is-transparent": color === "transparent" || !color
      }),
      "aria-label": label,
      style: color ? { "--swatch-color": color } : void 0,
      title: type === "elementStroke" ? t("labels.showStroke") : t("labels.showBackground"),
      children: /* @__PURE__ */ jsx22("div", { className: "color-picker__button-outline" })
    }
  );
};
var ColorPicker = ({
  type,
  color,
  onChange,
  label,
  elements,
  palette: palette2 = COLOR_PALETTE,
  topPicks,
  updateData,
  appState
}) => {
  return /* @__PURE__ */ jsx22("div", { children: /* @__PURE__ */ jsxs12("div", { role: "dialog", "aria-modal": "true", className: "color-picker-container", children: [
    /* @__PURE__ */ jsx22(
      TopPicks,
      {
        activeColor: color,
        onChange,
        type,
        topPicks
      }
    ),
    /* @__PURE__ */ jsx22(ButtonSeparator, {}),
    /* @__PURE__ */ jsxs12(
      Popover2.Root,
      {
        open: appState.openPopup === type,
        onOpenChange: (open) => {
          updateData({ openPopup: open ? type : null });
        },
        children: [
          /* @__PURE__ */ jsx22(ColorPickerTrigger, { color, label, type }),
          appState.openPopup === type && /* @__PURE__ */ jsx22(
            ColorPickerPopupContent,
            {
              type,
              color,
              onChange,
              label,
              elements,
              palette: palette2,
              updateData
            }
          )
        ]
      }
    )
  ] }) });
};

// components/IconPicker.tsx
init_define_import_meta_env();
import React10 from "react";

// components/Popover.tsx
init_define_import_meta_env();
import { useLayoutEffect as useLayoutEffect3, useRef as useRef9, useEffect as useEffect11 } from "react";
init_utils2();
init_keys();
import { unstable_batchedUpdates } from "react-dom";
import { jsx as jsx23 } from "react/jsx-runtime";
var Popover3 = ({
  children,
  left,
  top,
  onCloseRequest,
  fitInViewport = false,
  offsetLeft = 0,
  offsetTop = 0,
  viewportWidth = window.innerWidth,
  viewportHeight = window.innerHeight
}) => {
  const popoverRef = useRef9(null);
  useEffect11(() => {
    const container = popoverRef.current;
    if (!container) {
      return;
    }
    if (!container.contains(document.activeElement)) {
      container.focus();
    }
    const handleKeyDown = (event) => {
      if (event.key === KEYS.TAB) {
        const focusableElements = queryFocusableElements(container);
        const { activeElement } = document;
        const currentIndex = focusableElements.findIndex(
          (element) => element === activeElement
        );
        if (activeElement === container) {
          if (event.shiftKey) {
            focusableElements[focusableElements.length - 1]?.focus();
          } else {
            focusableElements[0].focus();
          }
          event.preventDefault();
          event.stopImmediatePropagation();
        } else if (currentIndex === 0 && event.shiftKey) {
          focusableElements[focusableElements.length - 1]?.focus();
          event.preventDefault();
          event.stopImmediatePropagation();
        } else if (currentIndex === focusableElements.length - 1 && !event.shiftKey) {
          focusableElements[0]?.focus();
          event.preventDefault();
          event.stopImmediatePropagation();
        }
      }
    };
    container.addEventListener("keydown", handleKeyDown);
    return () => container.removeEventListener("keydown", handleKeyDown);
  }, []);
  const lastInitializedPosRef = useRef9(
    null
  );
  useLayoutEffect3(() => {
    if (fitInViewport && popoverRef.current && top != null && left != null) {
      const container = popoverRef.current;
      const { width, height } = container.getBoundingClientRect();
      if (lastInitializedPosRef.current?.top === top && lastInitializedPosRef.current?.left === left) {
        return;
      }
      lastInitializedPosRef.current = { top, left };
      if (width >= viewportWidth) {
        container.style.width = `${viewportWidth}px`;
        container.style.left = "0px";
        container.style.overflowX = "scroll";
      } else if (left + width - offsetLeft > viewportWidth) {
        container.style.left = `${viewportWidth - width - 10}px`;
      } else {
        container.style.left = `${left}px`;
      }
      if (height >= viewportHeight) {
        container.style.height = `${viewportHeight - 20}px`;
        container.style.top = "10px";
        container.style.overflowY = "scroll";
      } else if (top + height - offsetTop > viewportHeight) {
        container.style.top = `${viewportHeight - height}px`;
      } else {
        container.style.top = `${top}px`;
      }
    }
  }, [
    top,
    left,
    fitInViewport,
    viewportWidth,
    viewportHeight,
    offsetLeft,
    offsetTop
  ]);
  useEffect11(() => {
    if (onCloseRequest) {
      const handler = (event) => {
        if (!popoverRef.current?.contains(event.target)) {
          unstable_batchedUpdates(() => onCloseRequest(event));
        }
      };
      document.addEventListener("pointerdown", handler, false);
      return () => document.removeEventListener("pointerdown", handler, false);
    }
  }, [onCloseRequest]);
  return /* @__PURE__ */ jsx23("div", { className: "popover", ref: popoverRef, tabIndex: -1, children });
};

// components/IconPicker.tsx
init_keys();
import clsx14 from "clsx";
import { Fragment as Fragment3, jsx as jsx24, jsxs as jsxs13 } from "react/jsx-runtime";
function Picker2({
  options,
  value,
  label,
  onChange,
  onClose
}) {
  const rFirstItem = React10.useRef();
  const rActiveItem = React10.useRef();
  const rGallery = React10.useRef(null);
  React10.useEffect(() => {
    if (rActiveItem.current) {
      rActiveItem.current.focus();
    } else if (rGallery.current) {
      rGallery.current.focus();
    }
  }, []);
  const handleKeyDown = (event) => {
    const pressedOption = options.find(
      (option) => option.keyBinding === event.key.toLowerCase()
    );
    if (!(event.metaKey || event.altKey || event.ctrlKey) && pressedOption) {
      const index = options.indexOf(pressedOption);
      rGallery.current.children[index].focus();
      event.preventDefault();
    } else if (event.key === KEYS.TAB) {
      setTimeout(() => {
        const active = rActiveItem.current;
        const docActive = document.activeElement;
        if (active !== docActive) {
          onClose();
        }
      }, 0);
    } else if (isArrowKey(event.key)) {
      const { activeElement } = document;
      const isRTL2 = getLanguage().rtl;
      const index = Array.prototype.indexOf.call(
        rGallery.current.children,
        activeElement
      );
      if (index !== -1) {
        const length = options.length;
        let nextIndex = index;
        switch (event.key) {
          case (isRTL2 ? KEYS.ARROW_LEFT : KEYS.ARROW_RIGHT):
          case KEYS.ARROW_DOWN: {
            nextIndex = (index + 1) % length;
            break;
          }
          case (isRTL2 ? KEYS.ARROW_RIGHT : KEYS.ARROW_LEFT):
          case KEYS.ARROW_UP: {
            nextIndex = (length + index - 1) % length;
            break;
          }
        }
        rGallery.current.children[nextIndex].focus();
      }
      event.preventDefault();
    } else if (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) {
      event.preventDefault();
      onClose();
    }
    event.nativeEvent.stopImmediatePropagation();
    event.stopPropagation();
  };
  return /* @__PURE__ */ jsx24(
    "div",
    {
      className: `picker`,
      role: "dialog",
      "aria-modal": "true",
      "aria-label": label,
      onKeyDown: handleKeyDown,
      children: /* @__PURE__ */ jsx24("div", { className: "picker-content", ref: rGallery, children: options.map((option, i) => /* @__PURE__ */ jsxs13(
        "button",
        {
          type: "button",
          className: clsx14("picker-option", {
            active: value === option.value
          }),
          onClick: (event) => {
            event.currentTarget.focus();
            onChange(option.value);
          },
          title: `${option.text} ${option.keyBinding && `\u2014 ${option.keyBinding.toUpperCase()}`}`,
          "aria-label": option.text || "none",
          "aria-keyshortcuts": option.keyBinding || void 0,
          ref: (el) => {
            if (el && i === 0) {
              rFirstItem.current = el;
            }
            if (el && option.value === value) {
              rActiveItem.current = el;
            }
          },
          onFocus: () => {
            onChange(option.value);
          },
          children: [
            option.icon,
            option.keyBinding && /* @__PURE__ */ jsx24("span", { className: "picker-keybinding", children: option.keyBinding })
          ]
        },
        option.text
      )) })
    }
  );
}
function IconPicker({
  value,
  label,
  options,
  onChange,
  group = ""
}) {
  const [isActive, setActive] = React10.useState(false);
  const rPickerButton = React10.useRef(null);
  const isRTL2 = getLanguage().rtl;
  return /* @__PURE__ */ jsxs13("div", { children: [
    /* @__PURE__ */ jsx24(
      "button",
      {
        name: group,
        type: "button",
        className: isActive ? "active" : "",
        "aria-label": label,
        onClick: () => setActive(!isActive),
        ref: rPickerButton,
        children: options.find((option) => option.value === value)?.icon
      }
    ),
    /* @__PURE__ */ jsx24(React10.Suspense, { fallback: "", children: isActive ? /* @__PURE__ */ jsxs13(Fragment3, { children: [
      /* @__PURE__ */ jsx24(
        Popover3,
        {
          onCloseRequest: (event) => event.target !== rPickerButton.current && setActive(false),
          ...isRTL2 ? { right: 5.5 } : { left: -5.5 },
          children: /* @__PURE__ */ jsx24(
            Picker2,
            {
              options: options.filter((opt) => opt.showInPicker !== false),
              value,
              label,
              onChange,
              onClose: () => {
                setActive(false);
                rPickerButton.current?.focus();
              }
            }
          )
        }
      ),
      /* @__PURE__ */ jsx24("div", { className: "picker-triangle" })
    ] }) : null })
  ] });
}

// components/FontPicker/FontPicker.tsx
init_define_import_meta_env();
import React15, { useCallback as useCallback3, useMemo as useMemo3 } from "react";
import * as Popover5 from "@radix-ui/react-popover";

// components/FontPicker/FontPickerList.tsx
init_define_import_meta_env();
import React14, {
  useMemo,
  useState as useState7,
  useRef as useRef11,
  useEffect as useEffect13,
  useCallback as useCallback2
} from "react";

// components/QuickSearch.tsx
init_define_import_meta_env();
init_icons();
import clsx15 from "clsx";
import React11 from "react";
import { jsx as jsx25, jsxs as jsxs14 } from "react/jsx-runtime";
var QuickSearch = React11.forwardRef(
  ({ className, placeholder, onChange }, ref) => {
    return /* @__PURE__ */ jsxs14("div", { className: clsx15("QuickSearch__wrapper", className), children: [
      searchIcon,
      /* @__PURE__ */ jsx25(
        "input",
        {
          ref,
          className: "QuickSearch__input",
          type: "text",
          placeholder,
          onChange: (e) => onChange(e.target.value.trim().toLowerCase())
        }
      )
    ] });
  }
);

// components/ScrollableList.tsx
init_define_import_meta_env();
import clsx16 from "clsx";
import { Children } from "react";
import { jsx as jsx26 } from "react/jsx-runtime";
var ScrollableList = ({
  className,
  placeholder,
  children
}) => {
  const isEmpty = !Children.count(children);
  return /* @__PURE__ */ jsx26("div", { className: clsx16("ScrollableList__wrapper", className), role: "menu", children: isEmpty ? /* @__PURE__ */ jsx26("div", { className: "empty", children: placeholder }) : children });
};

// components/dropdownMenu/DropdownMenuGroup.tsx
init_define_import_meta_env();
import { jsx as jsx27, jsxs as jsxs15 } from "react/jsx-runtime";
var MenuGroup = ({
  children,
  className = "",
  style,
  title
}) => {
  return /* @__PURE__ */ jsxs15("div", { className: `dropdown-menu-group ${className}`, style, children: [
    title && /* @__PURE__ */ jsx27("p", { className: "dropdown-menu-group-title", children: title }),
    children
  ] });
};
var DropdownMenuGroup_default = MenuGroup;
MenuGroup.displayName = "DropdownMenuGroup";

// components/dropdownMenu/DropdownMenuItem.tsx
init_define_import_meta_env();
import { useEffect as useEffect12, useRef as useRef10 } from "react";

// components/dropdownMenu/common.ts
init_define_import_meta_env();
init_constants();
init_utils2();
import React12, { useContext } from "react";
var DropdownMenuContentPropsContext = React12.createContext({});
var getDropdownMenuItemClassName = (className = "", selected = false, hovered = false) => {
  return `dropdown-menu-item dropdown-menu-item-base ${className}
  ${selected ? "dropdown-menu-item--selected" : ""} ${hovered ? "dropdown-menu-item--hovered" : ""}`.trim();
};
var useHandleDropdownMenuItemClick = (origOnClick, onSelect) => {
  const DropdownMenuContentProps = useContext(DropdownMenuContentPropsContext);
  return composeEventHandlers(origOnClick, (event) => {
    const itemSelectEvent = new CustomEvent("menu.itemSelect" /* MENU_ITEM_SELECT */, {
      bubbles: true,
      cancelable: true
    });
    onSelect?.(itemSelectEvent);
    if (!itemSelectEvent.defaultPrevented) {
      DropdownMenuContentProps.onSelect?.(itemSelectEvent);
    }
  });
};

// components/dropdownMenu/DropdownMenuItemContent.tsx
init_define_import_meta_env();
import { Fragment as Fragment4, jsx as jsx28, jsxs as jsxs16 } from "react/jsx-runtime";
var MenuItemContent = ({
  textStyle,
  icon,
  shortcut,
  children
}) => {
  const device = useDevice();
  return /* @__PURE__ */ jsxs16(Fragment4, { children: [
    icon && /* @__PURE__ */ jsx28("div", { className: "dropdown-menu-item__icon", children: icon }),
    /* @__PURE__ */ jsx28("div", { style: textStyle, className: "dropdown-menu-item__text", children }),
    shortcut && !device.editor.isMobile && /* @__PURE__ */ jsx28("div", { className: "dropdown-menu-item__shortcut", children: shortcut })
  ] });
};
var DropdownMenuItemContent_default = MenuItemContent;

// components/dropdownMenu/DropdownMenuItem.tsx
init_constants();
import { jsx as jsx29 } from "react/jsx-runtime";
var DropdownMenuItem = ({
  icon,
  value,
  order,
  children,
  shortcut,
  className,
  hovered,
  selected,
  textStyle,
  onSelect,
  onClick,
  ...rest
}) => {
  const handleClick = useHandleDropdownMenuItemClick(onClick, onSelect);
  const ref = useRef10(null);
  useEffect12(() => {
    if (hovered) {
      if (order === 0) {
        ref.current?.scrollIntoView({ block: "end" });
      } else {
        ref.current?.scrollIntoView({ block: "nearest" });
      }
    }
  }, [hovered, order]);
  return /* @__PURE__ */ jsx29(
    "button",
    {
      ...rest,
      ref,
      value,
      onClick: handleClick,
      className: getDropdownMenuItemClassName(className, selected, hovered),
      title: rest.title ?? rest["aria-label"],
      children: /* @__PURE__ */ jsx29(DropdownMenuItemContent_default, { textStyle, icon, shortcut, children })
    }
  );
};
DropdownMenuItem.displayName = "DropdownMenuItem";
var DropDownMenuItemBadgeType = {
  GREEN: "green",
  RED: "red",
  BLUE: "blue"
};
var DropDownMenuItemBadge = ({
  type = DropDownMenuItemBadgeType.BLUE,
  children
}) => {
  const { theme } = useExcalidrawAppState();
  const style = {
    display: "inline-flex",
    marginLeft: "auto",
    padding: "2px 4px",
    borderRadius: 6,
    fontSize: 9,
    fontFamily: "Cascadia, monospace",
    border: theme === THEME.LIGHT ? "1.5px solid white" : "none"
  };
  switch (type) {
    case DropDownMenuItemBadgeType.GREEN:
      Object.assign(style, {
        backgroundColor: "var(--background-color-badge)",
        color: "var(--color-badge)"
      });
      break;
    case DropDownMenuItemBadgeType.RED:
      Object.assign(style, {
        backgroundColor: "pink",
        color: "darkred"
      });
      break;
    case DropDownMenuItemBadgeType.BLUE:
    default:
      Object.assign(style, {
        background: "var(--color-promo)",
        color: "var(--color-surface-lowest)"
      });
  }
  return /* @__PURE__ */ jsx29("div", { className: "DropDownMenuItemBadge", style, children });
};
DropDownMenuItemBadge.displayName = "DropdownMenuItemBadge";
DropdownMenuItem.Badge = DropDownMenuItemBadge;
var DropdownMenuItem_default = DropdownMenuItem;

// components/FontPicker/FontPickerList.tsx
init_utils2();

// components/FontPicker/keyboardNavHandlers.ts
init_define_import_meta_env();
init_keys();
var fontPickerKeyHandler = ({
  event,
  inputRef,
  hoveredFont,
  filteredFonts,
  onClose,
  onSelect,
  onHover
}) => {
  if (!event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key.toLowerCase() === KEYS.F) {
    inputRef.current?.focus();
    return true;
  }
  if (event.key === KEYS.ESCAPE) {
    onClose();
    return true;
  }
  if (event.key === KEYS.ENTER) {
    if (hoveredFont?.value) {
      onSelect(hoveredFont.value);
    }
    return true;
  }
  if (event.key === KEYS.ARROW_DOWN) {
    if (hoveredFont?.next) {
      onHover(hoveredFont.next.value);
    } else if (filteredFonts[0]?.value) {
      onHover(filteredFonts[0].value);
    }
    return true;
  }
  if (event.key === KEYS.ARROW_UP) {
    if (hoveredFont?.prev) {
      onHover(hoveredFont.prev.value);
    } else if (filteredFonts[filteredFonts.length - 1]?.value) {
      onHover(filteredFonts[filteredFonts.length - 1].value);
    }
    return true;
  }
};

// components/FontPicker/FontPickerList.tsx
init_fonts();
import { jsx as jsx30, jsxs as jsxs17 } from "react/jsx-runtime";
var FontPickerList = React14.memo(
  ({
    selectedFontFamily,
    hoveredFontFamily,
    onSelect,
    onHover,
    onLeave,
    onOpen,
    onClose
  }) => {
    const { container } = useExcalidrawContainer();
    const { fonts } = useApp();
    const { showDeprecatedFonts } = useAppProps();
    const [searchTerm, setSearchTerm] = useState7("");
    const inputRef = useRef11(null);
    const allFonts = useMemo(
      () => Array.from(Fonts.registered.entries()).filter(([_, { metadata }]) => !metadata.serverSide).map(([familyId, { metadata, fonts: fonts2 }]) => {
        const fontDescriptor = {
          value: familyId,
          icon: metadata.icon,
          text: fonts2[0].fontFace.family
        };
        if (metadata.deprecated) {
          Object.assign(fontDescriptor, {
            deprecated: metadata.deprecated,
            badge: {
              type: DropDownMenuItemBadgeType.RED,
              placeholder: t("fontList.badge.old")
            }
          });
        }
        return fontDescriptor;
      }).sort(
        (a, b) => a.text.toLowerCase() > b.text.toLowerCase() ? 1 : -1
      ),
      []
    );
    const sceneFamilies = useMemo(
      () => new Set(fonts.getSceneFontFamilies()),
      // cache per selected font family, so hover re-render won't mess it up
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [selectedFontFamily]
    );
    const sceneFonts = useMemo(
      () => allFonts.filter((font) => sceneFamilies.has(font.value)),
      // always show all the fonts in the scene, even those that were deprecated
      [allFonts, sceneFamilies]
    );
    const availableFonts = useMemo(
      () => allFonts.filter(
        (font) => !sceneFamilies.has(font.value) && (showDeprecatedFonts || !font.deprecated)
        // skip deprecated fonts
      ),
      [allFonts, sceneFamilies, showDeprecatedFonts]
    );
    const filteredFonts = useMemo(
      () => arrayToList(
        [...sceneFonts, ...availableFonts].filter(
          (font) => font.text?.toLowerCase().includes(searchTerm)
        )
      ),
      [sceneFonts, availableFonts, searchTerm]
    );
    const hoveredFont = useMemo(() => {
      let font;
      if (hoveredFontFamily) {
        font = filteredFonts.find((font2) => font2.value === hoveredFontFamily);
      } else if (selectedFontFamily) {
        font = filteredFonts.find((font2) => font2.value === selectedFontFamily);
      }
      if (!font && searchTerm) {
        if (filteredFonts[0]?.value) {
          onHover(filteredFonts[0].value);
        } else {
          onLeave();
        }
      }
      return font;
    }, [
      hoveredFontFamily,
      selectedFontFamily,
      searchTerm,
      filteredFonts,
      onHover,
      onLeave
    ]);
    const onKeyDown = useCallback2(
      (event) => {
        const handled = fontPickerKeyHandler({
          event,
          inputRef,
          hoveredFont,
          filteredFonts,
          onSelect,
          onHover,
          onClose
        });
        if (handled) {
          event.preventDefault();
          event.stopPropagation();
        }
      },
      [hoveredFont, filteredFonts, onSelect, onHover, onClose]
    );
    useEffect13(() => {
      onOpen();
      return () => {
        onClose();
      };
    }, []);
    const sceneFilteredFonts = useMemo(
      () => filteredFonts.filter((font) => sceneFamilies.has(font.value)),
      [filteredFonts, sceneFamilies]
    );
    const availableFilteredFonts = useMemo(
      () => filteredFonts.filter((font) => !sceneFamilies.has(font.value)),
      [filteredFonts, sceneFamilies]
    );
    const renderFont = (font, index) => /* @__PURE__ */ jsxs17(
      DropdownMenuItem_default,
      {
        icon: font.icon,
        value: font.value,
        order: index,
        textStyle: {
          fontFamily: getFontFamilyString({ fontFamily: font.value })
        },
        hovered: font.value === hoveredFont?.value,
        selected: font.value === selectedFontFamily,
        tabIndex: font.value === selectedFontFamily ? 0 : -1,
        onClick: (e) => {
          onSelect(Number(e.currentTarget.value));
        },
        onMouseMove: () => {
          if (hoveredFont?.value !== font.value) {
            onHover(font.value);
          }
        },
        children: [
          font.text,
          font.badge && /* @__PURE__ */ jsx30(DropDownMenuItemBadge, { type: font.badge.type, children: font.badge.placeholder })
        ]
      },
      font.value
    );
    const groups = [];
    if (sceneFilteredFonts.length) {
      groups.push(
        /* @__PURE__ */ jsx30(DropdownMenuGroup_default, { title: t("fontList.sceneFonts"), children: sceneFilteredFonts.map(renderFont) }, "group_1")
      );
    }
    if (availableFilteredFonts.length) {
      groups.push(
        /* @__PURE__ */ jsx30(DropdownMenuGroup_default, { title: t("fontList.availableFonts"), children: availableFilteredFonts.map(
          (font, index) => renderFont(font, index + sceneFilteredFonts.length)
        ) }, "group_2")
      );
    }
    return /* @__PURE__ */ jsxs17(
      PropertiesPopover,
      {
        className: "properties-content",
        container,
        style: { width: "15rem" },
        onClose,
        onPointerLeave: onLeave,
        onKeyDown,
        children: [
          /* @__PURE__ */ jsx30(
            QuickSearch,
            {
              ref: inputRef,
              placeholder: t("quickSearch.placeholder"),
              onChange: debounce(setSearchTerm, 20)
            }
          ),
          /* @__PURE__ */ jsx30(
            ScrollableList,
            {
              className: "dropdown-menu fonts manual-hover",
              placeholder: t("fontList.empty"),
              children: groups.length ? groups : null
            }
          )
        ]
      }
    );
  },
  (prev, next) => prev.selectedFontFamily === next.selectedFontFamily && prev.hoveredFontFamily === next.hoveredFontFamily
);

// components/FontPicker/FontPickerTrigger.tsx
init_define_import_meta_env();
import * as Popover4 from "@radix-ui/react-popover";
import { useMemo as useMemo2 } from "react";
init_icons();
import { jsx as jsx31 } from "react/jsx-runtime";
var FontPickerTrigger = ({
  selectedFontFamily
}) => {
  const isTriggerActive = useMemo2(
    () => Boolean(selectedFontFamily && !isDefaultFont(selectedFontFamily)),
    [selectedFontFamily]
  );
  return /* @__PURE__ */ jsx31(Popover4.Trigger, { asChild: true, children: /* @__PURE__ */ jsx31("div", { children: /* @__PURE__ */ jsx31(
    ButtonIcon,
    {
      standalone: true,
      icon: TextIcon,
      title: t("labels.showFonts"),
      className: "properties-trigger",
      testId: "font-family-show-fonts",
      active: isTriggerActive,
      onClick: () => {
      }
    }
  ) }) });
};

// components/FontPicker/FontPicker.tsx
init_icons();
init_constants();
import { jsx as jsx32, jsxs as jsxs18 } from "react/jsx-runtime";
var DEFAULT_FONTS = [
  {
    value: FONT_FAMILY.Excalifont,
    icon: FreedrawIcon,
    text: t("labels.handDrawn"),
    testId: "font-family-handrawn"
  },
  {
    value: FONT_FAMILY.Nunito,
    icon: FontFamilyNormalIcon,
    text: t("labels.normal"),
    testId: "font-family-normal"
  },
  {
    value: FONT_FAMILY["Comic Shanns"],
    icon: FontFamilyCodeIcon,
    text: t("labels.code"),
    testId: "font-family-code"
  }
];
var defaultFontFamilies = new Set(DEFAULT_FONTS.map((x) => x.value));
var isDefaultFont = (fontFamily) => {
  if (!fontFamily) {
    return false;
  }
  return defaultFontFamilies.has(fontFamily);
};
var FontPicker = React15.memo(
  ({
    isOpened,
    selectedFontFamily,
    hoveredFontFamily,
    onSelect,
    onHover,
    onLeave,
    onPopupChange
  }) => {
    const defaultFonts = useMemo3(() => DEFAULT_FONTS, []);
    const onSelectCallback = useCallback3(
      (value) => {
        if (value) {
          onSelect(value);
        }
      },
      [onSelect]
    );
    return /* @__PURE__ */ jsxs18("div", { role: "dialog", "aria-modal": "true", className: "FontPicker__container", children: [
      /* @__PURE__ */ jsx32(
        ButtonIconSelect,
        {
          type: "button",
          options: defaultFonts,
          value: selectedFontFamily,
          onClick: onSelectCallback
        }
      ),
      /* @__PURE__ */ jsx32(ButtonSeparator, {}),
      /* @__PURE__ */ jsxs18(Popover5.Root, { open: isOpened, onOpenChange: onPopupChange, children: [
        /* @__PURE__ */ jsx32(FontPickerTrigger, { selectedFontFamily }),
        isOpened && /* @__PURE__ */ jsx32(
          FontPickerList,
          {
            selectedFontFamily,
            hoveredFontFamily,
            onSelect: onSelectCallback,
            onHover,
            onLeave,
            onOpen: () => onPopupChange(true),
            onClose: () => onPopupChange(false)
          }
        )
      ] })
    ] });
  },
  (prev, next) => prev.isOpened === next.isOpened && prev.selectedFontFamily === next.selectedFontFamily && prev.hoveredFontFamily === next.hoveredFontFamily
);

// actions/actionProperties.tsx
init_icons();
init_constants();
init_element();
init_mutateElement();
init_textElement();
init_typeChecks();
init_keys();
init_random();
init_scene();
init_comparisons();
init_utils2();
init_register();
init_store();
init_fonts();
init_binding();
init_routing();
init_linearElementEditor();
init_math();
import { Fragment as Fragment5, jsx as jsx33, jsxs as jsxs19 } from "react/jsx-runtime";
var FONT_SIZE_RELATIVE_INCREASE_STEP = 0.1;
var changeProperty = (elements, appState, callback, includeBoundText = false) => {
  const selectedElementIds = arrayToMap(
    getSelectedElements(elements, appState, {
      includeBoundTextElement: includeBoundText
    })
  );
  return elements.map((element) => {
    if (selectedElementIds.get(element.id) || element.id === appState.editingTextElement?.id) {
      return callback(element);
    }
    return element;
  });
};
var getFormValue = function(elements, appState, getAttribute, isRelevantElement, defaultValue) {
  const editingTextElement = appState.editingTextElement;
  const nonDeletedElements = getNonDeletedElements2(elements);
  let ret = null;
  if (editingTextElement) {
    ret = getAttribute(editingTextElement);
  }
  if (!ret) {
    const hasSelection = isSomeElementSelected(nonDeletedElements, appState);
    if (hasSelection) {
      ret = getCommonAttributeOfSelectedElements(
        isRelevantElement === true ? nonDeletedElements : nonDeletedElements.filter((el) => isRelevantElement(el)),
        appState,
        getAttribute
      ) ?? (typeof defaultValue === "function" ? defaultValue(true) : defaultValue);
    } else {
      ret = typeof defaultValue === "function" ? defaultValue(false) : defaultValue;
    }
  }
  return ret;
};
var offsetElementAfterFontResize = (prevElement, nextElement) => {
  if (isBoundToContainer(nextElement) || !nextElement.autoResize) {
    return nextElement;
  }
  return mutateElement(
    nextElement,
    {
      x: prevElement.textAlign === "left" ? prevElement.x : prevElement.x + (prevElement.width - nextElement.width) / (prevElement.textAlign === "center" ? 2 : 1),
      // centering vertically is non-standard, but for Excalidraw I think
      // it makes sense
      y: prevElement.y + (prevElement.height - nextElement.height) / 2
    },
    false
  );
};
var changeFontSize = (elements, appState, app, getNewFontSize, fallbackValue) => {
  const newFontSizes = /* @__PURE__ */ new Set();
  return {
    elements: changeProperty(
      elements,
      appState,
      (oldElement) => {
        if (isTextElement(oldElement)) {
          const newFontSize = getNewFontSize(oldElement);
          newFontSizes.add(newFontSize);
          let newElement2 = newElementWith(oldElement, {
            fontSize: newFontSize
          });
          redrawTextBoundingBox(
            newElement2,
            app.scene.getContainerElement(oldElement),
            app.scene.getNonDeletedElementsMap()
          );
          newElement2 = offsetElementAfterFontResize(oldElement, newElement2);
          return newElement2;
        }
        return oldElement;
      },
      true
    ),
    appState: {
      ...appState,
      // update state only if we've set all select text elements to
      // the same font size
      currentItemFontSize: newFontSizes.size === 1 ? [...newFontSizes][0] : fallbackValue ?? appState.currentItemFontSize
    },
    storeAction: StoreAction.CAPTURE
  };
};
var actionChangeStrokeColor = register({
  name: "changeStrokeColor",
  label: "labels.stroke",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      ...value.currentItemStrokeColor && {
        elements: changeProperty(
          elements,
          appState,
          (el) => {
            return hasStrokeColor(el.type) ? newElementWith(el, {
              strokeColor: value.currentItemStrokeColor
            }) : el;
          },
          true
        )
      },
      appState: {
        ...appState,
        ...value
      },
      storeAction: !!value.currentItemStrokeColor ? StoreAction.CAPTURE : StoreAction.NONE
    };
  },
  PanelComponent: ({ elements, appState, updateData, appProps }) => /* @__PURE__ */ jsxs19(Fragment5, { children: [
    /* @__PURE__ */ jsx33("h3", { "aria-hidden": "true", children: t("labels.stroke") }),
    /* @__PURE__ */ jsx33(
      ColorPicker,
      {
        topPicks: DEFAULT_ELEMENT_STROKE_PICKS,
        palette: DEFAULT_ELEMENT_STROKE_COLOR_PALETTE,
        type: "elementStroke",
        label: t("labels.stroke"),
        color: getFormValue(
          elements,
          appState,
          (element) => element.strokeColor,
          true,
          appState.currentItemStrokeColor
        ),
        onChange: (color) => updateData({ currentItemStrokeColor: color }),
        elements,
        appState,
        updateData
      }
    )
  ] })
});
var actionChangeBackgroundColor = register({
  name: "changeBackgroundColor",
  label: "labels.changeBackground",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      ...value.currentItemBackgroundColor && {
        elements: changeProperty(
          elements,
          appState,
          (el) => newElementWith(el, {
            backgroundColor: value.currentItemBackgroundColor
          })
        )
      },
      appState: {
        ...appState,
        ...value
      },
      storeAction: !!value.currentItemBackgroundColor ? StoreAction.CAPTURE : StoreAction.NONE
    };
  },
  PanelComponent: ({ elements, appState, updateData, appProps }) => /* @__PURE__ */ jsxs19(Fragment5, { children: [
    /* @__PURE__ */ jsx33("h3", { "aria-hidden": "true", children: t("labels.background") }),
    /* @__PURE__ */ jsx33(
      ColorPicker,
      {
        topPicks: DEFAULT_ELEMENT_BACKGROUND_PICKS,
        palette: DEFAULT_ELEMENT_BACKGROUND_COLOR_PALETTE,
        type: "elementBackground",
        label: t("labels.background"),
        color: getFormValue(
          elements,
          appState,
          (element) => element.backgroundColor,
          true,
          appState.currentItemBackgroundColor
        ),
        onChange: (color) => updateData({ currentItemBackgroundColor: color }),
        elements,
        appState,
        updateData
      }
    )
  ] })
});
var actionChangeFillStyle = register({
  name: "changeFillStyle",
  label: "labels.fill",
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    trackEvent(
      "element",
      "changeFillStyle",
      `${value} (${app.device.editor.isMobile ? "mobile" : "desktop"})`
    );
    return {
      elements: changeProperty(
        elements,
        appState,
        (el) => newElementWith(el, {
          fillStyle: value
        })
      ),
      appState: { ...appState, currentItemFillStyle: value },
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData }) => {
    const selectedElements = getSelectedElements(elements, appState);
    const allElementsZigZag = selectedElements.length > 0 && selectedElements.every((el) => el.fillStyle === "zigzag");
    return /* @__PURE__ */ jsxs19("fieldset", { children: [
      /* @__PURE__ */ jsx33("legend", { children: t("labels.fill") }),
      /* @__PURE__ */ jsx33(
        ButtonIconSelect,
        {
          type: "button",
          options: [
            {
              value: "hachure",
              text: `${allElementsZigZag ? t("labels.zigzag") : t("labels.hachure")} (${getShortcutKey("Alt-Click")})`,
              icon: allElementsZigZag ? FillZigZagIcon : FillHachureIcon,
              active: allElementsZigZag ? true : void 0,
              testId: `fill-hachure`
            },
            {
              value: "cross-hatch",
              text: t("labels.crossHatch"),
              icon: FillCrossHatchIcon,
              testId: `fill-cross-hatch`
            },
            {
              value: "solid",
              text: t("labels.solid"),
              icon: FillSolidIcon,
              testId: `fill-solid`
            }
          ],
          value: getFormValue(
            elements,
            appState,
            (element) => element.fillStyle,
            (element) => element.hasOwnProperty("fillStyle"),
            (hasSelection) => hasSelection ? null : appState.currentItemFillStyle
          ),
          onClick: (value, event) => {
            const nextValue = event.altKey && value === "hachure" && selectedElements.every((el) => el.fillStyle === "hachure") ? "zigzag" : value;
            updateData(nextValue);
          }
        }
      )
    ] });
  }
});
var actionChangeStrokeWidth = register({
  name: "changeStrokeWidth",
  label: "labels.strokeWidth",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      elements: changeProperty(
        elements,
        appState,
        (el) => newElementWith(el, {
          strokeWidth: value
        })
      ),
      appState: { ...appState, currentItemStrokeWidth: value },
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ jsxs19("fieldset", { children: [
    /* @__PURE__ */ jsx33("legend", { children: t("labels.strokeWidth") }),
    /* @__PURE__ */ jsx33(
      ButtonIconSelect,
      {
        group: "stroke-width",
        options: [
          {
            value: STROKE_WIDTH.thin,
            text: t("labels.thin"),
            icon: StrokeWidthBaseIcon,
            testId: "strokeWidth-thin"
          },
          {
            value: STROKE_WIDTH.bold,
            text: t("labels.bold"),
            icon: StrokeWidthBoldIcon,
            testId: "strokeWidth-bold"
          },
          {
            value: STROKE_WIDTH.extraBold,
            text: t("labels.extraBold"),
            icon: StrokeWidthExtraBoldIcon,
            testId: "strokeWidth-extraBold"
          }
        ],
        value: getFormValue(
          elements,
          appState,
          (element) => element.strokeWidth,
          (element) => element.hasOwnProperty("strokeWidth"),
          (hasSelection) => hasSelection ? null : appState.currentItemStrokeWidth
        ),
        onChange: (value) => updateData(value)
      }
    )
  ] })
});
var actionChangeSloppiness = register({
  name: "changeSloppiness",
  label: "labels.sloppiness",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      elements: changeProperty(
        elements,
        appState,
        (el) => newElementWith(el, {
          seed: randomInteger(),
          roughness: value
        })
      ),
      appState: { ...appState, currentItemRoughness: value },
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ jsxs19("fieldset", { children: [
    /* @__PURE__ */ jsx33("legend", { children: t("labels.sloppiness") }),
    /* @__PURE__ */ jsx33(
      ButtonIconSelect,
      {
        group: "sloppiness",
        options: [
          {
            value: 0,
            text: t("labels.architect"),
            icon: SloppinessArchitectIcon
          },
          {
            value: 1,
            text: t("labels.artist"),
            icon: SloppinessArtistIcon
          },
          {
            value: 2,
            text: t("labels.cartoonist"),
            icon: SloppinessCartoonistIcon
          }
        ],
        value: getFormValue(
          elements,
          appState,
          (element) => element.roughness,
          (element) => element.hasOwnProperty("roughness"),
          (hasSelection) => hasSelection ? null : appState.currentItemRoughness
        ),
        onChange: (value) => updateData(value)
      }
    )
  ] })
});
var actionChangeStrokeStyle = register({
  name: "changeStrokeStyle",
  label: "labels.strokeStyle",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      elements: changeProperty(
        elements,
        appState,
        (el) => newElementWith(el, {
          strokeStyle: value
        })
      ),
      appState: { ...appState, currentItemStrokeStyle: value },
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ jsxs19("fieldset", { children: [
    /* @__PURE__ */ jsx33("legend", { children: t("labels.strokeStyle") }),
    /* @__PURE__ */ jsx33(
      ButtonIconSelect,
      {
        group: "strokeStyle",
        options: [
          {
            value: "solid",
            text: t("labels.strokeStyle_solid"),
            icon: StrokeWidthBaseIcon
          },
          {
            value: "dashed",
            text: t("labels.strokeStyle_dashed"),
            icon: StrokeStyleDashedIcon
          },
          {
            value: "dotted",
            text: t("labels.strokeStyle_dotted"),
            icon: StrokeStyleDottedIcon
          }
        ],
        value: getFormValue(
          elements,
          appState,
          (element) => element.strokeStyle,
          (element) => element.hasOwnProperty("strokeStyle"),
          (hasSelection) => hasSelection ? null : appState.currentItemStrokeStyle
        ),
        onChange: (value) => updateData(value)
      }
    )
  ] })
});
var actionChangeOpacity = register({
  name: "changeOpacity",
  label: "labels.opacity",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      elements: changeProperty(
        elements,
        appState,
        (el) => newElementWith(el, {
          opacity: value
        }),
        true
      ),
      appState: { ...appState, currentItemOpacity: value },
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ jsxs19("label", { className: "control-label", children: [
    t("labels.opacity"),
    /* @__PURE__ */ jsx33(
      "input",
      {
        type: "range",
        min: "0",
        max: "100",
        step: "10",
        onChange: (event) => updateData(+event.target.value),
        value: getFormValue(
          elements,
          appState,
          (element) => element.opacity,
          true,
          appState.currentItemOpacity
        ) ?? void 0
      }
    )
  ] })
});
var actionChangeFontSize = register({
  name: "changeFontSize",
  label: "labels.fontSize",
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    return changeFontSize(elements, appState, app, () => value, value);
  },
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsxs19("fieldset", { children: [
    /* @__PURE__ */ jsx33("legend", { children: t("labels.fontSize") }),
    /* @__PURE__ */ jsx33(
      ButtonIconSelect,
      {
        group: "font-size",
        options: [
          {
            value: 16,
            text: t("labels.small"),
            icon: FontSizeSmallIcon,
            testId: "fontSize-small"
          },
          {
            value: 20,
            text: t("labels.medium"),
            icon: FontSizeMediumIcon,
            testId: "fontSize-medium"
          },
          {
            value: 28,
            text: t("labels.large"),
            icon: FontSizeLargeIcon,
            testId: "fontSize-large"
          },
          {
            value: 36,
            text: t("labels.veryLarge"),
            icon: FontSizeExtraLargeIcon,
            testId: "fontSize-veryLarge"
          }
        ],
        value: getFormValue(
          elements,
          appState,
          (element) => {
            if (isTextElement(element)) {
              return element.fontSize;
            }
            const boundTextElement = getBoundTextElement(
              element,
              app.scene.getNonDeletedElementsMap()
            );
            if (boundTextElement) {
              return boundTextElement.fontSize;
            }
            return null;
          },
          (element) => isTextElement(element) || getBoundTextElement(
            element,
            app.scene.getNonDeletedElementsMap()
          ) !== null,
          (hasSelection) => hasSelection ? null : appState.currentItemFontSize || DEFAULT_FONT_SIZE
        ),
        onChange: (value) => updateData(value)
      }
    )
  ] })
});
var actionDecreaseFontSize = register({
  name: "decreaseFontSize",
  label: "labels.decreaseFontSize",
  icon: fontSizeIcon,
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    return changeFontSize(
      elements,
      appState,
      app,
      (element) => Math.round(
        // get previous value before relative increase (doesn't work fully
        // due to rounding and float precision issues)
        1 / (1 + FONT_SIZE_RELATIVE_INCREASE_STEP) * element.fontSize
      )
    );
  },
  keyTest: (event) => {
    return event[KEYS.CTRL_OR_CMD] && event.shiftKey && // KEYS.COMMA needed for MacOS
    (event.key === KEYS.CHEVRON_LEFT || event.key === KEYS.COMMA);
  }
});
var actionIncreaseFontSize = register({
  name: "increaseFontSize",
  label: "labels.increaseFontSize",
  icon: fontSizeIcon,
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    return changeFontSize(
      elements,
      appState,
      app,
      (element) => Math.round(element.fontSize * (1 + FONT_SIZE_RELATIVE_INCREASE_STEP))
    );
  },
  keyTest: (event) => {
    return event[KEYS.CTRL_OR_CMD] && event.shiftKey && // KEYS.PERIOD needed for MacOS
    (event.key === KEYS.CHEVRON_RIGHT || event.key === KEYS.PERIOD);
  }
});
var actionChangeFontFamily = register({
  name: "changeFontFamily",
  label: "labels.fontFamily",
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    const { cachedElements, resetAll, resetContainers, ...nextAppState } = value;
    if (resetAll) {
      const nextElements = changeProperty(
        elements,
        appState,
        (element) => {
          const cachedElement = cachedElements?.get(element.id);
          if (cachedElement) {
            const newElement2 = newElementWith(element, {
              ...cachedElement
            });
            return newElement2;
          }
          return element;
        },
        true
      );
      return {
        elements: nextElements,
        appState: {
          ...appState,
          ...nextAppState
        },
        storeAction: StoreAction.UPDATE
      };
    }
    const { currentItemFontFamily, currentHoveredFontFamily } = value;
    let nexStoreAction = StoreAction.NONE;
    let nextFontFamily;
    let skipOnHoverRender = false;
    if (currentItemFontFamily) {
      nextFontFamily = currentItemFontFamily;
      nexStoreAction = StoreAction.CAPTURE;
    } else if (currentHoveredFontFamily) {
      nextFontFamily = currentHoveredFontFamily;
      nexStoreAction = StoreAction.NONE;
      const selectedTextElements = getSelectedElements(elements, appState, {
        includeBoundTextElement: true
      }).filter((element) => isTextElement(element));
      if (selectedTextElements.length > 200) {
        skipOnHoverRender = true;
      } else {
        let i = 0;
        let textLengthAccumulator = 0;
        while (i < selectedTextElements.length && textLengthAccumulator < 5e3) {
          const textElement = selectedTextElements[i];
          textLengthAccumulator += textElement?.originalText.length || 0;
          i++;
        }
        if (textLengthAccumulator > 5e3) {
          skipOnHoverRender = true;
        }
      }
    }
    const result = {
      appState: {
        ...appState,
        ...nextAppState
      },
      storeAction: nexStoreAction
    };
    if (nextFontFamily && !skipOnHoverRender) {
      const elementContainerMapping = /* @__PURE__ */ new Map();
      let uniqueChars = /* @__PURE__ */ new Set();
      let skipFontFaceCheck = false;
      const fontsCache = Array.from(Fonts.loadedFontsCache.values());
      const fontFamily = Object.entries(FONT_FAMILY).find(
        ([_, value2]) => value2 === nextFontFamily
      )?.[0];
      if (currentHoveredFontFamily && fontFamily && fontsCache.some((sig) => sig.startsWith(fontFamily))) {
        skipFontFaceCheck = true;
      }
      Object.assign(result, {
        elements: changeProperty(
          elements,
          appState,
          (oldElement) => {
            if (isTextElement(oldElement) && (oldElement.fontFamily !== nextFontFamily || currentItemFontFamily)) {
              const newElement2 = newElementWith(
                oldElement,
                {
                  fontFamily: nextFontFamily,
                  lineHeight: getLineHeight(nextFontFamily)
                }
              );
              const cachedContainer = cachedElements?.get(oldElement.containerId || "") || {};
              const container = app.scene.getContainerElement(oldElement);
              if (resetContainers && container && cachedContainer) {
                mutateElement(container, { ...cachedContainer }, false);
              }
              if (!skipFontFaceCheck) {
                uniqueChars = /* @__PURE__ */ new Set([
                  ...uniqueChars,
                  ...Array.from(newElement2.originalText)
                ]);
              }
              elementContainerMapping.set(newElement2, container);
              return newElement2;
            }
            return oldElement;
          },
          true
        )
      });
      const fontString = `10px ${getFontFamilyString({
        fontFamily: nextFontFamily
      })}`;
      const chars = Array.from(uniqueChars.values()).join();
      if (skipFontFaceCheck || window.document.fonts.check(fontString, chars)) {
        for (const [element, container] of elementContainerMapping) {
          redrawTextBoundingBox(
            element,
            container,
            app.scene.getNonDeletedElementsMap(),
            false
          );
        }
      } else {
        window.document.fonts.load(fontString, chars).then((fontFaces) => {
          for (const [element, container] of elementContainerMapping) {
            const latestElement = app.scene.getElement(element.id);
            const latestContainer = container ? app.scene.getElement(container.id) : null;
            if (latestElement) {
              redrawTextBoundingBox(
                latestElement,
                latestContainer,
                app.scene.getNonDeletedElementsMap(),
                false
              );
            }
          }
          app.fonts.onLoaded(fontFaces);
        });
      }
    }
    return result;
  },
  PanelComponent: ({ elements, appState, app, updateData }) => {
    const cachedElementsRef = useRef12(/* @__PURE__ */ new Map());
    const prevSelectedFontFamilyRef = useRef12(null);
    const [batchedData, setBatchedData] = useState8({});
    const isUnmounted = useRef12(true);
    const selectedFontFamily = useMemo4(() => {
      const getFontFamily = (elementsArray, elementsMap) => getFormValue(
        elementsArray,
        appState,
        (element) => {
          if (isTextElement(element)) {
            return element.fontFamily;
          }
          const boundTextElement = getBoundTextElement(element, elementsMap);
          if (boundTextElement) {
            return boundTextElement.fontFamily;
          }
          return null;
        },
        (element) => isTextElement(element) || getBoundTextElement(element, elementsMap) !== null,
        (hasSelection) => hasSelection ? null : appState.currentItemFontFamily || DEFAULT_FONT_FAMILY
      );
      if (batchedData.openPopup === "fontFamily" && appState.openPopup === "fontFamily") {
        return getFontFamily(
          Array.from(cachedElementsRef.current?.values() ?? []),
          cachedElementsRef.current
        );
      }
      if (!batchedData.openPopup && appState.openPopup !== "fontFamily") {
        return getFontFamily(elements, app.scene.getNonDeletedElementsMap());
      }
      return prevSelectedFontFamilyRef.current;
    }, [batchedData.openPopup, appState, elements, app.scene]);
    useEffect14(() => {
      prevSelectedFontFamilyRef.current = selectedFontFamily;
    }, [selectedFontFamily]);
    useEffect14(() => {
      if (Object.keys(batchedData).length) {
        updateData(batchedData);
        setBatchedData({});
      }
    }, [batchedData]);
    useEffect14(() => {
      isUnmounted.current = false;
      return () => {
        isUnmounted.current = true;
      };
    }, []);
    return /* @__PURE__ */ jsxs19("fieldset", { children: [
      /* @__PURE__ */ jsx33("legend", { children: t("labels.fontFamily") }),
      /* @__PURE__ */ jsx33(
        FontPicker,
        {
          isOpened: appState.openPopup === "fontFamily",
          selectedFontFamily,
          hoveredFontFamily: appState.currentHoveredFontFamily,
          onSelect: (fontFamily) => {
            setBatchedData({
              openPopup: null,
              currentHoveredFontFamily: null,
              currentItemFontFamily: fontFamily
            });
            cachedElementsRef.current.clear();
          },
          onHover: (fontFamily) => {
            setBatchedData({
              currentHoveredFontFamily: fontFamily,
              cachedElements: new Map(cachedElementsRef.current),
              resetContainers: true
            });
          },
          onLeave: () => {
            setBatchedData({
              currentHoveredFontFamily: null,
              cachedElements: new Map(cachedElementsRef.current),
              resetAll: true
            });
          },
          onPopupChange: (open) => {
            if (open) {
              cachedElementsRef.current.clear();
              const { editingTextElement } = appState;
              if (editingTextElement?.type === "text") {
                const latesteditingTextElement = app.scene.getElement(
                  editingTextElement.id
                );
                cachedElementsRef.current.set(
                  editingTextElement.id,
                  newElementWith(
                    latesteditingTextElement || editingTextElement,
                    {},
                    true
                  )
                );
              } else {
                const selectedElements = getSelectedElements(
                  elements,
                  appState,
                  {
                    includeBoundTextElement: true
                  }
                );
                for (const element of selectedElements) {
                  cachedElementsRef.current.set(
                    element.id,
                    newElementWith(element, {}, true)
                  );
                }
              }
              setBatchedData({
                openPopup: "fontFamily"
              });
            } else {
              const data = {
                openPopup: null,
                currentHoveredFontFamily: null,
                cachedElements: new Map(cachedElementsRef.current),
                resetAll: true
              };
              if (isUnmounted.current) {
                updateData({ ...batchedData, ...data });
              } else {
                setBatchedData(data);
              }
              cachedElementsRef.current.clear();
            }
          }
        }
      )
    ] });
  }
});
var actionChangeTextAlign = register({
  name: "changeTextAlign",
  label: "Change text alignment",
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    return {
      elements: changeProperty(
        elements,
        appState,
        (oldElement) => {
          if (isTextElement(oldElement)) {
            const newElement2 = newElementWith(
              oldElement,
              { textAlign: value }
            );
            redrawTextBoundingBox(
              newElement2,
              app.scene.getContainerElement(oldElement),
              app.scene.getNonDeletedElementsMap()
            );
            return newElement2;
          }
          return oldElement;
        },
        true
      ),
      appState: {
        ...appState,
        currentItemTextAlign: value
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData, app }) => {
    const elementsMap = app.scene.getNonDeletedElementsMap();
    return /* @__PURE__ */ jsxs19("fieldset", { children: [
      /* @__PURE__ */ jsx33("legend", { children: t("labels.textAlign") }),
      /* @__PURE__ */ jsx33(
        ButtonIconSelect,
        {
          group: "text-align",
          options: [
            {
              value: "left",
              text: t("labels.left"),
              icon: TextAlignLeftIcon,
              testId: "align-left"
            },
            {
              value: "center",
              text: t("labels.center"),
              icon: TextAlignCenterIcon,
              testId: "align-horizontal-center"
            },
            {
              value: "right",
              text: t("labels.right"),
              icon: TextAlignRightIcon,
              testId: "align-right"
            }
          ],
          value: getFormValue(
            elements,
            appState,
            (element) => {
              if (isTextElement(element)) {
                return element.textAlign;
              }
              const boundTextElement = getBoundTextElement(
                element,
                elementsMap
              );
              if (boundTextElement) {
                return boundTextElement.textAlign;
              }
              return null;
            },
            (element) => isTextElement(element) || getBoundTextElement(element, elementsMap) !== null,
            (hasSelection) => hasSelection ? null : appState.currentItemTextAlign
          ),
          onChange: (value) => updateData(value)
        }
      )
    ] });
  }
});
var actionChangeVerticalAlign = register({
  name: "changeVerticalAlign",
  label: "Change vertical alignment",
  trackEvent: { category: "element" },
  perform: (elements, appState, value, app) => {
    return {
      elements: changeProperty(
        elements,
        appState,
        (oldElement) => {
          if (isTextElement(oldElement)) {
            const newElement2 = newElementWith(
              oldElement,
              { verticalAlign: value }
            );
            redrawTextBoundingBox(
              newElement2,
              app.scene.getContainerElement(oldElement),
              app.scene.getNonDeletedElementsMap()
            );
            return newElement2;
          }
          return oldElement;
        },
        true
      ),
      appState: {
        ...appState
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData, app }) => {
    return /* @__PURE__ */ jsx33("fieldset", { children: /* @__PURE__ */ jsx33(
      ButtonIconSelect,
      {
        group: "text-align",
        options: [
          {
            value: VERTICAL_ALIGN.TOP,
            text: t("labels.alignTop"),
            icon: /* @__PURE__ */ jsx33(TextAlignTopIcon, { theme: appState.theme }),
            testId: "align-top"
          },
          {
            value: VERTICAL_ALIGN.MIDDLE,
            text: t("labels.centerVertically"),
            icon: /* @__PURE__ */ jsx33(TextAlignMiddleIcon, { theme: appState.theme }),
            testId: "align-middle"
          },
          {
            value: VERTICAL_ALIGN.BOTTOM,
            text: t("labels.alignBottom"),
            icon: /* @__PURE__ */ jsx33(TextAlignBottomIcon, { theme: appState.theme }),
            testId: "align-bottom"
          }
        ],
        value: getFormValue(
          elements,
          appState,
          (element) => {
            if (isTextElement(element) && element.containerId) {
              return element.verticalAlign;
            }
            const boundTextElement = getBoundTextElement(
              element,
              app.scene.getNonDeletedElementsMap()
            );
            if (boundTextElement) {
              return boundTextElement.verticalAlign;
            }
            return null;
          },
          (element) => isTextElement(element) || getBoundTextElement(
            element,
            app.scene.getNonDeletedElementsMap()
          ) !== null,
          (hasSelection) => hasSelection ? null : VERTICAL_ALIGN.MIDDLE
        ),
        onChange: (value) => updateData(value)
      }
    ) });
  }
});
var actionChangeRoundness = register({
  name: "changeRoundness",
  label: "Change edge roundness",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      elements: changeProperty(elements, appState, (el) => {
        if (isElbowArrow(el)) {
          return el;
        }
        return newElementWith(el, {
          roundness: value === "round" ? {
            type: isUsingAdaptiveRadius(el.type) ? ROUNDNESS.ADAPTIVE_RADIUS : ROUNDNESS.PROPORTIONAL_RADIUS
          } : null
        });
      }),
      appState: {
        ...appState,
        currentItemRoundness: value
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData }) => {
    const targetElements = getTargetElements(
      getNonDeletedElements2(elements),
      appState
    );
    const hasLegacyRoundness = targetElements.some(
      (el) => el.roundness?.type === ROUNDNESS.LEGACY
    );
    return /* @__PURE__ */ jsxs19("fieldset", { children: [
      /* @__PURE__ */ jsx33("legend", { children: t("labels.edges") }),
      /* @__PURE__ */ jsx33(
        ButtonIconSelect,
        {
          group: "edges",
          options: [
            {
              value: "sharp",
              text: t("labels.sharp"),
              icon: EdgeSharpIcon
            },
            {
              value: "round",
              text: t("labels.round"),
              icon: EdgeRoundIcon
            }
          ],
          value: getFormValue(
            elements,
            appState,
            (element) => hasLegacyRoundness ? null : element.roundness ? "round" : "sharp",
            (element) => !isArrowElement(element) && element.hasOwnProperty("roundness"),
            (hasSelection) => hasSelection ? null : appState.currentItemRoundness
          ),
          onChange: (value) => updateData(value)
        }
      )
    ] });
  }
});
var getArrowheadOptions = (flip) => {
  return [
    {
      value: null,
      text: t("labels.arrowhead_none"),
      keyBinding: "q",
      icon: ArrowheadNoneIcon
    },
    {
      value: "arrow",
      text: t("labels.arrowhead_arrow"),
      keyBinding: "w",
      icon: /* @__PURE__ */ jsx33(ArrowheadArrowIcon, { flip })
    },
    {
      value: "bar",
      text: t("labels.arrowhead_bar"),
      keyBinding: "e",
      icon: /* @__PURE__ */ jsx33(ArrowheadBarIcon, { flip })
    },
    {
      value: "dot",
      text: t("labels.arrowhead_circle"),
      keyBinding: null,
      icon: /* @__PURE__ */ jsx33(ArrowheadCircleIcon, { flip }),
      showInPicker: false
    },
    {
      value: "circle",
      text: t("labels.arrowhead_circle"),
      keyBinding: "r",
      icon: /* @__PURE__ */ jsx33(ArrowheadCircleIcon, { flip }),
      showInPicker: false
    },
    {
      value: "circle_outline",
      text: t("labels.arrowhead_circle_outline"),
      keyBinding: null,
      icon: /* @__PURE__ */ jsx33(ArrowheadCircleOutlineIcon, { flip }),
      showInPicker: false
    },
    {
      value: "triangle",
      text: t("labels.arrowhead_triangle"),
      icon: /* @__PURE__ */ jsx33(ArrowheadTriangleIcon, { flip }),
      keyBinding: "t"
    },
    {
      value: "triangle_outline",
      text: t("labels.arrowhead_triangle_outline"),
      icon: /* @__PURE__ */ jsx33(ArrowheadTriangleOutlineIcon, { flip }),
      keyBinding: null,
      showInPicker: false
    },
    {
      value: "diamond",
      text: t("labels.arrowhead_diamond"),
      icon: /* @__PURE__ */ jsx33(ArrowheadDiamondIcon, { flip }),
      keyBinding: null,
      showInPicker: false
    },
    {
      value: "diamond_outline",
      text: t("labels.arrowhead_diamond_outline"),
      icon: /* @__PURE__ */ jsx33(ArrowheadDiamondOutlineIcon, { flip }),
      keyBinding: null,
      showInPicker: false
    }
  ];
};
var actionChangeArrowhead = register({
  name: "changeArrowhead",
  label: "Change arrowheads",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      elements: changeProperty(elements, appState, (el) => {
        if (isLinearElement(el)) {
          const { position, type } = value;
          if (position === "start") {
            const element = newElementWith(el, {
              startArrowhead: type
            });
            return element;
          } else if (position === "end") {
            const element = newElementWith(el, {
              endArrowhead: type
            });
            return element;
          }
        }
        return el;
      }),
      appState: {
        ...appState,
        [value.position === "start" ? "currentItemStartArrowhead" : "currentItemEndArrowhead"]: value.type
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData }) => {
    const isRTL2 = getLanguage().rtl;
    return /* @__PURE__ */ jsxs19("fieldset", { children: [
      /* @__PURE__ */ jsx33("legend", { children: t("labels.arrowheads") }),
      /* @__PURE__ */ jsxs19("div", { className: "iconSelectList buttonList", children: [
        /* @__PURE__ */ jsx33(
          IconPicker,
          {
            label: "arrowhead_start",
            options: getArrowheadOptions(!isRTL2),
            value: getFormValue(
              elements,
              appState,
              (element) => isLinearElement(element) && canHaveArrowheads(element.type) ? element.startArrowhead : appState.currentItemStartArrowhead,
              true,
              appState.currentItemStartArrowhead
            ),
            onChange: (value) => updateData({ position: "start", type: value })
          }
        ),
        /* @__PURE__ */ jsx33(
          IconPicker,
          {
            label: "arrowhead_end",
            group: "arrowheads",
            options: getArrowheadOptions(!!isRTL2),
            value: getFormValue(
              elements,
              appState,
              (element) => isLinearElement(element) && canHaveArrowheads(element.type) ? element.endArrowhead : appState.currentItemEndArrowhead,
              true,
              appState.currentItemEndArrowhead
            ),
            onChange: (value) => updateData({ position: "end", type: value })
          }
        )
      ] })
    ] });
  }
});
var actionChangeArrowType = register({
  name: "changeArrowType",
  label: "Change arrow types",
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    return {
      elements: changeProperty(elements, appState, (el) => {
        if (!isArrowElement(el)) {
          return el;
        }
        const newElement2 = newElementWith(el, {
          roundness: value === ARROW_TYPE.round ? {
            type: ROUNDNESS.PROPORTIONAL_RADIUS
          } : null,
          elbowed: value === ARROW_TYPE.elbow,
          points: value === ARROW_TYPE.elbow || el.elbowed ? [el.points[0], el.points[el.points.length - 1]] : el.points
        });
        if (isElbowArrow(newElement2)) {
          const elementsMap = app.scene.getNonDeletedElementsMap();
          app.dismissLinearEditor();
          const startGlobalPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(
            newElement2,
            0,
            elementsMap
          );
          const endGlobalPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(
            newElement2,
            -1,
            elementsMap
          );
          const startHoveredElement = !newElement2.startBinding && getHoveredElementForBinding(
            tupleToCoors(startGlobalPoint),
            elements,
            elementsMap,
            true
          );
          const endHoveredElement = !newElement2.endBinding && getHoveredElementForBinding(
            tupleToCoors(endGlobalPoint),
            elements,
            elementsMap,
            true
          );
          const startElement = startHoveredElement ? startHoveredElement : newElement2.startBinding && elementsMap.get(
            newElement2.startBinding.elementId
          );
          const endElement = endHoveredElement ? endHoveredElement : newElement2.endBinding && elementsMap.get(
            newElement2.endBinding.elementId
          );
          const finalStartPoint = startHoveredElement ? bindPointToSnapToElementOutline(
            startGlobalPoint,
            endGlobalPoint,
            startHoveredElement,
            elementsMap
          ) : startGlobalPoint;
          const finalEndPoint = endHoveredElement ? bindPointToSnapToElementOutline(
            endGlobalPoint,
            startGlobalPoint,
            endHoveredElement,
            elementsMap
          ) : endGlobalPoint;
          startHoveredElement && bindLinearElement(
            newElement2,
            startHoveredElement,
            "start",
            elementsMap
          );
          endHoveredElement && bindLinearElement(
            newElement2,
            endHoveredElement,
            "end",
            elementsMap
          );
          mutateElbowArrow(
            newElement2,
            elementsMap,
            [finalStartPoint, finalEndPoint].map(
              (p) => pointFrom(p[0] - newElement2.x, p[1] - newElement2.y)
            ),
            vector(0, 0),
            {
              ...startElement && newElement2.startBinding ? {
                startBinding: {
                  // @ts-ignore TS cannot discern check above
                  ...newElement2.startBinding,
                  ...calculateFixedPointForElbowArrowBinding(
                    newElement2,
                    startElement,
                    "start",
                    elementsMap
                  )
                }
              } : {},
              ...endElement && newElement2.endBinding ? {
                endBinding: {
                  // @ts-ignore TS cannot discern check above
                  ...newElement2.endBinding,
                  ...calculateFixedPointForElbowArrowBinding(
                    newElement2,
                    endElement,
                    "end",
                    elementsMap
                  )
                }
              } : {}
            }
          );
        }
        return newElement2;
      }),
      appState: {
        ...appState,
        currentItemArrowType: value
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData }) => {
    return /* @__PURE__ */ jsxs19("fieldset", { children: [
      /* @__PURE__ */ jsx33("legend", { children: t("labels.arrowtypes") }),
      /* @__PURE__ */ jsx33(
        ButtonIconSelect,
        {
          group: "arrowtypes",
          options: [
            {
              value: ARROW_TYPE.sharp,
              text: t("labels.arrowtype_sharp"),
              icon: sharpArrowIcon,
              testId: "sharp-arrow"
            },
            {
              value: ARROW_TYPE.round,
              text: t("labels.arrowtype_round"),
              icon: roundArrowIcon,
              testId: "round-arrow"
            },
            {
              value: ARROW_TYPE.elbow,
              text: t("labels.arrowtype_elbowed"),
              icon: elbowArrowIcon,
              testId: "elbow-arrow"
            }
          ],
          value: getFormValue(
            elements,
            appState,
            (element) => {
              if (isArrowElement(element)) {
                return element.elbowed ? ARROW_TYPE.elbow : element.roundness ? ARROW_TYPE.round : ARROW_TYPE.sharp;
              }
              return null;
            },
            (element) => isArrowElement(element),
            (hasSelection) => hasSelection ? null : appState.currentItemArrowType
          ),
          onChange: (value) => updateData(value)
        }
      )
    ] });
  }
});

// actions/actionCanvas.tsx
init_define_import_meta_env();
init_icons();
init_constants();
init_element();
init_keys();
init_scene();
init_scroll();

// scene/zoom.ts
init_define_import_meta_env();
var getStateForZoom = ({
  viewportX,
  viewportY,
  nextZoom
}, appState) => {
  const appLayerX = viewportX - appState.offsetLeft;
  const appLayerY = viewportY - appState.offsetTop;
  const currentZoom = appState.zoom.value;
  const baseScrollX = appState.scrollX + (appLayerX - appLayerX / currentZoom);
  const baseScrollY = appState.scrollY + (appLayerY - appLayerY / currentZoom);
  const zoomOffsetScrollX = -(appLayerX - appLayerX / nextZoom);
  const zoomOffsetScrollY = -(appLayerY - appLayerY / nextZoom);
  return {
    scrollX: baseScrollX + zoomOffsetScrollX,
    scrollY: baseScrollY + zoomOffsetScrollY,
    zoom: {
      value: nextZoom
    }
  };
};

// actions/actionCanvas.tsx
init_utils2();
init_register();

// components/Tooltip.tsx
init_define_import_meta_env();
import { useEffect as useEffect15 } from "react";
import { jsx as jsx34 } from "react/jsx-runtime";
var getTooltipDiv = () => {
  const existingDiv = document.querySelector(
    ".excalidraw-tooltip"
  );
  if (existingDiv) {
    return existingDiv;
  }
  const div = document.createElement("div");
  document.body.appendChild(div);
  div.classList.add("excalidraw-tooltip");
  return div;
};
var updateTooltipPosition = (tooltip, item, position = "bottom") => {
  const tooltipRect = tooltip.getBoundingClientRect();
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;
  const margin = 5;
  let left = item.left + item.width / 2 - tooltipRect.width / 2;
  if (left < 0) {
    left = margin;
  } else if (left + tooltipRect.width >= viewportWidth) {
    left = viewportWidth - tooltipRect.width - margin;
  }
  let top;
  if (position === "bottom") {
    top = item.top + item.height + margin;
    if (top + tooltipRect.height >= viewportHeight) {
      top = item.top - tooltipRect.height - margin;
    }
  } else {
    top = item.top - tooltipRect.height - margin;
    if (top < 0) {
      top = item.top + item.height + margin;
    }
  }
  Object.assign(tooltip.style, {
    top: `${top}px`,
    left: `${left}px`
  });
};
var updateTooltip = (item, tooltip, label, long) => {
  tooltip.classList.add("excalidraw-tooltip--visible");
  tooltip.style.minWidth = long ? "50ch" : "10ch";
  tooltip.style.maxWidth = long ? "50ch" : "15ch";
  tooltip.textContent = label;
  const itemRect = item.getBoundingClientRect();
  updateTooltipPosition(tooltip, itemRect);
};
var Tooltip = ({
  children,
  label,
  long = false,
  style,
  disabled
}) => {
  useEffect15(() => {
    return () => getTooltipDiv().classList.remove("excalidraw-tooltip--visible");
  }, []);
  if (disabled) {
    return null;
  }
  return /* @__PURE__ */ jsx34(
    "div",
    {
      className: "excalidraw-tooltip-wrapper",
      onPointerEnter: (event) => updateTooltip(
        event.currentTarget,
        getTooltipDiv(),
        label,
        long
      ),
      onPointerLeave: () => getTooltipDiv().classList.remove("excalidraw-tooltip--visible"),
      style,
      children
    }
  );
};

// actions/actionCanvas.tsx
init_mutateElement();
init_appState();
init_colors();
init_cursor();
init_store();
init_math();
import { jsx as jsx35, jsxs as jsxs20 } from "react/jsx-runtime";
var actionChangeViewBackgroundColor = register({
  name: "changeViewBackgroundColor",
  label: "labels.canvasBackground",
  paletteName: "Change canvas background color",
  trackEvent: false,
  predicate: (elements, appState, props, app) => {
    return !!app.props.UIOptions.canvasActions.changeViewBackgroundColor && !appState.viewModeEnabled;
  },
  perform: (_, appState, value) => {
    return {
      appState: { ...appState, ...value },
      storeAction: !!value.viewBackgroundColor ? StoreAction.CAPTURE : StoreAction.NONE
    };
  },
  PanelComponent: ({ elements, appState, updateData, appProps }) => {
    return /* @__PURE__ */ jsx35(
      ColorPicker,
      {
        palette: null,
        topPicks: DEFAULT_CANVAS_BACKGROUND_PICKS,
        label: t("labels.canvasBackground"),
        type: "canvasBackground",
        color: appState.viewBackgroundColor,
        onChange: (color) => updateData({ viewBackgroundColor: color }),
        "data-testid": "canvas-background-picker",
        elements,
        appState,
        updateData
      }
    );
  }
});
var actionClearCanvas = register({
  name: "clearCanvas",
  label: "labels.clearCanvas",
  paletteName: "Clear canvas",
  icon: TrashIcon,
  trackEvent: { category: "canvas" },
  predicate: (elements, appState, props, app) => {
    return !!app.props.UIOptions.canvasActions.clearCanvas && !appState.viewModeEnabled;
  },
  perform: (elements, appState, _, app) => {
    app.imageCache.clear();
    return {
      elements: elements.map(
        (element) => newElementWith(element, { isDeleted: true })
      ),
      appState: {
        ...getDefaultAppState(),
        files: {},
        theme: appState.theme,
        penMode: appState.penMode,
        penDetected: appState.penDetected,
        exportBackground: appState.exportBackground,
        exportEmbedScene: appState.exportEmbedScene,
        gridSize: appState.gridSize,
        gridStep: appState.gridStep,
        gridModeEnabled: appState.gridModeEnabled,
        stats: appState.stats,
        pasteDialog: appState.pasteDialog,
        activeTool: appState.activeTool.type === "image" ? { ...appState.activeTool, type: "selection" } : appState.activeTool
      },
      storeAction: StoreAction.CAPTURE
    };
  }
});
var actionZoomIn = register({
  name: "zoomIn",
  label: "buttons.zoomIn",
  viewMode: true,
  icon: ZoomInIcon,
  trackEvent: { category: "canvas" },
  perform: (_elements, appState, _, app) => {
    return {
      appState: {
        ...appState,
        ...getStateForZoom(
          {
            viewportX: appState.width / 2 + appState.offsetLeft,
            viewportY: appState.height / 2 + appState.offsetTop,
            nextZoom: getNormalizedZoom(appState.zoom.value + ZOOM_STEP)
          },
          appState
        ),
        userToFollow: null
      },
      storeAction: StoreAction.NONE
    };
  },
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ jsx35(
    ToolButton,
    {
      type: "button",
      className: "zoom-in-button zoom-button",
      icon: ZoomInIcon,
      title: `${t("buttons.zoomIn")} \u2014 ${getShortcutKey("CtrlOrCmd++")}`,
      "aria-label": t("buttons.zoomIn"),
      disabled: appState.zoom.value >= MAX_ZOOM,
      onClick: () => {
        updateData(null);
      }
    }
  ),
  keyTest: (event) => (event.code === CODES.EQUAL || event.code === CODES.NUM_ADD) && (event[KEYS.CTRL_OR_CMD] || event.shiftKey)
});
var actionZoomOut = register({
  name: "zoomOut",
  label: "buttons.zoomOut",
  icon: ZoomOutIcon,
  viewMode: true,
  trackEvent: { category: "canvas" },
  perform: (_elements, appState, _, app) => {
    return {
      appState: {
        ...appState,
        ...getStateForZoom(
          {
            viewportX: appState.width / 2 + appState.offsetLeft,
            viewportY: appState.height / 2 + appState.offsetTop,
            nextZoom: getNormalizedZoom(appState.zoom.value - ZOOM_STEP)
          },
          appState
        ),
        userToFollow: null
      },
      storeAction: StoreAction.NONE
    };
  },
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ jsx35(
    ToolButton,
    {
      type: "button",
      className: "zoom-out-button zoom-button",
      icon: ZoomOutIcon,
      title: `${t("buttons.zoomOut")} \u2014 ${getShortcutKey("CtrlOrCmd+-")}`,
      "aria-label": t("buttons.zoomOut"),
      disabled: appState.zoom.value <= MIN_ZOOM,
      onClick: () => {
        updateData(null);
      }
    }
  ),
  keyTest: (event) => (event.code === CODES.MINUS || event.code === CODES.NUM_SUBTRACT) && (event[KEYS.CTRL_OR_CMD] || event.shiftKey)
});
var actionResetZoom = register({
  name: "resetZoom",
  label: "buttons.resetZoom",
  icon: ZoomResetIcon,
  viewMode: true,
  trackEvent: { category: "canvas" },
  perform: (_elements, appState, _, app) => {
    return {
      appState: {
        ...appState,
        ...getStateForZoom(
          {
            viewportX: appState.width / 2 + appState.offsetLeft,
            viewportY: appState.height / 2 + appState.offsetTop,
            nextZoom: getNormalizedZoom(1)
          },
          appState
        ),
        userToFollow: null
      },
      storeAction: StoreAction.NONE
    };
  },
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ jsx35(Tooltip, { label: t("buttons.resetZoom"), style: { height: "100%" }, children: /* @__PURE__ */ jsxs20(
    ToolButton,
    {
      type: "button",
      className: "reset-zoom-button zoom-button",
      title: t("buttons.resetZoom"),
      "aria-label": t("buttons.resetZoom"),
      onClick: () => {
        updateData(null);
      },
      children: [
        (appState.zoom.value * 100).toFixed(0),
        "%"
      ]
    }
  ) }),
  keyTest: (event) => (event.code === CODES.ZERO || event.code === CODES.NUM_ZERO) && (event[KEYS.CTRL_OR_CMD] || event.shiftKey)
});
var zoomValueToFitBoundsOnViewport = (bounds, viewportDimensions, viewportZoomFactor = 1) => {
  const [x1, y1, x2, y2] = bounds;
  const commonBoundsWidth = x2 - x1;
  const zoomValueForWidth = viewportDimensions.width / commonBoundsWidth;
  const commonBoundsHeight = y2 - y1;
  const zoomValueForHeight = viewportDimensions.height / commonBoundsHeight;
  const smallestZoomValue = Math.min(zoomValueForWidth, zoomValueForHeight);
  const adjustedZoomValue = smallestZoomValue * clamp(viewportZoomFactor, 0.1, 1);
  return Math.min(adjustedZoomValue, 1);
};
var zoomToFitBounds = ({
  bounds,
  appState,
  canvasOffsets,
  fitToViewport = false,
  viewportZoomFactor = 1,
  minZoom = -Infinity,
  maxZoom = Infinity
}) => {
  viewportZoomFactor = clamp(viewportZoomFactor, MIN_ZOOM, MAX_ZOOM);
  const [x1, y1, x2, y2] = bounds;
  const centerX = (x1 + x2) / 2;
  const centerY = (y1 + y2) / 2;
  const canvasOffsetLeft = canvasOffsets?.left ?? 0;
  const canvasOffsetTop = canvasOffsets?.top ?? 0;
  const canvasOffsetRight = canvasOffsets?.right ?? 0;
  const canvasOffsetBottom = canvasOffsets?.bottom ?? 0;
  const effectiveCanvasWidth = appState.width - canvasOffsetLeft - canvasOffsetRight;
  const effectiveCanvasHeight = appState.height - canvasOffsetTop - canvasOffsetBottom;
  let adjustedZoomValue;
  if (fitToViewport) {
    const commonBoundsWidth = x2 - x1;
    const commonBoundsHeight = y2 - y1;
    adjustedZoomValue = Math.min(
      effectiveCanvasWidth / commonBoundsWidth,
      effectiveCanvasHeight / commonBoundsHeight
    ) * viewportZoomFactor;
  } else {
    adjustedZoomValue = zoomValueToFitBoundsOnViewport(
      bounds,
      {
        width: effectiveCanvasWidth,
        height: effectiveCanvasHeight
      },
      viewportZoomFactor
    );
  }
  const newZoomValue = getNormalizedZoom(
    clamp(roundToStep(adjustedZoomValue, ZOOM_STEP, "floor"), minZoom, maxZoom)
  );
  const centerScroll = centerScrollOn({
    scenePoint: { x: centerX, y: centerY },
    viewportDimensions: {
      width: appState.width,
      height: appState.height
    },
    offsets: canvasOffsets,
    zoom: { value: newZoomValue }
  });
  return {
    appState: {
      ...appState,
      scrollX: centerScroll.scrollX,
      scrollY: centerScroll.scrollY,
      zoom: { value: newZoomValue }
    },
    storeAction: StoreAction.NONE
  };
};
var zoomToFit = ({
  canvasOffsets,
  targetElements,
  appState,
  fitToViewport,
  viewportZoomFactor,
  minZoom,
  maxZoom
}) => {
  const commonBounds = getCommonBounds(getNonDeletedElements2(targetElements));
  return zoomToFitBounds({
    canvasOffsets,
    bounds: commonBounds,
    appState,
    fitToViewport,
    viewportZoomFactor,
    minZoom,
    maxZoom
  });
};
var actionZoomToFitSelectionInViewport = register({
  name: "zoomToFitSelectionInViewport",
  label: "labels.zoomToFitViewport",
  icon: zoomAreaIcon,
  trackEvent: { category: "canvas" },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    return zoomToFit({
      targetElements: selectedElements.length ? selectedElements : elements,
      appState: {
        ...appState,
        userToFollow: null
      },
      fitToViewport: false,
      canvasOffsets: app.getEditorUIOffsets()
    });
  },
  // NOTE shift-2 should have been assigned actionZoomToFitSelection.
  // TBD on how proceed
  keyTest: (event) => event.code === CODES.TWO && event.shiftKey && !event.altKey && !event[KEYS.CTRL_OR_CMD]
});
var actionZoomToFitSelection = register({
  name: "zoomToFitSelection",
  label: "helpDialog.zoomToSelection",
  icon: zoomAreaIcon,
  trackEvent: { category: "canvas" },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    return zoomToFit({
      targetElements: selectedElements.length ? selectedElements : elements,
      appState: {
        ...appState,
        userToFollow: null
      },
      fitToViewport: true,
      canvasOffsets: app.getEditorUIOffsets()
    });
  },
  // NOTE this action should use shift-2 per figma, alas
  keyTest: (event) => event.code === CODES.THREE && event.shiftKey && !event.altKey && !event[KEYS.CTRL_OR_CMD]
});
var actionZoomToFit = register({
  name: "zoomToFit",
  label: "helpDialog.zoomToFit",
  icon: zoomAreaIcon,
  viewMode: true,
  trackEvent: { category: "canvas" },
  perform: (elements, appState, _, app) => zoomToFit({
    targetElements: elements,
    appState: {
      ...appState,
      userToFollow: null
    },
    fitToViewport: false,
    canvasOffsets: app.getEditorUIOffsets()
  }),
  keyTest: (event) => event.code === CODES.ONE && event.shiftKey && !event.altKey && !event[KEYS.CTRL_OR_CMD]
});
var actionToggleTheme = register({
  name: "toggleTheme",
  label: (_, appState) => {
    return appState.theme === THEME.DARK ? "buttons.lightMode" : "buttons.darkMode";
  },
  keywords: ["toggle", "dark", "light", "mode", "theme"],
  icon: (appState) => appState.theme === THEME.LIGHT ? MoonIcon : SunIcon,
  viewMode: true,
  trackEvent: { category: "canvas" },
  perform: (_, appState, value) => {
    return {
      appState: {
        ...appState,
        theme: value || (appState.theme === THEME.LIGHT ? THEME.DARK : THEME.LIGHT)
      },
      storeAction: StoreAction.NONE
    };
  },
  keyTest: (event) => event.altKey && event.shiftKey && event.code === CODES.D,
  predicate: (elements, appState, props, app) => {
    return !!app.props.UIOptions.canvasActions.toggleTheme;
  }
});
var actionToggleEraserTool = register({
  name: "toggleEraserTool",
  label: "toolBar.eraser",
  trackEvent: { category: "toolbar" },
  perform: (elements, appState) => {
    let activeTool;
    if (isEraserActive(appState)) {
      activeTool = updateActiveTool(appState, {
        ...appState.activeTool.lastActiveTool || {
          type: "selection"
        },
        lastActiveToolBeforeEraser: null
      });
    } else {
      activeTool = updateActiveTool(appState, {
        type: "eraser",
        lastActiveToolBeforeEraser: appState.activeTool
      });
    }
    return {
      appState: {
        ...appState,
        selectedElementIds: {},
        selectedGroupIds: {},
        activeEmbeddable: null,
        activeTool
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => event.key === KEYS.E
});
var actionToggleHandTool = register({
  name: "toggleHandTool",
  label: "toolBar.hand",
  paletteName: "Toggle hand tool",
  trackEvent: { category: "toolbar" },
  icon: handIcon,
  viewMode: false,
  perform: (elements, appState, _, app) => {
    let activeTool;
    if (isHandToolActive(appState)) {
      activeTool = updateActiveTool(appState, {
        ...appState.activeTool.lastActiveTool || {
          type: "selection"
        },
        lastActiveToolBeforeEraser: null
      });
    } else {
      activeTool = updateActiveTool(appState, {
        type: "hand",
        lastActiveToolBeforeEraser: appState.activeTool
      });
      setCursor(app.interactiveCanvas, CURSOR_TYPE.GRAB);
    }
    return {
      appState: {
        ...appState,
        selectedElementIds: {},
        selectedGroupIds: {},
        activeEmbeddable: null,
        activeTool
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => !event.altKey && !event[KEYS.CTRL_OR_CMD] && event.key === KEYS.H
});

// actions/actionFinalize.tsx
init_define_import_meta_env();
init_keys();
init_element();
init_utils2();
init_icons();
init_register();
init_mutateElement();
init_linearElementEditor();
init_binding();
init_typeChecks();
init_cursor();
init_store();
init_math();
init_shapes();
import { jsx as jsx36 } from "react/jsx-runtime";
var actionFinalize = register({
  name: "finalize",
  label: "",
  trackEvent: false,
  perform: (elements, appState, _, app) => {
    const { interactiveCanvas, focusContainer, scene } = app;
    const elementsMap = scene.getNonDeletedElementsMap();
    if (appState.editingLinearElement) {
      const { elementId, startBindingElement, endBindingElement } = appState.editingLinearElement;
      const element = LinearElementEditor.getElement(elementId, elementsMap);
      if (element) {
        if (isBindingElement(element)) {
          bindOrUnbindLinearElement(
            element,
            startBindingElement,
            endBindingElement,
            elementsMap,
            scene
          );
        }
        return {
          elements: element.points.length < 2 || isInvisiblySmallElement(element) ? elements.filter((el) => el.id !== element.id) : void 0,
          appState: {
            ...appState,
            cursorButton: "up",
            editingLinearElement: null
          },
          storeAction: StoreAction.CAPTURE
        };
      }
    }
    let newElements = elements;
    const pendingImageElement = appState.pendingImageElementId && scene.getElement(appState.pendingImageElementId);
    if (pendingImageElement) {
      mutateElement(pendingImageElement, { isDeleted: true }, false);
    }
    if (window.document.activeElement instanceof HTMLElement) {
      focusContainer();
    }
    const multiPointElement = appState.multiElement ? appState.multiElement : appState.newElement?.type === "freedraw" ? appState.newElement : null;
    if (multiPointElement) {
      if (multiPointElement.type !== "freedraw" && appState.lastPointerDownWith !== "touch") {
        const { points, lastCommittedPoint } = multiPointElement;
        if (!lastCommittedPoint || points[points.length - 1] !== lastCommittedPoint) {
          mutateElement(multiPointElement, {
            points: multiPointElement.points.slice(0, -1)
          });
        }
      }
      if (isInvisiblySmallElement(multiPointElement)) {
        newElements = newElements.filter(
          (el) => el.id !== multiPointElement.id
        );
      }
      const isLoop = isPathALoop(multiPointElement.points, appState.zoom.value);
      if (multiPointElement.type === "line" || multiPointElement.type === "freedraw") {
        if (isLoop) {
          const linePoints = multiPointElement.points;
          const firstPoint = linePoints[0];
          mutateElement(multiPointElement, {
            points: linePoints.map(
              (p, index) => index === linePoints.length - 1 ? pointFrom(firstPoint[0], firstPoint[1]) : p
            )
          });
        }
      }
      if (isBindingElement(multiPointElement) && !isLoop && multiPointElement.points.length > 1) {
        const [x, y] = LinearElementEditor.getPointAtIndexGlobalCoordinates(
          multiPointElement,
          -1,
          arrayToMap(elements)
        );
        maybeBindLinearElement(
          multiPointElement,
          appState,
          { x, y },
          elementsMap,
          elements
        );
      }
    }
    if (!appState.activeTool.locked && appState.activeTool.type !== "freedraw" || !multiPointElement) {
      resetCursor(interactiveCanvas);
    }
    let activeTool;
    if (appState.activeTool.type === "eraser") {
      activeTool = updateActiveTool(appState, {
        ...appState.activeTool.lastActiveTool || {
          type: "selection"
        },
        lastActiveToolBeforeEraser: null
      });
    } else {
      activeTool = updateActiveTool(appState, {
        type: "selection"
      });
    }
    return {
      elements: newElements,
      appState: {
        ...appState,
        cursorButton: "up",
        activeTool: (appState.activeTool.locked || appState.activeTool.type === "freedraw") && multiPointElement ? appState.activeTool : activeTool,
        activeEmbeddable: null,
        newElement: null,
        selectionElement: null,
        multiElement: null,
        editingTextElement: null,
        startBoundElement: null,
        suggestedBindings: [],
        selectedElementIds: multiPointElement && !appState.activeTool.locked && appState.activeTool.type !== "freedraw" ? {
          ...appState.selectedElementIds,
          [multiPointElement.id]: true
        } : appState.selectedElementIds,
        // To select the linear element when user has finished mutipoint editing
        selectedLinearElement: multiPointElement && isLinearElement(multiPointElement) ? new LinearElementEditor(multiPointElement) : appState.selectedLinearElement,
        pendingImageElementId: null
      },
      // TODO: #7348 we should not capture everything, but if we don't, it leads to incosistencies -> revisit
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event, appState) => event.key === KEYS.ESCAPE && (appState.editingLinearElement !== null || !appState.newElement && appState.multiElement === null) || (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) && appState.multiElement !== null,
  PanelComponent: ({ appState, updateData, data }) => /* @__PURE__ */ jsx36(
    ToolButton,
    {
      type: "button",
      icon: done,
      title: t("buttons.done"),
      "aria-label": t("buttons.done"),
      onClick: updateData,
      visible: appState.multiElement != null,
      size: data?.size || "medium",
      style: { pointerEvents: "all" }
    }
  )
});

// actions/actionExport.tsx
init_define_import_meta_env();
init_icons();

// components/ProjectName.tsx
init_define_import_meta_env();
init_utils2();
import { useState as useState9 } from "react";
init_keys();
import { jsx as jsx37, jsxs as jsxs21 } from "react/jsx-runtime";
var ProjectName = (props) => {
  const { id } = useExcalidrawContainer();
  const [fileName, setFileName] = useState9(props.value);
  const handleBlur = (event) => {
    if (!props.ignoreFocus) {
      focusNearestParent(event.target);
    }
    const value = event.target.value;
    if (value !== props.value) {
      props.onChange(value);
    }
  };
  const handleKeyDown = (event) => {
    if (event.key === KEYS.ENTER) {
      event.preventDefault();
      if (event.nativeEvent.isComposing || event.keyCode === 229) {
        return;
      }
      event.currentTarget.blur();
    }
  };
  return /* @__PURE__ */ jsxs21("div", { className: "ProjectName", children: [
    /* @__PURE__ */ jsx37("label", { className: "ProjectName-label", htmlFor: "filename", children: `${props.label}:` }),
    /* @__PURE__ */ jsx37(
      "input",
      {
        type: "text",
        className: "TextInput",
        onBlur: handleBlur,
        onKeyDown: handleKeyDown,
        id: `${id}-filename`,
        value: fileName,
        onChange: (event) => setFileName(event.target.value)
      }
    )
  ] });
};

// components/DarkModeToggle.tsx
init_define_import_meta_env();
init_constants();
import { jsx as jsx38 } from "react/jsx-runtime";
var DarkModeToggle = (props) => {
  const title = props.title || (props.value === THEME.DARK ? t("buttons.lightMode") : t("buttons.darkMode"));
  return /* @__PURE__ */ jsx38(
    ToolButton,
    {
      type: "icon",
      icon: props.value === THEME.LIGHT ? ICONS.MOON : ICONS.SUN,
      title,
      "aria-label": title,
      onClick: () => props.onChange(props.value === THEME.DARK ? THEME.LIGHT : THEME.DARK),
      "data-testid": "toggle-dark-mode"
    }
  );
};
var ICONS = {
  SUN: /* @__PURE__ */ jsx38("svg", { width: "512", height: "512", className: "rtl-mirror", viewBox: "0 0 512 512", children: /* @__PURE__ */ jsx38(
    "path",
    {
      fill: "currentColor",
      d: "M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"
    }
  ) }),
  MOON: /* @__PURE__ */ jsx38("svg", { width: "512", height: "512", className: "rtl-mirror", viewBox: "0 0 512 512", children: /* @__PURE__ */ jsx38(
    "path",
    {
      fill: "currentColor",
      d: "M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 0 0 283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z"
    }
  ) })
};

// data/index.ts
init_define_import_meta_env();
init_clipboard();
init_constants();
init_element();
init_typeChecks();
init_scene();
init_export();
init_utils2();
init_blob();
init_filesystem();
init_json();
init_frame();
init_blob();
init_json();
var prepareElementsForExport = (elements, { selectedElementIds }, exportSelectionOnly) => {
  elements = getNonDeletedElements2(elements);
  const isExportingSelection = exportSelectionOnly && isSomeElementSelected(elements, { selectedElementIds });
  let exportingFrame = null;
  let exportedElements = isExportingSelection ? getSelectedElements(
    elements,
    { selectedElementIds },
    {
      includeBoundTextElement: true
    }
  ) : elements;
  if (isExportingSelection) {
    if (exportedElements.length === 1 && isFrameLikeElement(exportedElements[0])) {
      exportingFrame = exportedElements[0];
      exportedElements = getElementsOverlappingFrame(elements, exportingFrame);
    } else if (exportedElements.length > 1) {
      exportedElements = getSelectedElements(
        elements,
        { selectedElementIds },
        {
          includeBoundTextElement: true,
          includeElementsInFrames: true
        }
      );
    }
  }
  return {
    exportingFrame,
    exportedElements: cloneJSON(exportedElements)
  };
};
var exportCanvas = async (type, elements, appState, files, {
  exportBackground,
  exportPadding = DEFAULT_EXPORT_PADDING,
  viewBackgroundColor,
  name = appState.name || DEFAULT_FILENAME,
  fileHandle = null,
  exportingFrame = null
}) => {
  if (elements.length === 0) {
    throw new Error(t("alerts.cannotExportEmptyCanvas"));
  }
  if (type === "svg" || type === "clipboard-svg") {
    const svgPromise = exportToSvg(
      elements,
      {
        exportBackground,
        exportWithDarkMode: appState.exportWithDarkMode,
        viewBackgroundColor,
        exportPadding,
        exportScale: appState.exportScale,
        exportEmbedScene: appState.exportEmbedScene && type === "svg"
      },
      files,
      { exportingFrame }
    );
    if (type === "svg") {
      return fileSave(
        svgPromise.then((svg) => {
          return new Blob([svg.outerHTML], { type: MIME_TYPES.svg });
        }),
        {
          description: "Export to SVG",
          name,
          extension: appState.exportEmbedScene ? "excalidraw.svg" : "svg",
          fileHandle
        }
      );
    } else if (type === "clipboard-svg") {
      const svg = await svgPromise.then((svg2) => svg2.outerHTML);
      try {
        await copyTextToSystemClipboard(svg);
      } catch (e) {
        throw new Error(t("errors.copyToSystemClipboardFailed"));
      }
      return;
    }
  }
  const tempCanvas = exportToCanvas(elements, appState, files, {
    exportBackground,
    viewBackgroundColor,
    exportPadding,
    exportingFrame
  });
  if (type === "png") {
    let blob = canvasToBlob(tempCanvas);
    if (appState.exportEmbedScene) {
      blob = blob.then(
        (blob2) => Promise.resolve().then(() => (init_image(), image_exports)).then(
          ({ encodePngMetadata: encodePngMetadata2 }) => encodePngMetadata2({
            blob: blob2,
            metadata: serializeAsJSON(elements, appState, files, "local")
          })
        )
      );
    }
    return fileSave(blob, {
      description: "Export to PNG",
      name,
      // FIXME reintroduce `excalidraw.png` when most people upgrade away
      // from 111.0.5563.64 (arm64), see #6349
      extension: (
        /* appState.exportEmbedScene ? "excalidraw.png" : */
        "png"
      ),
      fileHandle
    });
  } else if (type === "clipboard") {
    try {
      const blob = canvasToBlob(tempCanvas);
      await copyBlobToClipboardAsPng(blob);
    } catch (error) {
      console.warn(error);
      if (error.name === "CANVAS_POSSIBLY_TOO_BIG") {
        throw new Error(t("canvasError.canvasTooBig"));
      }
      if (isFirefox && error.name === "TypeError") {
        throw new Error(
          `${t("alerts.couldNotCopyToClipboard")}

${t(
            "hints.firefox_clipboard_write"
          )}`
        );
      } else {
        throw new Error(t("alerts.couldNotCopyToClipboard"));
      }
    }
  } else {
    throw new Error("Unsupported export type");
  }
};

// data/resave.ts
init_define_import_meta_env();
init_blob();
var resaveAsImageWithScene = async (elements, appState, files, name) => {
  const { exportBackground, viewBackgroundColor, fileHandle } = appState;
  const fileHandleType = getFileHandleType(fileHandle);
  if (!fileHandle || !isImageFileHandleType(fileHandleType)) {
    throw new Error(
      "fileHandle should exist and should be of type svg or png when resaving"
    );
  }
  appState = {
    ...appState,
    exportEmbedScene: true
  };
  const { exportedElements, exportingFrame } = prepareElementsForExport(
    elements,
    appState,
    false
  );
  await exportCanvas(fileHandleType, exportedElements, appState, files, {
    exportBackground,
    viewBackgroundColor,
    name,
    fileHandle,
    exportingFrame
  });
  return { fileHandle };
};

// actions/actionExport.tsx
init_keys();
init_register();

// components/CheckboxItem.tsx
init_define_import_meta_env();
init_icons();
import clsx17 from "clsx";
import { jsx as jsx39, jsxs as jsxs22 } from "react/jsx-runtime";
var CheckboxItem = ({ children, checked, onChange, className }) => {
  return /* @__PURE__ */ jsxs22(
    "div",
    {
      className: clsx17("Checkbox", className, { "is-checked": checked }),
      onClick: (event) => {
        onChange(!checked, event);
        event.currentTarget.querySelector(
          ".Checkbox-box"
        ).focus();
      },
      children: [
        /* @__PURE__ */ jsx39(
          "button",
          {
            type: "button",
            className: "Checkbox-box",
            role: "checkbox",
            "aria-checked": checked,
            children: checkIcon
          }
        ),
        /* @__PURE__ */ jsx39("div", { className: "Checkbox-label", children })
      ]
    }
  );
};

// actions/actionExport.tsx
init_export();
init_constants();
init_scene();
init_element();
init_blob();
init_filesystem();
init_store();
import { Fragment as Fragment6, jsx as jsx40, jsxs as jsxs23 } from "react/jsx-runtime";
var actionChangeProjectName = register({
  name: "changeProjectName",
  label: "labels.fileTitle",
  trackEvent: false,
  perform: (_elements, appState, value) => {
    return {
      appState: { ...appState, name: value },
      storeAction: StoreAction.NONE
    };
  },
  PanelComponent: ({ appState, updateData, appProps, data, app }) => /* @__PURE__ */ jsx40(
    ProjectName,
    {
      label: t("labels.fileTitle"),
      value: app.getName(),
      onChange: (name) => updateData(name),
      ignoreFocus: data?.ignoreFocus ?? false
    }
  )
});
var actionChangeExportScale = register({
  name: "changeExportScale",
  label: "imageExportDialog.scale",
  trackEvent: { category: "export", action: "scale" },
  perform: (_elements, appState, value) => {
    return {
      appState: { ...appState, exportScale: value },
      storeAction: StoreAction.NONE
    };
  },
  PanelComponent: ({ elements: allElements, appState, updateData }) => {
    const elements = getNonDeletedElements2(allElements);
    const exportSelected = isSomeElementSelected(elements, appState);
    const exportedElements = exportSelected ? getSelectedElements(elements, appState) : elements;
    return /* @__PURE__ */ jsx40(Fragment6, { children: EXPORT_SCALES.map((s) => {
      const [width, height] = getExportSize(
        exportedElements,
        DEFAULT_EXPORT_PADDING,
        s
      );
      const scaleButtonTitle = `${t(
        "imageExportDialog.label.scale"
      )} ${s}x (${width}x${height})`;
      return /* @__PURE__ */ jsx40(
        ToolButton,
        {
          size: "small",
          type: "radio",
          icon: `${s}x`,
          name: "export-canvas-scale",
          title: scaleButtonTitle,
          "aria-label": scaleButtonTitle,
          id: "export-canvas-scale",
          checked: s === appState.exportScale,
          onChange: () => updateData(s)
        },
        s
      );
    }) });
  }
});
var actionChangeExportBackground = register({
  name: "changeExportBackground",
  label: "imageExportDialog.label.withBackground",
  trackEvent: { category: "export", action: "toggleBackground" },
  perform: (_elements, appState, value) => {
    return {
      appState: { ...appState, exportBackground: value },
      storeAction: StoreAction.NONE
    };
  },
  PanelComponent: ({ appState, updateData }) => /* @__PURE__ */ jsx40(
    CheckboxItem,
    {
      checked: appState.exportBackground,
      onChange: (checked) => updateData(checked),
      children: t("imageExportDialog.label.withBackground")
    }
  )
});
var actionChangeExportEmbedScene = register({
  name: "changeExportEmbedScene",
  label: "imageExportDialog.tooltip.embedScene",
  trackEvent: { category: "export", action: "embedScene" },
  perform: (_elements, appState, value) => {
    return {
      appState: { ...appState, exportEmbedScene: value },
      storeAction: StoreAction.NONE
    };
  },
  PanelComponent: ({ appState, updateData }) => /* @__PURE__ */ jsxs23(
    CheckboxItem,
    {
      checked: appState.exportEmbedScene,
      onChange: (checked) => updateData(checked),
      children: [
        t("imageExportDialog.label.embedScene"),
        /* @__PURE__ */ jsx40(Tooltip, { label: t("imageExportDialog.tooltip.embedScene"), long: true, children: /* @__PURE__ */ jsx40("div", { className: "excalidraw-tooltip-icon", children: questionCircle }) })
      ]
    }
  )
});
var actionSaveToActiveFile = register({
  name: "saveToActiveFile",
  label: "buttons.save",
  icon: ExportIcon,
  trackEvent: { category: "export" },
  predicate: (elements, appState, props, app) => {
    return !!app.props.UIOptions.canvasActions.saveToActiveFile && !!appState.fileHandle && !appState.viewModeEnabled;
  },
  perform: async (elements, appState, value, app) => {
    const fileHandleExists = !!appState.fileHandle;
    try {
      const { fileHandle } = isImageFileHandle(appState.fileHandle) ? await resaveAsImageWithScene(
        elements,
        appState,
        app.files,
        app.getName()
      ) : await saveAsJSON(elements, appState, app.files, app.getName());
      return {
        storeAction: StoreAction.NONE,
        appState: {
          ...appState,
          fileHandle,
          toast: fileHandleExists ? {
            message: fileHandle?.name ? t("toast.fileSavedToFilename").replace(
              "{filename}",
              `"${fileHandle.name}"`
            ) : t("toast.fileSaved")
          } : null
        }
      };
    } catch (error) {
      if (error?.name !== "AbortError") {
        console.error(error);
      } else {
        console.warn(error);
      }
      return { storeAction: StoreAction.NONE };
    }
  },
  keyTest: (event) => event.key === KEYS.S && event[KEYS.CTRL_OR_CMD] && !event.shiftKey
});
var actionSaveFileToDisk = register({
  name: "saveFileToDisk",
  label: "exportDialog.disk_title",
  icon: ExportIcon,
  viewMode: true,
  trackEvent: { category: "export" },
  perform: async (elements, appState, value, app) => {
    try {
      const { fileHandle } = await saveAsJSON(
        elements,
        {
          ...appState,
          fileHandle: null
        },
        app.files,
        app.getName()
      );
      return {
        storeAction: StoreAction.NONE,
        appState: {
          ...appState,
          openDialog: null,
          fileHandle,
          toast: { message: t("toast.fileSaved") }
        }
      };
    } catch (error) {
      if (error?.name !== "AbortError") {
        console.error(error);
      } else {
        console.warn(error);
      }
      return { storeAction: StoreAction.NONE };
    }
  },
  keyTest: (event) => event.key === KEYS.S && event.shiftKey && event[KEYS.CTRL_OR_CMD],
  PanelComponent: ({ updateData }) => /* @__PURE__ */ jsx40(
    ToolButton,
    {
      type: "button",
      icon: saveAs,
      title: t("buttons.saveAs"),
      "aria-label": t("buttons.saveAs"),
      showAriaLabel: useDevice().editor.isMobile,
      hidden: !nativeFileSystemSupported,
      onClick: () => updateData(null),
      "data-testid": "save-as-button"
    }
  )
});
var actionLoadScene = register({
  name: "loadScene",
  label: "buttons.load",
  trackEvent: { category: "export" },
  predicate: (elements, appState, props, app) => {
    return !!app.props.UIOptions.canvasActions.loadScene && !appState.viewModeEnabled;
  },
  perform: async (elements, appState, _, app) => {
    try {
      const {
        elements: loadedElements,
        appState: loadedAppState,
        files
      } = await loadFromJSON(appState, elements);
      return {
        elements: loadedElements,
        appState: loadedAppState,
        files,
        storeAction: StoreAction.CAPTURE
      };
    } catch (error) {
      if (error?.name === "AbortError") {
        console.warn(error);
        return false;
      }
      return {
        elements,
        appState: { ...appState, errorMessage: error.message },
        files: app.files,
        storeAction: StoreAction.NONE
      };
    }
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.O
});
var actionExportWithDarkMode = register({
  name: "exportWithDarkMode",
  label: "imageExportDialog.label.darkMode",
  trackEvent: { category: "export", action: "toggleTheme" },
  perform: (_elements, appState, value) => {
    return {
      appState: { ...appState, exportWithDarkMode: value },
      storeAction: StoreAction.NONE
    };
  },
  PanelComponent: ({ appState, updateData }) => /* @__PURE__ */ jsx40(
    "div",
    {
      style: {
        display: "flex",
        justifyContent: "flex-end",
        marginTop: "-45px",
        marginBottom: "10px"
      },
      children: /* @__PURE__ */ jsx40(
        DarkModeToggle,
        {
          value: appState.exportWithDarkMode ? THEME.DARK : THEME.LIGHT,
          onChange: (theme) => {
            updateData(theme === THEME.DARK);
          },
          title: t("imageExportDialog.label.darkMode")
        }
      )
    }
  )
});

// actions/actionStyles.ts
init_define_import_meta_env();
init_element();
init_keys();
init_register();
init_mutateElement();
init_constants();
init_textElement();
init_typeChecks();
init_scene();
init_icons();
init_store();
init_fonts();
var copiedStyles = "{}";
var actionCopyStyles = register({
  name: "copyStyles",
  label: "labels.copyStyles",
  icon: paintIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState, formData, app) => {
    const elementsCopied = [];
    const element = elements.find((el) => appState.selectedElementIds[el.id]);
    elementsCopied.push(element);
    if (element && hasBoundTextElement(element)) {
      const boundTextElement = getBoundTextElement(
        element,
        app.scene.getNonDeletedElementsMap()
      );
      elementsCopied.push(boundTextElement);
    }
    if (element) {
      copiedStyles = JSON.stringify(elementsCopied);
    }
    return {
      appState: {
        ...appState,
        toast: { message: t("toast.copyStyles") }
      },
      storeAction: StoreAction.NONE
    };
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.C
});
var actionPasteStyles = register({
  name: "pasteStyles",
  label: "labels.pasteStyles",
  icon: paintIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState, formData, app) => {
    const elementsCopied = JSON.parse(copiedStyles);
    const pastedElement = elementsCopied[0];
    const boundTextElement = elementsCopied[1];
    if (!isExcalidrawElement(pastedElement)) {
      return { elements, storeAction: StoreAction.NONE };
    }
    const selectedElements = getSelectedElements(elements, appState, {
      includeBoundTextElement: true
    });
    const selectedElementIds = selectedElements.map((element) => element.id);
    return {
      elements: elements.map((element) => {
        if (selectedElementIds.includes(element.id)) {
          let elementStylesToCopyFrom = pastedElement;
          if (isTextElement(element) && element.containerId) {
            elementStylesToCopyFrom = boundTextElement;
          }
          if (!elementStylesToCopyFrom) {
            return element;
          }
          let newElement2 = newElementWith(element, {
            backgroundColor: elementStylesToCopyFrom?.backgroundColor,
            strokeWidth: elementStylesToCopyFrom?.strokeWidth,
            strokeColor: elementStylesToCopyFrom?.strokeColor,
            strokeStyle: elementStylesToCopyFrom?.strokeStyle,
            fillStyle: elementStylesToCopyFrom?.fillStyle,
            opacity: elementStylesToCopyFrom?.opacity,
            roughness: elementStylesToCopyFrom?.roughness,
            roundness: elementStylesToCopyFrom.roundness ? canApplyRoundnessTypeToElement(
              elementStylesToCopyFrom.roundness.type,
              element
            ) ? elementStylesToCopyFrom.roundness : getDefaultRoundnessTypeForElement(element) : null
          });
          if (isTextElement(newElement2)) {
            const fontSize = elementStylesToCopyFrom.fontSize || DEFAULT_FONT_SIZE;
            const fontFamily = elementStylesToCopyFrom.fontFamily || DEFAULT_FONT_FAMILY;
            newElement2 = newElementWith(newElement2, {
              fontSize,
              fontFamily,
              textAlign: elementStylesToCopyFrom.textAlign || DEFAULT_TEXT_ALIGN,
              lineHeight: elementStylesToCopyFrom.lineHeight || getLineHeight(fontFamily)
            });
            let container = null;
            if (newElement2.containerId) {
              container = selectedElements.find(
                (element2) => isTextElement(newElement2) && element2.id === newElement2.containerId
              ) || null;
            }
            redrawTextBoundingBox(
              newElement2,
              container,
              app.scene.getNonDeletedElementsMap()
            );
          }
          if (newElement2.type === "arrow" && isArrowElement(elementStylesToCopyFrom)) {
            newElement2 = newElementWith(newElement2, {
              startArrowhead: elementStylesToCopyFrom.startArrowhead,
              endArrowhead: elementStylesToCopyFrom.endArrowhead
            });
          }
          if (isFrameLikeElement(element)) {
            newElement2 = newElementWith(newElement2, {
              roundness: null,
              backgroundColor: "transparent"
            });
          }
          return newElement2;
        }
        return element;
      }),
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.V
});

// actions/actionMenu.tsx
init_define_import_meta_env();
init_icons();
init_element();
init_register();
init_keys();
init_store();
import { jsx as jsx41 } from "react/jsx-runtime";
var actionToggleCanvasMenu = register({
  name: "toggleCanvasMenu",
  label: "buttons.menu",
  trackEvent: { category: "menu" },
  perform: (_, appState) => ({
    appState: {
      ...appState,
      openMenu: appState.openMenu === "canvas" ? null : "canvas"
    },
    storeAction: StoreAction.NONE
  }),
  PanelComponent: ({ appState, updateData }) => /* @__PURE__ */ jsx41(
    ToolButton,
    {
      type: "button",
      icon: HamburgerMenuIcon,
      "aria-label": t("buttons.menu"),
      onClick: updateData,
      selected: appState.openMenu === "canvas"
    }
  )
});
var actionToggleEditMenu = register({
  name: "toggleEditMenu",
  label: "buttons.edit",
  trackEvent: { category: "menu" },
  perform: (_elements, appState) => ({
    appState: {
      ...appState,
      openMenu: appState.openMenu === "shape" ? null : "shape"
    },
    storeAction: StoreAction.NONE
  }),
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ jsx41(
    ToolButton,
    {
      visible: showSelectedShapeActions(
        appState,
        getNonDeletedElements2(elements)
      ),
      type: "button",
      icon: palette,
      "aria-label": t("buttons.edit"),
      onClick: updateData,
      selected: appState.openMenu === "shape"
    }
  )
});
var actionShortcuts = register({
  name: "toggleShortcuts",
  label: "welcomeScreen.defaults.helpHint",
  icon: HelpIconThin,
  viewMode: true,
  trackEvent: { category: "menu", action: "toggleHelpDialog" },
  perform: (_elements, appState, _, { focusContainer }) => {
    if (appState.openDialog?.name === "help") {
      focusContainer();
    }
    return {
      appState: {
        ...appState,
        openDialog: appState.openDialog?.name === "help" ? null : {
          name: "help"
        }
      },
      storeAction: StoreAction.NONE
    };
  },
  keyTest: (event) => event.key === KEYS.QUESTION_MARK
});

// actions/actionGroup.tsx
init_define_import_meta_env();
init_keys();
init_utils2();
init_register();
init_icons();
init_mutateElement();
init_scene();
init_groups();
init_element();
init_random();
init_typeChecks();
init_frame();
init_fractionalIndex();
init_store();
import { jsx as jsx42 } from "react/jsx-runtime";
var allElementsInSameGroup = (elements) => {
  if (elements.length >= 2) {
    const groupIds = elements[0].groupIds;
    for (const groupId of groupIds) {
      if (elements.reduce(
        (acc, element) => acc && isElementInGroup(element, groupId),
        true
      )) {
        return true;
      }
    }
  }
  return false;
};
var enableActionGroup = (elements, appState, app) => {
  const selectedElements = app.scene.getSelectedElements({
    selectedElementIds: appState.selectedElementIds,
    includeBoundTextElement: true
  });
  return selectedElements.length >= 2 && !allElementsInSameGroup(selectedElements);
};
var actionGroup = register({
  name: "group",
  label: "labels.group",
  icon: (appState) => /* @__PURE__ */ jsx42(GroupIcon, { theme: appState.theme }),
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true
    });
    if (selectedElements.length < 2) {
      return { appState, elements, storeAction: StoreAction.NONE };
    }
    const selectedGroupIds = getSelectedGroupIds(appState);
    if (selectedGroupIds.length === 1) {
      const selectedGroupId = selectedGroupIds[0];
      const elementIdsInGroup = new Set(
        getElementsInGroup(elements, selectedGroupId).map(
          (element) => element.id
        )
      );
      const selectedElementIds = new Set(
        selectedElements.map((element) => element.id)
      );
      const combinedSet = /* @__PURE__ */ new Set([
        ...Array.from(elementIdsInGroup),
        ...Array.from(selectedElementIds)
      ]);
      if (combinedSet.size === elementIdsInGroup.size) {
        return { appState, elements, storeAction: StoreAction.NONE };
      }
    }
    let nextElements = [...elements];
    const groupingElementsFromDifferentFrames = new Set(selectedElements.map((element) => element.frameId)).size > 1;
    if (groupingElementsFromDifferentFrames) {
      const frameElementsMap = groupByFrameLikes(selectedElements);
      frameElementsMap.forEach((elementsInFrame, frameId) => {
        removeElementsFromFrame(
          elementsInFrame,
          app.scene.getNonDeletedElementsMap()
        );
      });
    }
    const newGroupId = randomId();
    const selectElementIds = arrayToMap(selectedElements);
    nextElements = nextElements.map((element) => {
      if (!selectElementIds.get(element.id)) {
        return element;
      }
      return newElementWith(element, {
        groupIds: addToGroup(
          element.groupIds,
          newGroupId,
          appState.editingGroupId
        )
      });
    });
    const elementsInGroup = getElementsInGroup(nextElements, newGroupId);
    const lastElementInGroup = elementsInGroup[elementsInGroup.length - 1];
    const lastGroupElementIndex = nextElements.lastIndexOf(
      lastElementInGroup
    );
    const elementsAfterGroup = nextElements.slice(lastGroupElementIndex + 1);
    const elementsBeforeGroup = nextElements.slice(0, lastGroupElementIndex).filter(
      (updatedElement) => !isElementInGroup(updatedElement, newGroupId)
    );
    const reorderedElements = syncMovedIndices(
      [...elementsBeforeGroup, ...elementsInGroup, ...elementsAfterGroup],
      arrayToMap(elementsInGroup)
    );
    return {
      appState: {
        ...appState,
        ...selectGroup(
          newGroupId,
          { ...appState, selectedGroupIds: {} },
          getNonDeletedElements2(nextElements)
        )
      },
      elements: reorderedElements,
      storeAction: StoreAction.CAPTURE
    };
  },
  predicate: (elements, appState, _, app) => enableActionGroup(elements, appState, app),
  keyTest: (event) => !event.shiftKey && event[KEYS.CTRL_OR_CMD] && event.key === KEYS.G,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx42(
    ToolButton,
    {
      hidden: !enableActionGroup(elements, appState, app),
      type: "button",
      icon: /* @__PURE__ */ jsx42(GroupIcon, { theme: appState.theme }),
      onClick: () => updateData(null),
      title: `${t("labels.group")} \u2014 ${getShortcutKey("CtrlOrCmd+G")}`,
      "aria-label": t("labels.group"),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});
var actionUngroup = register({
  name: "ungroup",
  label: "labels.ungroup",
  icon: (appState) => /* @__PURE__ */ jsx42(UngroupIcon, { theme: appState.theme }),
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    const groupIds = getSelectedGroupIds(appState);
    const elementsMap = arrayToMap(elements);
    if (groupIds.length === 0) {
      return { appState, elements, storeAction: StoreAction.NONE };
    }
    let nextElements = [...elements];
    const boundTextElementIds = [];
    nextElements = nextElements.map((element) => {
      if (isBoundToContainer(element)) {
        boundTextElementIds.push(element.id);
      }
      const nextGroupIds = removeFromSelectedGroups(
        element.groupIds,
        appState.selectedGroupIds
      );
      if (nextGroupIds.length === element.groupIds.length) {
        return element;
      }
      return newElementWith(element, {
        groupIds: nextGroupIds
      });
    });
    const updateAppState = selectGroupsForSelectedElements(
      appState,
      getNonDeletedElements2(nextElements),
      appState,
      null
    );
    const selectedElements = app.scene.getSelectedElements(appState);
    const selectedElementFrameIds = new Set(
      selectedElements.filter((element) => element.frameId).map((element) => element.frameId)
    );
    const targetFrames = getFrameLikeElements(elements).filter(
      (frame) => selectedElementFrameIds.has(frame.id)
    );
    targetFrames.forEach((frame) => {
      if (frame) {
        nextElements = replaceAllElementsInFrame(
          nextElements,
          getElementsInResizingFrame(
            nextElements,
            frame,
            appState,
            elementsMap
          ),
          frame,
          app
        );
      }
    });
    updateAppState.selectedElementIds = Object.entries(
      updateAppState.selectedElementIds
    ).reduce(
      (acc, [id, selected]) => {
        if (selected && !boundTextElementIds.includes(id)) {
          acc[id] = true;
        }
        return acc;
      },
      {}
    );
    return {
      appState: { ...appState, ...updateAppState },
      elements: nextElements,
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => event.shiftKey && event[KEYS.CTRL_OR_CMD] && event.key === KEYS.G.toUpperCase(),
  predicate: (elements, appState) => getSelectedGroupIds(appState).length > 0,
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ jsx42(
    ToolButton,
    {
      type: "button",
      hidden: getSelectedGroupIds(appState).length === 0,
      icon: /* @__PURE__ */ jsx42(UngroupIcon, { theme: appState.theme }),
      onClick: () => updateData(null),
      title: `${t("labels.ungroup")} \u2014 ${getShortcutKey("CtrlOrCmd+Shift+G")}`,
      "aria-label": t("labels.ungroup"),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});

// actions/actionNavigate.tsx
init_define_import_meta_env();

// clients.ts
init_define_import_meta_env();
init_constants();

// renderer/roundRect.ts
init_define_import_meta_env();
var roundRect = (context, x, y, width, height, radius, strokeColor) => {
  context.beginPath();
  context.moveTo(x + radius, y);
  context.lineTo(x + width - radius, y);
  context.quadraticCurveTo(x + width, y, x + width, y + radius);
  context.lineTo(x + width, y + height - radius);
  context.quadraticCurveTo(
    x + width,
    y + height,
    x + width - radius,
    y + height
  );
  context.lineTo(x + radius, y + height);
  context.quadraticCurveTo(x, y + height, x, y + height - radius);
  context.lineTo(x, y + radius);
  context.quadraticCurveTo(x, y, x + radius, y);
  context.closePath();
  context.fill();
  if (strokeColor) {
    context.strokeStyle = strokeColor;
  }
  context.stroke();
};

// types.ts
init_define_import_meta_env();

// clients.ts
function hashToInteger(id) {
  let hash = 0;
  if (id.length === 0) {
    return hash;
  }
  for (let i = 0; i < id.length; i++) {
    const char = id.charCodeAt(i);
    hash = (hash << 5) - hash + char;
  }
  return hash;
}
var getClientColor = (socketId, collaborator) => {
  const hash = Math.abs(hashToInteger(collaborator?.id || socketId));
  const hue = hash % 37 * 10;
  const saturation = 100;
  const lightness = 83;
  return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
};
var getNameInitial = (name) => {
  const firstCodePoint = name?.trim()?.codePointAt(0);
  return (firstCodePoint ? String.fromCodePoint(firstCodePoint) : "?").toUpperCase();
};
var renderRemoteCursors = ({
  context,
  renderConfig,
  appState,
  normalizedWidth,
  normalizedHeight
}) => {
  for (const [socketId, pointer] of renderConfig.remotePointerViewportCoords) {
    let { x, y } = pointer;
    const collaborator = appState.collaborators.get(socketId);
    x -= appState.offsetLeft;
    y -= appState.offsetTop;
    const width = 11;
    const height = 14;
    const isOutOfBounds = x < 0 || x > normalizedWidth - width || y < 0 || y > normalizedHeight - height;
    x = Math.max(x, 0);
    x = Math.min(x, normalizedWidth - width);
    y = Math.max(y, 0);
    y = Math.min(y, normalizedHeight - height);
    const background = getClientColor(socketId, collaborator);
    context.save();
    context.strokeStyle = background;
    context.fillStyle = background;
    const userState = renderConfig.remotePointerUserStates.get(socketId);
    const isInactive = isOutOfBounds || userState === "idle" /* IDLE */ || userState === "away" /* AWAY */;
    if (isInactive) {
      context.globalAlpha = 0.3;
    }
    if (renderConfig.remotePointerButton.get(socketId) === "down") {
      context.beginPath();
      context.arc(x, y, 15, 0, 2 * Math.PI, false);
      context.lineWidth = 3;
      context.strokeStyle = "#ffffff88";
      context.stroke();
      context.closePath();
      context.beginPath();
      context.arc(x, y, 15, 0, 2 * Math.PI, false);
      context.lineWidth = 1;
      context.strokeStyle = background;
      context.stroke();
      context.closePath();
    }
    const IS_SPEAKING_COLOR = appState.theme === THEME.DARK ? "#2f6330" : COLOR_VOICE_CALL;
    const isSpeaking = collaborator?.isSpeaking;
    if (isSpeaking) {
      context.fillStyle = IS_SPEAKING_COLOR;
      context.strokeStyle = IS_SPEAKING_COLOR;
      context.lineWidth = 10;
      context.lineJoin = "round";
      context.beginPath();
      context.moveTo(x, y);
      context.lineTo(x + 0, y + 14);
      context.lineTo(x + 4, y + 9);
      context.lineTo(x + 11, y + 8);
      context.closePath();
      context.stroke();
      context.fill();
    }
    context.fillStyle = COLOR_WHITE;
    context.strokeStyle = COLOR_WHITE;
    context.lineWidth = 6;
    context.lineJoin = "round";
    context.beginPath();
    context.moveTo(x, y);
    context.lineTo(x + 0, y + 14);
    context.lineTo(x + 4, y + 9);
    context.lineTo(x + 11, y + 8);
    context.closePath();
    context.stroke();
    context.fill();
    context.fillStyle = background;
    context.strokeStyle = background;
    context.lineWidth = 2;
    context.lineJoin = "round";
    context.beginPath();
    if (isInactive) {
      context.moveTo(x - 1, y - 1);
      context.lineTo(x - 1, y + 15);
      context.lineTo(x + 5, y + 10);
      context.lineTo(x + 12, y + 9);
      context.closePath();
      context.fill();
    } else {
      context.moveTo(x, y);
      context.lineTo(x + 0, y + 14);
      context.lineTo(x + 4, y + 9);
      context.lineTo(x + 11, y + 8);
      context.closePath();
      context.fill();
      context.stroke();
    }
    const username = renderConfig.remotePointerUsernames.get(socketId) || "";
    if (!isOutOfBounds && username) {
      context.font = "600 12px sans-serif";
      const offsetX = (isSpeaking ? x + 0 : x) + width / 2;
      const offsetY = (isSpeaking ? y + 0 : y) + height + 2;
      const paddingHorizontal = 5;
      const paddingVertical = 3;
      const measure = context.measureText(username);
      const measureHeight = measure.actualBoundingBoxDescent + measure.actualBoundingBoxAscent;
      const finalHeight = Math.max(measureHeight, 12);
      const boxX = offsetX - 1;
      const boxY = offsetY - 1;
      const boxWidth = measure.width + 2 + paddingHorizontal * 2 + 2;
      const boxHeight = finalHeight + 2 + paddingVertical * 2 + 2;
      if (context.roundRect) {
        context.beginPath();
        context.roundRect(boxX, boxY, boxWidth, boxHeight, 8);
        context.fillStyle = background;
        context.fill();
        context.strokeStyle = COLOR_WHITE;
        context.stroke();
        if (isSpeaking) {
          context.beginPath();
          context.roundRect(boxX - 2, boxY - 2, boxWidth + 4, boxHeight + 4, 8);
          context.strokeStyle = IS_SPEAKING_COLOR;
          context.stroke();
        }
      } else {
        roundRect(context, boxX, boxY, boxWidth, boxHeight, 8, COLOR_WHITE);
      }
      context.fillStyle = COLOR_CHARCOAL_BLACK;
      context.fillText(
        username,
        offsetX + paddingHorizontal + 1,
        offsetY + paddingVertical + measure.actualBoundingBoxAscent + Math.floor((finalHeight - measureHeight) / 2) + 2
      );
      if (isSpeaking) {
        context.fillStyle = IS_SPEAKING_COLOR;
        const barheight = 8;
        const margin = 8;
        const gap = 5;
        context.fillRect(
          boxX + boxWidth + margin,
          boxY + (boxHeight / 2 - barheight / 2),
          2,
          barheight
        );
        context.fillRect(
          boxX + boxWidth + margin + gap,
          boxY + (boxHeight / 2 - barheight * 2 / 2),
          2,
          barheight * 2
        );
        context.fillRect(
          boxX + boxWidth + margin + gap * 2,
          boxY + (boxHeight / 2 - barheight / 2),
          2,
          barheight
        );
      }
    }
    context.restore();
    context.closePath();
  }
};

// components/Avatar.tsx
init_define_import_meta_env();
import { useState as useState10 } from "react";
import clsx18 from "clsx";
import { jsx as jsx43 } from "react/jsx-runtime";
var Avatar = ({
  color,
  onClick,
  name,
  src,
  className
}) => {
  const shortName = getNameInitial(name);
  const [error, setError] = useState10(false);
  const loadImg = !error && src;
  const style = loadImg ? void 0 : { background: color };
  return /* @__PURE__ */ jsx43("div", { className: clsx18("Avatar", className), style, onClick, children: loadImg ? /* @__PURE__ */ jsx43(
    "img",
    {
      className: "Avatar-img",
      src,
      alt: shortName,
      referrerPolicy: "no-referrer",
      onError: () => setError(true)
    }
  ) : shortName });
};

// actions/actionNavigate.tsx
init_icons();
init_store();
init_register();
import clsx19 from "clsx";
import { jsx as jsx44, jsxs as jsxs24 } from "react/jsx-runtime";
var actionGoToCollaborator = register({
  name: "goToCollaborator",
  label: "Go to a collaborator",
  viewMode: true,
  trackEvent: { category: "collab" },
  perform: (_elements, appState, collaborator) => {
    if (!collaborator.socketId || appState.userToFollow?.socketId === collaborator.socketId || collaborator.isCurrentUser) {
      return {
        appState: {
          ...appState,
          userToFollow: null
        },
        storeAction: StoreAction.NONE
      };
    }
    return {
      appState: {
        ...appState,
        userToFollow: {
          socketId: collaborator.socketId,
          username: collaborator.username || ""
        },
        // Close mobile menu
        openMenu: appState.openMenu === "canvas" ? null : appState.openMenu
      },
      storeAction: StoreAction.NONE
    };
  },
  PanelComponent: ({ updateData, data, appState }) => {
    const { socketId, collaborator, withName, isBeingFollowed } = data;
    const background = getClientColor(socketId, collaborator);
    const statusClassNames = clsx19({
      "is-followed": isBeingFollowed,
      "is-current-user": collaborator.isCurrentUser === true,
      "is-speaking": collaborator.isSpeaking,
      "is-in-call": collaborator.isInCall,
      "is-muted": collaborator.isMuted
    });
    const statusIconJSX = collaborator.isInCall ? collaborator.isSpeaking ? /* @__PURE__ */ jsxs24(
      "div",
      {
        className: "UserList__collaborator-status-icon-speaking-indicator",
        title: t("userList.hint.isSpeaking"),
        children: [
          /* @__PURE__ */ jsx44("div", {}),
          /* @__PURE__ */ jsx44("div", {}),
          /* @__PURE__ */ jsx44("div", {})
        ]
      }
    ) : collaborator.isMuted ? /* @__PURE__ */ jsx44(
      "div",
      {
        className: "UserList__collaborator-status-icon-microphone-muted",
        title: t("userList.hint.micMuted"),
        children: microphoneMutedIcon
      }
    ) : /* @__PURE__ */ jsx44("div", { title: t("userList.hint.inCall"), children: microphoneIcon }) : null;
    return withName ? /* @__PURE__ */ jsxs24(
      "div",
      {
        className: `dropdown-menu-item dropdown-menu-item-base UserList__collaborator ${statusClassNames}`,
        style: { [`--avatar-size`]: "1.5rem" },
        onClick: () => updateData(collaborator),
        children: [
          /* @__PURE__ */ jsx44(
            Avatar,
            {
              color: background,
              onClick: () => {
              },
              name: collaborator.username || "",
              src: collaborator.avatarUrl,
              className: statusClassNames
            }
          ),
          /* @__PURE__ */ jsx44("div", { className: "UserList__collaborator-name", children: collaborator.username }),
          /* @__PURE__ */ jsxs24("div", { className: "UserList__collaborator-status-icons", "aria-hidden": true, children: [
            isBeingFollowed && /* @__PURE__ */ jsx44(
              "div",
              {
                className: "UserList__collaborator-status-icon-is-followed",
                title: t("userList.hint.followStatus"),
                children: eyeIcon
              }
            ),
            statusIconJSX
          ] })
        ]
      }
    ) : /* @__PURE__ */ jsxs24(
      "div",
      {
        className: `UserList__collaborator UserList__collaborator--avatar-only ${statusClassNames}`,
        children: [
          /* @__PURE__ */ jsx44(
            Avatar,
            {
              color: background,
              onClick: () => {
                updateData(collaborator);
              },
              name: collaborator.username || "",
              src: collaborator.avatarUrl,
              className: statusClassNames
            }
          ),
          statusIconJSX && /* @__PURE__ */ jsx44("div", { className: "UserList__collaborator-status-icon", children: statusIconJSX })
        ]
      }
    );
  }
});

// actions/actionAddToLibrary.ts
init_define_import_meta_env();
init_register();
init_newElement();
init_random();
init_constants();
init_store();
var actionAddToLibrary = register({
  name: "addToLibrary",
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true,
      includeElementsInFrames: true
    });
    for (const type of LIBRARY_DISABLED_TYPES) {
      if (selectedElements.some((element) => element.type === type)) {
        return {
          storeAction: StoreAction.NONE,
          appState: {
            ...appState,
            errorMessage: t(`errors.libraryElementTypeError.${type}`)
          }
        };
      }
    }
    return app.library.getLatestLibrary().then((items) => {
      return app.library.setLibrary([
        {
          id: randomId(),
          status: "unpublished",
          elements: selectedElements.map(deepCopyElement),
          created: Date.now()
        },
        ...items
      ]);
    }).then(() => {
      return {
        storeAction: StoreAction.NONE,
        appState: {
          ...appState,
          toast: { message: t("toast.addedToLibrary") }
        }
      };
    }).catch((error) => {
      return {
        storeAction: StoreAction.NONE,
        appState: {
          ...appState,
          errorMessage: error.message
        }
      };
    });
  },
  label: "labels.addToLibrary"
});

// actions/actionAlign.tsx
init_define_import_meta_env();

// align.ts
init_define_import_meta_env();
init_mutateElement();
init_bounds();
init_groups();
var alignElements = (selectedElements, elementsMap, alignment) => {
  const groups = getMaximumGroups(
    selectedElements,
    elementsMap
  );
  const selectionBoundingBox = getCommonBoundingBox(selectedElements);
  return groups.flatMap((group) => {
    const translation2 = calculateTranslation(
      group,
      selectionBoundingBox,
      alignment
    );
    return group.map(
      (element) => newElementWith(element, {
        x: element.x + translation2.x,
        y: element.y + translation2.y
      })
    );
  });
};
var calculateTranslation = (group, selectionBoundingBox, { axis, position }) => {
  const groupBoundingBox = getCommonBoundingBox(group);
  const [min, max] = axis === "x" ? ["minX", "maxX"] : ["minY", "maxY"];
  const noTranslation = { x: 0, y: 0 };
  if (position === "start") {
    return {
      ...noTranslation,
      [axis]: selectionBoundingBox[min] - groupBoundingBox[min]
    };
  } else if (position === "end") {
    return {
      ...noTranslation,
      [axis]: selectionBoundingBox[max] - groupBoundingBox[max]
    };
  }
  return {
    ...noTranslation,
    [axis]: (selectionBoundingBox[min] + selectionBoundingBox[max]) / 2 - (groupBoundingBox[min] + groupBoundingBox[max]) / 2
  };
};

// actions/actionAlign.tsx
init_icons();
init_element();
init_typeChecks();
init_frame();
init_keys();
init_scene();
init_store();
init_utils2();
init_register();
import { jsx as jsx45 } from "react/jsx-runtime";
var alignActionsPredicate = (elements, appState, _, app) => {
  const selectedElements = app.scene.getSelectedElements(appState);
  return selectedElements.length > 1 && // TODO enable aligning frames when implemented properly
  !selectedElements.some((el) => isFrameLikeElement(el));
};
var alignSelectedElements = (elements, appState, app, alignment) => {
  const selectedElements = app.scene.getSelectedElements(appState);
  const elementsMap = arrayToMap(elements);
  const updatedElements = alignElements(
    selectedElements,
    elementsMap,
    alignment
  );
  const updatedElementsMap = arrayToMap(updatedElements);
  return updateFrameMembershipOfSelectedElements(
    elements.map((element) => updatedElementsMap.get(element.id) || element),
    appState,
    app
  );
};
var actionAlignTop = register({
  name: "alignTop",
  label: "labels.alignTop",
  icon: AlignTopIcon,
  trackEvent: { category: "element" },
  predicate: alignActionsPredicate,
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "start",
        axis: "y"
      }),
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_UP,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx45(
    ToolButton,
    {
      hidden: !alignActionsPredicate(elements, appState, null, app),
      type: "button",
      icon: AlignTopIcon,
      onClick: () => updateData(null),
      title: `${t("labels.alignTop")} \u2014 ${getShortcutKey(
        "CtrlOrCmd+Shift+Up"
      )}`,
      "aria-label": t("labels.alignTop"),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});
var actionAlignBottom = register({
  name: "alignBottom",
  label: "labels.alignBottom",
  icon: AlignBottomIcon,
  trackEvent: { category: "element" },
  predicate: alignActionsPredicate,
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "end",
        axis: "y"
      }),
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_DOWN,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx45(
    ToolButton,
    {
      hidden: !alignActionsPredicate(elements, appState, null, app),
      type: "button",
      icon: AlignBottomIcon,
      onClick: () => updateData(null),
      title: `${t("labels.alignBottom")} \u2014 ${getShortcutKey(
        "CtrlOrCmd+Shift+Down"
      )}`,
      "aria-label": t("labels.alignBottom"),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});
var actionAlignLeft = register({
  name: "alignLeft",
  label: "labels.alignLeft",
  icon: AlignLeftIcon,
  trackEvent: { category: "element" },
  predicate: alignActionsPredicate,
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "start",
        axis: "x"
      }),
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_LEFT,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx45(
    ToolButton,
    {
      hidden: !alignActionsPredicate(elements, appState, null, app),
      type: "button",
      icon: AlignLeftIcon,
      onClick: () => updateData(null),
      title: `${t("labels.alignLeft")} \u2014 ${getShortcutKey(
        "CtrlOrCmd+Shift+Left"
      )}`,
      "aria-label": t("labels.alignLeft"),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});
var actionAlignRight = register({
  name: "alignRight",
  label: "labels.alignRight",
  icon: AlignRightIcon,
  trackEvent: { category: "element" },
  predicate: alignActionsPredicate,
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "end",
        axis: "x"
      }),
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_RIGHT,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx45(
    ToolButton,
    {
      hidden: !alignActionsPredicate(elements, appState, null, app),
      type: "button",
      icon: AlignRightIcon,
      onClick: () => updateData(null),
      title: `${t("labels.alignRight")} \u2014 ${getShortcutKey(
        "CtrlOrCmd+Shift+Right"
      )}`,
      "aria-label": t("labels.alignRight"),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});
var actionAlignVerticallyCentered = register({
  name: "alignVerticallyCentered",
  label: "labels.centerVertically",
  icon: CenterVerticallyIcon,
  trackEvent: { category: "element" },
  predicate: alignActionsPredicate,
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "center",
        axis: "y"
      }),
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx45(
    ToolButton,
    {
      hidden: !alignActionsPredicate(elements, appState, null, app),
      type: "button",
      icon: CenterVerticallyIcon,
      onClick: () => updateData(null),
      title: t("labels.centerVertically"),
      "aria-label": t("labels.centerVertically"),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});
var actionAlignHorizontallyCentered = register({
  name: "alignHorizontallyCentered",
  label: "labels.centerHorizontally",
  icon: CenterHorizontallyIcon,
  trackEvent: { category: "element" },
  predicate: alignActionsPredicate,
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "center",
        axis: "x"
      }),
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx45(
    ToolButton,
    {
      hidden: !alignActionsPredicate(elements, appState, null, app),
      type: "button",
      icon: CenterHorizontallyIcon,
      onClick: () => updateData(null),
      title: t("labels.centerHorizontally"),
      "aria-label": t("labels.centerHorizontally"),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});

// actions/actionDistribute.tsx
init_define_import_meta_env();
init_icons();

// distribute.ts
init_define_import_meta_env();
init_mutateElement();
init_groups();
init_bounds();
var distributeElements = (selectedElements, elementsMap, distribution) => {
  const [start2, mid, end, extent] = distribution.axis === "x" ? ["minX", "midX", "maxX", "width"] : ["minY", "midY", "maxY", "height"];
  const bounds = getCommonBoundingBox(selectedElements);
  const groups = getMaximumGroups(selectedElements, elementsMap).map((group) => [group, getCommonBoundingBox(group)]).sort((a, b) => a[1][mid] - b[1][mid]);
  let span = 0;
  for (const group of groups) {
    span += group[1][extent];
  }
  const step = (bounds[extent] - span) / (groups.length - 1);
  if (step < 0) {
    const index0 = groups.findIndex((g) => g[1][start2] === bounds[start2]);
    const index1 = groups.findIndex((g) => g[1][end] === bounds[end]);
    const step2 = (groups[index1][1][mid] - groups[index0][1][mid]) / (groups.length - 1);
    let pos2 = groups[index0][1][mid];
    return groups.flatMap(([group, box], index) => {
      const translation2 = {
        x: 0,
        y: 0
      };
      if (index !== index0 && index !== index1) {
        pos2 += step2;
        translation2[distribution.axis] = pos2 - box[mid];
      }
      return group.map(
        (element) => newElementWith(element, {
          x: element.x + translation2.x,
          y: element.y + translation2.y
        })
      );
    });
  }
  let pos = bounds[start2];
  return groups.flatMap(([group, box]) => {
    const translation2 = {
      x: 0,
      y: 0
    };
    translation2[distribution.axis] = pos - box[start2];
    pos += step;
    pos += box[extent];
    return group.map(
      (element) => newElementWith(element, {
        x: element.x + translation2.x,
        y: element.y + translation2.y
      })
    );
  });
};

// actions/actionDistribute.tsx
init_element();
init_typeChecks();
init_frame();
init_keys();
init_scene();
init_store();
init_utils2();
init_register();
import { jsx as jsx46 } from "react/jsx-runtime";
var enableActionGroup2 = (appState, app) => {
  const selectedElements = app.scene.getSelectedElements(appState);
  return selectedElements.length > 1 && // TODO enable distributing frames when implemented properly
  !selectedElements.some((el) => isFrameLikeElement(el));
};
var distributeSelectedElements = (elements, appState, app, distribution) => {
  const selectedElements = app.scene.getSelectedElements(appState);
  const updatedElements = distributeElements(
    selectedElements,
    app.scene.getNonDeletedElementsMap(),
    distribution
  );
  const updatedElementsMap = arrayToMap(updatedElements);
  return updateFrameMembershipOfSelectedElements(
    elements.map((element) => updatedElementsMap.get(element.id) || element),
    appState,
    app
  );
};
var distributeHorizontally = register({
  name: "distributeHorizontally",
  label: "labels.distributeHorizontally",
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: distributeSelectedElements(elements, appState, app, {
        space: "between",
        axis: "x"
      }),
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.H,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx46(
    ToolButton,
    {
      hidden: !enableActionGroup2(appState, app),
      type: "button",
      icon: DistributeHorizontallyIcon,
      onClick: () => updateData(null),
      title: `${t("labels.distributeHorizontally")} \u2014 ${getShortcutKey(
        "Alt+H"
      )}`,
      "aria-label": t("labels.distributeHorizontally"),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});
var distributeVertically = register({
  name: "distributeVertically",
  label: "labels.distributeVertically",
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: distributeSelectedElements(elements, appState, app, {
        space: "between",
        axis: "y"
      }),
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.V,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ jsx46(
    ToolButton,
    {
      hidden: !enableActionGroup2(appState, app),
      type: "button",
      icon: DistributeVerticallyIcon,
      onClick: () => updateData(null),
      title: `${t("labels.distributeVertically")} \u2014 ${getShortcutKey("Alt+V")}`,
      "aria-label": t("labels.distributeVertically"),
      visible: isSomeElementSelected(getNonDeletedElements2(elements), appState)
    }
  )
});

// actions/actionFlip.ts
init_define_import_meta_env();
init_register();
init_scene();
init_element();
init_resizeElements();
init_utils2();
init_keys();
init_bounds();
init_binding();
init_frame();
init_icons();
init_store();
init_typeChecks();
init_routing();
init_mutateElement();
var actionFlipHorizontal = register({
  name: "flipHorizontal",
  label: "labels.flipHorizontal",
  icon: flipHorizontal,
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    return {
      elements: updateFrameMembershipOfSelectedElements(
        flipSelectedElements(
          elements,
          app.scene.getNonDeletedElementsMap(),
          appState,
          "horizontal",
          app
        ),
        appState,
        app
      ),
      appState,
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => event.shiftKey && event.code === CODES.H
});
var actionFlipVertical = register({
  name: "flipVertical",
  label: "labels.flipVertical",
  icon: flipVertical,
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    return {
      elements: updateFrameMembershipOfSelectedElements(
        flipSelectedElements(
          elements,
          app.scene.getNonDeletedElementsMap(),
          appState,
          "vertical",
          app
        ),
        appState,
        app
      ),
      appState,
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => event.shiftKey && event.code === CODES.V && !event[KEYS.CTRL_OR_CMD]
});
var flipSelectedElements = (elements, elementsMap, appState, flipDirection, app) => {
  const selectedElements = getSelectedElements(
    getNonDeletedElements2(elements),
    appState,
    {
      includeBoundTextElement: true,
      includeElementsInFrames: true
    }
  );
  const updatedElements = flipElements(
    selectedElements,
    elementsMap,
    appState,
    flipDirection,
    app
  );
  const updatedElementsMap = arrayToMap(updatedElements);
  return elements.map(
    (element) => updatedElementsMap.get(element.id) || element
  );
};
var flipElements = (selectedElements, elementsMap, appState, flipDirection, app) => {
  if (selectedElements.every(
    (element) => isArrowElement(element) && (element.startBinding || element.endBinding)
  )) {
    return selectedElements.map((element) => {
      const _element = element;
      return newElementWith(_element, {
        startArrowhead: _element.endArrowhead,
        endArrowhead: _element.startArrowhead
      });
    });
  }
  const { minX, minY, maxX, maxY, midX, midY } = getCommonBoundingBox(selectedElements);
  resizeMultipleElements(
    elementsMap,
    selectedElements,
    elementsMap,
    "nw",
    true,
    true,
    flipDirection === "horizontal" ? maxX : minX,
    flipDirection === "horizontal" ? minY : maxY
  );
  bindOrUnbindLinearElements(
    selectedElements.filter(isLinearElement),
    elementsMap,
    app.scene.getNonDeletedElements(),
    app.scene,
    isBindingEnabled(appState),
    []
  );
  const { elbowArrows, otherElements } = selectedElements.reduce(
    (acc, element) => isElbowArrow(element) ? { ...acc, elbowArrows: acc.elbowArrows.concat(element) } : { ...acc, otherElements: acc.otherElements.concat(element) },
    { elbowArrows: [], otherElements: [] }
  );
  const { midX: newMidX, midY: newMidY } = getCommonBoundingBox(selectedElements);
  const [diffX, diffY] = [midX - newMidX, midY - newMidY];
  otherElements.forEach(
    (element) => mutateElement(element, {
      x: element.x + diffX,
      y: element.y + diffY
    })
  );
  elbowArrows.forEach(
    (element) => mutateElbowArrow(
      element,
      elementsMap,
      element.points,
      void 0,
      void 0,
      {
        informMutation: false
      }
    )
  );
  return selectedElements;
};

// actions/actionClipboard.tsx
init_define_import_meta_env();
init_keys();
init_register();
init_clipboard();
init_element();
init_constants();
init_icons();
init_store();
var actionCopy = register({
  name: "copy",
  label: "labels.copy",
  icon: DuplicateIcon,
  trackEvent: { category: "element" },
  perform: async (elements, appState, event, app) => {
    const elementsToCopy = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true,
      includeElementsInFrames: true
    });
    try {
      await copyToClipboard(elementsToCopy, app.files, event);
    } catch (error) {
      return {
        storeAction: StoreAction.NONE,
        appState: {
          ...appState,
          errorMessage: error.message
        }
      };
    }
    return {
      storeAction: StoreAction.NONE
    };
  },
  // don't supply a shortcut since we handle this conditionally via onCopy event
  keyTest: void 0
});
var actionPaste = register({
  name: "paste",
  label: "labels.paste",
  trackEvent: { category: "element" },
  perform: async (elements, appState, data, app) => {
    let types;
    try {
      types = await readSystemClipboard();
    } catch (error) {
      if (error.name === "AbortError" || error.name === "NotAllowedError") {
        return false;
      }
      console.error(`actionPaste ${error.name}: ${error.message}`);
      if (isFirefox) {
        return {
          storeAction: StoreAction.NONE,
          appState: {
            ...appState,
            errorMessage: t("hints.firefox_clipboard_write")
          }
        };
      }
      return {
        storeAction: StoreAction.NONE,
        appState: {
          ...appState,
          errorMessage: t("errors.asyncPasteFailedOnRead")
        }
      };
    }
    try {
      app.pasteFromClipboard(createPasteEvent({ types }));
    } catch (error) {
      console.error(error);
      return {
        storeAction: StoreAction.NONE,
        appState: {
          ...appState,
          errorMessage: t("errors.asyncPasteFailedOnParse")
        }
      };
    }
    return {
      storeAction: StoreAction.NONE
    };
  },
  // don't supply a shortcut since we handle this conditionally via onCopy event
  keyTest: void 0
});
var actionCut = register({
  name: "cut",
  label: "labels.cut",
  icon: cutIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState, event, app) => {
    actionCopy.perform(elements, appState, event, app);
    return actionDeleteSelected.perform(elements, appState, null, app);
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.X
});
var actionCopyAsSvg = register({
  name: "copyAsSvg",
  label: "labels.copyAsSvg",
  icon: svgIcon,
  trackEvent: { category: "element" },
  perform: async (elements, appState, _data, app) => {
    if (!app.canvas) {
      return {
        storeAction: StoreAction.NONE
      };
    }
    const { exportedElements, exportingFrame } = prepareElementsForExport(
      elements,
      appState,
      true
    );
    try {
      await exportCanvas(
        "clipboard-svg",
        exportedElements,
        appState,
        app.files,
        {
          ...appState,
          exportingFrame,
          name: app.getName()
        }
      );
      return {
        storeAction: StoreAction.NONE
      };
    } catch (error) {
      console.error(error);
      return {
        appState: {
          ...appState,
          errorMessage: error.message
        },
        storeAction: StoreAction.NONE
      };
    }
  },
  predicate: (elements) => {
    return probablySupportsClipboardWriteText && elements.length > 0;
  },
  keywords: ["svg", "clipboard", "copy"]
});
var actionCopyAsPng = register({
  name: "copyAsPng",
  label: "labels.copyAsPng",
  icon: pngIcon,
  trackEvent: { category: "element" },
  perform: async (elements, appState, _data, app) => {
    if (!app.canvas) {
      return {
        storeAction: StoreAction.NONE
      };
    }
    const selectedElements = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true,
      includeElementsInFrames: true
    });
    const { exportedElements, exportingFrame } = prepareElementsForExport(
      elements,
      appState,
      true
    );
    try {
      await exportCanvas("clipboard", exportedElements, appState, app.files, {
        ...appState,
        exportingFrame,
        name: app.getName()
      });
      return {
        appState: {
          ...appState,
          toast: {
            message: t("toast.copyToClipboardAsPng", {
              exportSelection: selectedElements.length ? t("toast.selection") : t("toast.canvas"),
              exportColorScheme: appState.exportWithDarkMode ? t("buttons.darkMode") : t("buttons.lightMode")
            })
          }
        },
        storeAction: StoreAction.NONE
      };
    } catch (error) {
      console.error(error);
      return {
        appState: {
          ...appState,
          errorMessage: error.message
        },
        storeAction: StoreAction.NONE
      };
    }
  },
  predicate: (elements) => {
    return probablySupportsClipboardBlob && elements.length > 0;
  },
  keyTest: (event) => event.code === CODES.C && event.altKey && event.shiftKey,
  keywords: ["png", "clipboard", "copy"]
});
var copyText = register({
  name: "copyText",
  label: "labels.copyText",
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true
    });
    try {
      copyTextToSystemClipboard(getTextFromElements(selectedElements));
    } catch (e) {
      throw new Error(t("errors.copyToSystemClipboardFailed"));
    }
    return {
      storeAction: StoreAction.NONE
    };
  },
  predicate: (elements, appState, _, app) => {
    return probablySupportsClipboardWriteText && app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true
    }).some(isTextElement);
  },
  keywords: ["text", "clipboard", "copy"]
});

// actions/actionToggleGridMode.tsx
init_define_import_meta_env();
init_keys();
init_register();
init_icons();
init_store();
var actionToggleGridMode = register({
  name: "gridMode",
  icon: gridIcon,
  keywords: ["snap"],
  label: "labels.toggleGrid",
  viewMode: true,
  trackEvent: {
    category: "canvas",
    predicate: (appState) => appState.gridModeEnabled
  },
  perform(elements, appState) {
    return {
      appState: {
        ...appState,
        gridModeEnabled: !this.checked(appState),
        objectsSnapModeEnabled: false
      },
      storeAction: StoreAction.NONE
    };
  },
  checked: (appState) => appState.gridModeEnabled,
  predicate: (element, appState, props) => {
    return props.gridModeEnabled === void 0;
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.code === CODES.QUOTE
});

// actions/actionToggleZenMode.tsx
init_define_import_meta_env();
init_icons();
init_keys();
init_store();
init_register();
var actionToggleZenMode = register({
  name: "zenMode",
  label: "buttons.zenMode",
  icon: coffeeIcon,
  paletteName: "Toggle zen mode",
  viewMode: true,
  trackEvent: {
    category: "canvas",
    predicate: (appState) => !appState.zenModeEnabled
  },
  perform(elements, appState) {
    return {
      appState: {
        ...appState,
        zenModeEnabled: !this.checked(appState)
      },
      storeAction: StoreAction.NONE
    };
  },
  checked: (appState) => appState.zenModeEnabled,
  predicate: (elements, appState, appProps) => {
    return typeof appProps.zenModeEnabled === "undefined";
  },
  keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.Z
});

// actions/actionToggleObjectsSnapMode.tsx
init_define_import_meta_env();
init_icons();
init_keys();
init_store();
init_register();
var actionToggleObjectsSnapMode = register({
  name: "objectsSnapMode",
  label: "buttons.objectsSnapMode",
  icon: magnetIcon,
  viewMode: false,
  trackEvent: {
    category: "canvas",
    predicate: (appState) => !appState.objectsSnapModeEnabled
  },
  perform(elements, appState) {
    return {
      appState: {
        ...appState,
        objectsSnapModeEnabled: !this.checked(appState),
        gridModeEnabled: false
      },
      storeAction: StoreAction.NONE
    };
  },
  checked: (appState) => appState.objectsSnapModeEnabled,
  predicate: (elements, appState, appProps) => {
    return typeof appProps.objectsSnapModeEnabled === "undefined";
  },
  keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.S
});

// actions/actionToggleStats.tsx
init_define_import_meta_env();
init_register();
init_keys();
init_icons();
init_store();
var actionToggleStats = register({
  name: "stats",
  label: "stats.fullTitle",
  icon: abacusIcon,
  paletteName: "Toggle stats",
  viewMode: true,
  trackEvent: { category: "menu" },
  keywords: ["edit", "attributes", "customize"],
  perform(elements, appState) {
    return {
      appState: {
        ...appState,
        stats: { ...appState.stats, open: !this.checked(appState) }
      },
      storeAction: StoreAction.NONE
    };
  },
  checked: (appState) => appState.stats.open,
  keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.SLASH
});

// actions/actionBoundText.tsx
init_define_import_meta_env();
init_constants();
init_element();
init_mutateElement();
init_textElement();
init_containerCache();
init_typeChecks();
init_utils2();
init_register();
init_fractionalIndex();
init_store();
var actionUnbindText = register({
  name: "unbindText",
  label: "labels.unbindText",
  trackEvent: { category: "element" },
  predicate: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    return selectedElements.some((element) => hasBoundTextElement(element));
  },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    const elementsMap = app.scene.getNonDeletedElementsMap();
    selectedElements.forEach((element) => {
      const boundTextElement = getBoundTextElement(element, elementsMap);
      if (boundTextElement) {
        const { width, height } = measureText(
          boundTextElement.originalText,
          getFontString(boundTextElement),
          boundTextElement.lineHeight
        );
        const originalContainerHeight = getOriginalContainerHeightFromCache(
          element.id
        );
        resetOriginalContainerCache(element.id);
        const { x, y } = computeBoundTextPosition(
          element,
          boundTextElement,
          elementsMap
        );
        mutateElement(boundTextElement, {
          containerId: null,
          width,
          height,
          text: boundTextElement.originalText,
          x,
          y
        });
        mutateElement(element, {
          boundElements: element.boundElements?.filter(
            (ele) => ele.id !== boundTextElement.id
          ),
          height: originalContainerHeight ? originalContainerHeight : element.height
        });
      }
    });
    return {
      elements,
      appState,
      storeAction: StoreAction.CAPTURE
    };
  }
});
var actionBindText = register({
  name: "bindText",
  label: "labels.bindText",
  trackEvent: { category: "element" },
  predicate: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    if (selectedElements.length === 2) {
      const textElement = isTextElement(selectedElements[0]) || isTextElement(selectedElements[1]);
      let bindingContainer;
      if (isTextBindableContainer(selectedElements[0])) {
        bindingContainer = selectedElements[0];
      } else if (isTextBindableContainer(selectedElements[1])) {
        bindingContainer = selectedElements[1];
      }
      if (textElement && bindingContainer && getBoundTextElement(
        bindingContainer,
        app.scene.getNonDeletedElementsMap()
      ) === null) {
        return true;
      }
    }
    return false;
  },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    let textElement;
    let container;
    if (isTextElement(selectedElements[0]) && isTextBindableContainer(selectedElements[1])) {
      textElement = selectedElements[0];
      container = selectedElements[1];
    } else {
      textElement = selectedElements[1];
      container = selectedElements[0];
    }
    mutateElement(textElement, {
      containerId: container.id,
      verticalAlign: VERTICAL_ALIGN.MIDDLE,
      textAlign: TEXT_ALIGN.CENTER,
      autoResize: true
    });
    mutateElement(container, {
      boundElements: (container.boundElements || []).concat({
        type: "text",
        id: textElement.id
      })
    });
    const originalContainerHeight = container.height;
    redrawTextBoundingBox(
      textElement,
      container,
      app.scene.getNonDeletedElementsMap()
    );
    updateOriginalContainerCache(container.id, originalContainerHeight);
    return {
      elements: pushTextAboveContainer(elements, container, textElement),
      appState: { ...appState, selectedElementIds: { [container.id]: true } },
      storeAction: StoreAction.CAPTURE
    };
  }
});
var pushTextAboveContainer = (elements, container, textElement) => {
  const updatedElements = elements.slice();
  const textElementIndex = updatedElements.findIndex(
    (ele) => ele.id === textElement.id
  );
  updatedElements.splice(textElementIndex, 1);
  const containerIndex = updatedElements.findIndex(
    (ele) => ele.id === container.id
  );
  updatedElements.splice(containerIndex + 1, 0, textElement);
  syncMovedIndices(updatedElements, arrayToMap([container, textElement]));
  return updatedElements;
};
var pushContainerBelowText = (elements, container, textElement) => {
  const updatedElements = elements.slice();
  const containerIndex = updatedElements.findIndex(
    (ele) => ele.id === container.id
  );
  updatedElements.splice(containerIndex, 1);
  const textElementIndex = updatedElements.findIndex(
    (ele) => ele.id === textElement.id
  );
  updatedElements.splice(textElementIndex, 0, container);
  syncMovedIndices(updatedElements, arrayToMap([container, textElement]));
  return updatedElements;
};
var actionWrapTextInContainer = register({
  name: "wrapTextInContainer",
  label: "labels.createContainerFromText",
  trackEvent: { category: "element" },
  predicate: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    const areTextElements = selectedElements.every((el) => isTextElement(el));
    return selectedElements.length > 0 && areTextElements;
  },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    let updatedElements = elements.slice();
    const containerIds = {};
    for (const textElement of selectedElements) {
      if (isTextElement(textElement)) {
        const container = newElement({
          type: "rectangle",
          backgroundColor: appState.currentItemBackgroundColor,
          boundElements: [
            ...textElement.boundElements || [],
            { id: textElement.id, type: "text" }
          ],
          angle: textElement.angle,
          fillStyle: appState.currentItemFillStyle,
          strokeColor: appState.currentItemStrokeColor,
          roughness: appState.currentItemRoughness,
          strokeWidth: appState.currentItemStrokeWidth,
          strokeStyle: appState.currentItemStrokeStyle,
          roundness: appState.currentItemRoundness === "round" ? {
            type: isUsingAdaptiveRadius("rectangle") ? ROUNDNESS.ADAPTIVE_RADIUS : ROUNDNESS.PROPORTIONAL_RADIUS
          } : null,
          opacity: 100,
          locked: false,
          x: textElement.x - BOUND_TEXT_PADDING,
          y: textElement.y - BOUND_TEXT_PADDING,
          width: computeContainerDimensionForBoundText(
            textElement.width,
            "rectangle"
          ),
          height: computeContainerDimensionForBoundText(
            textElement.height,
            "rectangle"
          ),
          groupIds: textElement.groupIds,
          frameId: textElement.frameId
        });
        if (textElement.boundElements?.length) {
          const linearElementIds = textElement.boundElements.filter((ele) => ele.type === "arrow").map((el) => el.id);
          const linearElements = updatedElements.filter(
            (ele) => linearElementIds.includes(ele.id)
          );
          linearElements.forEach((ele) => {
            let startBinding = ele.startBinding;
            let endBinding = ele.endBinding;
            if (startBinding?.elementId === textElement.id) {
              startBinding = {
                ...startBinding,
                elementId: container.id
              };
            }
            if (endBinding?.elementId === textElement.id) {
              endBinding = { ...endBinding, elementId: container.id };
            }
            if (startBinding || endBinding) {
              mutateElement(ele, { startBinding, endBinding }, false);
            }
          });
        }
        mutateElement(
          textElement,
          {
            containerId: container.id,
            verticalAlign: VERTICAL_ALIGN.MIDDLE,
            boundElements: null,
            textAlign: TEXT_ALIGN.CENTER,
            autoResize: true
          },
          false
        );
        redrawTextBoundingBox(
          textElement,
          container,
          app.scene.getNonDeletedElementsMap()
        );
        updatedElements = pushContainerBelowText(
          [...updatedElements, container],
          container,
          textElement
        );
        containerIds[container.id] = true;
      }
    }
    return {
      elements: updatedElements,
      appState: {
        ...appState,
        selectedElementIds: containerIds
      },
      storeAction: StoreAction.CAPTURE
    };
  }
});

// actions/actionLink.tsx
init_define_import_meta_env();

// components/hyperlink/Hyperlink.tsx
init_define_import_meta_env();
init_utils2();
init_embeddable();
init_mutateElement();
init_icons();
init_keys();
init_constants();
init_bounds();
import {
  useCallback as useCallback4,
  useEffect as useEffect16,
  useLayoutEffect as useLayoutEffect4,
  useRef as useRef13,
  useState as useState11
} from "react";
import clsx20 from "clsx";
init_scene();
init_collision2();
init_url();
init_typeChecks();
init_helpers();
init_math();
import { jsx as jsx47, jsxs as jsxs25 } from "react/jsx-runtime";
var CONTAINER_WIDTH = 320;
var SPACE_BOTTOM = 85;
var CONTAINER_PADDING = 5;
var CONTAINER_HEIGHT = 42;
var AUTO_HIDE_TIMEOUT = 500;
var IS_HYPERLINK_TOOLTIP_VISIBLE = false;
var embeddableLinkCache = /* @__PURE__ */ new Map();
var Hyperlink = ({
  element,
  elementsMap,
  setAppState,
  onLinkOpen,
  setToast,
  updateEmbedValidationStatus
}) => {
  const appState = useExcalidrawAppState();
  const appProps = useAppProps();
  const linkVal = element.link || "";
  const [inputVal, setInputVal] = useState11(linkVal);
  const inputRef = useRef13(null);
  const isEditing = appState.showHyperlinkPopup === "editor";
  const handleSubmit = useCallback4(() => {
    if (!inputRef.current) {
      return;
    }
    const link = normalizeLink(inputRef.current.value) || null;
    if (!element.link && link) {
      trackEvent("hyperlink", "create");
    }
    if (isEmbeddableElement(element)) {
      if (appState.activeEmbeddable?.element === element) {
        setAppState({ activeEmbeddable: null });
      }
      if (!link) {
        mutateElement(element, {
          link: null
        });
        updateEmbedValidationStatus(element, false);
        return;
      }
      if (!embeddableURLValidator(link, appProps.validateEmbeddable)) {
        if (link) {
          setToast({ message: t("toast.unableToEmbed"), closable: true });
        }
        element.link && embeddableLinkCache.set(element.id, element.link);
        mutateElement(element, {
          link
        });
        updateEmbedValidationStatus(element, false);
      } else {
        const { width, height } = element;
        const embedLink = getEmbedLink(link);
        if (embedLink?.error instanceof URIError) {
          setToast({
            message: t("toast.unrecognizedLinkFormat"),
            closable: true
          });
        }
        const ar = embedLink ? embedLink.intrinsicSize.w / embedLink.intrinsicSize.h : 1;
        const hasLinkChanged = embeddableLinkCache.get(element.id) !== element.link;
        mutateElement(element, {
          ...hasLinkChanged ? {
            width: embedLink?.type === "video" ? width > height ? width : height * ar : width,
            height: embedLink?.type === "video" ? width > height ? width / ar : height : height
          } : {},
          link
        });
        updateEmbedValidationStatus(element, true);
        if (embeddableLinkCache.has(element.id)) {
          embeddableLinkCache.delete(element.id);
        }
      }
    } else {
      mutateElement(element, { link });
    }
  }, [
    element,
    setToast,
    appProps.validateEmbeddable,
    appState.activeEmbeddable,
    setAppState,
    updateEmbedValidationStatus
  ]);
  useLayoutEffect4(() => {
    return () => {
      handleSubmit();
    };
  }, [handleSubmit]);
  useEffect16(() => {
    let timeoutId = null;
    const handlePointerMove = (event) => {
      if (isEditing) {
        return;
      }
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      const shouldHide = shouldHideLinkPopup(
        element,
        elementsMap,
        appState,
        pointFrom(event.clientX, event.clientY)
      );
      if (shouldHide) {
        timeoutId = window.setTimeout(() => {
          setAppState({ showHyperlinkPopup: false });
        }, AUTO_HIDE_TIMEOUT);
      }
    };
    window.addEventListener("pointermove" /* POINTER_MOVE */, handlePointerMove, false);
    return () => {
      window.removeEventListener("pointermove" /* POINTER_MOVE */, handlePointerMove, false);
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  }, [appState, element, isEditing, setAppState, elementsMap]);
  const handleRemove = useCallback4(() => {
    trackEvent("hyperlink", "delete");
    mutateElement(element, { link: null });
    if (isEditing) {
      inputRef.current.value = "";
    }
    setAppState({ showHyperlinkPopup: false });
  }, [setAppState, element, isEditing]);
  const onEdit = () => {
    trackEvent("hyperlink", "edit", "popup-ui");
    setAppState({ showHyperlinkPopup: "editor" });
  };
  const { x, y } = getCoordsForPopover(element, appState, elementsMap);
  if (appState.contextMenu || appState.selectedElementsAreBeingDragged || appState.resizingElement || appState.isRotating || appState.openMenu || appState.viewModeEnabled) {
    return null;
  }
  return /* @__PURE__ */ jsxs25(
    "div",
    {
      className: "excalidraw-hyperlinkContainer",
      style: {
        top: `${y}px`,
        left: `${x}px`,
        width: CONTAINER_WIDTH,
        padding: CONTAINER_PADDING
      },
      onClick: () => {
        if (!element.link && !isEditing) {
          setAppState({ showHyperlinkPopup: "editor" });
        }
      },
      children: [
        isEditing ? /* @__PURE__ */ jsx47(
          "input",
          {
            className: clsx20("excalidraw-hyperlinkContainer-input"),
            placeholder: "Type or paste your link here",
            ref: inputRef,
            value: inputVal,
            onChange: (event) => setInputVal(event.target.value),
            autoFocus: true,
            onKeyDown: (event) => {
              event.stopPropagation();
              if (event[KEYS.CTRL_OR_CMD] && event.key === KEYS.K) {
                event.preventDefault();
              }
              if (event.key === KEYS.ENTER || event.key === KEYS.ESCAPE) {
                handleSubmit();
                setAppState({ showHyperlinkPopup: "info" });
              }
            }
          }
        ) : element.link ? /* @__PURE__ */ jsx47(
          "a",
          {
            href: normalizeLink(element.link || ""),
            className: "excalidraw-hyperlinkContainer-link",
            target: isLocalLink(element.link) ? "_self" : "_blank",
            onClick: (event) => {
              if (element.link && onLinkOpen) {
                const customEvent = wrapEvent(
                  "excalidraw-link" /* EXCALIDRAW_LINK */,
                  event.nativeEvent
                );
                onLinkOpen(
                  {
                    ...element,
                    link: normalizeLink(element.link)
                  },
                  customEvent
                );
                if (customEvent.defaultPrevented) {
                  event.preventDefault();
                }
              }
            },
            rel: "noopener noreferrer",
            children: element.link
          }
        ) : /* @__PURE__ */ jsx47("div", { className: "excalidraw-hyperlinkContainer-link", children: t("labels.link.empty") }),
        /* @__PURE__ */ jsxs25("div", { className: "excalidraw-hyperlinkContainer__buttons", children: [
          !isEditing && /* @__PURE__ */ jsx47(
            ToolButton,
            {
              type: "button",
              title: t("buttons.edit"),
              "aria-label": t("buttons.edit"),
              label: t("buttons.edit"),
              onClick: onEdit,
              className: "excalidraw-hyperlinkContainer--edit",
              icon: FreedrawIcon
            }
          ),
          linkVal && !isEmbeddableElement(element) && /* @__PURE__ */ jsx47(
            ToolButton,
            {
              type: "button",
              title: t("buttons.remove"),
              "aria-label": t("buttons.remove"),
              label: t("buttons.remove"),
              onClick: handleRemove,
              className: "excalidraw-hyperlinkContainer--remove",
              icon: TrashIcon
            }
          )
        ] })
      ]
    }
  );
};
var getCoordsForPopover = (element, appState, elementsMap) => {
  const [x1, y1] = getElementAbsoluteCoords(element, elementsMap);
  const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(
    { sceneX: x1 + element.width / 2, sceneY: y1 },
    appState
  );
  const x = viewportX - appState.offsetLeft - CONTAINER_WIDTH / 2;
  const y = viewportY - appState.offsetTop - SPACE_BOTTOM;
  return { x, y };
};
var getContextMenuLabel = (elements, appState) => {
  const selectedElements = getSelectedElements(elements, appState);
  const label = selectedElements[0]?.link ? isEmbeddableElement(selectedElements[0]) ? "labels.link.editEmbed" : "labels.link.edit" : isEmbeddableElement(selectedElements[0]) ? "labels.link.createEmbed" : "labels.link.create";
  return label;
};
var HYPERLINK_TOOLTIP_TIMEOUT_ID = null;
var showHyperlinkTooltip = (element, appState, elementsMap) => {
  if (HYPERLINK_TOOLTIP_TIMEOUT_ID) {
    clearTimeout(HYPERLINK_TOOLTIP_TIMEOUT_ID);
  }
  HYPERLINK_TOOLTIP_TIMEOUT_ID = window.setTimeout(
    () => renderTooltip(element, appState, elementsMap),
    HYPERLINK_TOOLTIP_DELAY
  );
};
var renderTooltip = (element, appState, elementsMap) => {
  if (!element.link) {
    return;
  }
  const tooltipDiv = getTooltipDiv();
  tooltipDiv.classList.add("excalidraw-tooltip--visible");
  tooltipDiv.style.maxWidth = "20rem";
  tooltipDiv.textContent = element.link;
  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
  const [linkX, linkY, linkWidth, linkHeight] = getLinkHandleFromCoords(
    [x1, y1, x2, y2],
    element.angle,
    appState
  );
  const linkViewportCoords = sceneCoordsToViewportCoords(
    { sceneX: linkX, sceneY: linkY },
    appState
  );
  updateTooltipPosition(
    tooltipDiv,
    {
      left: linkViewportCoords.x,
      top: linkViewportCoords.y,
      width: linkWidth,
      height: linkHeight
    },
    "top"
  );
  trackEvent("hyperlink", "tooltip", "link-icon");
  IS_HYPERLINK_TOOLTIP_VISIBLE = true;
};
var hideHyperlinkToolip = () => {
  if (HYPERLINK_TOOLTIP_TIMEOUT_ID) {
    clearTimeout(HYPERLINK_TOOLTIP_TIMEOUT_ID);
  }
  if (IS_HYPERLINK_TOOLTIP_VISIBLE) {
    IS_HYPERLINK_TOOLTIP_VISIBLE = false;
    getTooltipDiv().classList.remove("excalidraw-tooltip--visible");
  }
};
var shouldHideLinkPopup = (element, elementsMap, appState, [clientX, clientY]) => {
  const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(
    { clientX, clientY },
    appState
  );
  const threshold = 15 / appState.zoom.value;
  if (hitElementBoundingBox(sceneX, sceneY, element, elementsMap)) {
    return false;
  }
  const [x1, y1, x2] = getElementAbsoluteCoords(element, elementsMap);
  if (sceneX >= x1 && sceneX <= x2 && sceneY >= y1 - SPACE_BOTTOM && sceneY <= y1) {
    return false;
  }
  const { x: popoverX, y: popoverY } = getCoordsForPopover(
    element,
    appState,
    elementsMap
  );
  if (clientX >= popoverX - threshold && clientX <= popoverX + CONTAINER_WIDTH + CONTAINER_PADDING * 2 + threshold && clientY >= popoverY - threshold && clientY <= popoverY + threshold + CONTAINER_PADDING * 2 + CONTAINER_HEIGHT) {
    return false;
  }
  return true;
};

// actions/actionLink.tsx
init_icons();
init_typeChecks();
init_keys();
init_scene();
init_store();
init_utils2();
init_register();
import { jsx as jsx48 } from "react/jsx-runtime";
var actionLink = register({
  name: "hyperlink",
  label: (elements, appState) => getContextMenuLabel(elements, appState),
  icon: LinkIcon,
  perform: (elements, appState) => {
    if (appState.showHyperlinkPopup === "editor") {
      return false;
    }
    return {
      elements,
      appState: {
        ...appState,
        showHyperlinkPopup: "editor",
        openMenu: null
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  trackEvent: { category: "hyperlink", action: "click" },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.K,
  predicate: (elements, appState) => {
    const selectedElements = getSelectedElements(elements, appState);
    return selectedElements.length === 1;
  },
  PanelComponent: ({ elements, appState, updateData }) => {
    const selectedElements = getSelectedElements(elements, appState);
    return /* @__PURE__ */ jsx48(
      ToolButton,
      {
        type: "button",
        icon: LinkIcon,
        "aria-label": t(getContextMenuLabel(elements, appState)),
        title: `${isEmbeddableElement(elements[0]) ? t("labels.link.labelEmbed") : t("labels.link.label")} - ${getShortcutKey("CtrlOrCmd+K")}`,
        onClick: () => updateData(null),
        selected: selectedElements.length === 1 && !!selectedElements[0].link
      }
    );
  }
});

// actions/actionElementLock.ts
init_define_import_meta_env();
init_icons();
init_mutateElement();
init_typeChecks();
init_keys();
init_scene();
init_store();
init_utils2();
init_register();
var shouldLock = (elements) => elements.every((el) => !el.locked);
var actionToggleElementLock = register({
  name: "toggleElementLock",
  label: (elements, appState, app) => {
    const selected = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: false
    });
    if (selected.length === 1 && !isFrameLikeElement(selected[0])) {
      return selected[0].locked ? "labels.elementLock.unlock" : "labels.elementLock.lock";
    }
    return shouldLock(selected) ? "labels.elementLock.lockAll" : "labels.elementLock.unlockAll";
  },
  icon: (appState, elements) => {
    const selectedElements = getSelectedElements(elements, appState);
    return shouldLock(selectedElements) ? LockedIcon : UnlockedIcon;
  },
  trackEvent: { category: "element" },
  predicate: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    return selectedElements.length > 0 && !selectedElements.some((element) => element.locked && element.frameId);
  },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true,
      includeElementsInFrames: true
    });
    if (!selectedElements.length) {
      return false;
    }
    const nextLockState = shouldLock(selectedElements);
    const selectedElementsMap = arrayToMap(selectedElements);
    return {
      elements: elements.map((element) => {
        if (!selectedElementsMap.has(element.id)) {
          return element;
        }
        return newElementWith(element, { locked: nextLockState });
      }),
      appState: {
        ...appState,
        selectedLinearElement: nextLockState ? null : appState.selectedLinearElement
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event, appState, elements, app) => {
    return event.key.toLocaleLowerCase() === KEYS.L && event[KEYS.CTRL_OR_CMD] && event.shiftKey && app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: false
    }).length > 0;
  }
});
var actionUnlockAllElements = register({
  name: "unlockAllElements",
  paletteName: "Unlock all elements",
  trackEvent: { category: "canvas" },
  viewMode: false,
  icon: UnlockedIcon,
  predicate: (elements, appState) => {
    const selectedElements = getSelectedElements(elements, appState);
    return selectedElements.length === 0 && elements.some((element) => element.locked);
  },
  perform: (elements, appState) => {
    const lockedElements = elements.filter((el) => el.locked);
    return {
      elements: elements.map((element) => {
        if (element.locked) {
          return newElementWith(element, { locked: false });
        }
        return element;
      }),
      appState: {
        ...appState,
        selectedElementIds: Object.fromEntries(
          lockedElements.map((el) => [el.id, true])
        )
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  label: "labels.elementLock.unlockAll"
});

// actions/actionLinearEditor.tsx
init_define_import_meta_env();

// components/CommandPalette/CommandPalette.tsx
init_define_import_meta_env();
import { useEffect as useEffect26, useRef as useRef23, useState as useState23 } from "react";
init_keys();

// components/Dialog.tsx
init_define_import_meta_env();
import clsx29 from "clsx";
import { useEffect as useEffect25, useState as useState20 } from "react";

// hooks/useCallbackRefState.ts
init_define_import_meta_env();
import { useCallback as useCallback5, useState as useState12 } from "react";
var useCallbackRefState = () => {
  const [refValue, setRefValue] = useState12(null);
  const refCallback = useCallback5((value) => setRefValue(value), []);
  return [refValue, refCallback];
};

// components/Dialog.tsx
init_keys();

// components/Modal.tsx
init_define_import_meta_env();
init_keys();
import { createPortal as createPortal2 } from "react-dom";
import clsx21 from "clsx";
import { useRef as useRef14 } from "react";
import { jsx as jsx49, jsxs as jsxs26 } from "react/jsx-runtime";
var Modal = (props) => {
  const { closeOnClickOutside = true } = props;
  const modalRoot = useCreatePortalContainer({
    className: "excalidraw-modal-container"
  });
  const animationsDisabledRef = useRef14(
    document.body.classList.contains("excalidraw-animations-disabled")
  );
  if (!modalRoot) {
    return null;
  }
  const handleKeydown = (event) => {
    if (event.key === KEYS.ESCAPE) {
      event.nativeEvent.stopImmediatePropagation();
      event.stopPropagation();
      props.onCloseRequest();
    }
  };
  return createPortal2(
    /* @__PURE__ */ jsxs26(
      "div",
      {
        className: clsx21("Modal", props.className, {
          "animations-disabled": animationsDisabledRef.current
        }),
        role: "dialog",
        "aria-modal": "true",
        onKeyDown: handleKeydown,
        "aria-labelledby": props.labelledBy,
        "data-prevent-outside-click": true,
        children: [
          /* @__PURE__ */ jsx49(
            "div",
            {
              className: "Modal__background",
              onClick: closeOnClickOutside ? props.onCloseRequest : void 0
            }
          ),
          /* @__PURE__ */ jsx49(
            "div",
            {
              className: "Modal__content",
              style: { "--max-width": `${props.maxWidth}px` },
              tabIndex: 0,
              children: props.children
            }
          )
        ]
      }
    ),
    modalRoot
  );
};

// components/Dialog.tsx
init_utils2();
import { useSetAtom as useSetAtom2 } from "jotai";

// components/LibraryMenu.tsx
init_define_import_meta_env();
import { useState as useState19, useCallback as useCallback10, useMemo as useMemo6, useRef as useRef20 } from "react";

// data/library.ts
init_define_import_meta_env();
init_blob();
init_restore();
import { atom as atom5 } from "jotai";
init_bounds();
init_errors();
init_constants();
import { useEffect as useEffect18, useRef as useRef15 } from "react";

// hooks/useLibraryItemSvg.ts
init_define_import_meta_env();
init_colors();
import { atom as atom4, useAtom as useAtom8 } from "jotai";
import { useEffect as useEffect17, useState as useState13 } from "react";
init_export2();
var libraryItemSvgsCache = atom4(/* @__PURE__ */ new Map());
var exportLibraryItemToSvg = async (elements) => {
  return await exportToSvg2({
    elements,
    appState: {
      exportBackground: false,
      viewBackgroundColor: COLOR_PALETTE.white
    },
    files: null,
    renderEmbeddables: false,
    skipInliningFonts: true
  });
};
var useLibraryItemSvg = (id, elements, svgCache) => {
  const [svg, setSvg] = useState13();
  useEffect17(() => {
    if (elements) {
      if (id) {
        const cachedSvg = svgCache.get(id);
        if (cachedSvg) {
          setSvg(cachedSvg);
        } else {
          (async () => {
            const exportedSvg = await exportLibraryItemToSvg(elements);
            exportedSvg.querySelector(".style-fonts")?.remove();
            if (exportedSvg) {
              svgCache.set(id, exportedSvg);
              setSvg(exportedSvg);
            }
          })();
        }
      } else {
        (async () => {
          const exportedSvg = await exportLibraryItemToSvg(elements);
          setSvg(exportedSvg);
        })();
      }
    }
  }, [id, elements, svgCache, setSvg]);
  return svg;
};
var useLibraryCache = () => {
  const [svgCache] = useAtom8(libraryItemSvgsCache, jotaiScope);
  const clearLibraryCache = () => svgCache.clear();
  const deleteItemsFromLibraryCache = (items) => {
    items.forEach((item) => svgCache.delete(item));
  };
  return {
    clearLibraryCache,
    deleteItemsFromLibraryCache,
    svgCache
  };
};

// data/library.ts
init_utils2();
init_emitter();

// queue.ts
init_define_import_meta_env();
init_utils2();
var Queue = class {
  jobs = [];
  running = false;
  tick() {
    if (this.running) {
      return;
    }
    const job = this.jobs.shift();
    if (job) {
      this.running = true;
      job.promise.resolve(
        promiseTry(job.jobFactory, ...job.args).finally(() => {
          this.running = false;
          this.tick();
        })
      );
    } else {
      this.running = false;
    }
  }
  push(jobFactory, ...args) {
    const promise = resolvablePromise();
    this.jobs.push({ jobFactory, promise, args });
    this.tick();
    return promise;
  }
};

// data/library.ts
init_element();
var onLibraryUpdateEmitter = new Emitter();
var libraryItemsAtom = atom5({ status: "loaded", isInitialized: false, libraryItems: [] });
var cloneLibraryItems = (libraryItems) => cloneJSON(libraryItems);
var isUniqueItem = (existingLibraryItems, targetLibraryItem) => {
  return !existingLibraryItems.find((libraryItem) => {
    if (libraryItem.elements.length !== targetLibraryItem.elements.length) {
      return false;
    }
    return libraryItem.elements.every((libItemExcalidrawItem, idx) => {
      return libItemExcalidrawItem.id === targetLibraryItem.elements[idx].id && libItemExcalidrawItem.versionNonce === targetLibraryItem.elements[idx].versionNonce;
    });
  });
};
var mergeLibraryItems = (localItems, otherItems) => {
  const newItems = [];
  for (const item of otherItems) {
    if (isUniqueItem(localItems, item)) {
      newItems.push(item);
    }
  }
  return [...newItems, ...localItems];
};
var createLibraryUpdate = (prevLibraryItems, nextLibraryItems) => {
  const nextItemsMap = arrayToMap(nextLibraryItems);
  const update = {
    deletedItems: /* @__PURE__ */ new Map(),
    addedItems: /* @__PURE__ */ new Map()
  };
  for (const item of prevLibraryItems) {
    if (!nextItemsMap.has(item.id)) {
      update.deletedItems.set(item.id, item);
    }
  }
  const prevItemsMap = arrayToMap(prevLibraryItems);
  for (const item of nextLibraryItems) {
    if (!prevItemsMap.has(item.id)) {
      update.addedItems.set(item.id, item);
    }
  }
  return update;
};
var Library = class {
  /** latest libraryItems */
  currLibraryItems = [];
  /** snapshot of library items since last onLibraryChange call */
  prevLibraryItems = cloneLibraryItems(this.currLibraryItems);
  app;
  constructor(app) {
    this.app = app;
  }
  updateQueue = [];
  getLastUpdateTask = () => {
    return this.updateQueue[this.updateQueue.length - 1];
  };
  notifyListeners = () => {
    if (this.updateQueue.length > 0) {
      jotaiStore.set(libraryItemsAtom, (s) => ({
        status: "loading",
        libraryItems: this.currLibraryItems,
        isInitialized: s.isInitialized
      }));
    } else {
      jotaiStore.set(libraryItemsAtom, {
        status: "loaded",
        libraryItems: this.currLibraryItems,
        isInitialized: true
      });
      try {
        const prevLibraryItems = this.prevLibraryItems;
        this.prevLibraryItems = cloneLibraryItems(this.currLibraryItems);
        const nextLibraryItems = cloneLibraryItems(this.currLibraryItems);
        this.app.props.onLibraryChange?.(nextLibraryItems);
        onLibraryUpdateEmitter.trigger(
          createLibraryUpdate(prevLibraryItems, nextLibraryItems),
          nextLibraryItems
        );
      } catch (error) {
        console.error(error);
      }
    }
  };
  /** call on excalidraw instance unmount */
  destroy = () => {
    this.updateQueue = [];
    this.currLibraryItems = [];
    jotaiStore.set(libraryItemSvgsCache, /* @__PURE__ */ new Map());
  };
  resetLibrary = () => {
    return this.setLibrary([]);
  };
  /**
   * @returns latest cloned libraryItems. Awaits all in-progress updates first.
   */
  getLatestLibrary = () => {
    return new Promise(async (resolve) => {
      try {
        const libraryItems = await (this.getLastUpdateTask() || this.currLibraryItems);
        if (this.updateQueue.length > 0) {
          resolve(this.getLatestLibrary());
        } else {
          resolve(cloneLibraryItems(libraryItems));
        }
      } catch (error) {
        return resolve(this.currLibraryItems);
      }
    });
  };
  // NOTE this is a high-level public API (exposed on ExcalidrawAPI) with
  // a slight overhead (always restoring library items). For internal use
  // where merging isn't needed, use `library.setLibrary()` directly.
  updateLibrary = async ({
    libraryItems,
    prompt = false,
    merge = false,
    openLibraryMenu = false,
    defaultStatus = "unpublished"
  }) => {
    if (openLibraryMenu) {
      this.app.setState({
        openSidebar: { name: DEFAULT_SIDEBAR.name, tab: LIBRARY_SIDEBAR_TAB }
      });
    }
    return this.setLibrary(() => {
      return new Promise(async (resolve, reject) => {
        try {
          const source = await (typeof libraryItems === "function" && !(libraryItems instanceof Blob) ? libraryItems(this.currLibraryItems) : libraryItems);
          let nextItems;
          if (source instanceof Blob) {
            nextItems = await loadLibraryFromBlob(source, defaultStatus);
          } else {
            nextItems = restoreLibraryItems(source, defaultStatus);
          }
          if (!prompt || window.confirm(
            t("alerts.confirmAddLibrary", {
              numShapes: nextItems.length
            })
          )) {
            if (prompt) {
              this.app.focusContainer();
            }
            if (merge) {
              resolve(mergeLibraryItems(this.currLibraryItems, nextItems));
            } else {
              resolve(nextItems);
            }
          } else {
            reject(new AbortError());
          }
        } catch (error) {
          reject(error);
        }
      });
    });
  };
  setLibrary = (libraryItems) => {
    const task = new Promise(async (resolve, reject) => {
      try {
        await this.getLastUpdateTask();
        if (typeof libraryItems === "function") {
          libraryItems = libraryItems(this.currLibraryItems);
        }
        this.currLibraryItems = cloneLibraryItems(await libraryItems);
        resolve(this.currLibraryItems);
      } catch (error) {
        reject(error);
      }
    }).catch((error) => {
      if (error.name === "AbortError") {
        console.warn("Library update aborted by user");
        return this.currLibraryItems;
      }
      throw error;
    }).finally(() => {
      this.updateQueue = this.updateQueue.filter((_task) => _task !== task);
      this.notifyListeners();
    });
    this.updateQueue.push(task);
    this.notifyListeners();
    return task;
  };
};
var library_default = Library;
var distributeLibraryItemsOnSquareGrid = (libraryItems) => {
  const PADDING = 50;
  const ITEMS_PER_ROW = Math.ceil(Math.sqrt(libraryItems.length));
  const resElements = [];
  const getMaxHeightPerRow = (row2) => {
    const maxHeight = libraryItems.slice(row2 * ITEMS_PER_ROW, row2 * ITEMS_PER_ROW + ITEMS_PER_ROW).reduce((acc, item) => {
      const { height } = getCommonBoundingBox(item.elements);
      return Math.max(acc, height);
    }, 0);
    return maxHeight;
  };
  const getMaxWidthPerCol = (targetCol) => {
    let index2 = 0;
    let currCol = 0;
    let maxWidth = 0;
    for (const item of libraryItems) {
      if (index2 % ITEMS_PER_ROW === 0) {
        currCol = 0;
      }
      if (currCol === targetCol) {
        const { width } = getCommonBoundingBox(item.elements);
        maxWidth = Math.max(maxWidth, width);
      }
      index2++;
      currCol++;
    }
    return maxWidth;
  };
  let colOffsetX = 0;
  let rowOffsetY = 0;
  let maxHeightCurrRow = 0;
  let maxWidthCurrCol = 0;
  let index = 0;
  let col = 0;
  let row = 0;
  for (const item of libraryItems) {
    if (index && index % ITEMS_PER_ROW === 0) {
      rowOffsetY += maxHeightCurrRow + PADDING;
      colOffsetX = 0;
      col = 0;
      row++;
    }
    if (col === 0) {
      maxHeightCurrRow = getMaxHeightPerRow(row);
    }
    maxWidthCurrCol = getMaxWidthPerCol(col);
    const { minX, minY, width, height } = getCommonBoundingBox(item.elements);
    const offsetCenterX = (maxWidthCurrCol - width) / 2;
    const offsetCenterY = (maxHeightCurrRow - height) / 2;
    resElements.push(
      ...item.elements.map((element) => ({
        ...element,
        x: element.x + // offset for column
        colOffsetX + // offset to center in given square grid
        offsetCenterX - // subtract minX so that given item starts at 0 coord
        minX,
        y: element.y + // offset for row
        rowOffsetY + // offset to center in given square grid
        offsetCenterY - // subtract minY so that given item starts at 0 coord
        minY
      }))
    );
    colOffsetX += maxWidthCurrCol + PADDING;
    index++;
    col++;
  }
  return resElements;
};
var parseLibraryTokensFromUrl = () => {
  const libraryUrl = (
    // current
    new URLSearchParams(window.location.hash.slice(1)).get(
      URL_HASH_KEYS.addLibrary
    ) || // legacy, kept for compat reasons
    new URLSearchParams(window.location.search).get(URL_QUERY_KEYS.addLibrary)
  );
  const idToken = libraryUrl ? new URLSearchParams(window.location.hash.slice(1)).get("token") : null;
  return libraryUrl ? { libraryUrl, idToken } : null;
};
var AdapterTransaction = class _AdapterTransaction {
  static queue = new Queue();
  static async getLibraryItems(adapter, source, _queue = true) {
    const task = () => new Promise(async (resolve, reject) => {
      try {
        const data = await adapter.load({ source });
        resolve(restoreLibraryItems(data?.libraryItems || [], "published"));
      } catch (error) {
        reject(error);
      }
    });
    if (_queue) {
      return _AdapterTransaction.queue.push(task);
    }
    return task();
  }
  static run = async (adapter, fn) => {
    const transaction = new _AdapterTransaction(adapter);
    return _AdapterTransaction.queue.push(() => fn(transaction));
  };
  // ------------------
  adapter;
  constructor(adapter) {
    this.adapter = adapter;
  }
  getLibraryItems(source) {
    return _AdapterTransaction.getLibraryItems(this.adapter, source, false);
  }
};
var lastSavedLibraryItemsHash = 0;
var librarySaveCounter = 0;
var getLibraryItemsHash = (items) => {
  return hashString(
    items.map((item) => {
      return `${item.id}:${hashElementsVersion(item.elements)}`;
    }).sort().join()
  );
};
var persistLibraryUpdate = async (adapter, update) => {
  try {
    librarySaveCounter++;
    return await AdapterTransaction.run(adapter, async (transaction) => {
      const nextLibraryItemsMap = arrayToMap(
        await transaction.getLibraryItems("save")
      );
      for (const [id] of update.deletedItems) {
        nextLibraryItemsMap.delete(id);
      }
      const addedItems = [];
      for (const [id, item] of update.addedItems) {
        if (nextLibraryItemsMap.has(id)) {
          nextLibraryItemsMap.set(id, item);
        } else {
          addedItems.push(item);
        }
      }
      const nextLibraryItems = addedItems.concat(
        Array.from(nextLibraryItemsMap.values())
      );
      const version = getLibraryItemsHash(nextLibraryItems);
      if (version !== lastSavedLibraryItemsHash) {
        await adapter.save({ libraryItems: nextLibraryItems });
      }
      lastSavedLibraryItemsHash = version;
      return nextLibraryItems;
    });
  } finally {
    librarySaveCounter--;
  }
};
var useHandleLibrary = (opts) => {
  const { excalidrawAPI } = opts;
  const optsRef = useRef15(opts);
  optsRef.current = opts;
  const isLibraryLoadedRef = useRef15(false);
  useEffect18(() => {
    if (!excalidrawAPI) {
      return;
    }
    isLibraryLoadedRef.current = false;
    const importLibraryFromURL = async ({
      libraryUrl,
      idToken
    }) => {
      const libraryPromise = new Promise(async (resolve, reject) => {
        try {
          const request = await fetch(decodeURIComponent(libraryUrl));
          const blob = await request.blob();
          resolve(blob);
        } catch (error) {
          reject(error);
        }
      });
      const shouldPrompt = idToken !== excalidrawAPI.id;
      await (shouldPrompt && document.hidden ? new Promise((resolve) => {
        window.addEventListener("focus", () => resolve(), {
          once: true
        });
      }) : null);
      try {
        await excalidrawAPI.updateLibrary({
          libraryItems: libraryPromise,
          prompt: shouldPrompt,
          merge: true,
          defaultStatus: "published",
          openLibraryMenu: true
        });
      } catch (error) {
        throw error;
      } finally {
        if (window.location.hash.includes(URL_HASH_KEYS.addLibrary)) {
          const hash = new URLSearchParams(window.location.hash.slice(1));
          hash.delete(URL_HASH_KEYS.addLibrary);
          window.history.replaceState({}, APP_NAME, `#${hash.toString()}`);
        } else if (window.location.search.includes(URL_QUERY_KEYS.addLibrary)) {
          const query = new URLSearchParams(window.location.search);
          query.delete(URL_QUERY_KEYS.addLibrary);
          window.history.replaceState({}, APP_NAME, `?${query.toString()}`);
        }
      }
    };
    const onHashChange = (event) => {
      event.preventDefault();
      const libraryUrlTokens2 = parseLibraryTokensFromUrl();
      if (libraryUrlTokens2) {
        event.stopImmediatePropagation();
        window.history.replaceState({}, "", event.oldURL);
        importLibraryFromURL(libraryUrlTokens2);
      }
    };
    const libraryUrlTokens = parseLibraryTokensFromUrl();
    if (libraryUrlTokens) {
      importLibraryFromURL(libraryUrlTokens);
    }
    if ("getInitialLibraryItems" in optsRef.current && optsRef.current.getInitialLibraryItems) {
      console.warn(
        "useHandleLibrar `opts.getInitialLibraryItems` is deprecated. Use `opts.adapter` instead."
      );
      Promise.resolve(optsRef.current.getInitialLibraryItems()).then((libraryItems) => {
        excalidrawAPI.updateLibrary({
          libraryItems,
          // merge with current library items because we may have already
          // populated it (e.g. by installing 3rd party library which can
          // happen before the DB data is loaded)
          merge: true
        });
      }).catch((error) => {
        console.error(
          `UseHandeLibrary getInitialLibraryItems failed: ${error?.message}`
        );
      });
    }
    if ("adapter" in optsRef.current && optsRef.current.adapter) {
      const adapter = optsRef.current.adapter;
      const migrationAdapter = optsRef.current.migrationAdapter;
      const initDataPromise = resolvablePromise();
      if (migrationAdapter) {
        initDataPromise.resolve(
          promiseTry(migrationAdapter.load).then(async (libraryData) => {
            let restoredData = null;
            try {
              if (!libraryData) {
                return AdapterTransaction.getLibraryItems(adapter, "load");
              }
              restoredData = restoreLibraryItems(
                libraryData.libraryItems || [],
                "published"
              );
              const nextItems = await persistLibraryUpdate(
                adapter,
                createLibraryUpdate([], restoredData)
              );
              try {
                await migrationAdapter.clear();
              } catch (error) {
                console.error(
                  `couldn't delete legacy library data: ${error.message}`
                );
              }
              return nextItems;
            } catch (error) {
              console.error(
                `couldn't migrate legacy library data: ${error.message}`
              );
              return restoredData;
            }
          }).catch((error) => {
            console.error(`error during library migration: ${error.message}`);
            return AdapterTransaction.getLibraryItems(adapter, "load");
          })
        );
      } else {
        initDataPromise.resolve(
          promiseTry(AdapterTransaction.getLibraryItems, adapter, "load")
        );
      }
      excalidrawAPI.updateLibrary({
        libraryItems: initDataPromise.then((libraryItems) => {
          const _libraryItems = libraryItems || [];
          lastSavedLibraryItemsHash = getLibraryItemsHash(_libraryItems);
          return _libraryItems;
        }),
        // merge with current library items because we may have already
        // populated it (e.g. by installing 3rd party library which can
        // happen before the DB data is loaded)
        merge: true
      }).finally(() => {
        isLibraryLoadedRef.current = true;
      });
    }
    window.addEventListener("hashchange" /* HASHCHANGE */, onHashChange);
    return () => {
      window.removeEventListener("hashchange" /* HASHCHANGE */, onHashChange);
    };
  }, [
    // important this useEffect only depends on excalidrawAPI so it only reruns
    // on editor remounts (the excalidrawAPI changes)
    excalidrawAPI
  ]);
  useEffect18(
    () => {
      const unsubOnLibraryUpdate = onLibraryUpdateEmitter.on(
        async (update, nextLibraryItems) => {
          const isLoaded = isLibraryLoadedRef.current;
          const adapter = "adapter" in optsRef.current && optsRef.current.adapter || null;
          try {
            if (adapter) {
              if (
                // if nextLibraryItems hash identical to previously saved hash,
                // exit early, even if actual upstream state ends up being
                // different (e.g. has more data than we have locally), as it'd
                // be low-impact scenario.
                lastSavedLibraryItemsHash !== getLibraryItemsHash(nextLibraryItems)
              ) {
                await persistLibraryUpdate(adapter, update);
              }
            }
          } catch (error) {
            console.error(
              `couldn't persist library update: ${error.message}`,
              update
            );
            if (isLoaded && optsRef.current.excalidrawAPI) {
              optsRef.current.excalidrawAPI.updateScene({
                appState: {
                  errorMessage: t("errors.saveLibraryError")
                }
              });
            }
          }
        }
      );
      const onUnload = (event) => {
        if (librarySaveCounter) {
          preventUnload(event);
        }
      };
      window.addEventListener("beforeunload" /* BEFORE_UNLOAD */, onUnload);
      return () => {
        window.removeEventListener("beforeunload" /* BEFORE_UNLOAD */, onUnload);
        unsubOnLibraryUpdate();
        lastSavedLibraryItemsHash = 0;
        librarySaveCounter = 0;
      };
    },
    [
      // this effect must not have any deps so it doesn't rerun
    ]
  );
};

// components/LibraryMenu.tsx
init_random();

// components/LibraryMenuItems.tsx
init_define_import_meta_env();
init_json();
import {
  useCallback as useCallback9,
  useEffect as useEffect24,
  useMemo as useMemo5,
  useRef as useRef19,
  useState as useState18
} from "react";
init_utils2();

// components/Stack.tsx
init_define_import_meta_env();
import { forwardRef as forwardRef2 } from "react";
import clsx22 from "clsx";
import { jsx as jsx50 } from "react/jsx-runtime";
var RowStack = forwardRef2(
  ({ children, gap, align, justifyContent, className, style }, ref) => {
    return /* @__PURE__ */ jsx50(
      "div",
      {
        className: clsx22("Stack Stack_horizontal", className),
        style: {
          "--gap": gap,
          alignItems: align,
          justifyContent,
          ...style
        },
        ref,
        children
      }
    );
  }
);
var ColStack = forwardRef2(
  ({ children, gap, align, justifyContent, className, style }, ref) => {
    return /* @__PURE__ */ jsx50(
      "div",
      {
        className: clsx22("", className),
        style: {
          "--gap": gap,
          justifyItems: align,
          justifyContent,
          ...style
        },
        ref,
        children
      }
    );
  }
);
var Stack_default = {
  Row: RowStack,
  Col: ColStack
};

// components/LibraryMenuItems.tsx
init_constants();
init_newElement();

// components/LibraryMenuControlButtons.tsx
init_define_import_meta_env();

// components/LibraryMenuBrowseButton.tsx
init_define_import_meta_env();
init_constants();
import { jsx as jsx51 } from "react/jsx-runtime";
var LibraryMenuBrowseButton = ({
  theme,
  id,
  libraryReturnUrl
}) => {
  const referrer = libraryReturnUrl || window.location.origin + window.location.pathname;
  return /* @__PURE__ */ jsx51(
    "a",
    {
      className: "library-menu-browse-button",
      href: `${define_import_meta_env_default.VITE_APP_LIBRARY_URL}?target=${window.name || "_blank"}&referrer=${referrer}&useHash=true&token=${id}&theme=${theme}&version=${VERSIONS.excalidrawLibrary}`,
      target: "_excalidraw_libraries",
      children: t("labels.libraries")
    }
  );
};
var LibraryMenuBrowseButton_default = LibraryMenuBrowseButton;

// components/LibraryMenuControlButtons.tsx
import clsx23 from "clsx";
import { jsx as jsx52, jsxs as jsxs27 } from "react/jsx-runtime";
var LibraryMenuControlButtons = ({
  libraryReturnUrl,
  theme,
  id,
  style,
  children,
  className
}) => {
  return /* @__PURE__ */ jsxs27(
    "div",
    {
      className: clsx23("library-menu-control-buttons", className),
      style,
      children: [
        /* @__PURE__ */ jsx52(
          LibraryMenuBrowseButton_default,
          {
            id,
            libraryReturnUrl,
            theme
          }
        ),
        children
      ]
    }
  );
};

// components/LibraryMenuHeaderContent.tsx
init_define_import_meta_env();
import { useCallback as useCallback7, useState as useState15 } from "react";

// components/Trans.tsx
init_define_import_meta_env();
import React20 from "react";
var SPLIT_REGEX = /({{[\w-]+}})|(<[\w-]+>)|(<\/[\w-]+>)/g;
var KEY_REGEXP = /{{([\w-]+)}}/;
var TAG_START_REGEXP = /<([\w-]+)>/;
var TAG_END_REGEXP = /<\/([\w-]+)>/;
var getTransChildren = (format, props) => {
  const stack = [
    {
      name: "",
      children: []
    }
  ];
  format.split(SPLIT_REGEX).filter(Boolean).forEach((match) => {
    const tagStartMatch = match.match(TAG_START_REGEXP);
    const tagEndMatch = match.match(TAG_END_REGEXP);
    const keyMatch = match.match(KEY_REGEXP);
    if (tagStartMatch !== null) {
      const name = tagStartMatch[1];
      if (props.hasOwnProperty(name)) {
        stack.push({
          name,
          children: []
        });
      } else {
        console.warn(
          `Trans: missed to pass in prop ${name} for interpolating ${format}`
        );
      }
    } else if (tagEndMatch !== null) {
      const name = tagEndMatch[1];
      if (name === stack[stack.length - 1].name) {
        const item = stack.pop();
        const itemChildren = React20.createElement(
          React20.Fragment,
          {},
          ...item.children
        );
        const fn = props[item.name];
        if (typeof fn === "function") {
          stack[stack.length - 1].children.push(fn(itemChildren));
        }
      } else {
        console.warn(
          `Trans: unexpected end tag ${match} for interpolating ${format}`
        );
      }
    } else if (keyMatch !== null) {
      const name = keyMatch[1];
      if (props.hasOwnProperty(name)) {
        stack[stack.length - 1].children.push(props[name]);
      } else {
        console.warn(
          `Trans: key ${name} not in props for interpolating ${format}`
        );
      }
    } else {
      stack[stack.length - 1].children.push(match);
    }
  });
  if (stack.length !== 1) {
    console.warn(`Trans: stack not empty for interpolating ${format}`);
  }
  return stack[0].children;
};
var Trans = ({
  i18nKey,
  children,
  ...props
}) => {
  const { t: t2 } = useI18n();
  return React20.createElement(
    React20.Fragment,
    {},
    ...getTransChildren(t2(i18nKey), props)
  );
};
var Trans_default = Trans;

// components/LibraryMenuHeaderContent.tsx
init_json();
init_icons();
init_filesystem();
init_utils2();
import { useAtom as useAtom9 } from "jotai";

// components/ConfirmDialog.tsx
init_define_import_meta_env();

// components/DialogActionButton.tsx
init_define_import_meta_env();
import clsx24 from "clsx";
import { jsx as jsx53, jsxs as jsxs28 } from "react/jsx-runtime";
var DialogActionButton = ({
  label,
  onClick,
  className,
  children,
  actionType,
  type = "button",
  isLoading,
  ...rest
}) => {
  const cs = actionType ? `Dialog__action-button--${actionType}` : "";
  return /* @__PURE__ */ jsxs28(
    "button",
    {
      className: clsx24("Dialog__action-button", cs, className),
      type,
      "aria-label": label,
      onClick,
      ...rest,
      children: [
        children && /* @__PURE__ */ jsx53("div", { style: isLoading ? { visibility: "hidden" } : {}, children }),
        /* @__PURE__ */ jsx53("div", { style: isLoading ? { visibility: "hidden" } : {}, children: label }),
        isLoading && /* @__PURE__ */ jsx53("div", { style: { position: "absolute", inset: 0 }, children: /* @__PURE__ */ jsx53(Spinner_default, {}) })
      ]
    }
  );
};
var DialogActionButton_default = DialogActionButton;

// components/ConfirmDialog.tsx
import { useSetAtom } from "jotai";
import { jsx as jsx54, jsxs as jsxs29 } from "react/jsx-runtime";
var ConfirmDialog = (props) => {
  const {
    onConfirm,
    onCancel,
    children,
    confirmText = t("buttons.confirm"),
    cancelText = t("buttons.cancel"),
    className = "",
    ...rest
  } = props;
  const setAppState = useExcalidrawSetAppState();
  const setIsLibraryMenuOpen = useSetAtom(isLibraryMenuOpenAtom, jotaiScope);
  const { container } = useExcalidrawContainer();
  return /* @__PURE__ */ jsxs29(
    Dialog,
    {
      onCloseRequest: onCancel,
      size: "small",
      ...rest,
      className: `confirm-dialog ${className}`,
      children: [
        children,
        /* @__PURE__ */ jsxs29("div", { className: "confirm-dialog-buttons", children: [
          /* @__PURE__ */ jsx54(
            DialogActionButton_default,
            {
              label: cancelText,
              onClick: () => {
                setAppState({ openMenu: null });
                setIsLibraryMenuOpen(false);
                onCancel();
                container?.focus();
              }
            }
          ),
          /* @__PURE__ */ jsx54(
            DialogActionButton_default,
            {
              label: confirmText,
              onClick: () => {
                setAppState({ openMenu: null });
                setIsLibraryMenuOpen(false);
                onConfirm();
                container?.focus();
              },
              actionType: "danger"
            }
          )
        ] })
      ]
    }
  );
};
var ConfirmDialog_default = ConfirmDialog;

// components/PublishLibrary.tsx
init_define_import_meta_env();
import { useCallback as useCallback6, useEffect as useEffect19, useRef as useRef16, useState as useState14 } from "react";
import OpenColor2 from "open-color";
init_export2();
init_constants();
init_blob();
init_utils2();
init_icons();

// data/EditorLocalStorage.ts
init_define_import_meta_env();
var EditorLocalStorage = class {
  static has(key) {
    try {
      return !!window.localStorage.getItem(key);
    } catch (error) {
      console.warn(`localStorage.getItem error: ${error.message}`);
      return false;
    }
  }
  static get(key) {
    try {
      const value = window.localStorage.getItem(key);
      if (value) {
        return JSON.parse(value);
      }
      return null;
    } catch (error) {
      console.warn(`localStorage.getItem error: ${error.message}`);
      return null;
    }
  }
  static set = (key, value) => {
    try {
      window.localStorage.setItem(key, JSON.stringify(value));
      return true;
    } catch (error) {
      console.warn(`localStorage.setItem error: ${error.message}`);
      return false;
    }
  };
  static delete = (name) => {
    try {
      window.localStorage.removeItem(name);
    } catch (error) {
      console.warn(`localStorage.removeItem error: ${error.message}`);
    }
  };
};

// components/PublishLibrary.tsx
import { jsx as jsx55, jsxs as jsxs30 } from "react/jsx-runtime";
var generatePreviewImage = async (libraryItems) => {
  const MAX_ITEMS_PER_ROW = 6;
  const BOX_SIZE = 128;
  const BOX_PADDING = Math.round(BOX_SIZE / 16);
  const BORDER_WIDTH = Math.max(Math.round(BOX_SIZE / 64), 2);
  const rows = chunk(libraryItems, MAX_ITEMS_PER_ROW);
  const canvas2 = document.createElement("canvas");
  canvas2.width = rows[0].length * BOX_SIZE + (rows[0].length + 1) * (BOX_PADDING * 2) - BOX_PADDING * 2;
  canvas2.height = rows.length * BOX_SIZE + (rows.length + 1) * (BOX_PADDING * 2) - BOX_PADDING * 2;
  const ctx = canvas2.getContext("2d");
  ctx.fillStyle = OpenColor2.white;
  ctx.fillRect(0, 0, canvas2.width, canvas2.height);
  for (const [index, item] of libraryItems.entries()) {
    const itemCanvas = await exportToCanvas2({
      elements: item.elements,
      files: null,
      maxWidthOrHeight: BOX_SIZE
    });
    const { width, height } = itemCanvas;
    const rowOffset = Math.floor(index / MAX_ITEMS_PER_ROW) * (BOX_SIZE + BOX_PADDING * 2);
    const colOffset = index % MAX_ITEMS_PER_ROW * (BOX_SIZE + BOX_PADDING * 2);
    ctx.drawImage(
      itemCanvas,
      colOffset + (BOX_SIZE - width) / 2 + BOX_PADDING,
      rowOffset + (BOX_SIZE - height) / 2 + BOX_PADDING
    );
    ctx.lineWidth = BORDER_WIDTH;
    ctx.strokeStyle = OpenColor2.gray[4];
    ctx.strokeRect(
      colOffset + BOX_PADDING / 2,
      rowOffset + BOX_PADDING / 2,
      BOX_SIZE + BOX_PADDING,
      BOX_SIZE + BOX_PADDING
    );
  }
  return await resizeImageFile(
    new File([await canvasToBlob(canvas2)], "preview", { type: MIME_TYPES.png }),
    {
      outputType: MIME_TYPES.jpg,
      maxWidthOrHeight: 5e3
    }
  );
};
var SingleLibraryItem = ({
  libItem,
  appState,
  index,
  onChange,
  onRemove
}) => {
  const svgRef = useRef16(null);
  const inputRef = useRef16(null);
  useEffect19(() => {
    const node = svgRef.current;
    if (!node) {
      return;
    }
    (async () => {
      const svg = await exportToSvg2({
        elements: libItem.elements,
        appState: {
          ...appState,
          viewBackgroundColor: OpenColor2.white,
          exportBackground: true
        },
        files: null,
        skipInliningFonts: true
      });
      node.innerHTML = svg.outerHTML;
    })();
  }, [libItem.elements, appState]);
  return /* @__PURE__ */ jsxs30("div", { className: "single-library-item", children: [
    libItem.status === "published" && /* @__PURE__ */ jsx55("span", { className: "single-library-item-status", children: t("labels.statusPublished") }),
    /* @__PURE__ */ jsx55("div", { ref: svgRef, className: "single-library-item__svg" }),
    /* @__PURE__ */ jsx55(
      ToolButton,
      {
        "aria-label": t("buttons.remove"),
        type: "button",
        icon: CloseIcon,
        className: "single-library-item--remove",
        onClick: onRemove.bind(null, libItem.id),
        title: t("buttons.remove")
      }
    ),
    /* @__PURE__ */ jsxs30(
      "div",
      {
        style: {
          display: "flex",
          margin: "0.8rem 0",
          width: "100%",
          fontSize: "14px",
          fontWeight: 500,
          flexDirection: "column"
        },
        children: [
          /* @__PURE__ */ jsxs30(
            "label",
            {
              style: {
                display: "flex",
                justifyContent: "space-between",
                flexDirection: "column"
              },
              children: [
                /* @__PURE__ */ jsxs30("div", { style: { padding: "0.5em 0" }, children: [
                  /* @__PURE__ */ jsx55("span", { style: { fontWeight: 500, color: OpenColor2.gray[6] }, children: t("publishDialog.itemName") }),
                  /* @__PURE__ */ jsx55("span", { "aria-hidden": "true", className: "required", children: "*" })
                ] }),
                /* @__PURE__ */ jsx55(
                  "input",
                  {
                    type: "text",
                    ref: inputRef,
                    style: { width: "80%", padding: "0.2rem" },
                    defaultValue: libItem.name,
                    placeholder: "Item name",
                    onChange: (event) => {
                      onChange(event.target.value, index);
                    }
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsx55("span", { className: "error", children: libItem.error })
        ]
      }
    )
  ] });
};
var PublishLibrary = ({
  onClose,
  libraryItems,
  appState,
  onSuccess,
  onError,
  updateItemsInStorage,
  onRemove
}) => {
  const [libraryData, setLibraryData] = useState14({
    authorName: "",
    githubHandle: "",
    name: "",
    description: "",
    twitterHandle: "",
    website: ""
  });
  const [isSubmitting, setIsSubmitting] = useState14(false);
  useEffect19(() => {
    const data = EditorLocalStorage.get(
      EDITOR_LS_KEYS.PUBLISH_LIBRARY
    );
    if (data) {
      setLibraryData(data);
    }
  }, []);
  const [clonedLibItems, setClonedLibItems] = useState14(
    libraryItems.slice()
  );
  useEffect19(() => {
    setClonedLibItems(libraryItems.slice());
  }, [libraryItems]);
  const onInputChange = (event) => {
    setLibraryData({
      ...libraryData,
      [event.target.name]: event.target.value
    });
  };
  const onSubmit = async (event) => {
    event.preventDefault();
    setIsSubmitting(true);
    const erroredLibItems = [];
    let isError = false;
    clonedLibItems.forEach((libItem) => {
      let error = "";
      if (!libItem.name) {
        error = t("publishDialog.errors.required");
        isError = true;
      }
      erroredLibItems.push({ ...libItem, error });
    });
    if (isError) {
      setClonedLibItems(erroredLibItems);
      setIsSubmitting(false);
      return;
    }
    const previewImage = await generatePreviewImage(clonedLibItems);
    const libContent = {
      type: EXPORT_DATA_TYPES.excalidrawLibrary,
      version: VERSIONS.excalidrawLibrary,
      source: EXPORT_SOURCE,
      libraryItems: clonedLibItems
    };
    const content = JSON.stringify(libContent, null, 2);
    const lib = new Blob([content], { type: "application/json" });
    const formData = new FormData();
    formData.append("excalidrawLib", lib);
    formData.append("previewImage", previewImage);
    formData.append("previewImageType", previewImage.type);
    formData.append("title", libraryData.name);
    formData.append("authorName", libraryData.authorName);
    formData.append("githubHandle", libraryData.githubHandle);
    formData.append("name", libraryData.name);
    formData.append("description", libraryData.description);
    formData.append("twitterHandle", libraryData.twitterHandle);
    formData.append("website", libraryData.website);
    fetch(`${define_import_meta_env_default.VITE_APP_LIBRARY_BACKEND}/submit`, {
      method: "post",
      body: formData
    }).then(
      (response) => {
        if (response.ok) {
          return response.json().then(({ url }) => {
            EditorLocalStorage.delete(EDITOR_LS_KEYS.PUBLISH_LIBRARY);
            onSuccess({
              url,
              authorName: libraryData.authorName,
              items: clonedLibItems
            });
          });
        }
        return response.json().catch(() => {
          throw new Error(response.statusText || "something went wrong");
        }).then((error) => {
          throw new Error(
            error.message || response.statusText || "something went wrong"
          );
        });
      },
      (err) => {
        console.error(err);
        onError(err);
        setIsSubmitting(false);
      }
    ).catch((err) => {
      console.error(err);
      onError(err);
      setIsSubmitting(false);
    });
  };
  const renderLibraryItems = () => {
    const items = [];
    clonedLibItems.forEach((libItem, index) => {
      items.push(
        /* @__PURE__ */ jsx55("div", { className: "single-library-item-wrapper", children: /* @__PURE__ */ jsx55(
          SingleLibraryItem,
          {
            libItem,
            appState,
            index,
            onChange: (val, index2) => {
              const items2 = clonedLibItems.slice();
              items2[index2].name = val;
              setClonedLibItems(items2);
            },
            onRemove
          }
        ) }, index)
      );
    });
    return /* @__PURE__ */ jsx55("div", { className: "selected-library-items", children: items });
  };
  const onDialogClose = useCallback6(() => {
    updateItemsInStorage(clonedLibItems);
    EditorLocalStorage.set(EDITOR_LS_KEYS.PUBLISH_LIBRARY, libraryData);
    onClose();
  }, [clonedLibItems, onClose, updateItemsInStorage, libraryData]);
  const shouldRenderForm = !!libraryItems.length;
  const containsPublishedItems = libraryItems.some(
    (item) => item.status === "published"
  );
  return /* @__PURE__ */ jsx55(
    Dialog,
    {
      onCloseRequest: onDialogClose,
      title: t("publishDialog.title"),
      className: "publish-library",
      children: shouldRenderForm ? /* @__PURE__ */ jsxs30("form", { onSubmit, children: [
        /* @__PURE__ */ jsx55("div", { className: "publish-library-note", children: /* @__PURE__ */ jsx55(
          Trans_default,
          {
            i18nKey: "publishDialog.noteDescription",
            link: (el) => /* @__PURE__ */ jsx55(
              "a",
              {
                href: "https://libraries.excalidraw.com",
                target: "_blank",
                rel: "noopener noreferrer",
                children: el
              }
            )
          }
        ) }),
        /* @__PURE__ */ jsx55("span", { className: "publish-library-note", children: /* @__PURE__ */ jsx55(
          Trans_default,
          {
            i18nKey: "publishDialog.noteGuidelines",
            link: (el) => /* @__PURE__ */ jsx55(
              "a",
              {
                href: "https://github.com/excalidraw/excalidraw-libraries#guidelines",
                target: "_blank",
                rel: "noopener noreferrer",
                children: el
              }
            )
          }
        ) }),
        /* @__PURE__ */ jsx55("div", { className: "publish-library-note", children: t("publishDialog.noteItems") }),
        containsPublishedItems && /* @__PURE__ */ jsx55("span", { className: "publish-library-note publish-library-warning", children: t("publishDialog.republishWarning") }),
        renderLibraryItems(),
        /* @__PURE__ */ jsxs30("div", { className: "publish-library__fields", children: [
          /* @__PURE__ */ jsxs30("label", { children: [
            /* @__PURE__ */ jsxs30("div", { children: [
              /* @__PURE__ */ jsx55("span", { children: t("publishDialog.libraryName") }),
              /* @__PURE__ */ jsx55("span", { "aria-hidden": "true", className: "required", children: "*" })
            ] }),
            /* @__PURE__ */ jsx55(
              "input",
              {
                type: "text",
                name: "name",
                required: true,
                value: libraryData.name,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.libraryName")
              }
            )
          ] }),
          /* @__PURE__ */ jsxs30("label", { style: { alignItems: "flex-start" }, children: [
            /* @__PURE__ */ jsxs30("div", { children: [
              /* @__PURE__ */ jsx55("span", { children: t("publishDialog.libraryDesc") }),
              /* @__PURE__ */ jsx55("span", { "aria-hidden": "true", className: "required", children: "*" })
            ] }),
            /* @__PURE__ */ jsx55(
              "textarea",
              {
                name: "description",
                rows: 4,
                required: true,
                value: libraryData.description,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.libraryDesc")
              }
            )
          ] }),
          /* @__PURE__ */ jsxs30("label", { children: [
            /* @__PURE__ */ jsxs30("div", { children: [
              /* @__PURE__ */ jsx55("span", { children: t("publishDialog.authorName") }),
              /* @__PURE__ */ jsx55("span", { "aria-hidden": "true", className: "required", children: "*" })
            ] }),
            /* @__PURE__ */ jsx55(
              "input",
              {
                type: "text",
                name: "authorName",
                required: true,
                value: libraryData.authorName,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.authorName")
              }
            )
          ] }),
          /* @__PURE__ */ jsxs30("label", { children: [
            /* @__PURE__ */ jsx55("span", { children: t("publishDialog.githubUsername") }),
            /* @__PURE__ */ jsx55(
              "input",
              {
                type: "text",
                name: "githubHandle",
                value: libraryData.githubHandle,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.githubHandle")
              }
            )
          ] }),
          /* @__PURE__ */ jsxs30("label", { children: [
            /* @__PURE__ */ jsx55("span", { children: t("publishDialog.twitterUsername") }),
            /* @__PURE__ */ jsx55(
              "input",
              {
                type: "text",
                name: "twitterHandle",
                value: libraryData.twitterHandle,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.twitterHandle")
              }
            )
          ] }),
          /* @__PURE__ */ jsxs30("label", { children: [
            /* @__PURE__ */ jsx55("span", { children: t("publishDialog.website") }),
            /* @__PURE__ */ jsx55(
              "input",
              {
                type: "text",
                name: "website",
                pattern: "https?://.+",
                title: t("publishDialog.errors.website"),
                value: libraryData.website,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.website")
              }
            )
          ] }),
          /* @__PURE__ */ jsx55("span", { className: "publish-library-note", children: /* @__PURE__ */ jsx55(
            Trans_default,
            {
              i18nKey: "publishDialog.noteLicense",
              link: (el) => /* @__PURE__ */ jsx55(
                "a",
                {
                  href: "https://github.com/excalidraw/excalidraw-libraries/blob/main/LICENSE",
                  target: "_blank",
                  rel: "noopener noreferrer",
                  children: el
                }
              )
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxs30("div", { className: "publish-library__buttons", children: [
          /* @__PURE__ */ jsx55(
            DialogActionButton_default,
            {
              label: t("buttons.cancel"),
              onClick: onDialogClose,
              "data-testid": "cancel-clear-canvas-button"
            }
          ),
          /* @__PURE__ */ jsx55(
            DialogActionButton_default,
            {
              type: "submit",
              label: t("buttons.submit"),
              actionType: "primary",
              isLoading: isSubmitting
            }
          )
        ] })
      ] }) : /* @__PURE__ */ jsx55("p", { style: { padding: "1em", textAlign: "center", fontWeight: 500 }, children: t("publishDialog.atleastOneLibItem") })
    }
  );
};
var PublishLibrary_default = PublishLibrary;

// components/dropdownMenu/DropdownMenu.tsx
init_define_import_meta_env();

// components/dropdownMenu/DropdownMenuTrigger.tsx
init_define_import_meta_env();
import clsx25 from "clsx";
import { jsx as jsx56 } from "react/jsx-runtime";
var MenuTrigger = ({
  className = "",
  children,
  onToggle,
  title,
  ...rest
}) => {
  const device = useDevice();
  const classNames = clsx25(
    `dropdown-menu-button ${className}`,
    "zen-mode-transition",
    {
      "dropdown-menu-button--mobile": device.editor.isMobile
    }
  ).trim();
  return /* @__PURE__ */ jsx56(
    "button",
    {
      "data-prevent-outside-click": true,
      className: classNames,
      onClick: onToggle,
      type: "button",
      "data-testid": "dropdown-menu-button",
      title,
      ...rest,
      children
    }
  );
};
var DropdownMenuTrigger_default = MenuTrigger;
MenuTrigger.displayName = "DropdownMenuTrigger";

// components/dropdownMenu/DropdownMenuSeparator.tsx
init_define_import_meta_env();
import { jsx as jsx57 } from "react/jsx-runtime";
var MenuSeparator = () => /* @__PURE__ */ jsx57(
  "div",
  {
    style: {
      height: "1px",
      backgroundColor: "var(--default-border-color)",
      margin: ".5rem 0"
    }
  }
);
var DropdownMenuSeparator_default = MenuSeparator;
MenuSeparator.displayName = "DropdownMenuSeparator";

// components/dropdownMenu/DropdownMenuContent.tsx
init_define_import_meta_env();
import clsx26 from "clsx";
import { useEffect as useEffect20, useRef as useRef17 } from "react";
init_keys();
init_constants();
import { jsx as jsx58 } from "react/jsx-runtime";
var MenuContent = ({
  children,
  onClickOutside,
  className = "",
  onSelect,
  style
}) => {
  const device = useDevice();
  const menuRef = useRef17(null);
  const callbacksRef = useStable({ onClickOutside });
  useOutsideClick(menuRef, () => {
    callbacksRef.onClickOutside?.();
  });
  useEffect20(() => {
    const onKeyDown = (event) => {
      if (event.key === KEYS.ESCAPE) {
        event.stopImmediatePropagation();
        callbacksRef.onClickOutside?.();
      }
    };
    const option = {
      // so that we can stop propagation of the event before it reaches
      // event handlers that were bound before this one
      capture: true
    };
    document.addEventListener("keydown" /* KEYDOWN */, onKeyDown, option);
    return () => {
      document.removeEventListener("keydown" /* KEYDOWN */, onKeyDown, option);
    };
  }, [callbacksRef]);
  const classNames = clsx26(`dropdown-menu ${className}`, {
    "dropdown-menu--mobile": device.editor.isMobile
  }).trim();
  return /* @__PURE__ */ jsx58(DropdownMenuContentPropsContext.Provider, { value: { onSelect }, children: /* @__PURE__ */ jsx58(
    "div",
    {
      ref: menuRef,
      className: classNames,
      style,
      "data-testid": "dropdown-menu",
      children: device.editor.isMobile ? /* @__PURE__ */ jsx58(Stack_default.Col, { className: "dropdown-menu-container", children }) : /* @__PURE__ */ jsx58(
        Island,
        {
          className: "dropdown-menu-container",
          padding: 2,
          style: { zIndex: 2 },
          children
        }
      )
    }
  ) });
};
MenuContent.displayName = "DropdownMenuContent";
var DropdownMenuContent_default = MenuContent;

// components/dropdownMenu/DropdownMenuItemLink.tsx
init_define_import_meta_env();
import { jsx as jsx59 } from "react/jsx-runtime";
var DropdownMenuItemLink = ({
  icon,
  shortcut,
  href,
  children,
  onSelect,
  className = "",
  selected,
  rel = "noreferrer",
  ...rest
}) => {
  const handleClick = useHandleDropdownMenuItemClick(rest.onClick, onSelect);
  return /* @__PURE__ */ jsx59(
    "a",
    {
      ...rest,
      href,
      target: "_blank",
      rel: "noreferrer",
      className: getDropdownMenuItemClassName(className, selected),
      title: rest.title ?? rest["aria-label"],
      onClick: handleClick,
      children: /* @__PURE__ */ jsx59(DropdownMenuItemContent_default, { icon, shortcut, children })
    }
  );
};
var DropdownMenuItemLink_default = DropdownMenuItemLink;
DropdownMenuItemLink.displayName = "DropdownMenuItemLink";

// components/dropdownMenu/DropdownMenuItemCustom.tsx
init_define_import_meta_env();
import { jsx as jsx60 } from "react/jsx-runtime";
var DropdownMenuItemCustom = ({
  children,
  className = "",
  selected,
  ...rest
}) => {
  return /* @__PURE__ */ jsx60(
    "div",
    {
      ...rest,
      className: `dropdown-menu-item-base dropdown-menu-item-custom ${className} ${selected ? `dropdown-menu-item--selected` : ``}`.trim(),
      children
    }
  );
};
var DropdownMenuItemCustom_default = DropdownMenuItemCustom;

// components/dropdownMenu/dropdownMenuUtils.ts
init_define_import_meta_env();
import React22 from "react";
var getMenuTriggerComponent = (children) => {
  const comp = React22.Children.toArray(children).find(
    (child) => React22.isValidElement(child) && typeof child.type !== "string" && //@ts-ignore
    child?.type.displayName && //@ts-ignore
    child.type.displayName === "DropdownMenuTrigger"
  );
  if (!comp) {
    return null;
  }
  return comp;
};
var getMenuContentComponent = (children) => {
  const comp = React22.Children.toArray(children).find(
    (child) => React22.isValidElement(child) && typeof child.type !== "string" && //@ts-ignore
    child?.type.displayName && //@ts-ignore
    child.type.displayName === "DropdownMenuContent"
  );
  if (!comp) {
    return null;
  }
  return comp;
};

// components/dropdownMenu/DropdownMenu.tsx
import { Fragment as Fragment7, jsxs as jsxs31 } from "react/jsx-runtime";
var DropdownMenu = ({
  children,
  open
}) => {
  const MenuTriggerComp = getMenuTriggerComponent(children);
  const MenuContentComp = getMenuContentComponent(children);
  return /* @__PURE__ */ jsxs31(Fragment7, { children: [
    MenuTriggerComp,
    open && MenuContentComp
  ] });
};
DropdownMenu.Trigger = DropdownMenuTrigger_default;
DropdownMenu.Content = DropdownMenuContent_default;
DropdownMenu.Item = DropdownMenuItem_default;
DropdownMenu.ItemLink = DropdownMenuItemLink_default;
DropdownMenu.ItemCustom = DropdownMenuItemCustom_default;
DropdownMenu.Group = DropdownMenuGroup_default;
DropdownMenu.Separator = DropdownMenuSeparator_default;
var DropdownMenu_default = DropdownMenu;
DropdownMenu.displayName = "DropdownMenu";

// components/LibraryMenuHeaderContent.tsx
import clsx27 from "clsx";
import { jsx as jsx61, jsxs as jsxs32 } from "react/jsx-runtime";
var getSelectedItems = (libraryItems, selectedItems) => libraryItems.filter((item) => selectedItems.includes(item.id));
var LibraryDropdownMenuButton = ({
  setAppState,
  selectedItems,
  library,
  onRemoveFromLibrary,
  resetLibrary,
  onSelectItems,
  appState,
  className
}) => {
  const [libraryItemsData] = useAtom9(libraryItemsAtom, jotaiScope);
  const [isLibraryMenuOpen, setIsLibraryMenuOpen] = useAtom9(
    isLibraryMenuOpenAtom,
    jotaiScope
  );
  const renderRemoveLibAlert = () => {
    const content = selectedItems.length ? t("alerts.removeItemsFromsLibrary", { count: selectedItems.length }) : t("alerts.resetLibrary");
    const title = selectedItems.length ? t("confirmDialog.removeItemsFromLib") : t("confirmDialog.resetLibrary");
    return /* @__PURE__ */ jsx61(
      ConfirmDialog_default,
      {
        onConfirm: () => {
          if (selectedItems.length) {
            onRemoveFromLibrary();
          } else {
            resetLibrary();
          }
          setShowRemoveLibAlert(false);
        },
        onCancel: () => {
          setShowRemoveLibAlert(false);
        },
        title,
        children: /* @__PURE__ */ jsx61("p", { children: content })
      }
    );
  };
  const [showRemoveLibAlert, setShowRemoveLibAlert] = useState15(false);
  const itemsSelected = !!selectedItems.length;
  const items = itemsSelected ? libraryItemsData.libraryItems.filter(
    (item) => selectedItems.includes(item.id)
  ) : libraryItemsData.libraryItems;
  const resetLabel = itemsSelected ? t("buttons.remove") : t("buttons.resetLibrary");
  const [showPublishLibraryDialog, setShowPublishLibraryDialog] = useState15(false);
  const [publishLibSuccess, setPublishLibSuccess] = useState15(null);
  const renderPublishSuccess = useCallback7(() => {
    return /* @__PURE__ */ jsxs32(
      Dialog,
      {
        onCloseRequest: () => setPublishLibSuccess(null),
        title: t("publishSuccessDialog.title"),
        className: "publish-library-success",
        size: "small",
        children: [
          /* @__PURE__ */ jsx61("p", { children: /* @__PURE__ */ jsx61(
            Trans_default,
            {
              i18nKey: "publishSuccessDialog.content",
              authorName: publishLibSuccess.authorName,
              link: (el) => /* @__PURE__ */ jsx61(
                "a",
                {
                  href: publishLibSuccess?.url,
                  target: "_blank",
                  rel: "noopener noreferrer",
                  children: el
                }
              )
            }
          ) }),
          /* @__PURE__ */ jsx61(
            ToolButton,
            {
              type: "button",
              title: t("buttons.close"),
              "aria-label": t("buttons.close"),
              label: t("buttons.close"),
              onClick: () => setPublishLibSuccess(null),
              "data-testid": "publish-library-success-close",
              className: "publish-library-success-close"
            }
          )
        ]
      }
    );
  }, [setPublishLibSuccess, publishLibSuccess]);
  const onPublishLibSuccess = (data, libraryItems) => {
    setShowPublishLibraryDialog(false);
    setPublishLibSuccess({ url: data.url, authorName: data.authorName });
    const nextLibItems = libraryItems.slice();
    nextLibItems.forEach((libItem) => {
      if (selectedItems.includes(libItem.id)) {
        libItem.status = "published";
      }
    });
    library.setLibrary(nextLibItems);
  };
  const onLibraryImport = async () => {
    try {
      await library.updateLibrary({
        libraryItems: fileOpen({
          description: "Excalidraw library files"
          // ToDo: Be over-permissive until https://bugs.webkit.org/show_bug.cgi?id=34442
          // gets resolved. Else, iOS users cannot open `.excalidraw` files.
          /*
            extensions: [".json", ".excalidrawlib"],
            */
        }),
        merge: true,
        openLibraryMenu: true
      });
    } catch (error) {
      if (error?.name === "AbortError") {
        console.warn(error);
        return;
      }
      setAppState({ errorMessage: t("errors.importLibraryError") });
    }
  };
  const onLibraryExport = async () => {
    const libraryItems = itemsSelected ? items : await library.getLatestLibrary();
    saveLibraryAsJSON(libraryItems).catch(muteFSAbortError).catch((error) => {
      setAppState({ errorMessage: error.message });
    });
  };
  const renderLibraryMenu = () => {
    return /* @__PURE__ */ jsxs32(DropdownMenu_default, { open: isLibraryMenuOpen, children: [
      /* @__PURE__ */ jsx61(
        DropdownMenu_default.Trigger,
        {
          onToggle: () => setIsLibraryMenuOpen(!isLibraryMenuOpen),
          children: DotsIcon
        }
      ),
      /* @__PURE__ */ jsxs32(
        DropdownMenu_default.Content,
        {
          onClickOutside: () => setIsLibraryMenuOpen(false),
          onSelect: () => setIsLibraryMenuOpen(false),
          className: "library-menu",
          children: [
            !itemsSelected && /* @__PURE__ */ jsx61(
              DropdownMenu_default.Item,
              {
                onSelect: onLibraryImport,
                icon: LoadIcon,
                "data-testid": "lib-dropdown--load",
                children: t("buttons.load")
              }
            ),
            !!items.length && /* @__PURE__ */ jsx61(
              DropdownMenu_default.Item,
              {
                onSelect: onLibraryExport,
                icon: ExportIcon,
                "data-testid": "lib-dropdown--export",
                children: t("buttons.export")
              }
            ),
            !!items.length && /* @__PURE__ */ jsx61(
              DropdownMenu_default.Item,
              {
                onSelect: () => setShowRemoveLibAlert(true),
                icon: TrashIcon,
                children: resetLabel
              }
            ),
            itemsSelected && /* @__PURE__ */ jsx61(
              DropdownMenu_default.Item,
              {
                icon: publishIcon,
                onSelect: () => setShowPublishLibraryDialog(true),
                "data-testid": "lib-dropdown--remove",
                children: t("buttons.publishLibrary")
              }
            )
          ]
        }
      )
    ] });
  };
  return /* @__PURE__ */ jsxs32("div", { className: clsx27("library-menu-dropdown-container", className), children: [
    renderLibraryMenu(),
    selectedItems.length > 0 && /* @__PURE__ */ jsx61("div", { className: "library-actions-counter", children: selectedItems.length }),
    showRemoveLibAlert && renderRemoveLibAlert(),
    showPublishLibraryDialog && /* @__PURE__ */ jsx61(
      PublishLibrary_default,
      {
        onClose: () => setShowPublishLibraryDialog(false),
        libraryItems: getSelectedItems(
          libraryItemsData.libraryItems,
          selectedItems
        ),
        appState,
        onSuccess: (data) => onPublishLibSuccess(data, libraryItemsData.libraryItems),
        onError: (error) => window.alert(error),
        updateItemsInStorage: () => library.setLibrary(libraryItemsData.libraryItems),
        onRemove: (id) => onSelectItems(selectedItems.filter((_id) => _id !== id))
      }
    ),
    publishLibSuccess && renderPublishSuccess()
  ] });
};
var LibraryDropdownMenu = ({
  selectedItems,
  onSelectItems,
  className
}) => {
  const { library } = useApp();
  const { clearLibraryCache, deleteItemsFromLibraryCache } = useLibraryCache();
  const appState = useUIAppState();
  const setAppState = useExcalidrawSetAppState();
  const [libraryItemsData] = useAtom9(libraryItemsAtom, jotaiScope);
  const removeFromLibrary = async (libraryItems) => {
    const nextItems = libraryItems.filter(
      (item) => !selectedItems.includes(item.id)
    );
    library.setLibrary(nextItems).catch(() => {
      setAppState({ errorMessage: t("alerts.errorRemovingFromLibrary") });
    });
    deleteItemsFromLibraryCache(selectedItems);
    onSelectItems([]);
  };
  const resetLibrary = () => {
    library.resetLibrary();
    clearLibraryCache();
  };
  return /* @__PURE__ */ jsx61(
    LibraryDropdownMenuButton,
    {
      appState,
      setAppState,
      selectedItems,
      onSelectItems,
      library,
      onRemoveFromLibrary: () => removeFromLibrary(libraryItemsData.libraryItems),
      resetLibrary,
      className
    }
  );
};

// components/LibraryMenuSection.tsx
init_define_import_meta_env();
import { memo as memo2, useEffect as useEffect22, useState as useState17 } from "react";

// components/LibraryUnit.tsx
init_define_import_meta_env();
import clsx28 from "clsx";
import { memo, useEffect as useEffect21, useRef as useRef18, useState as useState16 } from "react";
init_icons();
import { jsx as jsx62, jsxs as jsxs33 } from "react/jsx-runtime";
var LibraryUnit = memo(
  ({
    id,
    elements,
    isPending,
    onClick,
    selected,
    onToggle,
    onDrag,
    svgCache
  }) => {
    const ref = useRef18(null);
    const svg = useLibraryItemSvg(id, elements, svgCache);
    useEffect21(() => {
      const node = ref.current;
      if (!node) {
        return;
      }
      if (svg) {
        node.innerHTML = svg.outerHTML;
      }
      return () => {
        node.innerHTML = "";
      };
    }, [svg]);
    const [isHovered, setIsHovered] = useState16(false);
    const isMobile = useDevice().editor.isMobile;
    const adder = isPending && /* @__PURE__ */ jsx62("div", { className: "library-unit__adder", children: PlusIcon });
    return /* @__PURE__ */ jsxs33(
      "div",
      {
        className: clsx28("library-unit", {
          "library-unit__active": elements,
          "library-unit--hover": elements && isHovered,
          "library-unit--selected": selected,
          "library-unit--skeleton": !svg
        }),
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => setIsHovered(false),
        children: [
          /* @__PURE__ */ jsx62(
            "div",
            {
              className: clsx28("library-unit__dragger", {
                "library-unit__pulse": !!isPending
              }),
              ref,
              draggable: !!elements,
              onClick: !!elements || !!isPending ? (event) => {
                if (id && event.shiftKey) {
                  onToggle(id, event);
                } else {
                  onClick(id);
                }
              } : void 0,
              onDragStart: (event) => {
                if (!id) {
                  event.preventDefault();
                  return;
                }
                setIsHovered(false);
                onDrag(id, event);
              }
            }
          ),
          adder,
          id && elements && (isHovered || isMobile || selected) && /* @__PURE__ */ jsx62(
            CheckboxItem,
            {
              checked: selected,
              onChange: (checked, event) => onToggle(id, event),
              className: "library-unit__checkbox"
            }
          )
        ]
      }
    );
  }
);
var EmptyLibraryUnit = () => /* @__PURE__ */ jsx62("div", { className: "library-unit library-unit--skeleton" });

// hooks/useTransition.ts
init_define_import_meta_env();
import React23, { useCallback as useCallback8 } from "react";
function useTransitionPolyfill() {
  const startTransition = useCallback8((callback) => callback(), []);
  return [false, startTransition];
}
var useTransition = React23.useTransition || useTransitionPolyfill;

// components/LibraryMenuSection.tsx
import { Fragment as Fragment8, jsx as jsx63 } from "react/jsx-runtime";
var LibraryMenuSectionGrid = ({
  children
}) => {
  return /* @__PURE__ */ jsx63("div", { className: "library-menu-items-container__grid", children });
};
var LibraryMenuSection = memo2(
  ({
    items,
    onItemSelectToggle,
    onItemDrag,
    isItemSelected,
    onClick,
    svgCache,
    itemsRenderedPerBatch
  }) => {
    const [, startTransition] = useTransition();
    const [index, setIndex] = useState17(0);
    useEffect22(() => {
      if (index < items.length) {
        startTransition(() => {
          setIndex(index + itemsRenderedPerBatch);
        });
      }
    }, [index, items.length, startTransition, itemsRenderedPerBatch]);
    return /* @__PURE__ */ jsx63(Fragment8, { children: items.map((item, i) => {
      return i < index ? /* @__PURE__ */ jsx63(
        LibraryUnit,
        {
          elements: item?.elements,
          isPending: !item?.id && !!item?.elements,
          onClick,
          svgCache,
          id: item?.id,
          selected: isItemSelected(item.id),
          onToggle: onItemSelectToggle,
          onDrag: onItemDrag
        },
        item?.id ?? i
      ) : /* @__PURE__ */ jsx63(EmptyLibraryUnit, {}, i);
    }) });
  }
);

// hooks/useScrollPosition.ts
init_define_import_meta_env();
import { useEffect as useEffect23 } from "react";
import { atom as atom6, useAtom as useAtom10 } from "jotai";
import throttle2 from "lodash.throttle";
var scrollPositionAtom = atom6(0);
var useScrollPosition = (elementRef) => {
  const [scrollPosition, setScrollPosition] = useAtom10(scrollPositionAtom);
  useEffect23(() => {
    const { current: element } = elementRef;
    if (!element) {
      return;
    }
    const handleScroll = throttle2(() => {
      const { scrollTop } = element;
      setScrollPosition(scrollTop);
    }, 200);
    element.addEventListener("scroll", handleScroll);
    return () => {
      handleScroll.cancel();
      element.removeEventListener("scroll", handleScroll);
    };
  }, [elementRef, setScrollPosition]);
  return scrollPosition;
};

// components/LibraryMenuItems.tsx
import { Fragment as Fragment9, jsx as jsx64, jsxs as jsxs34 } from "react/jsx-runtime";
var ITEMS_RENDERED_PER_BATCH = 17;
var CACHED_ITEMS_RENDERED_PER_BATCH = 64;
function LibraryMenuItems({
  isLoading,
  libraryItems,
  onAddToLibrary,
  onInsertLibraryItems,
  pendingElements,
  theme,
  id,
  libraryReturnUrl,
  onSelectItems,
  selectedItems
}) {
  const libraryContainerRef = useRef19(null);
  const scrollPosition = useScrollPosition(libraryContainerRef);
  useEffect24(() => {
    if (scrollPosition > 0) {
      libraryContainerRef.current?.scrollTo(0, scrollPosition);
    }
  }, []);
  const { svgCache } = useLibraryCache();
  const unpublishedItems = useMemo5(
    () => libraryItems.filter((item) => item.status !== "published"),
    [libraryItems]
  );
  const publishedItems = useMemo5(
    () => libraryItems.filter((item) => item.status === "published"),
    [libraryItems]
  );
  const showBtn = !libraryItems.length && !pendingElements.length;
  const isLibraryEmpty = !pendingElements.length && !unpublishedItems.length && !publishedItems.length;
  const [lastSelectedItem, setLastSelectedItem] = useState18(null);
  const onItemSelectToggle = useCallback9(
    (id2, event) => {
      const shouldSelect = !selectedItems.includes(id2);
      const orderedItems = [...unpublishedItems, ...publishedItems];
      if (shouldSelect) {
        if (event.shiftKey && lastSelectedItem) {
          const rangeStart = orderedItems.findIndex(
            (item) => item.id === lastSelectedItem
          );
          const rangeEnd = orderedItems.findIndex((item) => item.id === id2);
          if (rangeStart === -1 || rangeEnd === -1) {
            onSelectItems([...selectedItems, id2]);
            return;
          }
          const selectedItemsMap = arrayToMap(selectedItems);
          const nextSelectedIds = orderedItems.reduce(
            (acc, item, idx) => {
              if (idx >= rangeStart && idx <= rangeEnd || selectedItemsMap.has(item.id)) {
                acc.push(item.id);
              }
              return acc;
            },
            []
          );
          onSelectItems(nextSelectedIds);
        } else {
          onSelectItems([...selectedItems, id2]);
        }
        setLastSelectedItem(id2);
      } else {
        setLastSelectedItem(null);
        onSelectItems(selectedItems.filter((_id) => _id !== id2));
      }
    },
    [
      lastSelectedItem,
      onSelectItems,
      publishedItems,
      selectedItems,
      unpublishedItems
    ]
  );
  const getInsertedElements = useCallback9(
    (id2) => {
      let targetElements;
      if (selectedItems.includes(id2)) {
        targetElements = libraryItems.filter(
          (item) => selectedItems.includes(item.id)
        );
      } else {
        targetElements = libraryItems.filter((item) => item.id === id2);
      }
      return targetElements.map((item) => {
        return {
          ...item,
          // duplicate each library item before inserting on canvas to confine
          // ids and bindings to each library item. See #6465
          elements: duplicateElements(item.elements, { randomizeSeed: true })
        };
      });
    },
    [libraryItems, selectedItems]
  );
  const onItemDrag = useCallback9(
    (id2, event) => {
      event.dataTransfer.setData(
        MIME_TYPES.excalidrawlib,
        serializeLibraryAsJSON(getInsertedElements(id2))
      );
    },
    [getInsertedElements]
  );
  const isItemSelected = useCallback9(
    (id2) => {
      if (!id2) {
        return false;
      }
      return selectedItems.includes(id2);
    },
    [selectedItems]
  );
  const onAddToLibraryClick = useCallback9(() => {
    onAddToLibrary(pendingElements);
  }, [pendingElements, onAddToLibrary]);
  const onItemClick = useCallback9(
    (id2) => {
      if (id2) {
        onInsertLibraryItems(getInsertedElements(id2));
      }
    },
    [getInsertedElements, onInsertLibraryItems]
  );
  const itemsRenderedPerBatch = svgCache.size >= libraryItems.length ? CACHED_ITEMS_RENDERED_PER_BATCH : ITEMS_RENDERED_PER_BATCH;
  return /* @__PURE__ */ jsxs34(
    "div",
    {
      className: "library-menu-items-container",
      style: pendingElements.length || unpublishedItems.length || publishedItems.length ? { justifyContent: "flex-start" } : { borderBottom: 0 },
      children: [
        !isLibraryEmpty && /* @__PURE__ */ jsx64(
          LibraryDropdownMenu,
          {
            selectedItems,
            onSelectItems,
            className: "library-menu-dropdown-container--in-heading"
          }
        ),
        /* @__PURE__ */ jsxs34(
          Stack_default.Col,
          {
            className: "library-menu-items-container__items",
            align: "start",
            gap: 1,
            style: {
              flex: publishedItems.length > 0 ? 1 : "0 1 auto",
              marginBottom: 0
            },
            ref: libraryContainerRef,
            children: [
              /* @__PURE__ */ jsxs34(Fragment9, { children: [
                !isLibraryEmpty && /* @__PURE__ */ jsx64("div", { className: "library-menu-items-container__header", children: t("labels.personalLib") }),
                isLoading && /* @__PURE__ */ jsx64(
                  "div",
                  {
                    style: {
                      position: "absolute",
                      top: "var(--container-padding-y)",
                      right: "var(--container-padding-x)",
                      transform: "translateY(50%)"
                    },
                    children: /* @__PURE__ */ jsx64(Spinner_default, {})
                  }
                ),
                !pendingElements.length && !unpublishedItems.length ? /* @__PURE__ */ jsxs34("div", { className: "library-menu-items__no-items", children: [
                  /* @__PURE__ */ jsx64("div", { className: "library-menu-items__no-items__label", children: t("library.noItems") }),
                  /* @__PURE__ */ jsx64("div", { className: "library-menu-items__no-items__hint", children: publishedItems.length > 0 ? t("library.hint_emptyPrivateLibrary") : t("library.hint_emptyLibrary") })
                ] }) : /* @__PURE__ */ jsxs34(LibraryMenuSectionGrid, { children: [
                  pendingElements.length > 0 && /* @__PURE__ */ jsx64(
                    LibraryMenuSection,
                    {
                      itemsRenderedPerBatch,
                      items: [{ id: null, elements: pendingElements }],
                      onItemSelectToggle,
                      onItemDrag,
                      onClick: onAddToLibraryClick,
                      isItemSelected,
                      svgCache
                    }
                  ),
                  /* @__PURE__ */ jsx64(
                    LibraryMenuSection,
                    {
                      itemsRenderedPerBatch,
                      items: unpublishedItems,
                      onItemSelectToggle,
                      onItemDrag,
                      onClick: onItemClick,
                      isItemSelected,
                      svgCache
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxs34(Fragment9, { children: [
                (publishedItems.length > 0 || pendingElements.length > 0 || unpublishedItems.length > 0) && /* @__PURE__ */ jsx64("div", { className: "library-menu-items-container__header library-menu-items-container__header--excal", children: t("labels.excalidrawLib") }),
                publishedItems.length > 0 ? /* @__PURE__ */ jsx64(LibraryMenuSectionGrid, { children: /* @__PURE__ */ jsx64(
                  LibraryMenuSection,
                  {
                    itemsRenderedPerBatch,
                    items: publishedItems,
                    onItemSelectToggle,
                    onItemDrag,
                    onClick: onItemClick,
                    isItemSelected,
                    svgCache
                  }
                ) }) : unpublishedItems.length > 0 ? /* @__PURE__ */ jsx64(
                  "div",
                  {
                    style: {
                      margin: "1rem 0",
                      display: "flex",
                      flexDirection: "column",
                      alignItems: "center",
                      justifyContent: "center",
                      width: "100%",
                      fontSize: ".9rem"
                    },
                    children: t("library.noItems")
                  }
                ) : null
              ] }),
              showBtn && /* @__PURE__ */ jsx64(
                LibraryMenuControlButtons,
                {
                  style: { padding: "16px 0", width: "100%" },
                  id,
                  libraryReturnUrl,
                  theme,
                  children: /* @__PURE__ */ jsx64(
                    LibraryDropdownMenu,
                    {
                      selectedItems,
                      onSelectItems
                    }
                  )
                }
              )
            ]
          }
        )
      ]
    }
  );
}

// components/LibraryMenu.tsx
import { atom as atom7, useAtom as useAtom11 } from "jotai";
init_scene();
init_utils2();
init_constants();
import { jsx as jsx65, jsxs as jsxs35 } from "react/jsx-runtime";
var isLibraryMenuOpenAtom = atom7(false);
var LibraryMenuWrapper = ({ children }) => {
  return /* @__PURE__ */ jsx65("div", { className: "layer-ui__library", children });
};
var LibraryMenuContent = ({
  onInsertLibraryItems,
  pendingElements,
  onAddToLibrary,
  setAppState,
  libraryReturnUrl,
  library,
  id,
  theme,
  selectedItems,
  onSelectItems
}) => {
  const [libraryItemsData] = useAtom11(libraryItemsAtom, jotaiScope);
  const _onAddToLibrary = useCallback10(
    (elements) => {
      const addToLibrary = async (processedElements, libraryItems2) => {
        trackEvent("element", "addToLibrary", "ui");
        for (const type of LIBRARY_DISABLED_TYPES) {
          if (processedElements.some((element) => element.type === type)) {
            return setAppState({
              errorMessage: t(`errors.libraryElementTypeError.${type}`)
            });
          }
        }
        const nextItems = [
          {
            status: "unpublished",
            elements: processedElements,
            id: randomId(),
            created: Date.now()
          },
          ...libraryItems2
        ];
        onAddToLibrary();
        library.setLibrary(nextItems).catch(() => {
          setAppState({ errorMessage: t("alerts.errorAddingToLibrary") });
        });
      };
      addToLibrary(elements, libraryItemsData.libraryItems);
    },
    [onAddToLibrary, library, setAppState, libraryItemsData.libraryItems]
  );
  const libraryItems = useMemo6(
    () => libraryItemsData.libraryItems,
    [libraryItemsData]
  );
  if (libraryItemsData.status === "loading" && !libraryItemsData.isInitialized) {
    return /* @__PURE__ */ jsx65(LibraryMenuWrapper, { children: /* @__PURE__ */ jsx65("div", { className: "layer-ui__library-message", children: /* @__PURE__ */ jsxs35("div", { children: [
      /* @__PURE__ */ jsx65(Spinner_default, { size: "2em" }),
      /* @__PURE__ */ jsx65("span", { children: t("labels.libraryLoadingMessage") })
    ] }) }) });
  }
  const showBtn = libraryItemsData.libraryItems.length > 0 || pendingElements.length > 0;
  return /* @__PURE__ */ jsxs35(LibraryMenuWrapper, { children: [
    /* @__PURE__ */ jsx65(
      LibraryMenuItems,
      {
        isLoading: libraryItemsData.status === "loading",
        libraryItems,
        onAddToLibrary: _onAddToLibrary,
        onInsertLibraryItems,
        pendingElements,
        id,
        libraryReturnUrl,
        theme,
        onSelectItems,
        selectedItems
      }
    ),
    showBtn && /* @__PURE__ */ jsx65(
      LibraryMenuControlButtons,
      {
        className: "library-menu-control-buttons--at-bottom",
        style: { padding: "16px 12px 0 12px" },
        id,
        libraryReturnUrl,
        theme
      }
    )
  ] });
};
var usePendingElementsMemo = (appState, elements) => {
  const create = () => getSelectedElements(elements, appState, {
    includeBoundTextElement: true,
    includeElementsInFrames: true
  });
  const val = useRef20(create());
  const prevAppState = useRef20(appState);
  const prevElements = useRef20(elements);
  if (!isShallowEqual(
    appState.selectedElementIds,
    prevAppState.current.selectedElementIds
  ) || !isShallowEqual(elements, prevElements.current)) {
    val.current = create();
    prevAppState.current = appState;
    prevElements.current = elements;
  }
  return val.current;
};
var LibraryMenu = () => {
  const { library, id, onInsertElements } = useApp();
  const appProps = useAppProps();
  const appState = useUIAppState();
  const setAppState = useExcalidrawSetAppState();
  const elements = useExcalidrawElements();
  const [selectedItems, setSelectedItems] = useState19([]);
  const memoizedLibrary = useMemo6(() => library, [library]);
  const pendingElements = usePendingElementsMemo(appState, elements);
  const onInsertLibraryItems = useCallback10(
    (libraryItems) => {
      onInsertElements(distributeLibraryItemsOnSquareGrid(libraryItems));
    },
    [onInsertElements]
  );
  const deselectItems = useCallback10(() => {
    setAppState({
      selectedElementIds: {},
      selectedGroupIds: {},
      activeEmbeddable: null
    });
  }, [setAppState]);
  return /* @__PURE__ */ jsx65(
    LibraryMenuContent,
    {
      pendingElements,
      onInsertLibraryItems,
      onAddToLibrary: deselectItems,
      setAppState,
      libraryReturnUrl: appProps.libraryReturnUrl,
      library: memoizedLibrary,
      id,
      theme: appState.theme,
      selectedItems,
      onSelectItems: setSelectedItems
    }
  );
};

// components/Dialog.tsx
init_icons();
import { jsx as jsx66, jsxs as jsxs36 } from "react/jsx-runtime";
function getDialogSize(size) {
  if (size && typeof size === "number") {
    return size;
  }
  switch (size) {
    case "small":
      return 550;
    case "wide":
      return 1024;
    case "regular":
    default:
      return 800;
  }
}
var Dialog = (props) => {
  const [islandNode, setIslandNode] = useCallbackRefState();
  const [lastActiveElement] = useState20(document.activeElement);
  const { id } = useExcalidrawContainer();
  const isFullscreen = useDevice().viewport.isMobile;
  useEffect25(() => {
    if (!islandNode) {
      return;
    }
    const focusableElements = queryFocusableElements(islandNode);
    setTimeout(() => {
      if (focusableElements.length > 0 && props.autofocus !== false) {
        (focusableElements[1] || focusableElements[0]).focus();
      }
    });
    const handleKeyDown = (event) => {
      if (event.key === KEYS.TAB) {
        const focusableElements2 = queryFocusableElements(islandNode);
        const { activeElement } = document;
        const currentIndex = focusableElements2.findIndex(
          (element) => element === activeElement
        );
        if (currentIndex === 0 && event.shiftKey) {
          focusableElements2[focusableElements2.length - 1].focus();
          event.preventDefault();
        } else if (currentIndex === focusableElements2.length - 1 && !event.shiftKey) {
          focusableElements2[0].focus();
          event.preventDefault();
        }
      }
    };
    islandNode.addEventListener("keydown", handleKeyDown);
    return () => islandNode.removeEventListener("keydown", handleKeyDown);
  }, [islandNode, props.autofocus]);
  const setAppState = useExcalidrawSetAppState();
  const setIsLibraryMenuOpen = useSetAtom2(isLibraryMenuOpenAtom, jotaiScope);
  const onClose = () => {
    setAppState({ openMenu: null });
    setIsLibraryMenuOpen(false);
    lastActiveElement.focus();
    props.onCloseRequest();
  };
  return /* @__PURE__ */ jsx66(
    Modal,
    {
      className: clsx29("Dialog", props.className, {
        "Dialog--fullscreen": isFullscreen
      }),
      labelledBy: "dialog-title",
      maxWidth: getDialogSize(props.size),
      onCloseRequest: onClose,
      closeOnClickOutside: props.closeOnClickOutside,
      children: /* @__PURE__ */ jsxs36(Island, { ref: setIslandNode, children: [
        props.title && /* @__PURE__ */ jsx66("h2", { id: `${id}-dialog-title`, className: "Dialog__title", children: /* @__PURE__ */ jsx66("span", { className: "Dialog__titleContent", children: props.title }) }),
        isFullscreen && /* @__PURE__ */ jsx66(
          "button",
          {
            className: "Dialog__close",
            onClick: onClose,
            title: t("buttons.close"),
            "aria-label": t("buttons.close"),
            type: "button",
            children: CloseIcon
          }
        ),
        /* @__PURE__ */ jsx66("div", { className: "Dialog__content", children: props.children })
      ] })
    }
  );
};

// components/TextField.tsx
init_define_import_meta_env();
import {
  forwardRef as forwardRef3,
  useRef as useRef21,
  useImperativeHandle,
  useLayoutEffect as useLayoutEffect5,
  useState as useState21
} from "react";
import clsx31 from "clsx";

// components/Button.tsx
init_define_import_meta_env();
init_utils2();
import clsx30 from "clsx";
import { jsx as jsx67 } from "react/jsx-runtime";
var Button = ({
  type = "button",
  onSelect,
  selected,
  children,
  className = "",
  ...rest
}) => {
  return /* @__PURE__ */ jsx67(
    "button",
    {
      onClick: composeEventHandlers(rest.onClick, (event) => {
        onSelect();
      }),
      type,
      className: clsx30("excalidraw-button", className, { selected }),
      ...rest,
      children
    }
  );
};

// components/TextField.tsx
init_icons();
import { jsx as jsx68, jsxs as jsxs37 } from "react/jsx-runtime";
var TextField = forwardRef3(
  ({
    onChange,
    label,
    fullWidth,
    placeholder,
    readonly,
    selectOnRender,
    onKeyDown,
    isRedacted = false,
    icon,
    className,
    ...rest
  }, ref) => {
    const innerRef = useRef21(null);
    useImperativeHandle(ref, () => innerRef.current);
    useLayoutEffect5(() => {
      if (selectOnRender) {
        innerRef.current?.focus();
        innerRef.current?.select();
      }
    }, [selectOnRender]);
    const [isTemporarilyUnredacted, setIsTemporarilyUnredacted] = useState21(false);
    return /* @__PURE__ */ jsxs37(
      "div",
      {
        className: clsx31("ExcTextField", className, {
          "ExcTextField--fullWidth": fullWidth,
          "ExcTextField--hasIcon": !!icon
        }),
        onClick: () => {
          innerRef.current?.focus();
        },
        children: [
          icon,
          label && /* @__PURE__ */ jsx68("div", { className: "ExcTextField__label", children: label }),
          /* @__PURE__ */ jsxs37(
            "div",
            {
              className: clsx31("ExcTextField__input", {
                "ExcTextField__input--readonly": readonly
              }),
              children: [
                /* @__PURE__ */ jsx68(
                  "input",
                  {
                    className: clsx31({
                      "is-redacted": "value" in rest && rest.value && isRedacted && !isTemporarilyUnredacted
                    }),
                    readOnly: readonly,
                    value: "value" in rest ? rest.value : void 0,
                    defaultValue: "defaultValue" in rest ? rest.defaultValue : void 0,
                    placeholder,
                    ref: innerRef,
                    onChange: (event) => onChange?.(event.target.value),
                    onKeyDown
                  }
                ),
                isRedacted && /* @__PURE__ */ jsx68(
                  Button,
                  {
                    onSelect: () => setIsTemporarilyUnredacted(!isTemporarilyUnredacted),
                    style: { border: 0, userSelect: "none" },
                    children: isTemporarilyUnredacted ? eyeClosedIcon : eyeIcon
                  }
                )
              ]
            }
          )
        ]
      }
    );
  }
);

// components/CommandPalette/CommandPalette.tsx
init_scene();
import clsx33 from "clsx";

// actions/shortcuts.ts
init_define_import_meta_env();
init_constants();
init_utils2();
var shortcutMap = {
  toggleTheme: [getShortcutKey("Shift+Alt+D")],
  saveScene: [getShortcutKey("CtrlOrCmd+S")],
  loadScene: [getShortcutKey("CtrlOrCmd+O")],
  clearCanvas: [getShortcutKey("CtrlOrCmd+Delete")],
  imageExport: [getShortcutKey("CtrlOrCmd+Shift+E")],
  commandPalette: [
    getShortcutKey("CtrlOrCmd+/"),
    getShortcutKey("CtrlOrCmd+Shift+P")
  ],
  cut: [getShortcutKey("CtrlOrCmd+X")],
  copy: [getShortcutKey("CtrlOrCmd+C")],
  paste: [getShortcutKey("CtrlOrCmd+V")],
  copyStyles: [getShortcutKey("CtrlOrCmd+Alt+C")],
  pasteStyles: [getShortcutKey("CtrlOrCmd+Alt+V")],
  selectAll: [getShortcutKey("CtrlOrCmd+A")],
  deleteSelectedElements: [getShortcutKey("Delete")],
  duplicateSelection: [
    getShortcutKey("CtrlOrCmd+D"),
    getShortcutKey(`Alt+${t("helpDialog.drag")}`)
  ],
  sendBackward: [getShortcutKey("CtrlOrCmd+[")],
  bringForward: [getShortcutKey("CtrlOrCmd+]")],
  sendToBack: [
    isDarwin ? getShortcutKey("CtrlOrCmd+Alt+[") : getShortcutKey("CtrlOrCmd+Shift+[")
  ],
  bringToFront: [
    isDarwin ? getShortcutKey("CtrlOrCmd+Alt+]") : getShortcutKey("CtrlOrCmd+Shift+]")
  ],
  copyAsPng: [getShortcutKey("Shift+Alt+C")],
  copyAsSvg: [],
  group: [getShortcutKey("CtrlOrCmd+G")],
  ungroup: [getShortcutKey("CtrlOrCmd+Shift+G")],
  gridMode: [getShortcutKey("CtrlOrCmd+'")],
  zenMode: [getShortcutKey("Alt+Z")],
  objectsSnapMode: [getShortcutKey("Alt+S")],
  stats: [getShortcutKey("Alt+/")],
  addToLibrary: [],
  flipHorizontal: [getShortcutKey("Shift+H")],
  flipVertical: [getShortcutKey("Shift+V")],
  viewMode: [getShortcutKey("Alt+R")],
  hyperlink: [getShortcutKey("CtrlOrCmd+K")],
  toggleElementLock: [getShortcutKey("CtrlOrCmd+Shift+L")],
  resetZoom: [getShortcutKey("CtrlOrCmd+0")],
  zoomOut: [getShortcutKey("CtrlOrCmd+-")],
  zoomIn: [getShortcutKey("CtrlOrCmd++")],
  zoomToFitSelection: [getShortcutKey("Shift+3")],
  zoomToFit: [getShortcutKey("Shift+1")],
  zoomToFitSelectionInViewport: [getShortcutKey("Shift+2")],
  toggleEraserTool: [getShortcutKey("E")],
  toggleHandTool: [getShortcutKey("H")],
  setFrameAsActiveTool: [getShortcutKey("F")],
  saveFileToDisk: [getShortcutKey("CtrlOrCmd+S")],
  saveToActiveFile: [getShortcutKey("CtrlOrCmd+S")],
  toggleShortcuts: [getShortcutKey("?")],
  searchMenu: [getShortcutKey("CtrlOrCmd+F")]
};
var getShortcutFromShortcutName = (name, idx = 0) => {
  const shortcuts = shortcutMap[name];
  return shortcuts && shortcuts.length > 0 ? shortcuts[idx] || shortcuts[0] : "";
};

// components/CommandPalette/CommandPalette.tsx
init_constants();
init_icons();
import fuzzy from "fuzzy";
init_utils2();
import { atom as atom9, useAtom as useAtom13 } from "jotai";

// deburr.ts
init_define_import_meta_env();
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsCombo = `[${rsComboRange}]`;
var reComboMark = RegExp(rsCombo, "g");
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var deburredLetters = {
  "\xC0": "A",
  "\xC1": "A",
  "\xC2": "A",
  "\xC3": "A",
  "\xC4": "A",
  "\xC5": "A",
  "\xE0": "a",
  "\xE1": "a",
  "\xE2": "a",
  "\xE3": "a",
  "\xE4": "a",
  "\xE5": "a",
  "\xC7": "C",
  "\xE7": "c",
  "\xD0": "D",
  "\xF0": "d",
  "\xC8": "E",
  "\xC9": "E",
  "\xCA": "E",
  "\xCB": "E",
  "\xE8": "e",
  "\xE9": "e",
  "\xEA": "e",
  "\xEB": "e",
  "\xCC": "I",
  "\xCD": "I",
  "\xCE": "I",
  "\xCF": "I",
  "\xEC": "i",
  "\xED": "i",
  "\xEE": "i",
  "\xEF": "i",
  "\xD1": "N",
  "\xF1": "n",
  "\xD2": "O",
  "\xD3": "O",
  "\xD4": "O",
  "\xD5": "O",
  "\xD6": "O",
  "\xD8": "O",
  "\xF2": "o",
  "\xF3": "o",
  "\xF4": "o",
  "\xF5": "o",
  "\xF6": "o",
  "\xF8": "o",
  "\xD9": "U",
  "\xDA": "U",
  "\xDB": "U",
  "\xDC": "U",
  "\xF9": "u",
  "\xFA": "u",
  "\xFB": "u",
  "\xFC": "u",
  "\xDD": "Y",
  "\xFD": "y",
  "\xFF": "y",
  // normaly Ae/ae
  "\xC6": "E",
  "\xE6": "e",
  // normally Th/th
  "\xDE": "T",
  "\xFE": "t",
  // normally ss
  "\xDF": "s",
  "\u0100": "A",
  "\u0102": "A",
  "\u0104": "A",
  "\u0101": "a",
  "\u0103": "a",
  "\u0105": "a",
  "\u0106": "C",
  "\u0108": "C",
  "\u010A": "C",
  "\u010C": "C",
  "\u0107": "c",
  "\u0109": "c",
  "\u010B": "c",
  "\u010D": "c",
  "\u010E": "D",
  "\u0110": "D",
  "\u010F": "d",
  "\u0111": "d",
  "\u0112": "E",
  "\u0114": "E",
  "\u0116": "E",
  "\u0118": "E",
  "\u011A": "E",
  "\u0113": "e",
  "\u0115": "e",
  "\u0117": "e",
  "\u0119": "e",
  "\u011B": "e",
  "\u011C": "G",
  "\u011E": "G",
  "\u0120": "G",
  "\u0122": "G",
  "\u011D": "g",
  "\u011F": "g",
  "\u0121": "g",
  "\u0123": "g",
  "\u0124": "H",
  "\u0126": "H",
  "\u0125": "h",
  "\u0127": "h",
  "\u0128": "I",
  "\u012A": "I",
  "\u012C": "I",
  "\u012E": "I",
  "\u0130": "I",
  "\u0129": "i",
  "\u012B": "i",
  "\u012D": "i",
  "\u012F": "i",
  "\u0131": "i",
  "\u0134": "J",
  "\u0135": "j",
  "\u0136": "K",
  "\u0137": "k",
  "\u0138": "k",
  "\u0139": "L",
  "\u013B": "L",
  "\u013D": "L",
  "\u013F": "L",
  "\u0141": "L",
  "\u013A": "l",
  "\u013C": "l",
  "\u013E": "l",
  "\u0140": "l",
  "\u0142": "l",
  "\u0143": "N",
  "\u0145": "N",
  "\u0147": "N",
  "\u014A": "N",
  "\u0144": "n",
  "\u0146": "n",
  "\u0148": "n",
  "\u014B": "n",
  "\u014C": "O",
  "\u014E": "O",
  "\u0150": "O",
  "\u014D": "o",
  "\u014F": "o",
  "\u0151": "o",
  "\u0154": "R",
  "\u0156": "R",
  "\u0158": "R",
  "\u0155": "r",
  "\u0157": "r",
  "\u0159": "r",
  "\u015A": "S",
  "\u015C": "S",
  "\u015E": "S",
  "\u0160": "S",
  "\u015B": "s",
  "\u015D": "s",
  "\u015F": "s",
  "\u0161": "s",
  "\u0162": "T",
  "\u0164": "T",
  "\u0166": "T",
  "\u0163": "t",
  "\u0165": "t",
  "\u0167": "t",
  "\u0168": "U",
  "\u016A": "U",
  "\u016C": "U",
  "\u016E": "U",
  "\u0170": "U",
  "\u0172": "U",
  "\u0169": "u",
  "\u016B": "u",
  "\u016D": "u",
  "\u016F": "u",
  "\u0171": "u",
  "\u0173": "u",
  "\u0174": "W",
  "\u0175": "w",
  "\u0176": "Y",
  "\u0177": "y",
  "\u0178": "Y",
  "\u0179": "Z",
  "\u017B": "Z",
  "\u017D": "Z",
  "\u017A": "z",
  "\u017C": "z",
  "\u017E": "z",
  // normally IJ/ij
  "\u0132": "I",
  "\u0133": "i",
  // normally OE/oe
  "\u0152": "E",
  "\u0153": "e",
  // normally "'n"
  "\u0149": "n",
  "\u017F": "s"
};
var deburr = (str) => {
  return str.replace(reLatin, (key) => {
    return deburredLetters[key] || key;
  }).replace(reComboMark, "");
};

// components/InlineIcon.tsx
init_define_import_meta_env();
import { jsx as jsx69 } from "react/jsx-runtime";
var InlineIcon = ({ icon }) => {
  return /* @__PURE__ */ jsx69(
    "span",
    {
      style: {
        width: "1em",
        margin: "0 0.5ex 0 0.5ex",
        display: "inline-block",
        lineHeight: 0,
        verticalAlign: "middle"
      },
      children: icon
    }
  );
};

// components/CommandPalette/CommandPalette.tsx
init_shapes();

// components/Actions.tsx
init_define_import_meta_env();
import { useState as useState22 } from "react";
init_scene();
init_shapes();
init_utils2();
init_comparisons();
init_typeChecks();
import clsx32 from "clsx";
init_textElement();
init_icons();
init_keys();

// context/tunnels.ts
init_define_import_meta_env();
import React28 from "react";
import tunnel from "tunnel-rat";
var TunnelsContext = React28.createContext(null);
var useTunnels = () => React28.useContext(TunnelsContext);
var useInitializeTunnels = () => {
  return React28.useMemo(() => {
    return {
      MainMenuTunnel: tunnel(),
      WelcomeScreenMenuHintTunnel: tunnel(),
      WelcomeScreenToolbarHintTunnel: tunnel(),
      WelcomeScreenHelpHintTunnel: tunnel(),
      WelcomeScreenCenterTunnel: tunnel(),
      FooterCenterTunnel: tunnel(),
      DefaultSidebarTriggerTunnel: tunnel(),
      DefaultSidebarTabTriggersTunnel: tunnel(),
      OverwriteConfirmDialogTunnel: tunnel(),
      TTDDialogTriggerTunnel: tunnel(),
      jotaiScope: Symbol()
    };
  }, []);
};

// components/Actions.tsx
init_constants();
import { Fragment as Fragment10, jsx as jsx70, jsxs as jsxs38 } from "react/jsx-runtime";
var canChangeStrokeColor = (appState, targetElements) => {
  let commonSelectedType = targetElements[0]?.type || null;
  for (const element of targetElements) {
    if (element.type !== commonSelectedType) {
      commonSelectedType = null;
      break;
    }
  }
  return hasStrokeColor(appState.activeTool.type) && appState.activeTool.type !== "image" && commonSelectedType !== "image" && commonSelectedType !== "frame" && commonSelectedType !== "magicframe" || targetElements.some((element) => hasStrokeColor(element.type));
};
var canChangeBackgroundColor = (appState, targetElements) => {
  return hasBackground(appState.activeTool.type) || targetElements.some((element) => hasBackground(element.type));
};
var SelectedShapeActions = ({
  appState,
  elementsMap,
  renderAction
}) => {
  const targetElements = getTargetElements(elementsMap, appState);
  let isSingleElementBoundContainer = false;
  if (targetElements.length === 2 && (hasBoundTextElement(targetElements[0]) || hasBoundTextElement(targetElements[1]))) {
    isSingleElementBoundContainer = true;
  }
  const isEditingTextOrNewElement = Boolean(
    appState.editingTextElement || appState.newElement
  );
  const device = useDevice();
  const isRTL2 = document.documentElement.getAttribute("dir") === "rtl";
  const showFillIcons = hasBackground(appState.activeTool.type) && !isTransparent(appState.currentItemBackgroundColor) || targetElements.some(
    (element) => hasBackground(element.type) && !isTransparent(element.backgroundColor)
  );
  const showLinkIcon = targetElements.length === 1 || isSingleElementBoundContainer;
  const showLineEditorAction = !appState.editingLinearElement && targetElements.length === 1 && isLinearElement(targetElements[0]) && !isElbowArrow(targetElements[0]);
  return /* @__PURE__ */ jsxs38("div", { className: "panelColumn", children: [
    /* @__PURE__ */ jsx70("div", { children: canChangeStrokeColor(appState, targetElements) && renderAction("changeStrokeColor") }),
    canChangeBackgroundColor(appState, targetElements) && /* @__PURE__ */ jsx70("div", { children: renderAction("changeBackgroundColor") }),
    showFillIcons && renderAction("changeFillStyle"),
    (hasStrokeWidth(appState.activeTool.type) || targetElements.some((element) => hasStrokeWidth(element.type))) && renderAction("changeStrokeWidth"),
    (appState.activeTool.type === "freedraw" || targetElements.some((element) => element.type === "freedraw")) && renderAction("changeStrokeShape"),
    (hasStrokeStyle(appState.activeTool.type) || targetElements.some((element) => hasStrokeStyle(element.type))) && /* @__PURE__ */ jsxs38(Fragment10, { children: [
      renderAction("changeStrokeStyle"),
      renderAction("changeSloppiness")
    ] }),
    (canChangeRoundness(appState.activeTool.type) || targetElements.some((element) => canChangeRoundness(element.type))) && /* @__PURE__ */ jsx70(Fragment10, { children: renderAction("changeRoundness") }),
    (toolIsArrow(appState.activeTool.type) || targetElements.some((element) => toolIsArrow(element.type))) && /* @__PURE__ */ jsx70(Fragment10, { children: renderAction("changeArrowType") }),
    (appState.activeTool.type === "text" || targetElements.some(isTextElement)) && /* @__PURE__ */ jsxs38(Fragment10, { children: [
      renderAction("changeFontFamily"),
      renderAction("changeFontSize"),
      (appState.activeTool.type === "text" || suppportsHorizontalAlign(targetElements, elementsMap)) && renderAction("changeTextAlign")
    ] }),
    shouldAllowVerticalAlign(targetElements, elementsMap) && renderAction("changeVerticalAlign"),
    (canHaveArrowheads(appState.activeTool.type) || targetElements.some((element) => canHaveArrowheads(element.type))) && /* @__PURE__ */ jsx70(Fragment10, { children: renderAction("changeArrowhead") }),
    renderAction("changeOpacity"),
    /* @__PURE__ */ jsxs38("fieldset", { children: [
      /* @__PURE__ */ jsx70("legend", { children: t("labels.layers") }),
      /* @__PURE__ */ jsxs38("div", { className: "buttonList", children: [
        renderAction("sendToBack"),
        renderAction("sendBackward"),
        renderAction("bringForward"),
        renderAction("bringToFront")
      ] })
    ] }),
    targetElements.length > 1 && !isSingleElementBoundContainer && /* @__PURE__ */ jsxs38("fieldset", { children: [
      /* @__PURE__ */ jsx70("legend", { children: t("labels.align") }),
      /* @__PURE__ */ jsxs38("div", { className: "buttonList", children: [
        isRTL2 ? /* @__PURE__ */ jsxs38(Fragment10, { children: [
          renderAction("alignRight"),
          renderAction("alignHorizontallyCentered"),
          renderAction("alignLeft")
        ] }) : /* @__PURE__ */ jsxs38(Fragment10, { children: [
          renderAction("alignLeft"),
          renderAction("alignHorizontallyCentered"),
          renderAction("alignRight")
        ] }),
        targetElements.length > 2 && renderAction("distributeHorizontally"),
        /* @__PURE__ */ jsx70("div", { style: { flexBasis: "100%", height: 0 } }),
        /* @__PURE__ */ jsxs38(
          "div",
          {
            style: {
              display: "flex",
              flexWrap: "wrap",
              gap: ".5rem",
              marginTop: "-0.5rem"
            },
            children: [
              renderAction("alignTop"),
              renderAction("alignVerticallyCentered"),
              renderAction("alignBottom"),
              targetElements.length > 2 && renderAction("distributeVertically")
            ]
          }
        )
      ] })
    ] }),
    !isEditingTextOrNewElement && targetElements.length > 0 && /* @__PURE__ */ jsxs38("fieldset", { children: [
      /* @__PURE__ */ jsx70("legend", { children: t("labels.actions") }),
      /* @__PURE__ */ jsxs38("div", { className: "buttonList", children: [
        !device.editor.isMobile && renderAction("duplicateSelection"),
        !device.editor.isMobile && renderAction("deleteSelectedElements"),
        renderAction("group"),
        renderAction("ungroup"),
        showLinkIcon && renderAction("hyperlink"),
        showLineEditorAction && renderAction("toggleLinearEditor")
      ] })
    ] })
  ] });
};
var ShapesSwitcher = ({
  activeTool,
  appState,
  app,
  UIOptions
}) => {
  const [isExtraToolsMenuOpen, setIsExtraToolsMenuOpen] = useState22(false);
  const frameToolSelected = activeTool.type === "frame";
  const laserToolSelected = activeTool.type === "laser";
  const embeddableToolSelected = activeTool.type === "embeddable";
  const { TTDDialogTriggerTunnel } = useTunnels();
  return /* @__PURE__ */ jsxs38(Fragment10, { children: [
    SHAPES.map(({ value, icon, key, numericKey, fillable }, index) => {
      if (UIOptions.tools?.[value] === false) {
        return null;
      }
      const label = t(`toolBar.${value}`);
      const letter = key && capitalizeString(typeof key === "string" ? key : key[0]);
      const shortcut = letter ? `${letter} ${t("helpDialog.or")} ${numericKey}` : `${numericKey}`;
      return /* @__PURE__ */ jsx70(
        ToolButton,
        {
          className: clsx32("Shape", { fillable }),
          type: "radio",
          icon,
          checked: activeTool.type === value,
          name: "editor-current-shape",
          title: `${capitalizeString(label)} \u2014 ${shortcut}`,
          keyBindingLabel: numericKey || letter,
          "aria-label": capitalizeString(label),
          "aria-keyshortcuts": shortcut,
          "data-testid": `toolbar-${value}`,
          onPointerDown: ({ pointerType }) => {
            if (!appState.penDetected && pointerType === "pen") {
              app.togglePenMode(true);
            }
          },
          onChange: ({ pointerType }) => {
            if (appState.activeTool.type !== value) {
              trackEvent("toolbar", value, "ui");
            }
            if (value === "image") {
              app.setActiveTool({
                type: value,
                insertOnCanvasDirectly: pointerType !== "mouse"
              });
            } else {
              app.setActiveTool({ type: value });
            }
          }
        },
        value
      );
    }),
    /* @__PURE__ */ jsx70("div", { className: "App-toolbar__divider" }),
    /* @__PURE__ */ jsxs38(DropdownMenu_default, { open: isExtraToolsMenuOpen, children: [
      /* @__PURE__ */ jsxs38(
        DropdownMenu_default.Trigger,
        {
          className: clsx32("App-toolbar__extra-tools-trigger", {
            "App-toolbar__extra-tools-trigger--selected": frameToolSelected || embeddableToolSelected || // in collab we're already highlighting the laser button
            // outside toolbar, so let's not highlight extra-tools button
            // on top of it
            laserToolSelected && !app.props.isCollaborating
          }),
          onToggle: () => setIsExtraToolsMenuOpen(!isExtraToolsMenuOpen),
          title: t("toolBar.extraTools"),
          children: [
            extraToolsIcon,
            app.props.aiEnabled !== false && /* @__PURE__ */ jsx70(
              "div",
              {
                style: {
                  display: "inline-flex",
                  marginLeft: "auto",
                  padding: "2px 4px",
                  borderRadius: 6,
                  fontSize: 8,
                  fontFamily: "Cascadia, monospace",
                  position: "absolute",
                  background: "var(--color-promo)",
                  color: "var(--color-surface-lowest)",
                  bottom: 3,
                  right: 4
                },
                children: "AI"
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsxs38(
        DropdownMenu_default.Content,
        {
          onClickOutside: () => setIsExtraToolsMenuOpen(false),
          onSelect: () => setIsExtraToolsMenuOpen(false),
          className: "App-toolbar__extra-tools-dropdown",
          style: {
            position: "fixed",
            top: 260,
            left: 60,
            width: 240
          },
          children: [
            /* @__PURE__ */ jsx70(
              DropdownMenu_default.Item,
              {
                onSelect: () => app.setActiveTool({ type: "frame" }),
                icon: frameToolIcon,
                shortcut: KEYS.F.toLocaleUpperCase(),
                "data-testid": "toolbar-frame",
                selected: frameToolSelected,
                children: t("toolBar.frame")
              }
            ),
            /* @__PURE__ */ jsx70(
              DropdownMenu_default.Item,
              {
                onSelect: () => app.setActiveTool({ type: "embeddable" }),
                icon: EmbedIcon,
                "data-testid": "toolbar-embeddable",
                selected: embeddableToolSelected,
                children: t("toolBar.embeddable")
              }
            ),
            /* @__PURE__ */ jsx70(
              DropdownMenu_default.Item,
              {
                onSelect: () => app.setActiveTool({ type: "laser" }),
                icon: laserPointerToolIcon,
                "data-testid": "toolbar-laser",
                selected: laserToolSelected,
                shortcut: KEYS.K.toLocaleUpperCase(),
                children: t("toolBar.laser")
              }
            ),
            /* @__PURE__ */ jsx70("div", { style: { margin: "6px 0", fontSize: 14, fontWeight: 600 }, children: "Generate" }),
            app.props.aiEnabled !== false && /* @__PURE__ */ jsx70(TTDDialogTriggerTunnel.Out, {}),
            /* @__PURE__ */ jsx70(
              DropdownMenu_default.Item,
              {
                onSelect: () => app.setOpenDialog({ name: "ttd", tab: "mermaid" }),
                icon: mermaidLogoIcon,
                "data-testid": "toolbar-embeddable",
                children: t("toolBar.mermaidToExcalidraw")
              }
            ),
            app.props.aiEnabled !== false && app.plugins.diagramToCode && /* @__PURE__ */ jsx70(Fragment10, { children: /* @__PURE__ */ jsxs38(
              DropdownMenu_default.Item,
              {
                onSelect: () => app.onMagicframeToolSelect(),
                icon: MagicIcon,
                "data-testid": "toolbar-magicframe",
                children: [
                  t("toolBar.magicframe"),
                  /* @__PURE__ */ jsx70(DropdownMenu_default.Item.Badge, { children: "AI" })
                ]
              }
            ) })
          ]
        }
      )
    ] })
  ] });
};
var ZoomActions = ({
  renderAction,
  zoom
}) => /* @__PURE__ */ jsx70(Stack_default.Col, { gap: 1, className: CLASSES.ZOOM_ACTIONS, children: /* @__PURE__ */ jsxs38(Stack_default.Row, { align: "center", children: [
  renderAction("zoomOut"),
  renderAction("resetZoom"),
  renderAction("zoomIn")
] }) });
var UndoRedoActions = ({
  renderAction,
  className
}) => /* @__PURE__ */ jsxs38("div", { className: `undo-redo-buttons ${className}`, children: [
  /* @__PURE__ */ jsx70("div", { className: "undo-button-container", children: /* @__PURE__ */ jsx70(Tooltip, { label: t("buttons.undo"), children: renderAction("undo") }) }),
  /* @__PURE__ */ jsx70("div", { className: "redo-button-container", children: /* @__PURE__ */ jsxs38(Tooltip, { label: t("buttons.redo"), children: [
    " ",
    renderAction("redo")
  ] }) })
] });
var ExitZenModeAction = ({
  actionManager,
  showExitZenModeBtn
}) => /* @__PURE__ */ jsx70(
  "button",
  {
    type: "button",
    className: clsx32("disable-zen-mode", {
      "disable-zen-mode--visible": showExitZenModeBtn
    }),
    onClick: () => actionManager.executeAction(actionToggleZenMode),
    children: t("buttons.exitZenMode")
  }
);
var FinalizeAction = ({
  renderAction,
  className
}) => /* @__PURE__ */ jsx70("div", { className: `finalize-button ${className}`, children: renderAction("finalize", { size: "small" }) });

// hooks/useStableCallback.ts
init_define_import_meta_env();
import { useRef as useRef22 } from "react";
var useStableCallback = (userFn) => {
  const stableRef = useRef22({ userFn });
  stableRef.current.userFn = userFn;
  if (!stableRef.current.stableFn) {
    stableRef.current.stableFn = (...args) => stableRef.current.userFn(...args);
  }
  return stableRef.current.stableFn;
};

// components/ActiveConfirmDialog.tsx
init_define_import_meta_env();
import { atom as atom8, useAtom as useAtom12 } from "jotai";
import { jsx as jsx71, jsxs as jsxs39 } from "react/jsx-runtime";
var activeConfirmDialogAtom = atom8(null);
var ActiveConfirmDialog = () => {
  const [activeConfirmDialog, setActiveConfirmDialog] = useAtom12(
    activeConfirmDialogAtom,
    jotaiScope
  );
  const actionManager = useExcalidrawActionManager();
  if (!activeConfirmDialog) {
    return null;
  }
  if (activeConfirmDialog === "clearCanvas") {
    return /* @__PURE__ */ jsx71(
      ConfirmDialog_default,
      {
        onConfirm: () => {
          actionManager.executeAction(actionClearCanvas);
          setActiveConfirmDialog(null);
        },
        onCancel: () => setActiveConfirmDialog(null),
        title: t("clearCanvasDialog.title"),
        children: /* @__PURE__ */ jsxs39("p", { className: "clear-canvas__content", children: [
          " ",
          t("alerts.clearReset")
        ] })
      }
    );
  }
  return null;
};

// components/CommandPalette/defaultCommandPaletteItems.ts
var defaultCommandPaletteItems_exports = {};
__export(defaultCommandPaletteItems_exports, {
  toggleTheme: () => toggleTheme
});
init_define_import_meta_env();
var toggleTheme = {
  ...actionToggleTheme,
  category: "App",
  label: "Toggle theme",
  perform: ({ actionManager }) => {
    actionManager.executeAction(actionToggleTheme, "commandPalette");
  }
};

// components/CommandPalette/CommandPalette.tsx
import { jsx as jsx72, jsxs as jsxs40 } from "react/jsx-runtime";
var lastUsedPaletteItem = atom9(null);
var DEFAULT_CATEGORIES = {
  app: "App",
  export: "Export",
  tools: "Tools",
  editor: "Editor",
  elements: "Elements",
  links: "Links"
};
var getCategoryOrder = (category) => {
  switch (category) {
    case DEFAULT_CATEGORIES.app:
      return 1;
    case DEFAULT_CATEGORIES.export:
      return 2;
    case DEFAULT_CATEGORIES.editor:
      return 3;
    case DEFAULT_CATEGORIES.tools:
      return 4;
    case DEFAULT_CATEGORIES.elements:
      return 5;
    case DEFAULT_CATEGORIES.links:
      return 6;
    default:
      return 10;
  }
};
var CommandShortcutHint = ({
  shortcut,
  className,
  children
}) => {
  const shortcuts = shortcut.replace("++", "+$").split("+");
  return /* @__PURE__ */ jsxs40("div", { className: clsx33("shortcut", className), children: [
    shortcuts.map((item, idx) => {
      return /* @__PURE__ */ jsx72("div", { className: "shortcut-wrapper", children: /* @__PURE__ */ jsx72("div", { className: "shortcut-key", children: item === "$" ? "+" : item }) }, item);
    }),
    /* @__PURE__ */ jsx72("div", { className: "shortcut-desc", children })
  ] });
};
var isCommandPaletteToggleShortcut = (event) => {
  return !event.altKey && event[KEYS.CTRL_OR_CMD] && (event.shiftKey && event.key.toLowerCase() === KEYS.P || event.key === KEYS.SLASH);
};
var CommandPalette = Object.assign(
  (props) => {
    const uiAppState = useUIAppState();
    const setAppState = useExcalidrawSetAppState();
    useEffect26(() => {
      const commandPaletteShortcut = (event) => {
        if (isCommandPaletteToggleShortcut(event)) {
          event.preventDefault();
          event.stopPropagation();
          setAppState((appState) => {
            const nextState = appState.openDialog?.name === "commandPalette" ? null : { name: "commandPalette" };
            if (nextState) {
              trackEvent("command_palette", "open", "shortcut");
            }
            return {
              openDialog: nextState
            };
          });
        }
      };
      window.addEventListener("keydown" /* KEYDOWN */, commandPaletteShortcut, {
        capture: true
      });
      return () => window.removeEventListener("keydown" /* KEYDOWN */, commandPaletteShortcut, {
        capture: true
      });
    }, [setAppState]);
    if (uiAppState.openDialog?.name !== "commandPalette") {
      return null;
    }
    return /* @__PURE__ */ jsx72(CommandPaletteInner, { ...props });
  },
  {
    defaultItems: defaultCommandPaletteItems_exports
  }
);
function CommandPaletteInner({
  customCommandPaletteItems
}) {
  const app = useApp();
  const uiAppState = useUIAppState();
  const setAppState = useExcalidrawSetAppState();
  const appProps = useAppProps();
  const actionManager = useExcalidrawActionManager();
  const [lastUsed, setLastUsed] = useAtom13(lastUsedPaletteItem);
  const [allCommands, setAllCommands] = useState23(null);
  const inputRef = useRef23(null);
  const stableDeps = useStable({
    uiAppState,
    customCommandPaletteItems,
    appProps
  });
  useEffect26(() => {
    const { uiAppState: uiAppState2, customCommandPaletteItems: customCommandPaletteItems2, appProps: appProps2 } = stableDeps;
    const getActionLabel = (action) => {
      let label = "";
      if (action.label) {
        if (typeof action.label === "function") {
          label = t(
            action.label(
              app.scene.getNonDeletedElements(),
              uiAppState2,
              app
            )
          );
        } else {
          label = t(action.label);
        }
      }
      return label;
    };
    const getActionIcon = (action) => {
      if (typeof action.icon === "function") {
        return action.icon(uiAppState2, app.scene.getNonDeletedElements());
      }
      return action.icon;
    };
    let commandsFromActions = [];
    const actionToCommand = (action, category, transformer) => {
      const command = {
        label: getActionLabel(action),
        icon: getActionIcon(action),
        category,
        shortcut: getShortcutFromShortcutName(action.name),
        keywords: action.keywords,
        predicate: action.predicate,
        viewMode: action.viewMode,
        perform: () => {
          actionManager.executeAction(action, "commandPalette");
        }
      };
      return transformer ? transformer(command, action) : command;
    };
    if (uiAppState2 && app.scene && actionManager) {
      const elementsCommands = [
        actionManager.actions.group,
        actionManager.actions.ungroup,
        actionManager.actions.cut,
        actionManager.actions.copy,
        actionManager.actions.deleteSelectedElements,
        actionManager.actions.copyStyles,
        actionManager.actions.pasteStyles,
        actionManager.actions.bringToFront,
        actionManager.actions.bringForward,
        actionManager.actions.sendBackward,
        actionManager.actions.sendToBack,
        actionManager.actions.alignTop,
        actionManager.actions.alignBottom,
        actionManager.actions.alignLeft,
        actionManager.actions.alignRight,
        actionManager.actions.alignVerticallyCentered,
        actionManager.actions.alignHorizontallyCentered,
        actionManager.actions.duplicateSelection,
        actionManager.actions.flipHorizontal,
        actionManager.actions.flipVertical,
        actionManager.actions.zoomToFitSelection,
        actionManager.actions.zoomToFitSelectionInViewport,
        actionManager.actions.increaseFontSize,
        actionManager.actions.decreaseFontSize,
        actionManager.actions.toggleLinearEditor,
        actionLink
      ].map(
        (action) => actionToCommand(
          action,
          DEFAULT_CATEGORIES.elements,
          (command, action2) => ({
            ...command,
            predicate: action2.predicate ? action2.predicate : (elements, appState, appProps3, app2) => {
              const selectedElements = getSelectedElements(
                elements,
                appState
              );
              return selectedElements.length > 0;
            }
          })
        )
      );
      const toolCommands = [
        actionManager.actions.toggleHandTool,
        actionManager.actions.setFrameAsActiveTool
      ].map((action) => actionToCommand(action, DEFAULT_CATEGORIES.tools));
      const editorCommands = [
        actionManager.actions.undo,
        actionManager.actions.redo,
        actionManager.actions.zoomIn,
        actionManager.actions.zoomOut,
        actionManager.actions.resetZoom,
        actionManager.actions.zoomToFit,
        actionManager.actions.zenMode,
        actionManager.actions.viewMode,
        actionManager.actions.gridMode,
        actionManager.actions.objectsSnapMode,
        actionManager.actions.toggleShortcuts,
        actionManager.actions.selectAll,
        actionManager.actions.toggleElementLock,
        actionManager.actions.unlockAllElements,
        actionManager.actions.stats
      ].map((action) => actionToCommand(action, DEFAULT_CATEGORIES.editor));
      const exportCommands = [
        actionManager.actions.saveToActiveFile,
        actionManager.actions.saveFileToDisk,
        actionManager.actions.copyAsPng,
        actionManager.actions.copyAsSvg
      ].map((action) => actionToCommand(action, DEFAULT_CATEGORIES.export));
      commandsFromActions = [
        ...elementsCommands,
        ...editorCommands,
        {
          label: getActionLabel(actionClearCanvas),
          icon: getActionIcon(actionClearCanvas),
          shortcut: getShortcutFromShortcutName(
            actionClearCanvas.name
          ),
          category: DEFAULT_CATEGORIES.editor,
          keywords: ["delete", "destroy"],
          viewMode: false,
          perform: () => {
            jotaiStore.set(activeConfirmDialogAtom, "clearCanvas");
          }
        },
        {
          label: t("buttons.exportImage"),
          category: DEFAULT_CATEGORIES.export,
          icon: ExportImageIcon,
          shortcut: getShortcutFromShortcutName("imageExport"),
          keywords: [
            "export",
            "image",
            "png",
            "jpeg",
            "svg",
            "clipboard",
            "picture"
          ],
          perform: () => {
            setAppState({ openDialog: { name: "imageExport" } });
          }
        },
        ...exportCommands
      ];
      const additionalCommands = [
        {
          label: t("toolBar.library"),
          category: DEFAULT_CATEGORIES.app,
          icon: LibraryIcon,
          viewMode: false,
          perform: () => {
            if (uiAppState2.openSidebar) {
              setAppState({
                openSidebar: null
              });
            } else {
              setAppState({
                openSidebar: {
                  name: DEFAULT_SIDEBAR.name,
                  tab: DEFAULT_SIDEBAR.defaultTab
                }
              });
            }
          }
        },
        {
          label: t("search.title"),
          category: DEFAULT_CATEGORIES.app,
          icon: searchIcon,
          viewMode: true,
          perform: () => {
            actionManager.executeAction(actionToggleSearchMenu);
          }
        },
        {
          label: t("labels.changeStroke"),
          keywords: ["color", "outline"],
          category: DEFAULT_CATEGORIES.elements,
          icon: bucketFillIcon,
          viewMode: false,
          predicate: (elements, appState) => {
            const selectedElements = getSelectedElements(elements, appState);
            return selectedElements.length > 0 && canChangeStrokeColor(appState, selectedElements);
          },
          perform: () => {
            setAppState((prevState) => ({
              openMenu: prevState.openMenu === "shape" ? null : "shape",
              openPopup: "elementStroke"
            }));
          }
        },
        {
          label: t("labels.changeBackground"),
          keywords: ["color", "fill"],
          icon: bucketFillIcon,
          category: DEFAULT_CATEGORIES.elements,
          viewMode: false,
          predicate: (elements, appState) => {
            const selectedElements = getSelectedElements(elements, appState);
            return selectedElements.length > 0 && canChangeBackgroundColor(appState, selectedElements);
          },
          perform: () => {
            setAppState((prevState) => ({
              openMenu: prevState.openMenu === "shape" ? null : "shape",
              openPopup: "elementBackground"
            }));
          }
        },
        {
          label: t("labels.canvasBackground"),
          keywords: ["color"],
          icon: bucketFillIcon,
          category: DEFAULT_CATEGORIES.editor,
          viewMode: false,
          perform: () => {
            setAppState((prevState) => ({
              openMenu: prevState.openMenu === "canvas" ? null : "canvas",
              openPopup: "canvasBackground"
            }));
          }
        },
        ...SHAPES.reduce((acc, shape) => {
          const { value, icon, key, numericKey } = shape;
          if (appProps2.UIOptions.tools?.[value] === false) {
            return acc;
          }
          const letter = key && capitalizeString(typeof key === "string" ? key : key[0]);
          const shortcut = letter || numericKey;
          const command = {
            label: t(`toolBar.${value}`),
            category: DEFAULT_CATEGORIES.tools,
            shortcut,
            icon,
            keywords: ["toolbar"],
            viewMode: false,
            perform: ({ event }) => {
              if (value === "image") {
                app.setActiveTool({
                  type: value,
                  insertOnCanvasDirectly: event.type === "keydown" /* KEYDOWN */
                });
              } else {
                app.setActiveTool({ type: value });
              }
            }
          };
          acc.push(command);
          return acc;
        }, []),
        ...toolCommands,
        {
          label: t("toolBar.lock"),
          category: DEFAULT_CATEGORIES.tools,
          icon: uiAppState2.activeTool.locked ? LockedIcon : UnlockedIcon,
          shortcut: KEYS.Q.toLocaleUpperCase(),
          viewMode: false,
          perform: () => {
            app.toggleLock();
          }
        },
        {
          label: `${t("labels.textToDiagram")}...`,
          category: DEFAULT_CATEGORIES.tools,
          icon: brainIconThin,
          viewMode: false,
          predicate: appProps2.aiEnabled,
          perform: () => {
            setAppState((state) => ({
              ...state,
              openDialog: {
                name: "ttd",
                tab: "text-to-diagram"
              }
            }));
          }
        },
        {
          label: `${t("toolBar.mermaidToExcalidraw")}...`,
          category: DEFAULT_CATEGORIES.tools,
          icon: mermaidLogoIcon,
          viewMode: false,
          predicate: appProps2.aiEnabled,
          perform: () => {
            setAppState((state) => ({
              ...state,
              openDialog: {
                name: "ttd",
                tab: "mermaid"
              }
            }));
          }
        }
        // {
        //   label: `${t("toolBar.magicframe")}...`,
        //   category: DEFAULT_CATEGORIES.tools,
        //   icon: MagicIconThin,
        //   viewMode: false,
        //   predicate: appProps.aiEnabled,
        //   perform: () => {
        //     app.onMagicframeToolSelect();
        //   },
        // },
      ];
      const allCommands2 = [
        ...commandsFromActions,
        ...additionalCommands,
        ...customCommandPaletteItems2 || []
      ].map((command) => {
        return {
          ...command,
          icon: command.icon || boltIcon,
          order: command.order ?? getCategoryOrder(command.category),
          haystack: `${deburr(command.label.toLocaleLowerCase())} ${command.keywords?.join(" ") || ""}`
        };
      });
      setAllCommands(allCommands2);
      setLastUsed(
        allCommands2.find((command) => command.label === lastUsed?.label) ?? null
      );
    }
  }, [
    stableDeps,
    app,
    actionManager,
    setAllCommands,
    lastUsed?.label,
    setLastUsed,
    setAppState
  ]);
  const [commandSearch, setCommandSearch] = useState23("");
  const [currentCommand, setCurrentCommand] = useState23(null);
  const [commandsByCategory, setCommandsByCategory] = useState23({});
  const closeCommandPalette = (cb) => {
    setAppState(
      {
        openDialog: null
      },
      cb
    );
    setCommandSearch("");
  };
  const executeCommand = (command, event) => {
    if (uiAppState.openDialog?.name === "commandPalette") {
      event.stopPropagation();
      event.preventDefault();
      document.body.classList.add("excalidraw-animations-disabled");
      closeCommandPalette(() => {
        command.perform({ actionManager, event });
        setLastUsed(command);
        requestAnimationFrame(() => {
          document.body.classList.remove("excalidraw-animations-disabled");
        });
      });
    }
  };
  const isCommandAvailable = useStableCallback(
    (command) => {
      if (command.viewMode === false && uiAppState.viewModeEnabled) {
        return false;
      }
      return typeof command.predicate === "function" ? command.predicate(
        app.scene.getNonDeletedElements(),
        uiAppState,
        appProps,
        app
      ) : command.predicate === void 0 || command.predicate;
    }
  );
  const handleKeyDown = useStableCallback((event) => {
    const ignoreAlphanumerics = isWritableElement(event.target) || isCommandPaletteToggleShortcut(event) || event.key === KEYS.ESCAPE;
    if (ignoreAlphanumerics && event.key !== KEYS.ARROW_UP && event.key !== KEYS.ARROW_DOWN && event.key !== KEYS.ENTER) {
      return;
    }
    const matchingCommands = Object.values(commandsByCategory).flat();
    const shouldConsiderLastUsed = lastUsed && !commandSearch && isCommandAvailable(lastUsed);
    if (event.key === KEYS.ARROW_UP) {
      event.preventDefault();
      const index = matchingCommands.findIndex(
        (item) => item.label === currentCommand?.label
      );
      if (shouldConsiderLastUsed) {
        if (index === 0) {
          setCurrentCommand(lastUsed);
          return;
        }
        if (currentCommand === lastUsed) {
          const nextItem2 = matchingCommands[matchingCommands.length - 1];
          if (nextItem2) {
            setCurrentCommand(nextItem2);
          }
          return;
        }
      }
      let nextIndex;
      if (index === -1) {
        nextIndex = matchingCommands.length - 1;
      } else {
        nextIndex = index === 0 ? matchingCommands.length - 1 : (index - 1) % matchingCommands.length;
      }
      const nextItem = matchingCommands[nextIndex];
      if (nextItem) {
        setCurrentCommand(nextItem);
      }
      return;
    }
    if (event.key === KEYS.ARROW_DOWN) {
      event.preventDefault();
      const index = matchingCommands.findIndex(
        (item) => item.label === currentCommand?.label
      );
      if (shouldConsiderLastUsed) {
        if (!currentCommand || index === matchingCommands.length - 1) {
          setCurrentCommand(lastUsed);
          return;
        }
        if (currentCommand === lastUsed) {
          const nextItem2 = matchingCommands[0];
          if (nextItem2) {
            setCurrentCommand(nextItem2);
          }
          return;
        }
      }
      const nextIndex = (index + 1) % matchingCommands.length;
      const nextItem = matchingCommands[nextIndex];
      if (nextItem) {
        setCurrentCommand(nextItem);
      }
      return;
    }
    if (event.key === KEYS.ENTER) {
      if (currentCommand) {
        setTimeout(() => {
          executeCommand(currentCommand, event);
        });
      }
    }
    if (ignoreAlphanumerics) {
      return;
    }
    event.stopPropagation();
    if (/^[a-zA-Z0-9]$/.test(event.key)) {
      inputRef?.current?.focus();
      return;
    }
    event.preventDefault();
  });
  useEffect26(() => {
    window.addEventListener("keydown" /* KEYDOWN */, handleKeyDown, {
      capture: true
    });
    return () => window.removeEventListener("keydown" /* KEYDOWN */, handleKeyDown, {
      capture: true
    });
  }, [handleKeyDown]);
  useEffect26(() => {
    if (!allCommands) {
      return;
    }
    const getNextCommandsByCategory = (commands) => {
      const nextCommandsByCategory = {};
      for (const command of commands) {
        if (nextCommandsByCategory[command.category]) {
          nextCommandsByCategory[command.category].push(command);
        } else {
          nextCommandsByCategory[command.category] = [command];
        }
      }
      return nextCommandsByCategory;
    };
    let matchingCommands = allCommands.filter(isCommandAvailable).sort((a, b) => a.order - b.order);
    const showLastUsed = !commandSearch && lastUsed && isCommandAvailable(lastUsed);
    if (!commandSearch) {
      setCommandsByCategory(
        getNextCommandsByCategory(
          showLastUsed ? matchingCommands.filter(
            (command) => command.label !== lastUsed?.label
          ) : matchingCommands
        )
      );
      setCurrentCommand(showLastUsed ? lastUsed : matchingCommands[0] || null);
      return;
    }
    const _query = deburr(
      commandSearch.toLocaleLowerCase().replace(/[<>_| -]/g, "")
    );
    matchingCommands = fuzzy.filter(_query, matchingCommands, {
      extract: (command) => command.haystack
    }).sort((a, b) => b.score - a.score).map((item) => item.original);
    setCommandsByCategory(getNextCommandsByCategory(matchingCommands));
    setCurrentCommand(matchingCommands[0] ?? null);
  }, [commandSearch, allCommands, isCommandAvailable, lastUsed]);
  return /* @__PURE__ */ jsxs40(
    Dialog,
    {
      onCloseRequest: () => closeCommandPalette(),
      closeOnClickOutside: true,
      title: false,
      size: 720,
      autofocus: true,
      className: "command-palette-dialog",
      children: [
        /* @__PURE__ */ jsx72(
          TextField,
          {
            value: commandSearch,
            placeholder: t("commandPalette.search.placeholder"),
            onChange: (value) => {
              setCommandSearch(value);
            },
            selectOnRender: true,
            ref: inputRef
          }
        ),
        !app.device.viewport.isMobile && /* @__PURE__ */ jsxs40("div", { className: "shortcuts-wrapper", children: [
          /* @__PURE__ */ jsx72(CommandShortcutHint, { shortcut: "\u2191\u2193", children: t("commandPalette.shortcuts.select") }),
          /* @__PURE__ */ jsx72(CommandShortcutHint, { shortcut: "\u21B5", children: t("commandPalette.shortcuts.confirm") }),
          /* @__PURE__ */ jsx72(CommandShortcutHint, { shortcut: getShortcutKey("Esc"), children: t("commandPalette.shortcuts.close") })
        ] }),
        /* @__PURE__ */ jsxs40("div", { className: "commands", children: [
          lastUsed && !commandSearch && /* @__PURE__ */ jsxs40("div", { className: "command-category", children: [
            /* @__PURE__ */ jsxs40("div", { className: "command-category-title", children: [
              t("commandPalette.recents"),
              /* @__PURE__ */ jsx72(
                "div",
                {
                  className: "icon",
                  style: {
                    marginLeft: "6px"
                  },
                  children: clockIcon
                }
              )
            ] }),
            /* @__PURE__ */ jsx72(
              CommandItem,
              {
                command: lastUsed,
                isSelected: lastUsed.label === currentCommand?.label,
                onClick: (event) => executeCommand(lastUsed, event),
                disabled: !isCommandAvailable(lastUsed),
                onMouseMove: () => setCurrentCommand(lastUsed),
                showShortcut: !app.device.viewport.isMobile,
                appState: uiAppState
              }
            )
          ] }),
          Object.keys(commandsByCategory).length > 0 ? Object.keys(commandsByCategory).map((category, idx) => {
            return /* @__PURE__ */ jsxs40("div", { className: "command-category", children: [
              /* @__PURE__ */ jsx72("div", { className: "command-category-title", children: category }),
              commandsByCategory[category].map((command) => /* @__PURE__ */ jsx72(
                CommandItem,
                {
                  command,
                  isSelected: command.label === currentCommand?.label,
                  onClick: (event) => executeCommand(command, event),
                  onMouseMove: () => setCurrentCommand(command),
                  showShortcut: !app.device.viewport.isMobile,
                  appState: uiAppState
                },
                command.label
              ))
            ] }, category);
          }) : allCommands ? /* @__PURE__ */ jsxs40("div", { className: "no-match", children: [
            /* @__PURE__ */ jsx72("div", { className: "icon", children: searchIcon }),
            " ",
            t("commandPalette.search.noMatch")
          ] }) : null
        ] })
      ]
    }
  );
}
var CommandItem = ({
  command,
  isSelected,
  disabled,
  onMouseMove,
  onClick,
  showShortcut,
  appState
}) => {
  const noop = () => {
  };
  return /* @__PURE__ */ jsxs40(
    "div",
    {
      className: clsx33("command-item", {
        "item-selected": isSelected,
        "item-disabled": disabled
      }),
      ref: (ref) => {
        if (isSelected && !disabled) {
          ref?.scrollIntoView?.({
            block: "nearest"
          });
        }
      },
      onClick: disabled ? noop : onClick,
      onMouseMove: disabled ? noop : onMouseMove,
      title: disabled ? t("commandPalette.itemNotAvailable") : "",
      children: [
        /* @__PURE__ */ jsxs40("div", { className: "name", children: [
          command.icon && /* @__PURE__ */ jsx72(
            InlineIcon,
            {
              icon: typeof command.icon === "function" ? command.icon(appState) : command.icon
            }
          ),
          command.label
        ] }),
        showShortcut && command.shortcut && /* @__PURE__ */ jsx72(CommandShortcutHint, { shortcut: command.shortcut })
      ]
    }
  );
};

// actions/actionLinearEditor.tsx
init_linearElementEditor();
init_typeChecks();
init_store();
init_register();
init_icons();
import { jsx as jsx73 } from "react/jsx-runtime";
var actionToggleLinearEditor = register({
  name: "toggleLinearEditor",
  category: DEFAULT_CATEGORIES.elements,
  label: (elements, appState, app) => {
    const selectedElement = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds
    })[0];
    return selectedElement?.type === "arrow" ? "labels.lineEditor.editArrow" : "labels.lineEditor.edit";
  },
  keywords: ["line"],
  trackEvent: {
    category: "element"
  },
  predicate: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    if (!appState.editingLinearElement && selectedElements.length === 1 && isLinearElement(selectedElements[0]) && !isElbowArrow(selectedElements[0])) {
      return true;
    }
    return false;
  },
  perform(elements, appState, _, app) {
    const selectedElement = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true
    })[0];
    const editingLinearElement = appState.editingLinearElement?.elementId === selectedElement.id ? null : new LinearElementEditor(selectedElement);
    return {
      appState: {
        ...appState,
        editingLinearElement
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ appState, updateData, app }) => {
    const selectedElement = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds
    })[0];
    const label = t(
      selectedElement.type === "arrow" ? "labels.lineEditor.editArrow" : "labels.lineEditor.edit"
    );
    return /* @__PURE__ */ jsx73(
      ToolButton,
      {
        type: "button",
        icon: lineEditorIcon,
        title: label,
        "aria-label": label,
        onClick: () => updateData(null)
      }
    );
  }
});

// actions/actionToggleSearchMenu.ts
init_define_import_meta_env();
init_keys();
init_register();
init_icons();
init_store();
init_constants();
var actionToggleSearchMenu = register({
  name: "searchMenu",
  icon: searchIcon,
  keywords: ["search", "find"],
  label: "search.title",
  viewMode: true,
  trackEvent: {
    category: "search_menu",
    action: "toggle",
    predicate: (appState) => appState.gridModeEnabled
  },
  perform(elements, appState, _, app) {
    if (appState.openSidebar?.name === DEFAULT_SIDEBAR.name && appState.openSidebar.tab === CANVAS_SEARCH_TAB) {
      const searchInput = app.excalidrawContainerValue.container?.querySelector(
        `.${CLASSES.SEARCH_MENU_INPUT_WRAPPER} input`
      );
      if (searchInput?.matches(":focus")) {
        return {
          appState: { ...appState, openSidebar: null },
          storeAction: StoreAction.NONE
        };
      }
      searchInput?.focus();
      searchInput?.select();
      return false;
    }
    return {
      appState: {
        ...appState,
        openSidebar: { name: DEFAULT_SIDEBAR.name, tab: CANVAS_SEARCH_TAB },
        openDialog: null
      },
      storeAction: StoreAction.NONE
    };
  },
  checked: (appState) => appState.gridModeEnabled,
  predicate: (element, appState, props) => {
    return props.gridModeEnabled === void 0;
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.F
});

// actions/actionHistory.tsx
init_define_import_meta_env();
init_icons();

// history.ts
init_define_import_meta_env();
init_emitter();
var HistoryChangedEvent = class {
  constructor(isUndoStackEmpty = true, isRedoStackEmpty = true) {
    this.isUndoStackEmpty = isUndoStackEmpty;
    this.isRedoStackEmpty = isRedoStackEmpty;
  }
};
var History = class _History {
  onHistoryChangedEmitter = new Emitter();
  undoStack = [];
  redoStack = [];
  get isUndoStackEmpty() {
    return this.undoStack.length === 0;
  }
  get isRedoStackEmpty() {
    return this.redoStack.length === 0;
  }
  clear() {
    this.undoStack.length = 0;
    this.redoStack.length = 0;
  }
  /**
   * Record a local change which will go into the history
   */
  record(elementsChange, appStateChange) {
    const entry = HistoryEntry.create(appStateChange, elementsChange);
    if (!entry.isEmpty()) {
      this.undoStack.push(entry.inverse());
      if (!entry.elementsChange.isEmpty()) {
        this.redoStack.length = 0;
      }
      this.onHistoryChangedEmitter.trigger(
        new HistoryChangedEvent(this.isUndoStackEmpty, this.isRedoStackEmpty)
      );
    }
  }
  undo(elements, appState, snapshot) {
    return this.perform(
      elements,
      appState,
      snapshot,
      () => _History.pop(this.undoStack),
      (entry) => _History.push(this.redoStack, entry, elements)
    );
  }
  redo(elements, appState, snapshot) {
    return this.perform(
      elements,
      appState,
      snapshot,
      () => _History.pop(this.redoStack),
      (entry) => _History.push(this.undoStack, entry, elements)
    );
  }
  perform(elements, appState, snapshot, pop, push) {
    try {
      let historyEntry = pop();
      if (historyEntry === null) {
        return;
      }
      let nextElements = elements;
      let nextAppState = appState;
      let containsVisibleChange = false;
      while (historyEntry) {
        try {
          [nextElements, nextAppState, containsVisibleChange] = historyEntry.applyTo(nextElements, nextAppState, snapshot);
        } finally {
          push(historyEntry);
        }
        if (containsVisibleChange) {
          break;
        }
        historyEntry = pop();
      }
      return [nextElements, nextAppState];
    } finally {
      this.onHistoryChangedEmitter.trigger(
        new HistoryChangedEvent(this.isUndoStackEmpty, this.isRedoStackEmpty)
      );
    }
  }
  static pop(stack) {
    if (!stack.length) {
      return null;
    }
    const entry = stack.pop();
    if (entry !== void 0) {
      return entry;
    }
    return null;
  }
  static push(stack, entry, prevElements) {
    const updatedEntry = entry.inverse().applyLatestChanges(prevElements);
    return stack.push(updatedEntry);
  }
};
var HistoryEntry = class _HistoryEntry {
  constructor(appStateChange, elementsChange) {
    this.appStateChange = appStateChange;
    this.elementsChange = elementsChange;
  }
  static create(appStateChange, elementsChange) {
    return new _HistoryEntry(appStateChange, elementsChange);
  }
  inverse() {
    return new _HistoryEntry(
      this.appStateChange.inverse(),
      this.elementsChange.inverse()
    );
  }
  applyTo(elements, appState, snapshot) {
    const [nextElements, elementsContainVisibleChange] = this.elementsChange.applyTo(elements, snapshot.elements);
    const [nextAppState, appStateContainsVisibleChange] = this.appStateChange.applyTo(appState, nextElements);
    const appliedVisibleChanges = elementsContainVisibleChange || appStateContainsVisibleChange;
    return [nextElements, nextAppState, appliedVisibleChanges];
  }
  /**
   * Apply latest (remote) changes to the history entry, creates new instance of `HistoryEntry`.
   */
  applyLatestChanges(elements) {
    const updatedElementsChange = this.elementsChange.applyLatestChanges(elements);
    return _HistoryEntry.create(this.appStateChange, updatedElementsChange);
  }
  isEmpty() {
    return this.appStateChange.isEmpty() && this.elementsChange.isEmpty();
  }
};

// actions/actionHistory.tsx
init_keys();
init_utils2();
init_constants();
init_store();

// hooks/useEmitter.ts
init_define_import_meta_env();
import { useEffect as useEffect27, useState as useState24 } from "react";
var useEmitter = (emitter, initialState) => {
  const [event, setEvent] = useState24(initialState);
  useEffect27(() => {
    const unsubscribe = emitter.on((event2) => {
      setEvent(event2);
    });
    return () => {
      unsubscribe();
    };
  }, [emitter]);
  return event;
};

// actions/actionHistory.tsx
import { jsx as jsx74 } from "react/jsx-runtime";
var executeHistoryAction = (app, appState, updater) => {
  if (!appState.multiElement && !appState.resizingElement && !appState.editingTextElement && !appState.newElement && !appState.selectedElementsAreBeingDragged && !appState.selectionElement && !app.flowChartCreator.isCreatingChart) {
    const result = updater();
    if (!result) {
      return { storeAction: StoreAction.NONE };
    }
    const [nextElementsMap, nextAppState] = result;
    const nextElements = Array.from(nextElementsMap.values());
    return {
      appState: nextAppState,
      elements: nextElements,
      storeAction: StoreAction.UPDATE
    };
  }
  return { storeAction: StoreAction.NONE };
};
var createUndoAction = (history, store) => ({
  name: "undo",
  label: "buttons.undo",
  icon: UndoIcon,
  trackEvent: { category: "history" },
  viewMode: false,
  perform: (elements, appState, value, app) => executeHistoryAction(
    app,
    appState,
    () => history.undo(
      arrayToMap(elements),
      // TODO: #7348 refactor action manager to already include `SceneElementsMap`
      appState,
      store.snapshot
    )
  ),
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key.toLowerCase() === KEYS.Z && !event.shiftKey,
  PanelComponent: ({ updateData, data }) => {
    const { isUndoStackEmpty } = useEmitter(
      history.onHistoryChangedEmitter,
      new HistoryChangedEvent(
        history.isUndoStackEmpty,
        history.isRedoStackEmpty
      )
    );
    return /* @__PURE__ */ jsx74(
      ToolButton,
      {
        type: "button",
        icon: UndoIcon,
        "aria-label": t("buttons.undo"),
        onClick: updateData,
        size: data?.size || "medium",
        disabled: isUndoStackEmpty,
        "data-testid": "button-undo"
      }
    );
  }
});
var createRedoAction = (history, store) => ({
  name: "redo",
  label: "buttons.redo",
  icon: RedoIcon,
  trackEvent: { category: "history" },
  viewMode: false,
  perform: (elements, appState, _, app) => executeHistoryAction(
    app,
    appState,
    () => history.redo(
      arrayToMap(elements),
      // TODO: #7348 refactor action manager to already include `SceneElementsMap`
      appState,
      store.snapshot
    )
  ),
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key.toLowerCase() === KEYS.Z || isWindows && event.ctrlKey && !event.shiftKey && event.key === KEYS.Y,
  PanelComponent: ({ updateData, data }) => {
    const { isRedoStackEmpty } = useEmitter(
      history.onHistoryChangedEmitter,
      new HistoryChangedEvent(
        history.isUndoStackEmpty,
        history.isRedoStackEmpty
      )
    );
    return /* @__PURE__ */ jsx74(
      ToolButton,
      {
        type: "button",
        icon: RedoIcon,
        "aria-label": t("buttons.redo"),
        onClick: updateData,
        size: data?.size || "medium",
        disabled: isRedoStackEmpty,
        "data-testid": "button-redo"
      }
    );
  }
});

// actions/manager.tsx
init_define_import_meta_env();
init_utils2();
import { jsx as jsx75 } from "react/jsx-runtime";
var trackAction = (action, source, appState, elements, app, value) => {
  if (action.trackEvent) {
    try {
      if (typeof action.trackEvent === "object") {
        const shouldTrack = action.trackEvent.predicate ? action.trackEvent.predicate(appState, elements, value) : true;
        if (shouldTrack) {
          trackEvent(
            action.trackEvent.category,
            action.trackEvent.action || action.name,
            `${source} (${app.device.editor.isMobile ? "mobile" : "desktop"})`
          );
        }
      }
    } catch (error) {
      console.error("error while logging action:", error);
    }
  }
};
var ActionManager = class {
  actions = {};
  updater;
  getAppState;
  getElementsIncludingDeleted;
  app;
  constructor(updater, getAppState, getElementsIncludingDeleted, app) {
    this.updater = (actionResult) => {
      if (isPromiseLike(actionResult)) {
        actionResult.then((actionResult2) => {
          return updater(actionResult2);
        });
      } else {
        return updater(actionResult);
      }
    };
    this.getAppState = getAppState;
    this.getElementsIncludingDeleted = getElementsIncludingDeleted;
    this.app = app;
  }
  registerAction(action) {
    this.actions[action.name] = action;
  }
  registerAll(actions2) {
    actions2.forEach((action) => this.registerAction(action));
  }
  handleKeyDown(event) {
    const canvasActions = this.app.props.UIOptions.canvasActions;
    const data = Object.values(this.actions).sort((a, b) => (b.keyPriority || 0) - (a.keyPriority || 0)).filter(
      (action2) => (action2.name in canvasActions ? canvasActions[action2.name] : true) && action2.keyTest && action2.keyTest(
        event,
        this.getAppState(),
        this.getElementsIncludingDeleted(),
        this.app
      )
    );
    if (data.length !== 1) {
      if (data.length > 1) {
        console.warn("Canceling as multiple actions match this shortcut", data);
      }
      return false;
    }
    const action = data[0];
    if (this.getAppState().viewModeEnabled && action.viewMode !== true) {
      return false;
    }
    const elements = this.getElementsIncludingDeleted();
    const appState = this.getAppState();
    const value = null;
    trackAction(action, "keyboard", appState, elements, this.app, null);
    event.preventDefault();
    event.stopPropagation();
    this.updater(data[0].perform(elements, appState, value, this.app));
    return true;
  }
  executeAction(action, source = "api", value = null) {
    const elements = this.getElementsIncludingDeleted();
    const appState = this.getAppState();
    trackAction(action, source, appState, elements, this.app, value);
    this.updater(action.perform(elements, appState, value, this.app));
  }
  /**
   * @param data additional data sent to the PanelComponent
   */
  renderAction = (name, data) => {
    const canvasActions = this.app.props.UIOptions.canvasActions;
    if (this.actions[name] && "PanelComponent" in this.actions[name] && (name in canvasActions ? canvasActions[name] : true)) {
      const action = this.actions[name];
      const PanelComponent = action.PanelComponent;
      PanelComponent.displayName = "PanelComponent";
      const elements = this.getElementsIncludingDeleted();
      const appState = this.getAppState();
      const updateData = (formState) => {
        trackAction(action, "ui", appState, elements, this.app, formState);
        this.updater(
          action.perform(
            this.getElementsIncludingDeleted(),
            this.getAppState(),
            formState,
            this.app
          )
        );
      };
      return /* @__PURE__ */ jsx75(
        PanelComponent,
        {
          elements: this.getElementsIncludingDeleted(),
          appState: this.getAppState(),
          updateData,
          appProps: this.app.props,
          app: this.app,
          data
        }
      );
    }
    return null;
  };
  isActionEnabled = (action) => {
    const elements = this.getElementsIncludingDeleted();
    const appState = this.getAppState();
    return !action.predicate || action.predicate(elements, appState, this.app.props, this.app);
  };
};

// components/App.tsx
init_register();
init_appState();
init_clipboard();
init_constants();
init_constants();
init_restore();
init_element();
init_binding();
init_linearElementEditor();
init_mutateElement();
init_newElement();
init_typeChecks();

// gesture.ts
init_define_import_meta_env();
var getCenter = (pointers) => {
  const allCoords = Array.from(pointers.values());
  return {
    x: sum(allCoords, (coords) => coords.x) / allCoords.length,
    y: sum(allCoords, (coords) => coords.y) / allCoords.length
  };
};
var getDistance = ([a, b]) => Math.hypot(a.x - b.x, a.y - b.y);
var sum = (array, mapper) => array.reduce((acc, item) => acc + mapper(item), 0);

// components/App.tsx
init_groups();
init_keys();
init_sizeHelpers();
init_scene();
init_Scene();
init_shapes();
init_shape();
init_collision();
init_utils2();
init_embeddable();

// components/ContextMenu.tsx
init_define_import_meta_env();
import clsx34 from "clsx";
import React29 from "react";
import { jsx as jsx76, jsxs as jsxs41 } from "react/jsx-runtime";
var CONTEXT_MENU_SEPARATOR = "separator";
var ContextMenu = React29.memo(
  ({ actionManager, items, top, left, onClose }) => {
    const appState = useExcalidrawAppState();
    const elements = useExcalidrawElements();
    const filteredItems = items.reduce((acc, item) => {
      if (item && (item === CONTEXT_MENU_SEPARATOR || !item.predicate || item.predicate(
        elements,
        appState,
        actionManager.app.props,
        actionManager.app
      ))) {
        acc.push(item);
      }
      return acc;
    }, []);
    return /* @__PURE__ */ jsx76(
      Popover3,
      {
        onCloseRequest: () => {
          onClose();
        },
        top,
        left,
        fitInViewport: true,
        offsetLeft: appState.offsetLeft,
        offsetTop: appState.offsetTop,
        viewportWidth: appState.width,
        viewportHeight: appState.height,
        children: /* @__PURE__ */ jsx76(
          "ul",
          {
            className: "context-menu",
            onContextMenu: (event) => event.preventDefault(),
            children: filteredItems.map((item, idx) => {
              if (item === CONTEXT_MENU_SEPARATOR) {
                if (!filteredItems[idx - 1] || filteredItems[idx - 1] === CONTEXT_MENU_SEPARATOR) {
                  return null;
                }
                return /* @__PURE__ */ jsx76("hr", { className: "context-menu-item-separator" }, idx);
              }
              const actionName = item.name;
              let label = "";
              if (item.label) {
                if (typeof item.label === "function") {
                  label = t(
                    item.label(
                      elements,
                      appState,
                      actionManager.app
                    )
                  );
                } else {
                  label = t(item.label);
                }
              }
              return /* @__PURE__ */ jsx76(
                "li",
                {
                  "data-testid": actionName,
                  onClick: () => {
                    onClose(() => {
                      actionManager.executeAction(item, "contextMenu");
                    });
                  },
                  children: /* @__PURE__ */ jsxs41(
                    "button",
                    {
                      type: "button",
                      className: clsx34("context-menu-item", {
                        dangerous: actionName === "deleteSelectedElements",
                        checkmark: item.checked?.(appState)
                      }),
                      children: [
                        /* @__PURE__ */ jsx76("div", { className: "context-menu-item__label", children: label }),
                        /* @__PURE__ */ jsx76("kbd", { className: "context-menu-item__shortcut", children: actionName ? getShortcutFromShortcutName(actionName) : "" })
                      ]
                    }
                  )
                },
                idx
              );
            })
          }
        )
      }
    );
  }
);

// components/LayerUI.tsx
init_define_import_meta_env();
init_constants();
init_element();
import clsx54 from "clsx";
import React40 from "react";
init_scene();
init_utils2();

// components/ErrorDialog.tsx
init_define_import_meta_env();
import React30, { useState as useState25 } from "react";
import { Fragment as Fragment11, jsx as jsx77 } from "react/jsx-runtime";
var ErrorDialog = ({
  children,
  onClose
}) => {
  const [modalIsShown, setModalIsShown] = useState25(!!children);
  const { container: excalidrawContainer } = useExcalidrawContainer();
  const handleClose = React30.useCallback(() => {
    setModalIsShown(false);
    if (onClose) {
      onClose();
    }
    excalidrawContainer?.focus();
  }, [onClose, excalidrawContainer]);
  return /* @__PURE__ */ jsx77(Fragment11, { children: modalIsShown && /* @__PURE__ */ jsx77(
    Dialog,
    {
      size: "small",
      onCloseRequest: handleClose,
      title: t("errorDialog.title"),
      children: /* @__PURE__ */ jsx77("div", { style: { whiteSpace: "pre-wrap" }, children })
    }
  ) });
};

// components/ImageExportDialog.tsx
init_define_import_meta_env();
import { useEffect as useEffect28, useRef as useRef25, useState as useState28 } from "react";
init_clipboard();
init_constants();
init_blob();
init_filesystem();
init_scene();
init_export2();
init_icons();

// components/RadioGroup.tsx
init_define_import_meta_env();
import clsx35 from "clsx";
import { jsx as jsx78, jsxs as jsxs42 } from "react/jsx-runtime";
var RadioGroup = function({
  onChange,
  value,
  choices,
  name
}) {
  return /* @__PURE__ */ jsx78("div", { className: "RadioGroup", children: choices.map((choice) => /* @__PURE__ */ jsxs42(
    "div",
    {
      className: clsx35("RadioGroup__choice", {
        active: choice.value === value
      }),
      title: choice.ariaLabel,
      children: [
        /* @__PURE__ */ jsx78(
          "input",
          {
            name,
            type: "radio",
            checked: choice.value === value,
            onChange: () => onChange(choice.value),
            "aria-label": choice.ariaLabel
          }
        ),
        choice.label
      ]
    },
    String(choice.value)
  )) });
};

// components/Switch.tsx
init_define_import_meta_env();
import clsx36 from "clsx";
import { jsx as jsx79 } from "react/jsx-runtime";
var Switch = ({
  title,
  name,
  checked,
  onChange,
  disabled = false
}) => {
  return /* @__PURE__ */ jsx79("div", { className: clsx36("Switch", { toggled: checked, disabled }), children: /* @__PURE__ */ jsx79(
    "input",
    {
      name,
      id: name,
      title,
      type: "checkbox",
      checked,
      disabled,
      onChange: () => onChange(!checked),
      onKeyDown: (event) => {
        if (event.key === " ") {
          onChange(!checked);
        }
      }
    }
  ) });
};

// components/FilledButton.tsx
init_define_import_meta_env();
import { forwardRef as forwardRef4, useState as useState26 } from "react";
import clsx37 from "clsx";
init_errors();
init_utils2();
init_icons();
import { jsx as jsx80, jsxs as jsxs43 } from "react/jsx-runtime";
var FilledButton = forwardRef4(
  ({
    children,
    icon,
    onClick,
    label,
    variant = "filled",
    color = "primary",
    size = "medium",
    fullWidth,
    className,
    status
  }, ref) => {
    const [isLoading, setIsLoading] = useState26(false);
    const _onClick = async (event) => {
      const ret = onClick?.(event);
      if (isPromiseLike(ret)) {
        const timer = window.setTimeout(() => {
          setIsLoading(true);
        }, 50);
        try {
          await ret;
        } catch (error) {
          if (!(error instanceof AbortError)) {
            throw error;
          } else {
            console.warn(error);
          }
        } finally {
          clearTimeout(timer);
          setIsLoading(false);
        }
      }
    };
    const _status = isLoading ? "loading" : status;
    color = _status === "success" ? "success" : color;
    return /* @__PURE__ */ jsx80(
      "button",
      {
        className: clsx37(
          "ExcButton",
          `ExcButton--color-${color}`,
          `ExcButton--variant-${variant}`,
          `ExcButton--size-${size}`,
          `ExcButton--status-${_status}`,
          { "ExcButton--fullWidth": fullWidth },
          className
        ),
        onClick: _onClick,
        type: "button",
        "aria-label": label,
        ref,
        disabled: _status === "loading" || _status === "success",
        children: /* @__PURE__ */ jsxs43("div", { className: "ExcButton__contents", children: [
          _status === "loading" ? /* @__PURE__ */ jsx80(Spinner_default, { className: "ExcButton__statusIcon" }) : _status === "success" && /* @__PURE__ */ jsx80("div", { className: "ExcButton__statusIcon", children: tablerCheckIcon }),
          icon && /* @__PURE__ */ jsx80("div", { className: "ExcButton__icon", "aria-hidden": true, children: icon }),
          variant !== "icon" && (children ?? label)
        ] })
      }
    );
  }
);

// components/ImageExportDialog.tsx
init_utils2();

// hooks/useCopiedIndicator.ts
init_define_import_meta_env();
import { useCallback as useCallback11, useRef as useRef24, useState as useState27 } from "react";
var TIMEOUT = 2e3;
var useCopyStatus = () => {
  const [copyStatus, setCopyStatus] = useState27(null);
  const timeoutRef = useRef24(0);
  const onCopy = () => {
    clearTimeout(timeoutRef.current);
    setCopyStatus("success");
    timeoutRef.current = window.setTimeout(() => {
      setCopyStatus(null);
    }, TIMEOUT);
  };
  const resetCopyStatus = useCallback11(() => {
    setCopyStatus(null);
  }, []);
  return {
    copyStatus,
    resetCopyStatus,
    onCopy
  };
};

// components/ImageExportDialog.tsx
import { jsx as jsx81, jsxs as jsxs44 } from "react/jsx-runtime";
var supportsContextFilters = "filter" in document.createElement("canvas").getContext("2d");
var ErrorCanvasPreview = () => {
  return /* @__PURE__ */ jsxs44("div", { children: [
    /* @__PURE__ */ jsx81("h3", { children: t("canvasError.cannotShowPreview") }),
    /* @__PURE__ */ jsx81("p", { children: /* @__PURE__ */ jsx81("span", { children: t("canvasError.canvasTooBig") }) }),
    /* @__PURE__ */ jsxs44("em", { children: [
      "(",
      t("canvasError.canvasTooBigTip"),
      ")"
    ] })
  ] });
};
var ImageExportModal = ({
  appStateSnapshot,
  elementsSnapshot,
  files,
  actionManager,
  onExportImage,
  name
}) => {
  const hasSelection = isSomeElementSelected(
    elementsSnapshot,
    appStateSnapshot
  );
  const [projectName, setProjectName] = useState28(name);
  const [exportSelectionOnly, setExportSelectionOnly] = useState28(hasSelection);
  const [exportWithBackground, setExportWithBackground] = useState28(
    appStateSnapshot.exportBackground
  );
  const [exportDarkMode, setExportDarkMode] = useState28(
    appStateSnapshot.exportWithDarkMode
  );
  const [embedScene, setEmbedScene] = useState28(
    appStateSnapshot.exportEmbedScene
  );
  const [exportScale, setExportScale] = useState28(appStateSnapshot.exportScale);
  const previewRef = useRef25(null);
  const [renderError, setRenderError] = useState28(null);
  const { onCopy, copyStatus, resetCopyStatus } = useCopyStatus();
  useEffect28(() => {
    resetCopyStatus();
  }, [
    projectName,
    exportWithBackground,
    exportDarkMode,
    exportScale,
    embedScene,
    resetCopyStatus
  ]);
  const { exportedElements, exportingFrame } = prepareElementsForExport(
    elementsSnapshot,
    appStateSnapshot,
    exportSelectionOnly
  );
  useEffect28(() => {
    const previewNode = previewRef.current;
    if (!previewNode) {
      return;
    }
    const maxWidth = previewNode.offsetWidth;
    const maxHeight = previewNode.offsetHeight;
    if (!maxWidth) {
      return;
    }
    exportToCanvas2({
      elements: exportedElements,
      appState: {
        ...appStateSnapshot,
        name: projectName,
        exportBackground: exportWithBackground,
        exportWithDarkMode: exportDarkMode,
        exportScale,
        exportEmbedScene: embedScene
      },
      files,
      exportPadding: DEFAULT_EXPORT_PADDING,
      maxWidthOrHeight: Math.max(maxWidth, maxHeight),
      exportingFrame
    }).then((canvas2) => {
      setRenderError(null);
      return canvasToBlob(canvas2).then(() => {
        previewNode.replaceChildren(canvas2);
      }).catch((e) => {
        if (e.name === "CANVAS_POSSIBLY_TOO_BIG") {
          throw new Error(t("canvasError.canvasTooBig"));
        }
        throw e;
      });
    }).catch((error) => {
      console.error(error);
      setRenderError(error);
    });
  }, [
    appStateSnapshot,
    files,
    exportedElements,
    exportingFrame,
    projectName,
    exportWithBackground,
    exportDarkMode,
    exportScale,
    embedScene
  ]);
  return /* @__PURE__ */ jsxs44("div", { className: "ImageExportModal", children: [
    /* @__PURE__ */ jsx81("h3", { children: t("imageExportDialog.header") }),
    /* @__PURE__ */ jsxs44("div", { className: "ImageExportModal__preview", children: [
      /* @__PURE__ */ jsx81("div", { className: "ImageExportModal__preview__canvas", ref: previewRef, children: renderError && /* @__PURE__ */ jsx81(ErrorCanvasPreview, {}) }),
      /* @__PURE__ */ jsx81("div", { className: "ImageExportModal__preview__filename", children: !nativeFileSystemSupported && /* @__PURE__ */ jsx81(
        "input",
        {
          type: "text",
          className: "TextInput",
          value: projectName,
          style: { width: "30ch" },
          onChange: (event) => {
            setProjectName(event.target.value);
            actionManager.executeAction(
              actionChangeProjectName,
              "ui",
              event.target.value
            );
          }
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxs44("div", { className: "ImageExportModal__settings", children: [
      /* @__PURE__ */ jsx81("h3", { children: t("imageExportDialog.header") }),
      hasSelection && /* @__PURE__ */ jsx81(
        ExportSetting,
        {
          label: t("imageExportDialog.label.onlySelected"),
          name: "exportOnlySelected",
          children: /* @__PURE__ */ jsx81(
            Switch,
            {
              name: "exportOnlySelected",
              checked: exportSelectionOnly,
              onChange: (checked) => {
                setExportSelectionOnly(checked);
              }
            }
          )
        }
      ),
      /* @__PURE__ */ jsx81(
        ExportSetting,
        {
          label: t("imageExportDialog.label.withBackground"),
          name: "exportBackgroundSwitch",
          children: /* @__PURE__ */ jsx81(
            Switch,
            {
              name: "exportBackgroundSwitch",
              checked: exportWithBackground,
              onChange: (checked) => {
                setExportWithBackground(checked);
                actionManager.executeAction(
                  actionChangeExportBackground,
                  "ui",
                  checked
                );
              }
            }
          )
        }
      ),
      supportsContextFilters && /* @__PURE__ */ jsx81(
        ExportSetting,
        {
          label: t("imageExportDialog.label.darkMode"),
          name: "exportDarkModeSwitch",
          children: /* @__PURE__ */ jsx81(
            Switch,
            {
              name: "exportDarkModeSwitch",
              checked: exportDarkMode,
              onChange: (checked) => {
                setExportDarkMode(checked);
                actionManager.executeAction(
                  actionExportWithDarkMode,
                  "ui",
                  checked
                );
              }
            }
          )
        }
      ),
      /* @__PURE__ */ jsx81(
        ExportSetting,
        {
          label: t("imageExportDialog.label.embedScene"),
          tooltip: t("imageExportDialog.tooltip.embedScene"),
          name: "exportEmbedSwitch",
          children: /* @__PURE__ */ jsx81(
            Switch,
            {
              name: "exportEmbedSwitch",
              checked: embedScene,
              onChange: (checked) => {
                setEmbedScene(checked);
                actionManager.executeAction(
                  actionChangeExportEmbedScene,
                  "ui",
                  checked
                );
              }
            }
          )
        }
      ),
      /* @__PURE__ */ jsx81(
        ExportSetting,
        {
          label: t("imageExportDialog.label.scale"),
          name: "exportScale",
          children: /* @__PURE__ */ jsx81(
            RadioGroup,
            {
              name: "exportScale",
              value: exportScale,
              onChange: (scale) => {
                setExportScale(scale);
                actionManager.executeAction(actionChangeExportScale, "ui", scale);
              },
              choices: EXPORT_SCALES.map((scale) => ({
                value: scale,
                label: `${scale}\xD7`
              }))
            }
          )
        }
      ),
      /* @__PURE__ */ jsxs44("div", { className: "ImageExportModal__settings__buttons", children: [
        /* @__PURE__ */ jsx81(
          FilledButton,
          {
            className: "ImageExportModal__settings__buttons__button",
            label: t("imageExportDialog.title.exportToPng"),
            onClick: () => onExportImage(EXPORT_IMAGE_TYPES.png, exportedElements, {
              exportingFrame
            }),
            icon: downloadIcon,
            children: t("imageExportDialog.button.exportToPng")
          }
        ),
        /* @__PURE__ */ jsx81(
          FilledButton,
          {
            className: "ImageExportModal__settings__buttons__button",
            label: t("imageExportDialog.title.exportToSvg"),
            onClick: () => onExportImage(EXPORT_IMAGE_TYPES.svg, exportedElements, {
              exportingFrame
            }),
            icon: downloadIcon,
            children: t("imageExportDialog.button.exportToSvg")
          }
        ),
        (probablySupportsClipboardBlob || isFirefox) && /* @__PURE__ */ jsx81(
          FilledButton,
          {
            className: "ImageExportModal__settings__buttons__button",
            label: t("imageExportDialog.title.copyPngToClipboard"),
            status: copyStatus,
            onClick: async () => {
              await onExportImage(
                EXPORT_IMAGE_TYPES.clipboard,
                exportedElements,
                {
                  exportingFrame
                }
              );
              onCopy();
            },
            icon: copyIcon,
            children: t("imageExportDialog.button.copyPngToClipboard")
          }
        )
      ] })
    ] })
  ] });
};
var ExportSetting = ({
  label,
  children,
  tooltip,
  name
}) => {
  return /* @__PURE__ */ jsxs44("div", { className: "ImageExportModal__settings__setting", title: label, children: [
    /* @__PURE__ */ jsxs44(
      "label",
      {
        htmlFor: name,
        className: "ImageExportModal__settings__setting__label",
        children: [
          label,
          tooltip && /* @__PURE__ */ jsx81(Tooltip, { label: tooltip, long: true, children: helpIcon })
        ]
      }
    ),
    /* @__PURE__ */ jsx81("div", { className: "ImageExportModal__settings__setting__content", children })
  ] });
};
var ImageExportDialog = ({
  elements,
  appState,
  files,
  actionManager,
  onExportImage,
  onCloseRequest,
  name
}) => {
  const [{ appStateSnapshot, elementsSnapshot }] = useState28(() => {
    return {
      appStateSnapshot: cloneJSON(appState),
      elementsSnapshot: cloneJSON(elements)
    };
  });
  return /* @__PURE__ */ jsx81(Dialog, { onCloseRequest, size: "wide", title: false, children: /* @__PURE__ */ jsx81(
    ImageExportModal,
    {
      elementsSnapshot,
      appStateSnapshot,
      files,
      actionManager,
      onExportImage,
      name
    }
  ) });
};

// components/FixedSideContainer.tsx
init_define_import_meta_env();
import clsx38 from "clsx";
import { jsx as jsx82 } from "react/jsx-runtime";
var FixedSideContainer = ({
  children,
  side,
  className
}) => /* @__PURE__ */ jsx82(
  "div",
  {
    className: clsx38(
      "FixedSideContainer",
      `FixedSideContainer_side_${side}`,
      className
    ),
    children
  }
);

// components/HintViewer.tsx
init_define_import_meta_env();
init_typeChecks();
init_utils2();
init_appState();

// element/flowchart.ts
init_define_import_meta_env();
init_heading();
init_binding();
init_linearElementEditor();
init_newElement();
init_keys();
init_mutateElement();
init_frame();
init_typeChecks();
init_utils2();
init_math();
init_shapes();
var VERTICAL_OFFSET = 100;
var HORIZONTAL_OFFSET = 100;
var getLinkDirectionFromKey = (key) => {
  switch (key) {
    case KEYS.ARROW_UP:
      return "up";
    case KEYS.ARROW_DOWN:
      return "down";
    case KEYS.ARROW_RIGHT:
      return "right";
    case KEYS.ARROW_LEFT:
      return "left";
    default:
      return "right";
  }
};
var getNodeRelatives = (type, node, elementsMap, direction) => {
  const items = [...elementsMap.values()].reduce(
    (acc, el) => {
      let oppositeBinding;
      if (isElbowArrow(el) && // we want check existence of the opposite binding, in the direction
      // we're interested in
      (oppositeBinding = el[type === "predecessors" ? "startBinding" : "endBinding"]) && // similarly, we need to filter only arrows bound to target node
      el[type === "predecessors" ? "endBinding" : "startBinding"]?.elementId === node.id) {
        const relative = elementsMap.get(oppositeBinding.elementId);
        if (!relative) {
          return acc;
        }
        invariant(
          isBindableElement(relative),
          "not an ExcalidrawBindableElement"
        );
        const edgePoint = type === "predecessors" ? el.points[el.points.length - 1] : [0, 0];
        const heading = headingForPointFromElement(node, aabbForElement(node), [
          edgePoint[0] + el.x,
          edgePoint[1] + el.y
        ]);
        acc.push({
          relative,
          heading
        });
      }
      return acc;
    },
    []
  );
  switch (direction) {
    case "up":
      return items.filter((item) => compareHeading(item.heading, HEADING_UP)).map((item) => item.relative);
    case "down":
      return items.filter((item) => compareHeading(item.heading, HEADING_DOWN)).map((item) => item.relative);
    case "right":
      return items.filter((item) => compareHeading(item.heading, HEADING_RIGHT)).map((item) => item.relative);
    case "left":
      return items.filter((item) => compareHeading(item.heading, HEADING_LEFT)).map((item) => item.relative);
  }
};
var getSuccessors = (node, elementsMap, direction) => {
  return getNodeRelatives("successors", node, elementsMap, direction);
};
var getPredecessors = (node, elementsMap, direction) => {
  return getNodeRelatives("predecessors", node, elementsMap, direction);
};
var getOffsets = (element, linkedNodes, direction) => {
  const _HORIZONTAL_OFFSET = HORIZONTAL_OFFSET + element.width;
  if (direction === "up" || direction === "down") {
    const _VERTICAL_OFFSET2 = VERTICAL_OFFSET + element.height;
    const minX = element.x;
    const maxX = element.x + element.width;
    if (linkedNodes.every(
      (linkedNode) => linkedNode.x + linkedNode.width < minX || linkedNode.x > maxX
    )) {
      return {
        x: 0,
        y: _VERTICAL_OFFSET2 * (direction === "up" ? -1 : 1)
      };
    }
  } else if (direction === "right" || direction === "left") {
    const minY = element.y;
    const maxY = element.y + element.height;
    if (linkedNodes.every(
      (linkedNode) => linkedNode.y + linkedNode.height < minY || linkedNode.y > maxY
    )) {
      return {
        x: (HORIZONTAL_OFFSET + element.width) * (direction === "left" ? -1 : 1),
        y: 0
      };
    }
  }
  if (direction === "up" || direction === "down") {
    const _VERTICAL_OFFSET2 = VERTICAL_OFFSET + element.height;
    const y2 = linkedNodes.length === 0 ? _VERTICAL_OFFSET2 : _VERTICAL_OFFSET2;
    const x2 = linkedNodes.length === 0 ? 0 : (linkedNodes.length + 1) % 2 === 0 ? (linkedNodes.length + 1) / 2 * _HORIZONTAL_OFFSET : linkedNodes.length / 2 * _HORIZONTAL_OFFSET * -1;
    if (direction === "up") {
      return {
        x: x2,
        y: y2 * -1
      };
    }
    return {
      x: x2,
      y: y2
    };
  }
  const _VERTICAL_OFFSET = VERTICAL_OFFSET + element.height;
  const x = (linkedNodes.length === 0 ? HORIZONTAL_OFFSET : HORIZONTAL_OFFSET) + element.width;
  const y = linkedNodes.length === 0 ? 0 : (linkedNodes.length + 1) % 2 === 0 ? (linkedNodes.length + 1) / 2 * _VERTICAL_OFFSET : linkedNodes.length / 2 * _VERTICAL_OFFSET * -1;
  if (direction === "left") {
    return {
      x: x * -1,
      y
    };
  }
  return {
    x,
    y
  };
};
var addNewNode = (element, elementsMap, appState, direction) => {
  const successors = getSuccessors(element, elementsMap, direction);
  const predeccessors = getPredecessors(element, elementsMap, direction);
  const offsets = getOffsets(
    element,
    [...successors, ...predeccessors],
    direction
  );
  const nextNode = newElement({
    type: element.type,
    x: element.x + offsets.x,
    y: element.y + offsets.y,
    // TODO: extract this to a util
    width: element.width,
    height: element.height,
    roundness: element.roundness,
    roughness: element.roughness,
    backgroundColor: element.backgroundColor,
    strokeColor: element.strokeColor,
    strokeWidth: element.strokeWidth
  });
  invariant(
    isFlowchartNodeElement(nextNode),
    "not an ExcalidrawFlowchartNodeElement"
  );
  const bindingArrow = createBindingArrow(
    element,
    nextNode,
    elementsMap,
    direction,
    appState
  );
  return {
    nextNode,
    bindingArrow
  };
};
var addNewNodes = (startNode, elementsMap, appState, direction, numberOfNodes) => {
  const newNodes = [];
  for (let i = 0; i < numberOfNodes; i++) {
    let nextX;
    let nextY;
    if (direction === "left" || direction === "right") {
      const totalHeight = VERTICAL_OFFSET * (numberOfNodes - 1) + numberOfNodes * startNode.height;
      const startY = startNode.y + startNode.height / 2 - totalHeight / 2;
      let offsetX = HORIZONTAL_OFFSET + startNode.width;
      if (direction === "left") {
        offsetX *= -1;
      }
      nextX = startNode.x + offsetX;
      const offsetY = (VERTICAL_OFFSET + startNode.height) * i;
      nextY = startY + offsetY;
    } else {
      const totalWidth = HORIZONTAL_OFFSET * (numberOfNodes - 1) + numberOfNodes * startNode.width;
      const startX = startNode.x + startNode.width / 2 - totalWidth / 2;
      let offsetY = VERTICAL_OFFSET + startNode.height;
      if (direction === "up") {
        offsetY *= -1;
      }
      nextY = startNode.y + offsetY;
      const offsetX = (HORIZONTAL_OFFSET + startNode.width) * i;
      nextX = startX + offsetX;
    }
    const nextNode = newElement({
      type: startNode.type,
      x: nextX,
      y: nextY,
      // TODO: extract this to a util
      width: startNode.width,
      height: startNode.height,
      roundness: startNode.roundness,
      roughness: startNode.roughness,
      backgroundColor: startNode.backgroundColor,
      strokeColor: startNode.strokeColor,
      strokeWidth: startNode.strokeWidth
    });
    invariant(
      isFlowchartNodeElement(nextNode),
      "not an ExcalidrawFlowchartNodeElement"
    );
    const bindingArrow = createBindingArrow(
      startNode,
      nextNode,
      elementsMap,
      direction,
      appState
    );
    newNodes.push(nextNode);
    newNodes.push(bindingArrow);
  }
  return newNodes;
};
var createBindingArrow = (startBindingElement, endBindingElement, elementsMap, direction, appState) => {
  let startX;
  let startY;
  const PADDING = 6;
  switch (direction) {
    case "up": {
      startX = startBindingElement.x + startBindingElement.width / 2;
      startY = startBindingElement.y - PADDING;
      break;
    }
    case "down": {
      startX = startBindingElement.x + startBindingElement.width / 2;
      startY = startBindingElement.y + startBindingElement.height + PADDING;
      break;
    }
    case "right": {
      startX = startBindingElement.x + startBindingElement.width + PADDING;
      startY = startBindingElement.y + startBindingElement.height / 2;
      break;
    }
    case "left": {
      startX = startBindingElement.x - PADDING;
      startY = startBindingElement.y + startBindingElement.height / 2;
      break;
    }
  }
  let endX;
  let endY;
  switch (direction) {
    case "up": {
      endX = endBindingElement.x + endBindingElement.width / 2 - startX;
      endY = endBindingElement.y + endBindingElement.height - startY + PADDING;
      break;
    }
    case "down": {
      endX = endBindingElement.x + endBindingElement.width / 2 - startX;
      endY = endBindingElement.y - startY - PADDING;
      break;
    }
    case "right": {
      endX = endBindingElement.x - startX - PADDING;
      endY = endBindingElement.y - startY + endBindingElement.height / 2;
      break;
    }
    case "left": {
      endX = endBindingElement.x + endBindingElement.width - startX + PADDING;
      endY = endBindingElement.y - startY + endBindingElement.height / 2;
      break;
    }
  }
  const bindingArrow = newArrowElement({
    type: "arrow",
    x: startX,
    y: startY,
    startArrowhead: appState.currentItemStartArrowhead,
    endArrowhead: appState.currentItemEndArrowhead,
    strokeColor: appState.currentItemStrokeColor,
    strokeStyle: appState.currentItemStrokeStyle,
    strokeWidth: appState.currentItemStrokeWidth,
    points: [pointFrom(0, 0), pointFrom(endX, endY)],
    elbowed: true
  });
  bindLinearElement(
    bindingArrow,
    startBindingElement,
    "start",
    elementsMap
  );
  bindLinearElement(
    bindingArrow,
    endBindingElement,
    "end",
    elementsMap
  );
  const changedElements = /* @__PURE__ */ new Map();
  changedElements.set(
    startBindingElement.id,
    startBindingElement
  );
  changedElements.set(
    endBindingElement.id,
    endBindingElement
  );
  changedElements.set(
    bindingArrow.id,
    bindingArrow
  );
  LinearElementEditor.movePoints(
    bindingArrow,
    [
      {
        index: 1,
        point: bindingArrow.points[1]
      }
    ],
    elementsMap,
    void 0,
    {
      changedElements
    }
  );
  return bindingArrow;
};
var FlowChartNavigator = class {
  isExploring = false;
  // nodes that are ONE link away (successor and predecessor both included)
  sameLevelNodes = [];
  sameLevelIndex = 0;
  // set it to the opposite of the defalut creation direction
  direction = null;
  // for speedier navigation
  visitedNodes = /* @__PURE__ */ new Set();
  clear() {
    this.isExploring = false;
    this.sameLevelNodes = [];
    this.sameLevelIndex = 0;
    this.direction = null;
    this.visitedNodes.clear();
  }
  exploreByDirection(element, elementsMap, direction) {
    if (!isBindableElement(element)) {
      return null;
    }
    if (direction !== this.direction) {
      this.clear();
    }
    if (!this.visitedNodes.has(element.id)) {
      this.visitedNodes.add(element.id);
    }
    if (this.isExploring && direction === this.direction && this.sameLevelNodes.length > 1) {
      this.sameLevelIndex = (this.sameLevelIndex + 1) % this.sameLevelNodes.length;
      return this.sameLevelNodes[this.sameLevelIndex].id;
    }
    const nodes = [
      ...getSuccessors(element, elementsMap, direction),
      ...getPredecessors(element, elementsMap, direction)
    ];
    if (nodes.length > 0) {
      this.sameLevelIndex = 0;
      this.isExploring = true;
      this.sameLevelNodes = nodes;
      this.direction = direction;
      this.visitedNodes.add(nodes[0].id);
      return nodes[0].id;
    }
    if (direction === this.direction || !this.isExploring) {
      if (!this.isExploring) {
        this.visitedNodes.add(element.id);
      }
      const otherDirections = [
        "up",
        "right",
        "down",
        "left"
      ].filter((dir) => dir !== direction);
      const otherLinkedNodes = otherDirections.map((dir) => [
        ...getSuccessors(element, elementsMap, dir),
        ...getPredecessors(element, elementsMap, dir)
      ]).flat().filter((linkedNode) => !this.visitedNodes.has(linkedNode.id));
      for (const linkedNode of otherLinkedNodes) {
        if (!this.visitedNodes.has(linkedNode.id)) {
          this.visitedNodes.add(linkedNode.id);
          this.isExploring = true;
          this.direction = direction;
          return linkedNode.id;
        }
      }
    }
    return null;
  }
};
var FlowChartCreator = class {
  isCreatingChart = false;
  numberOfNodes = 0;
  direction = "right";
  pendingNodes = null;
  createNodes(startNode, elementsMap, appState, direction) {
    if (direction !== this.direction) {
      const { nextNode, bindingArrow } = addNewNode(
        startNode,
        elementsMap,
        appState,
        direction
      );
      this.numberOfNodes = 1;
      this.isCreatingChart = true;
      this.direction = direction;
      this.pendingNodes = [nextNode, bindingArrow];
    } else {
      this.numberOfNodes += 1;
      const newNodes = addNewNodes(
        startNode,
        elementsMap,
        appState,
        direction,
        this.numberOfNodes
      );
      this.isCreatingChart = true;
      this.direction = direction;
      this.pendingNodes = newNodes;
    }
    if (startNode.frameId) {
      const frame = elementsMap.get(startNode.frameId);
      invariant(
        frame && isFrameElement(frame),
        "not an ExcalidrawFrameElement"
      );
      if (frame && this.pendingNodes.every(
        (node) => elementsAreInFrameBounds([node], frame, elementsMap) || elementOverlapsWithFrame(node, frame, elementsMap)
      )) {
        this.pendingNodes = this.pendingNodes.map(
          (node) => mutateElement(
            node,
            {
              frameId: startNode.frameId
            },
            false
          )
        );
      }
    }
  }
  clear() {
    this.isCreatingChart = false;
    this.pendingNodes = null;
    this.direction = null;
    this.numberOfNodes = 0;
  }
};
var isNodeInFlowchart = (element, elementsMap) => {
  for (const [, el] of elementsMap) {
    if (el.type === "arrow" && (el.startBinding?.elementId === element.id || el.endBinding?.elementId === element.id)) {
      return true;
    }
  }
  return false;
};

// components/HintViewer.tsx
init_snapping();
init_constants();
import { jsx as jsx83 } from "react/jsx-runtime";
var getHints = ({
  appState,
  isMobile,
  device,
  app
}) => {
  const { activeTool, isResizing, isRotating, lastPointerDownWith } = appState;
  const multiMode = appState.multiElement !== null;
  if (appState.openSidebar?.name === DEFAULT_SIDEBAR.name && appState.openSidebar.tab === CANVAS_SEARCH_TAB && appState.searchMatches?.length) {
    return t("hints.dismissSearch");
  }
  if (appState.openSidebar && !device.editor.canFitSidebar) {
    return null;
  }
  if (isEraserActive(appState)) {
    return t("hints.eraserRevert");
  }
  if (activeTool.type === "arrow" || activeTool.type === "line") {
    if (multiMode) {
      return t("hints.linearElementMulti");
    }
    if (activeTool.type === "arrow") {
      return t("hints.arrowTool", { arrowShortcut: getShortcutKey("A") });
    }
    return t("hints.linearElement");
  }
  if (activeTool.type === "freedraw") {
    return t("hints.freeDraw");
  }
  if (activeTool.type === "text") {
    return t("hints.text");
  }
  if (activeTool.type === "embeddable") {
    return t("hints.embeddable");
  }
  if (appState.activeTool.type === "image" && appState.pendingImageElementId) {
    return t("hints.placeImage");
  }
  const selectedElements = app.scene.getSelectedElements(appState);
  if (isResizing && lastPointerDownWith === "mouse" && selectedElements.length === 1) {
    const targetElement = selectedElements[0];
    if (isLinearElement(targetElement) && targetElement.points.length === 2) {
      return t("hints.lockAngle");
    }
    return isImageElement(targetElement) ? t("hints.resizeImage") : t("hints.resize");
  }
  if (isRotating && lastPointerDownWith === "mouse") {
    return t("hints.rotate");
  }
  if (selectedElements.length === 1 && isTextElement(selectedElements[0])) {
    return t("hints.text_selected");
  }
  if (appState.editingTextElement) {
    return t("hints.text_editing");
  }
  if (activeTool.type === "selection") {
    if (appState.selectionElement && !selectedElements.length && !appState.editingTextElement && !appState.editingLinearElement) {
      if (isGridModeEnabled(app) && appState.selectedElementsAreBeingDragged) {
        return t("hints.disableSnapping");
      }
    }
    if (selectedElements.length === 1) {
      if (isLinearElement(selectedElements[0])) {
        if (appState.editingLinearElement) {
          return appState.editingLinearElement.selectedPointsIndices ? t("hints.lineEditor_pointSelected") : t("hints.lineEditor_nothingSelected");
        }
        return t("hints.lineEditor_info");
      }
      if (!appState.newElement && !appState.selectedElementsAreBeingDragged && isTextBindableContainer(selectedElements[0])) {
        if (isFlowchartNodeElement(selectedElements[0])) {
          if (isNodeInFlowchart(
            selectedElements[0],
            app.scene.getNonDeletedElementsMap()
          )) {
            return [t("hints.bindTextToElement"), t("hints.createFlowchart")];
          }
          return [t("hints.bindTextToElement"), t("hints.createFlowchart")];
        }
        return t("hints.bindTextToElement");
      }
    }
  }
  return null;
};
var HintViewer = ({
  appState,
  isMobile,
  device,
  app
}) => {
  const hints = getHints({
    appState,
    isMobile,
    device,
    app
  });
  if (!hints) {
    return null;
  }
  const hint = Array.isArray(hints) ? hints.map((hint2) => {
    return getShortcutKey(hint2).replace(/\. ?$/, "");
  }).join(". ") : getShortcutKey(hints);
  return /* @__PURE__ */ jsx83("div", { className: "HintViewer", children: /* @__PURE__ */ jsx83("span", { children: hint }) });
};

// components/LockButton.tsx
init_define_import_meta_env();
init_icons();
import clsx39 from "clsx";
import { jsx as jsx84, jsxs as jsxs45 } from "react/jsx-runtime";
var DEFAULT_SIZE = "medium";
var ICONS2 = {
  CHECKED: LockedIcon,
  UNCHECKED: UnlockedIcon
};
var LockButton = (props) => {
  return /* @__PURE__ */ jsxs45(
    "label",
    {
      className: clsx39(
        "ToolIcon ToolIcon__lock",
        `ToolIcon_size_${DEFAULT_SIZE}`,
        {
          "is-mobile": props.isMobile
        }
      ),
      title: `${props.title} \u2014 Q`,
      children: [
        /* @__PURE__ */ jsx84(
          "input",
          {
            className: "ToolIcon_type_checkbox",
            type: "checkbox",
            name: props.name,
            onChange: props.onChange,
            checked: props.checked,
            "aria-label": props.title,
            "data-testid": "toolbar-lock"
          }
        ),
        /* @__PURE__ */ jsx84("div", { className: "ToolIcon__icon", children: props.checked ? ICONS2.CHECKED : ICONS2.UNCHECKED })
      ]
    }
  );
};

// components/MobileMenu.tsx
init_define_import_meta_env();
init_element();
init_scene();

// components/Section.tsx
init_define_import_meta_env();
import { Fragment as Fragment12, jsx as jsx85, jsxs as jsxs46 } from "react/jsx-runtime";
var Section = ({ heading, children, ...props }) => {
  const { id } = useExcalidrawContainer();
  const header = /* @__PURE__ */ jsx85("h2", { className: "visually-hidden", id: `${id}-${heading}-title`, children: t(`headings.${heading}`) });
  return /* @__PURE__ */ jsx85("section", { ...props, "aria-labelledby": `${id}-${heading}-title`, style: { marginTop: 80 }, children: typeof children === "function" ? children(header) : /* @__PURE__ */ jsxs46(Fragment12, { children: [
    header,
    children
  ] }) });
};

// scene/scrollbars.ts
init_define_import_meta_env();
init_element();
init_utils2();
var SCROLLBAR_MARGIN = 4;
var SCROLLBAR_WIDTH = 6;
var SCROLLBAR_COLOR = "rgba(0,0,0,0.3)";
var getScrollBars = (elements, viewportWidth, viewportHeight, appState) => {
  if (!elements.length) {
    return {
      horizontal: null,
      vertical: null
    };
  }
  const [elementsMinX, elementsMinY, elementsMaxX, elementsMaxY] = getCommonBounds(elements);
  const viewportWidthWithZoom = viewportWidth / appState.zoom.value;
  const viewportHeightWithZoom = viewportHeight / appState.zoom.value;
  const viewportWidthDiff = viewportWidth - viewportWidthWithZoom;
  const viewportHeightDiff = viewportHeight - viewportHeightWithZoom;
  const safeArea = {
    top: parseInt(getGlobalCSSVariable("sat")) || 0,
    bottom: parseInt(getGlobalCSSVariable("sab")) || 0,
    left: parseInt(getGlobalCSSVariable("sal")) || 0,
    right: parseInt(getGlobalCSSVariable("sar")) || 0
  };
  const isRTL2 = getLanguage().rtl;
  const viewportMinX = -appState.scrollX + viewportWidthDiff / 2 + safeArea.left;
  const viewportMinY = -appState.scrollY + viewportHeightDiff / 2 + safeArea.top;
  const viewportMaxX = viewportMinX + viewportWidthWithZoom - safeArea.right;
  const viewportMaxY = viewportMinY + viewportHeightWithZoom - safeArea.bottom;
  const sceneMinX = Math.min(elementsMinX, viewportMinX);
  const sceneMinY = Math.min(elementsMinY, viewportMinY);
  const sceneMaxX = Math.max(elementsMaxX, viewportMaxX);
  const sceneMaxY = Math.max(elementsMaxY, viewportMaxY);
  return {
    horizontal: viewportMinX === sceneMinX && viewportMaxX === sceneMaxX ? null : {
      x: Math.max(safeArea.left, SCROLLBAR_MARGIN) + (viewportMinX - sceneMinX) / (sceneMaxX - sceneMinX) * viewportWidth,
      y: viewportHeight - SCROLLBAR_WIDTH - Math.max(SCROLLBAR_MARGIN, safeArea.bottom),
      width: (viewportMaxX - viewportMinX) / (sceneMaxX - sceneMinX) * viewportWidth - Math.max(SCROLLBAR_MARGIN * 2, safeArea.left + safeArea.right),
      height: SCROLLBAR_WIDTH
    },
    vertical: viewportMinY === sceneMinY && viewportMaxY === sceneMaxY ? null : {
      x: isRTL2 ? Math.max(safeArea.left, SCROLLBAR_MARGIN) : viewportWidth - SCROLLBAR_WIDTH - Math.max(safeArea.right, SCROLLBAR_MARGIN),
      y: (viewportMinY - sceneMinY) / (sceneMaxY - sceneMinY) * viewportHeight + Math.max(safeArea.top, SCROLLBAR_MARGIN),
      width: SCROLLBAR_WIDTH,
      height: (viewportMaxY - viewportMinY) / (sceneMaxY - sceneMinY) * viewportHeight - Math.max(SCROLLBAR_MARGIN * 2, safeArea.top + safeArea.bottom)
    }
  };
};
var isOverScrollBars = (scrollBars, x, y) => {
  const [isOverHorizontal, isOverVertical] = [
    scrollBars.horizontal,
    scrollBars.vertical
  ].map((scrollBar) => {
    return scrollBar != null && scrollBar.x <= x && x <= scrollBar.x + scrollBar.width && scrollBar.y <= y && y <= scrollBar.y + scrollBar.height;
  });
  const isOverEither = isOverHorizontal || isOverVertical;
  return { isOverEither, isOverHorizontal, isOverVertical };
};

// components/PenModeButton.tsx
init_define_import_meta_env();
init_icons();
import clsx40 from "clsx";
import { jsx as jsx86, jsxs as jsxs47 } from "react/jsx-runtime";
var DEFAULT_SIZE2 = "medium";
var PenModeButton = (props) => {
  if (!props.penDetected) {
    return null;
  }
  return /* @__PURE__ */ jsxs47(
    "label",
    {
      className: clsx40(
        "ToolIcon ToolIcon__penMode",
        `ToolIcon_size_${DEFAULT_SIZE2}`,
        {
          "is-mobile": props.isMobile
        }
      ),
      title: `${props.title}`,
      children: [
        /* @__PURE__ */ jsx86(
          "input",
          {
            className: "ToolIcon_type_checkbox",
            type: "checkbox",
            name: props.name,
            onChange: props.onChange,
            checked: props.checked,
            "aria-label": props.title
          }
        ),
        /* @__PURE__ */ jsx86("div", { className: "ToolIcon__icon", children: PenModeIcon })
      ]
    }
  );
};

// components/HandButton.tsx
init_define_import_meta_env();
import clsx41 from "clsx";
init_icons();
init_keys();
import { jsx as jsx87 } from "react/jsx-runtime";
var HandButton = (props) => {
  return /* @__PURE__ */ jsx87(
    ToolButton,
    {
      className: clsx41("Shape", { fillable: false }),
      type: "radio",
      icon: handIcon,
      name: "editor-current-shape",
      checked: props.checked,
      title: `${props.title} \u2014 H`,
      keyBindingLabel: !props.isMobile ? KEYS.H.toLocaleUpperCase() : void 0,
      "aria-label": `${props.title} \u2014 H`,
      "aria-keyshortcuts": KEYS.H,
      "data-testid": `toolbar-hand`,
      onChange: () => props.onChange?.()
    }
  );
};

// components/MobileMenu.tsx
init_appState();
import { Fragment as Fragment13, jsx as jsx88, jsxs as jsxs48 } from "react/jsx-runtime";
var MobileMenu = ({
  appState,
  elements,
  actionManager,
  setAppState,
  onLockToggle,
  onHandToolToggle,
  onPenModeToggle,
  renderTopRightUI,
  renderCustomStats,
  renderSidebars,
  device,
  renderWelcomeScreen,
  UIOptions,
  app
}) => {
  const {
    WelcomeScreenCenterTunnel,
    MainMenuTunnel,
    DefaultSidebarTriggerTunnel
  } = useTunnels();
  const renderToolbar = () => {
    return /* @__PURE__ */ jsxs48(FixedSideContainer, { side: "top", className: "App-top-bar", children: [
      renderWelcomeScreen && /* @__PURE__ */ jsx88(WelcomeScreenCenterTunnel.Out, {}),
      /* @__PURE__ */ jsx88(Section, { heading: "shapes", children: (heading) => /* @__PURE__ */ jsx88(Stack_default.Col, { gap: 4, align: "center", children: /* @__PURE__ */ jsxs48(Stack_default.Row, { gap: 1, className: "App-toolbar-container", children: [
        /* @__PURE__ */ jsxs48(Island, { padding: 1, className: "App-toolbar App-toolbar--mobile", children: [
          heading,
          /* @__PURE__ */ jsx88(Stack_default.Row, { gap: 1, children: /* @__PURE__ */ jsx88(
            ShapesSwitcher,
            {
              appState,
              activeTool: appState.activeTool,
              UIOptions,
              app
            }
          ) })
        ] }),
        renderTopRightUI && renderTopRightUI(true, appState),
        /* @__PURE__ */ jsxs48("div", { className: "mobile-misc-tools-container", children: [
          !appState.viewModeEnabled && /* @__PURE__ */ jsx88(DefaultSidebarTriggerTunnel.Out, {}),
          /* @__PURE__ */ jsx88(
            PenModeButton,
            {
              checked: appState.penMode,
              onChange: () => onPenModeToggle(null),
              title: t("toolBar.penMode"),
              isMobile: true,
              penDetected: appState.penDetected
            }
          ),
          /* @__PURE__ */ jsx88(
            LockButton,
            {
              checked: appState.activeTool.locked,
              onChange: onLockToggle,
              title: t("toolBar.lock"),
              isMobile: true
            }
          ),
          /* @__PURE__ */ jsx88(
            HandButton,
            {
              checked: isHandToolActive(appState),
              onChange: () => onHandToolToggle(),
              title: t("toolBar.hand"),
              isMobile: true
            }
          )
        ] })
      ] }) }) }),
      /* @__PURE__ */ jsx88(
        HintViewer,
        {
          appState,
          isMobile: true,
          device,
          app
        }
      )
    ] });
  };
  const renderAppToolbar = () => {
    if (appState.viewModeEnabled) {
      return /* @__PURE__ */ jsx88("div", { className: "App-toolbar-content", children: /* @__PURE__ */ jsx88(MainMenuTunnel.Out, {}) });
    }
    return /* @__PURE__ */ jsxs48("div", { className: "App-toolbar-content", children: [
      /* @__PURE__ */ jsx88(MainMenuTunnel.Out, {}),
      actionManager.renderAction("toggleEditMenu"),
      actionManager.renderAction("undo"),
      actionManager.renderAction("redo"),
      actionManager.renderAction(
        appState.multiElement ? "finalize" : "duplicateSelection"
      ),
      actionManager.renderAction("deleteSelectedElements")
    ] });
  };
  return /* @__PURE__ */ jsxs48(Fragment13, { children: [
    renderSidebars(),
    !appState.viewModeEnabled && renderToolbar(),
    /* @__PURE__ */ jsx88(
      "div",
      {
        className: "App-bottom-bar",
        style: {
          marginBottom: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2,
          marginLeft: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2,
          marginRight: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2
        },
        children: /* @__PURE__ */ jsxs48(Island, { padding: 0, children: [
          appState.openMenu === "shape" && !appState.viewModeEnabled && showSelectedShapeActions(appState, elements) ? /* @__PURE__ */ jsx88(Section, { className: "App-mobile-menu", heading: "selectedShapeActions", children: /* @__PURE__ */ jsx88(
            SelectedShapeActions,
            {
              appState,
              elementsMap: app.scene.getNonDeletedElementsMap(),
              renderAction: actionManager.renderAction
            }
          ) }) : null,
          /* @__PURE__ */ jsxs48("footer", { className: "App-toolbar", children: [
            renderAppToolbar(),
            appState.scrolledOutside && !appState.openMenu && !appState.openSidebar && /* @__PURE__ */ jsx88(
              "button",
              {
                type: "button",
                className: "scroll-back-to-content",
                onClick: () => {
                  setAppState((appState2) => ({
                    ...calculateScrollCenter(elements, appState2)
                  }));
                },
                children: t("buttons.scrollBackToContent")
              }
            )
          ] })
        ] })
      }
    )
  ] });
};

// components/PasteChartDialog.tsx
init_define_import_meta_env();
import oc3 from "open-color";
import React33, { useLayoutEffect as useLayoutEffect6, useRef as useRef26, useState as useState29 } from "react";
init_charts();
init_export();
import { jsx as jsx89, jsxs as jsxs49 } from "react/jsx-runtime";
var ChartPreviewBtn = (props) => {
  const previewRef = useRef26(null);
  const [chartElements, setChartElements] = useState29(
    null
  );
  useLayoutEffect6(() => {
    if (!props.spreadsheet) {
      return;
    }
    const elements = renderSpreadsheet(
      props.chartType,
      props.spreadsheet,
      0,
      0
    );
    setChartElements(elements);
    let svg;
    const previewNode = previewRef.current;
    (async () => {
      svg = await exportToSvg(
        elements,
        {
          exportBackground: false,
          viewBackgroundColor: oc3.white
        },
        null
        // files
      );
      svg.querySelector(".style-fonts")?.remove();
      previewNode.replaceChildren();
      previewNode.appendChild(svg);
      if (props.selected) {
        previewNode.parentNode.focus();
      }
    })();
    return () => {
      previewNode.replaceChildren();
    };
  }, [props.spreadsheet, props.chartType, props.selected]);
  return /* @__PURE__ */ jsx89(
    "button",
    {
      type: "button",
      className: "ChartPreview",
      onClick: () => {
        if (chartElements) {
          props.onClick(props.chartType, chartElements);
        }
      },
      children: /* @__PURE__ */ jsx89("div", { ref: previewRef })
    }
  );
};
var PasteChartDialog = ({
  setAppState,
  appState,
  onClose
}) => {
  const { onInsertElements } = useApp();
  const handleClose = React33.useCallback(() => {
    if (onClose) {
      onClose();
    }
  }, [onClose]);
  const handleChartClick = (chartType, elements) => {
    onInsertElements(elements);
    trackEvent("paste", "chart", chartType);
    setAppState({
      currentChartType: chartType,
      pasteDialog: {
        shown: false,
        data: null
      }
    });
  };
  return /* @__PURE__ */ jsx89(
    Dialog,
    {
      size: "small",
      onCloseRequest: handleClose,
      title: t("labels.pasteCharts"),
      className: "PasteChartDialog",
      autofocus: false,
      children: /* @__PURE__ */ jsxs49("div", { className: "container", children: [
        /* @__PURE__ */ jsx89(
          ChartPreviewBtn,
          {
            chartType: "bar",
            spreadsheet: appState.pasteDialog.data,
            selected: appState.currentChartType === "bar",
            onClick: handleChartClick
          }
        ),
        /* @__PURE__ */ jsx89(
          ChartPreviewBtn,
          {
            chartType: "line",
            spreadsheet: appState.pasteDialog.data,
            selected: appState.currentChartType === "line",
            onClick: handleChartClick
          }
        )
      ] })
    }
  );
};

// components/HelpDialog.tsx
init_define_import_meta_env();
import React34 from "react";
init_keys();
init_utils2();
init_clipboard();
init_constants();
import { Fragment as Fragment14, jsx as jsx90, jsxs as jsxs50 } from "react/jsx-runtime";
var Section2 = (props) => /* @__PURE__ */ jsxs50(Fragment14, { children: [
  /* @__PURE__ */ jsx90("h3", { children: props.title }),
  /* @__PURE__ */ jsx90("div", { className: "HelpDialog__islands-container", children: props.children })
] });
var ShortcutIsland = (props) => /* @__PURE__ */ jsxs50("div", { className: `HelpDialog__island ${props.className}`, children: [
  /* @__PURE__ */ jsx90("h4", { className: "HelpDialog__island-title", children: props.caption }),
  /* @__PURE__ */ jsx90("div", { className: "HelpDialog__island-content", children: props.children })
] });
function* intersperse(as, delim) {
  let first = true;
  for (const x of as) {
    if (!first) {
      yield delim;
    }
    first = false;
    yield x;
  }
}
var upperCaseSingleChars = (str) => {
  return str.replace(/\b[a-z]\b/, (c) => c.toUpperCase());
};
var Shortcut = ({
  label,
  shortcuts,
  isOr = true
}) => {
  const splitShortcutKeys = shortcuts.map((shortcut) => {
    const keys = shortcut.endsWith("++") ? [...shortcut.slice(0, -2).split("+"), "+"] : shortcut.split("+");
    return keys.map((key) => /* @__PURE__ */ jsx90(ShortcutKey, { children: upperCaseSingleChars(key) }, key));
  });
  return /* @__PURE__ */ jsxs50("div", { className: "HelpDialog__shortcut", children: [
    /* @__PURE__ */ jsx90("div", { children: label }),
    /* @__PURE__ */ jsx90("div", { className: "HelpDialog__key-container", children: [...intersperse(splitShortcutKeys, isOr ? t("helpDialog.or") : null)] })
  ] });
};
var ShortcutKey = (props) => /* @__PURE__ */ jsx90("kbd", { className: "HelpDialog__key", ...props });
var HelpDialog = ({ onClose }) => {
  const handleClose = React34.useCallback(() => {
    if (onClose) {
      onClose();
    }
  }, [onClose]);
  return /* @__PURE__ */ jsx90(Fragment14, { children: /* @__PURE__ */ jsx90(
    Dialog,
    {
      onCloseRequest: handleClose,
      title: t("helpDialog.title"),
      className: "HelpDialog",
      children: /* @__PURE__ */ jsxs50(Section2, { title: t("helpDialog.shortcuts"), children: [
        /* @__PURE__ */ jsxs50(
          ShortcutIsland,
          {
            className: "HelpDialog__island--tools",
            caption: t("helpDialog.tools"),
            children: [
              /* @__PURE__ */ jsx90(Shortcut, { label: t("toolBar.hand"), shortcuts: [KEYS.H] }),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("toolBar.selection"),
                  shortcuts: [KEYS.V, KEYS["1"]]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("toolBar.rectangle"),
                  shortcuts: [KEYS.R, KEYS["2"]]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("toolBar.diamond"),
                  shortcuts: [KEYS.D, KEYS["3"]]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("toolBar.ellipse"),
                  shortcuts: [KEYS.O, KEYS["4"]]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("toolBar.arrow"),
                  shortcuts: [KEYS.A, KEYS["5"]]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("toolBar.line"),
                  shortcuts: [KEYS.L, KEYS["6"]]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("toolBar.freedraw"),
                  shortcuts: [KEYS.P, KEYS["7"]]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("toolBar.text"),
                  shortcuts: [KEYS.T, KEYS["8"]]
                }
              ),
              /* @__PURE__ */ jsx90(Shortcut, { label: t("toolBar.image"), shortcuts: [KEYS["9"]] }),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("toolBar.eraser"),
                  shortcuts: [KEYS.E, KEYS["0"]]
                }
              ),
              /* @__PURE__ */ jsx90(Shortcut, { label: t("toolBar.frame"), shortcuts: [KEYS.F] }),
              /* @__PURE__ */ jsx90(Shortcut, { label: t("toolBar.laser"), shortcuts: [KEYS.K] }),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.eyeDropper"),
                  shortcuts: [KEYS.I, "Shift+S", "Shift+G"]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("helpDialog.editLineArrowPoints"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Enter")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("helpDialog.editText"),
                  shortcuts: [getShortcutKey("Enter")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("helpDialog.textNewLine"),
                  shortcuts: [
                    getShortcutKey("Enter"),
                    getShortcutKey("Shift+Enter")
                  ]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("helpDialog.textFinish"),
                  shortcuts: [
                    getShortcutKey("Esc"),
                    getShortcutKey("CtrlOrCmd+Enter")
                  ]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("helpDialog.curvedArrow"),
                  shortcuts: [
                    "A",
                    t("helpDialog.click"),
                    t("helpDialog.click"),
                    t("helpDialog.click")
                  ],
                  isOr: false
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("helpDialog.curvedLine"),
                  shortcuts: [
                    "L",
                    t("helpDialog.click"),
                    t("helpDialog.click"),
                    t("helpDialog.click")
                  ],
                  isOr: false
                }
              ),
              /* @__PURE__ */ jsx90(Shortcut, { label: t("toolBar.lock"), shortcuts: [KEYS.Q] }),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("helpDialog.preventBinding"),
                  shortcuts: [getShortcutKey("CtrlOrCmd")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("toolBar.link"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+K")]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxs50(
          ShortcutIsland,
          {
            className: "HelpDialog__island--view",
            caption: t("helpDialog.view"),
            children: [
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("buttons.zoomIn"),
                  shortcuts: [getShortcutKey("CtrlOrCmd++")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("buttons.zoomOut"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+-")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("buttons.resetZoom"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+0")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("helpDialog.zoomToFit"),
                  shortcuts: ["Shift+1"]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("helpDialog.zoomToSelection"),
                  shortcuts: ["Shift+2"]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("helpDialog.movePageUpDown"),
                  shortcuts: ["PgUp/PgDn"]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("helpDialog.movePageLeftRight"),
                  shortcuts: ["Shift+PgUp/PgDn"]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("buttons.zenMode"),
                  shortcuts: [getShortcutKey("Alt+Z")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("buttons.objectsSnapMode"),
                  shortcuts: [getShortcutKey("Alt+S")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.toggleGrid"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+'")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.viewMode"),
                  shortcuts: [getShortcutKey("Alt+R")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.toggleTheme"),
                  shortcuts: [getShortcutKey("Alt+Shift+D")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("stats.fullTitle"),
                  shortcuts: [getShortcutKey("Alt+/")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("search.title"),
                  shortcuts: [getShortcutFromShortcutName("searchMenu")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("commandPalette.title"),
                  shortcuts: isFirefox ? [getShortcutFromShortcutName("commandPalette")] : [
                    getShortcutFromShortcutName("commandPalette"),
                    getShortcutFromShortcutName("commandPalette", 1)
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxs50(
          ShortcutIsland,
          {
            className: "HelpDialog__island--editor",
            caption: t("helpDialog.editor"),
            children: [
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("helpDialog.createFlowchart"),
                  shortcuts: [getShortcutKey(`CtrlOrCmd+Arrow Key`)],
                  isOr: true
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("helpDialog.navigateFlowchart"),
                  shortcuts: [getShortcutKey(`Alt+Arrow Key`)],
                  isOr: true
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.moveCanvas"),
                  shortcuts: [
                    getShortcutKey(`Space+${t("helpDialog.drag")}`),
                    getShortcutKey(`Wheel+${t("helpDialog.drag")}`)
                  ],
                  isOr: true
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("buttons.clearReset"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Delete")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.delete"),
                  shortcuts: [getShortcutKey("Delete")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.cut"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+X")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.copy"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+C")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.paste"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+V")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.pasteAsPlaintext"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Shift+V")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.selectAll"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+A")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.multiSelect"),
                  shortcuts: [getShortcutKey(`Shift+${t("helpDialog.click")}`)]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("helpDialog.deepSelect"),
                  shortcuts: [getShortcutKey(`CtrlOrCmd+${t("helpDialog.click")}`)]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("helpDialog.deepBoxSelect"),
                  shortcuts: [getShortcutKey(`CtrlOrCmd+${t("helpDialog.drag")}`)]
                }
              ),
              (probablySupportsClipboardBlob || isFirefox) && /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.copyAsPng"),
                  shortcuts: [getShortcutKey("Shift+Alt+C")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.copyStyles"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Alt+C")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.pasteStyles"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Alt+V")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.sendToBack"),
                  shortcuts: [
                    isDarwin ? getShortcutKey("CtrlOrCmd+Alt+[") : getShortcutKey("CtrlOrCmd+Shift+[")
                  ]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.bringToFront"),
                  shortcuts: [
                    isDarwin ? getShortcutKey("CtrlOrCmd+Alt+]") : getShortcutKey("CtrlOrCmd+Shift+]")
                  ]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.sendBackward"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+[")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.bringForward"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+]")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.alignTop"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Shift+Up")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.alignBottom"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Shift+Down")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.alignLeft"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Shift+Left")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.alignRight"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Shift+Right")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.duplicateSelection"),
                  shortcuts: [
                    getShortcutKey("CtrlOrCmd+D"),
                    getShortcutKey(`Alt+${t("helpDialog.drag")}`)
                  ]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("helpDialog.toggleElementLock"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Shift+L")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("buttons.undo"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Z")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("buttons.redo"),
                  shortcuts: isWindows ? [
                    getShortcutKey("CtrlOrCmd+Y"),
                    getShortcutKey("CtrlOrCmd+Shift+Z")
                  ] : [getShortcutKey("CtrlOrCmd+Shift+Z")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.group"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+G")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.ungroup"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Shift+G")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.flipHorizontal"),
                  shortcuts: [getShortcutKey("Shift+H")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.flipVertical"),
                  shortcuts: [getShortcutKey("Shift+V")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.showStroke"),
                  shortcuts: [getShortcutKey("S")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.showBackground"),
                  shortcuts: [getShortcutKey("G")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.showFonts"),
                  shortcuts: [getShortcutKey("Shift+F")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.decreaseFontSize"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Shift+<")]
                }
              ),
              /* @__PURE__ */ jsx90(
                Shortcut,
                {
                  label: t("labels.increaseFontSize"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Shift+>")]
                }
              )
            ]
          }
        )
      ] })
    }
  ) });
};

// components/UserList.tsx
init_define_import_meta_env();
import React35, { useLayoutEffect as useLayoutEffect7 } from "react";
import clsx42 from "clsx";
import * as Popover6 from "@radix-ui/react-popover";
init_utils2();
init_constants();
import { Fragment as Fragment15, jsx as jsx91, jsxs as jsxs51 } from "react/jsx-runtime";
var DEFAULT_MAX_AVATARS = 4;
var SHOW_COLLABORATORS_FILTER_AT = 8;
var ConditionalTooltipWrapper = ({
  shouldWrap,
  children,
  username
}) => shouldWrap ? /* @__PURE__ */ jsx91(Tooltip, { label: username || "Unknown user", children }) : /* @__PURE__ */ jsx91(Fragment15, { children });
var renderCollaborator = ({
  actionManager,
  collaborator,
  socketId,
  withName = false,
  shouldWrapWithTooltip = false,
  isBeingFollowed
}) => {
  const data = {
    socketId,
    collaborator,
    withName,
    isBeingFollowed
  };
  const avatarJSX = actionManager.renderAction("goToCollaborator", data);
  return /* @__PURE__ */ jsx91(
    ConditionalTooltipWrapper,
    {
      username: collaborator.username,
      shouldWrap: shouldWrapWithTooltip,
      children: avatarJSX
    },
    socketId
  );
};
var collaboratorComparatorKeys = [
  "avatarUrl",
  "id",
  "socketId",
  "username",
  "isInCall",
  "isSpeaking",
  "isMuted"
];
var UserList = React35.memo(
  ({ className, mobile, collaborators, userToFollow }) => {
    const actionManager = useExcalidrawActionManager();
    const uniqueCollaboratorsMap = /* @__PURE__ */ new Map();
    collaborators.forEach((collaborator, socketId) => {
      const userId = collaborator.id || socketId;
      uniqueCollaboratorsMap.set(
        // filter on user id, else fall back on unique socketId
        userId,
        { ...collaborator, socketId }
      );
    });
    const uniqueCollaboratorsArray = Array.from(
      uniqueCollaboratorsMap.values()
    ).filter((collaborator) => collaborator.username?.trim());
    const [searchTerm, setSearchTerm] = React35.useState("");
    const filteredCollaborators = uniqueCollaboratorsArray.filter(
      (collaborator) => collaborator.username?.toLowerCase().includes(searchTerm)
    );
    const userListWrapper = React35.useRef(null);
    useLayoutEffect7(() => {
      if (userListWrapper.current) {
        const updateMaxAvatars = (width) => {
          const maxAvatars2 = Math.max(1, Math.min(8, Math.floor(width / 38)));
          setMaxAvatars(maxAvatars2);
        };
        updateMaxAvatars(userListWrapper.current.clientWidth);
        if (!supportsResizeObserver) {
          return;
        }
        const resizeObserver = new ResizeObserver((entries) => {
          for (const entry of entries) {
            const { width } = entry.contentRect;
            updateMaxAvatars(width);
          }
        });
        resizeObserver.observe(userListWrapper.current);
        return () => {
          resizeObserver.disconnect();
        };
      }
    }, []);
    const [maxAvatars, setMaxAvatars] = React35.useState(DEFAULT_MAX_AVATARS);
    const firstNCollaborators = uniqueCollaboratorsArray.slice(
      0,
      maxAvatars - 1
    );
    const firstNAvatarsJSX = firstNCollaborators.map(
      (collaborator) => renderCollaborator({
        actionManager,
        collaborator,
        socketId: collaborator.socketId,
        shouldWrapWithTooltip: true,
        isBeingFollowed: collaborator.socketId === userToFollow
      })
    );
    return mobile ? /* @__PURE__ */ jsx91("div", { className: clsx42("UserList UserList_mobile", className), children: uniqueCollaboratorsArray.map(
      (collaborator) => renderCollaborator({
        actionManager,
        collaborator,
        socketId: collaborator.socketId,
        shouldWrapWithTooltip: true,
        isBeingFollowed: collaborator.socketId === userToFollow
      })
    ) }) : /* @__PURE__ */ jsx91("div", { className: "UserList__wrapper", ref: userListWrapper, children: /* @__PURE__ */ jsxs51(
      "div",
      {
        className: clsx42("UserList", className),
        style: { [`--max-avatars`]: maxAvatars },
        children: [
          firstNAvatarsJSX,
          uniqueCollaboratorsArray.length > maxAvatars - 1 && /* @__PURE__ */ jsxs51(Popover6.Root, { children: [
            /* @__PURE__ */ jsxs51(Popover6.Trigger, { className: "UserList__more", children: [
              "+",
              uniqueCollaboratorsArray.length - maxAvatars + 1
            ] }),
            /* @__PURE__ */ jsx91(
              Popover6.Content,
              {
                style: {
                  zIndex: 2,
                  width: "15rem",
                  textAlign: "left"
                },
                align: "end",
                sideOffset: 10,
                children: /* @__PURE__ */ jsxs51(Island, { padding: 2, children: [
                  uniqueCollaboratorsArray.length >= SHOW_COLLABORATORS_FILTER_AT && /* @__PURE__ */ jsx91(
                    QuickSearch,
                    {
                      placeholder: t("quickSearch.placeholder"),
                      onChange: setSearchTerm
                    }
                  ),
                  /* @__PURE__ */ jsx91(
                    ScrollableList,
                    {
                      className: "dropdown-menu UserList__collaborators",
                      placeholder: t("userList.empty"),
                      children: filteredCollaborators.length > 0 ? [
                        /* @__PURE__ */ jsx91("div", { className: "hint", children: t("userList.hint.text") }),
                        filteredCollaborators.map(
                          (collaborator) => renderCollaborator({
                            actionManager,
                            collaborator,
                            socketId: collaborator.socketId,
                            withName: true,
                            isBeingFollowed: collaborator.socketId === userToFollow
                          })
                        )
                      ] : []
                    }
                  ),
                  /* @__PURE__ */ jsx91(
                    Popover6.Arrow,
                    {
                      width: 20,
                      height: 10,
                      style: {
                        fill: "var(--popup-bg-color)",
                        filter: "drop-shadow(rgba(0, 0, 0, 0.05) 0px 3px 2px)"
                      }
                    }
                  )
                ] })
              }
            )
          ] })
        ]
      }
    ) });
  },
  (prev, next) => {
    if (prev.collaborators.size !== next.collaborators.size || prev.mobile !== next.mobile || prev.className !== next.className || prev.userToFollow !== next.userToFollow) {
      return false;
    }
    const nextCollaboratorSocketIds = next.collaborators.keys();
    for (const [socketId, collaborator] of prev.collaborators) {
      const nextCollaborator = next.collaborators.get(socketId);
      if (!nextCollaborator || // this checks order of collaborators in the map is the same
      // as previous render
      socketId !== nextCollaboratorSocketIds.next().value || !isShallowEqual(
        collaborator,
        nextCollaborator,
        collaboratorComparatorKeys
      )) {
        return false;
      }
    }
    return true;
  }
);

// components/JSONExportDialog.tsx
init_define_import_meta_env();
import React36 from "react";
init_icons();

// components/Card.tsx
init_define_import_meta_env();
import OpenColor3 from "open-color";
import { jsx as jsx92 } from "react/jsx-runtime";
var Card = ({ children, color }) => {
  return /* @__PURE__ */ jsx92(
    "div",
    {
      className: "Card",
      style: {
        ["--card-color"]: color === "primary" ? "var(--color-primary)" : OpenColor3[color][7],
        ["--card-color-darker"]: color === "primary" ? "var(--color-primary-darker)" : OpenColor3[color][8],
        ["--card-color-darkest"]: color === "primary" ? "var(--color-primary-darkest)" : OpenColor3[color][9]
      },
      children
    }
  );
};

// components/JSONExportDialog.tsx
init_filesystem();
init_utils2();
import { Fragment as Fragment16, jsx as jsx93, jsxs as jsxs52 } from "react/jsx-runtime";
var JSONExportModal = ({
  elements,
  appState,
  setAppState,
  files,
  actionManager,
  exportOpts,
  canvas: canvas2,
  onCloseRequest
}) => {
  const { onExportToBackend } = exportOpts;
  return /* @__PURE__ */ jsx93("div", { className: "ExportDialog ExportDialog--json", children: /* @__PURE__ */ jsxs52("div", { className: "ExportDialog-cards", children: [
    exportOpts.saveFileToDisk && /* @__PURE__ */ jsxs52(Card, { color: "lime", children: [
      /* @__PURE__ */ jsx93("div", { className: "Card-icon", children: exportToFileIcon }),
      /* @__PURE__ */ jsx93("h2", { children: t("exportDialog.disk_title") }),
      /* @__PURE__ */ jsxs52("div", { className: "Card-details", children: [
        t("exportDialog.disk_details"),
        !nativeFileSystemSupported && actionManager.renderAction("changeProjectName")
      ] }),
      /* @__PURE__ */ jsx93(
        ToolButton,
        {
          className: "Card-button",
          type: "button",
          title: t("exportDialog.disk_button"),
          "aria-label": t("exportDialog.disk_button"),
          showAriaLabel: true,
          onClick: () => {
            actionManager.executeAction(actionSaveFileToDisk, "ui");
          }
        }
      )
    ] }),
    onExportToBackend && /* @__PURE__ */ jsxs52(Card, { color: "pink", children: [
      /* @__PURE__ */ jsx93("div", { className: "Card-icon", children: LinkIcon }),
      /* @__PURE__ */ jsx93("h2", { children: t("exportDialog.link_title") }),
      /* @__PURE__ */ jsx93("div", { className: "Card-details", children: t("exportDialog.link_details") }),
      /* @__PURE__ */ jsx93(
        ToolButton,
        {
          className: "Card-button",
          type: "button",
          title: t("exportDialog.link_button"),
          "aria-label": t("exportDialog.link_button"),
          showAriaLabel: true,
          onClick: async () => {
            try {
              trackEvent("export", "link", `ui (${getFrame()})`);
              await onExportToBackend(elements, appState, files);
              onCloseRequest();
            } catch (error) {
              setAppState({ errorMessage: error.message });
            }
          }
        }
      )
    ] }),
    exportOpts.renderCustomUI && exportOpts.renderCustomUI(elements, appState, files, canvas2)
  ] }) });
};
var JSONExportDialog = ({
  elements,
  appState,
  files,
  actionManager,
  exportOpts,
  canvas: canvas2,
  setAppState
}) => {
  const handleClose = React36.useCallback(() => {
    setAppState({ openDialog: null });
  }, [setAppState]);
  return /* @__PURE__ */ jsx93(Fragment16, { children: appState.openDialog?.name === "jsonExport" && /* @__PURE__ */ jsx93(Dialog, { onCloseRequest: handleClose, title: t("buttons.export"), children: /* @__PURE__ */ jsx93(
    JSONExportModal,
    {
      elements,
      appState,
      setAppState,
      files,
      actionManager,
      onCloseRequest: handleClose,
      exportOpts,
      canvas: canvas2
    }
  ) }) });
};

// components/footer/Footer.tsx
init_define_import_meta_env();
import clsx43 from "clsx";

// components/HelpButton.tsx
init_define_import_meta_env();
init_icons();
import { jsx as jsx94 } from "react/jsx-runtime";
var HelpButton = (props) => /* @__PURE__ */ jsx94(
  "button",
  {
    className: "help-icon",
    onClick: props.onClick,
    type: "button",
    title: `${t("helpDialog.title")} \u2014 ?`,
    "aria-label": t("helpDialog.title"),
    children: HelpIcon
  }
);

// components/footer/Footer.tsx
import { jsx as jsx95, jsxs as jsxs53 } from "react/jsx-runtime";
var Footer = ({
  appState,
  actionManager,
  showExitZenModeBtn,
  renderWelcomeScreen
}) => {
  const { FooterCenterTunnel, WelcomeScreenHelpHintTunnel } = useTunnels();
  const device = useDevice();
  const showFinalize = !appState.viewModeEnabled && appState.multiElement && device.isTouchScreen;
  return /* @__PURE__ */ jsxs53(
    "footer",
    {
      role: "contentinfo",
      className: "layer-ui__wrapper__footer App-menu App-menu_bottom",
      children: [
        /* @__PURE__ */ jsx95(
          "div",
          {
            className: clsx43("layer-ui__wrapper__footer-left zen-mode-transition", {
              "layer-ui__wrapper__footer-left--transition-left": appState.zenModeEnabled
            }),
            children: /* @__PURE__ */ jsx95(Stack_default.Col, { gap: 2, children: /* @__PURE__ */ jsxs53(Section, { heading: "canvasActions", children: [
              /* @__PURE__ */ jsx95(
                ZoomActions,
                {
                  renderAction: actionManager.renderAction,
                  zoom: appState.zoom
                }
              ),
              !appState.viewModeEnabled && /* @__PURE__ */ jsx95(
                UndoRedoActions,
                {
                  renderAction: actionManager.renderAction,
                  className: clsx43("zen-mode-transition", {
                    "layer-ui__wrapper__footer-left--transition-bottom": appState.zenModeEnabled
                  })
                }
              ),
              showFinalize && /* @__PURE__ */ jsx95(
                FinalizeAction,
                {
                  renderAction: actionManager.renderAction,
                  className: clsx43("zen-mode-transition", {
                    "layer-ui__wrapper__footer-left--transition-left": appState.zenModeEnabled
                  })
                }
              )
            ] }) })
          }
        ),
        /* @__PURE__ */ jsx95(FooterCenterTunnel.Out, {}),
        /* @__PURE__ */ jsx95(
          "div",
          {
            className: clsx43("layer-ui__wrapper__footer-right zen-mode-transition", {
              "transition-right": appState.zenModeEnabled
            }),
            children: /* @__PURE__ */ jsxs53("div", { style: { position: "relative" }, children: [
              renderWelcomeScreen && /* @__PURE__ */ jsx95(WelcomeScreenHelpHintTunnel.Out, {}),
              /* @__PURE__ */ jsx95(
                HelpButton,
                {
                  onClick: () => actionManager.executeAction(actionShortcuts)
                }
              )
            ] })
          }
        ),
        /* @__PURE__ */ jsx95(
          ExitZenModeAction,
          {
            actionManager,
            showExitZenModeBtn
          }
        )
      ]
    }
  );
};
var Footer_default = Footer;
Footer.displayName = "Footer";

// components/Sidebar/Sidebar.tsx
init_define_import_meta_env();
import {
  useEffect as useEffect29,
  useLayoutEffect as useLayoutEffect8,
  useRef as useRef27,
  useState as useState30,
  forwardRef as forwardRef5,
  useImperativeHandle as useImperativeHandle2,
  useCallback as useCallback12
} from "react";
import { atom as atom10, useSetAtom as useSetAtom3 } from "jotai";

// components/Sidebar/common.ts
init_define_import_meta_env();
import React37 from "react";
var SidebarPropsContext = React37.createContext({});

// components/Sidebar/SidebarHeader.tsx
init_define_import_meta_env();
import clsx44 from "clsx";
import { useContext as useContext2 } from "react";
init_icons();
import { jsx as jsx96, jsxs as jsxs54 } from "react/jsx-runtime";
var SidebarHeader = ({
  children,
  className
}) => {
  const device = useDevice();
  const props = useContext2(SidebarPropsContext);
  const renderDockButton = !!(device.editor.canFitSidebar && props.shouldRenderDockButton);
  return /* @__PURE__ */ jsxs54(
    "div",
    {
      className: clsx44("sidebar__header", className),
      "data-testid": "sidebar-header",
      children: [
        children,
        /* @__PURE__ */ jsxs54("div", { className: "sidebar__header__buttons", children: [
          renderDockButton && /* @__PURE__ */ jsx96(Tooltip, { label: t("labels.sidebarLock"), children: /* @__PURE__ */ jsx96(
            Button,
            {
              onSelect: () => props.onDock?.(!props.docked),
              selected: !!props.docked,
              className: "sidebar__dock",
              "data-testid": "sidebar-dock",
              "aria-label": t("labels.sidebarLock"),
              children: PinIcon
            }
          ) }),
          /* @__PURE__ */ jsx96(
            Button,
            {
              "data-testid": "sidebar-close",
              className: "sidebar__close",
              onSelect: props.onCloseRequest,
              "aria-label": t("buttons.close"),
              children: CloseIcon
            }
          )
        ] })
      ]
    }
  );
};
SidebarHeader.displayName = "SidebarHeader";

// components/Sidebar/Sidebar.tsx
import clsx46 from "clsx";
init_utils2();
init_keys();
init_constants();

// components/Sidebar/SidebarTrigger.tsx
init_define_import_meta_env();
import clsx45 from "clsx";
import { jsx as jsx97, jsxs as jsxs55 } from "react/jsx-runtime";
var SidebarTrigger = ({
  name,
  tab,
  icon,
  title,
  children,
  onToggle,
  className,
  style
}) => {
  const setAppState = useExcalidrawSetAppState();
  const appState = useUIAppState();
  return /* @__PURE__ */ jsxs55("label", { title, className: "sidebar-trigger__label-element", children: [
    /* @__PURE__ */ jsx97(
      "input",
      {
        className: "ToolIcon_type_checkbox",
        type: "checkbox",
        onChange: (event) => {
          document.querySelector(".layer-ui__wrapper")?.classList.remove("animate");
          const isOpen = event.target.checked;
          setAppState({ openSidebar: isOpen ? { name, tab } : null });
          onToggle?.(isOpen);
        },
        checked: appState.openSidebar?.name === name,
        "aria-label": title,
        "aria-keyshortcuts": "0"
      }
    ),
    /* @__PURE__ */ jsxs55("div", { className: clsx45("sidebar-trigger", className), style, children: [
      icon && /* @__PURE__ */ jsx97("div", { children: icon }),
      children && /* @__PURE__ */ jsx97("div", { className: "sidebar-trigger__label", children })
    ] })
  ] });
};
SidebarTrigger.displayName = "SidebarTrigger";

// components/Sidebar/SidebarTabTriggers.tsx
init_define_import_meta_env();
import * as RadixTabs from "@radix-ui/react-tabs";
import { jsx as jsx98 } from "react/jsx-runtime";
var SidebarTabTriggers = ({
  children,
  ...rest
}) => {
  return /* @__PURE__ */ jsx98(RadixTabs.List, { className: "sidebar-triggers", ...rest, children });
};
SidebarTabTriggers.displayName = "SidebarTabTriggers";

// components/Sidebar/SidebarTabTrigger.tsx
init_define_import_meta_env();
import * as RadixTabs2 from "@radix-ui/react-tabs";
import { jsx as jsx99 } from "react/jsx-runtime";
var SidebarTabTrigger = ({
  children,
  tab,
  onSelect,
  ...rest
}) => {
  return /* @__PURE__ */ jsx99(RadixTabs2.Trigger, { value: tab, asChild: true, onSelect, children: /* @__PURE__ */ jsx99(
    "button",
    {
      type: "button",
      className: `excalidraw-button sidebar-tab-trigger`,
      ...rest,
      children
    }
  ) });
};
SidebarTabTrigger.displayName = "SidebarTabTrigger";

// components/Sidebar/SidebarTabs.tsx
init_define_import_meta_env();
import * as RadixTabs3 from "@radix-ui/react-tabs";
import { jsx as jsx100 } from "react/jsx-runtime";
var SidebarTabs = ({
  children,
  ...rest
}) => {
  const appState = useUIAppState();
  const setAppState = useExcalidrawSetAppState();
  if (!appState.openSidebar) {
    return null;
  }
  const { name } = appState.openSidebar;
  return /* @__PURE__ */ jsx100(
    RadixTabs3.Root,
    {
      className: "sidebar-tabs-root",
      value: appState.openSidebar.tab,
      onValueChange: (tab) => setAppState((state) => ({
        ...state,
        openSidebar: { ...state.openSidebar, name, tab }
      })),
      ...rest,
      children
    }
  );
};
SidebarTabs.displayName = "SidebarTabs";

// components/Sidebar/SidebarTab.tsx
init_define_import_meta_env();
import * as RadixTabs4 from "@radix-ui/react-tabs";
import { jsx as jsx101 } from "react/jsx-runtime";
var SidebarTab = ({
  tab,
  children,
  ...rest
}) => {
  return /* @__PURE__ */ jsx101(RadixTabs4.Content, { ...rest, value: tab, "data-testid": tab, children });
};
SidebarTab.displayName = "SidebarTab";

// components/Sidebar/Sidebar.tsx
import { jsx as jsx102 } from "react/jsx-runtime";
import { createElement } from "react";
var isSidebarDockedAtom = atom10(false);
var SidebarInner = forwardRef5(
  ({
    name,
    children,
    onDock,
    docked,
    className,
    ...rest
  }, ref) => {
    if (define_import_meta_env_default.DEV && onDock && docked == null) {
      console.warn(
        "Sidebar: `docked` must be set when `onDock` is supplied for the sidebar to be user-dockable. To hide this message, either pass `docked` or remove `onDock`"
      );
    }
    const setAppState = useExcalidrawSetAppState();
    const setIsSidebarDockedAtom = useSetAtom3(isSidebarDockedAtom, jotaiScope);
    useLayoutEffect8(() => {
      setIsSidebarDockedAtom(!!docked);
      return () => {
        setIsSidebarDockedAtom(false);
      };
    }, [setIsSidebarDockedAtom, docked]);
    const headerPropsRef = useRef27(
      {}
    );
    headerPropsRef.current.onCloseRequest = () => {
      setAppState({ openSidebar: null });
    };
    headerPropsRef.current.onDock = (isDocked) => onDock?.(isDocked);
    headerPropsRef.current = updateObject(headerPropsRef.current, {
      docked,
      // explicit prop to rerender on update
      shouldRenderDockButton: !!onDock && docked != null
    });
    const islandRef = useRef27(null);
    useImperativeHandle2(ref, () => {
      return islandRef.current;
    });
    const device = useDevice();
    const closeLibrary = useCallback12(() => {
      const isDialogOpen = !!document.querySelector(".Dialog");
      if (isDialogOpen) {
        return;
      }
      setAppState({ openSidebar: null });
    }, [setAppState]);
    useOutsideClick(
      islandRef,
      useCallback12(
        (event) => {
          if (event.target.closest(".sidebar-trigger")) {
            return;
          }
          if (!docked || !device.editor.canFitSidebar) {
            closeLibrary();
          }
        },
        [closeLibrary, docked, device.editor.canFitSidebar]
      )
    );
    useEffect29(() => {
      const handleKeyDown = (event) => {
        if (event.key === KEYS.ESCAPE && (!docked || !device.editor.canFitSidebar)) {
          closeLibrary();
        }
      };
      document.addEventListener("keydown" /* KEYDOWN */, handleKeyDown);
      return () => {
        document.removeEventListener("keydown" /* KEYDOWN */, handleKeyDown);
      };
    }, [closeLibrary, docked, device.editor.canFitSidebar]);
    return /* @__PURE__ */ jsx102(
      Island,
      {
        ...rest,
        className: clsx46("sidebar", { "sidebar--docked": docked }, className),
        ref: islandRef,
        children: /* @__PURE__ */ jsx102(SidebarPropsContext.Provider, { value: headerPropsRef.current, children })
      }
    );
  }
);
SidebarInner.displayName = "SidebarInner";
var Sidebar = Object.assign(
  forwardRef5((props, ref) => {
    const appState = useUIAppState();
    const { onStateChange } = props;
    const refPrevOpenSidebar = useRef27(appState.openSidebar);
    useEffect29(() => {
      if (
        // closing sidebar
        (!appState.openSidebar && refPrevOpenSidebar?.current?.name === props.name || // opening current sidebar
        appState.openSidebar?.name === props.name && refPrevOpenSidebar?.current?.name !== props.name || // switching tabs or switching to a different sidebar
        refPrevOpenSidebar.current?.name === props.name) && appState.openSidebar !== refPrevOpenSidebar.current
      ) {
        onStateChange?.(
          appState.openSidebar?.name !== props.name ? null : appState.openSidebar
        );
      }
      refPrevOpenSidebar.current = appState.openSidebar;
    }, [appState.openSidebar, onStateChange, props.name]);
    const [mounted, setMounted] = useState30(false);
    useLayoutEffect8(() => {
      setMounted(true);
      return () => setMounted(false);
    }, []);
    const shouldRender = mounted && appState.openSidebar?.name === props.name;
    if (!shouldRender) {
      return null;
    }
    return /* @__PURE__ */ createElement(SidebarInner, { ...props, ref, key: props.name });
  }),
  {
    Header: SidebarHeader,
    TabTriggers: SidebarTabTriggers,
    TabTrigger: SidebarTabTrigger,
    Tabs: SidebarTabs,
    Tab: SidebarTab,
    Trigger: SidebarTrigger
  }
);
Sidebar.displayName = "Sidebar";

// components/LayerUI.tsx
import { Provider, useAtom as useAtom18, useAtomValue as useAtomValue2 } from "jotai";

// components/main-menu/MainMenu.tsx
init_define_import_meta_env();

// components/main-menu/DefaultItems.tsx
var DefaultItems_exports = {};
__export(DefaultItems_exports, {
  ChangeCanvasBackground: () => ChangeCanvasBackground,
  ClearCanvas: () => ClearCanvas,
  CommandPalette: () => CommandPalette2,
  Export: () => Export,
  Help: () => Help,
  LiveCollaborationTrigger: () => LiveCollaborationTrigger,
  LoadScene: () => LoadScene,
  SaveAsImage: () => SaveAsImage,
  SaveToActiveFile: () => SaveToActiveFile,
  SearchMenu: () => SearchMenu,
  Socials: () => Socials,
  ToggleTheme: () => ToggleTheme
});
init_define_import_meta_env();
init_icons();
import clsx47 from "clsx";
import { useSetAtom as useSetAtom4 } from "jotai";

// components/OverwriteConfirm/OverwriteConfirmState.ts
init_define_import_meta_env();
import { atom as atom11 } from "jotai";
var overwriteConfirmStateAtom = atom11({
  active: false
});
async function openConfirmModal({
  title,
  description,
  actionLabel,
  color
}) {
  return new Promise((resolve) => {
    jotaiStore.set(overwriteConfirmStateAtom, {
      active: true,
      onConfirm: () => resolve(true),
      onClose: () => resolve(false),
      onReject: () => resolve(false),
      title,
      description,
      actionLabel,
      color
    });
  });
}

// components/dropdownMenu/DropdownMenuItemContentRadio.tsx
init_define_import_meta_env();
import { Fragment as Fragment17, jsx as jsx103, jsxs as jsxs56 } from "react/jsx-runtime";
var DropdownMenuItemContentRadio = ({
  value,
  shortcut,
  onChange,
  choices,
  children,
  name
}) => {
  const device = useDevice();
  return /* @__PURE__ */ jsxs56(Fragment17, { children: [
    /* @__PURE__ */ jsxs56("div", { className: "dropdown-menu-item-base dropdown-menu-item-bare", children: [
      /* @__PURE__ */ jsx103("label", { className: "dropdown-menu-item__text", htmlFor: name, children }),
      /* @__PURE__ */ jsx103(
        RadioGroup,
        {
          name,
          value,
          onChange,
          choices
        }
      )
    ] }),
    shortcut && !device.editor.isMobile && /* @__PURE__ */ jsx103("div", { className: "dropdown-menu-item__shortcut dropdown-menu-item__shortcut--orphaned", children: shortcut })
  ] });
};
DropdownMenuItemContentRadio.displayName = "DropdownMenuItemContentRadio";
var DropdownMenuItemContentRadio_default = DropdownMenuItemContentRadio;

// components/main-menu/DefaultItems.tsx
init_constants();
import { Fragment as Fragment18, jsx as jsx104, jsxs as jsxs57 } from "react/jsx-runtime";
var LoadScene = () => {
  const { t: t2 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  const elements = useExcalidrawElements();
  if (!actionManager.isActionEnabled(actionLoadScene)) {
    return null;
  }
  const handleSelect = async () => {
    if (!elements.length || await openConfirmModal({
      title: t2("overwriteConfirm.modal.loadFromFile.title"),
      actionLabel: t2("overwriteConfirm.modal.loadFromFile.button"),
      color: "warning",
      description: /* @__PURE__ */ jsx104(
        Trans_default,
        {
          i18nKey: "overwriteConfirm.modal.loadFromFile.description",
          bold: (text) => /* @__PURE__ */ jsx104("strong", { children: text }),
          br: () => /* @__PURE__ */ jsx104("br", {})
        }
      )
    })) {
      actionManager.executeAction(actionLoadScene);
    }
  };
  return /* @__PURE__ */ jsx104(
    DropdownMenuItem_default,
    {
      icon: LoadIcon,
      onSelect: handleSelect,
      "data-testid": "load-button",
      shortcut: getShortcutFromShortcutName("loadScene"),
      "aria-label": t2("buttons.load"),
      children: t2("buttons.load")
    }
  );
};
LoadScene.displayName = "LoadScene";
var SaveToActiveFile = () => {
  const { t: t2 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  if (!actionManager.isActionEnabled(actionSaveToActiveFile)) {
    return null;
  }
  return /* @__PURE__ */ jsx104(
    DropdownMenuItem_default,
    {
      shortcut: getShortcutFromShortcutName("saveScene"),
      "data-testid": "save-button",
      onSelect: () => actionManager.executeAction(actionSaveToActiveFile),
      icon: save,
      "aria-label": `${t2("buttons.save")}`,
      children: `${t2("buttons.save")}`
    }
  );
};
SaveToActiveFile.displayName = "SaveToActiveFile";
var SaveAsImage = () => {
  const setAppState = useExcalidrawSetAppState();
  const { t: t2 } = useI18n();
  return /* @__PURE__ */ jsx104(
    DropdownMenuItem_default,
    {
      icon: ExportImageIcon,
      "data-testid": "image-export-button",
      onSelect: () => setAppState({ openDialog: { name: "imageExport" } }),
      shortcut: getShortcutFromShortcutName("imageExport"),
      "aria-label": t2("buttons.exportImage"),
      children: t2("buttons.exportImage")
    }
  );
};
SaveAsImage.displayName = "SaveAsImage";
var CommandPalette2 = (opts) => {
  const setAppState = useExcalidrawSetAppState();
  const { t: t2 } = useI18n();
  return /* @__PURE__ */ jsx104(
    DropdownMenuItem_default,
    {
      icon: boltIcon,
      "data-testid": "command-palette-button",
      onSelect: () => {
        trackEvent("command_palette", "open", "menu");
        setAppState({ openDialog: { name: "commandPalette" } });
      },
      shortcut: getShortcutFromShortcutName("commandPalette"),
      "aria-label": t2("commandPalette.title"),
      className: opts?.className,
      children: t2("commandPalette.title")
    }
  );
};
CommandPalette2.displayName = "CommandPalette";
var SearchMenu = (opts) => {
  const { t: t2 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  return /* @__PURE__ */ jsx104(
    DropdownMenuItem_default,
    {
      icon: searchIcon,
      "data-testid": "search-menu-button",
      onSelect: () => {
        actionManager.executeAction(actionToggleSearchMenu);
      },
      shortcut: getShortcutFromShortcutName("searchMenu"),
      "aria-label": t2("search.title"),
      className: opts?.className,
      children: t2("search.title")
    }
  );
};
SearchMenu.displayName = "SearchMenu";
var Help = () => {
  const { t: t2 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  return /* @__PURE__ */ jsx104(
    DropdownMenuItem_default,
    {
      "data-testid": "help-menu-item",
      icon: HelpIcon,
      onSelect: () => actionManager.executeAction(actionShortcuts),
      shortcut: "?",
      "aria-label": t2("helpDialog.title"),
      children: t2("helpDialog.title")
    }
  );
};
Help.displayName = "Help";
var ClearCanvas = () => {
  const { t: t2 } = useI18n();
  const setActiveConfirmDialog = useSetAtom4(
    activeConfirmDialogAtom,
    jotaiScope
  );
  const actionManager = useExcalidrawActionManager();
  if (!actionManager.isActionEnabled(actionClearCanvas)) {
    return null;
  }
  return /* @__PURE__ */ jsx104(
    DropdownMenuItem_default,
    {
      icon: TrashIcon,
      onSelect: () => setActiveConfirmDialog("clearCanvas"),
      "data-testid": "clear-canvas-button",
      "aria-label": t2("buttons.clearReset"),
      children: t2("buttons.clearReset")
    }
  );
};
ClearCanvas.displayName = "ClearCanvas";
var ToggleTheme = (props) => {
  const { t: t2 } = useI18n();
  const appState = useUIAppState();
  const actionManager = useExcalidrawActionManager();
  const shortcut = getShortcutFromShortcutName("toggleTheme");
  if (!actionManager.isActionEnabled(actionToggleTheme)) {
    return null;
  }
  if (props?.allowSystemTheme) {
    return /* @__PURE__ */ jsx104(
      DropdownMenuItemContentRadio_default,
      {
        name: "theme",
        value: props.theme,
        onChange: (value) => props.onSelect(value),
        choices: [
          {
            value: THEME.LIGHT,
            label: SunIcon,
            ariaLabel: `${t2("buttons.lightMode")} - ${shortcut}`
          },
          {
            value: THEME.DARK,
            label: MoonIcon,
            ariaLabel: `${t2("buttons.darkMode")} - ${shortcut}`
          },
          {
            value: "system",
            label: DeviceDesktopIcon,
            ariaLabel: t2("buttons.systemMode")
          }
        ],
        children: t2("labels.theme")
      }
    );
  }
  return /* @__PURE__ */ jsx104(
    DropdownMenuItem_default,
    {
      onSelect: (event) => {
        event.preventDefault();
        if (props?.onSelect) {
          props.onSelect(
            appState.theme === THEME.DARK ? THEME.LIGHT : THEME.DARK
          );
        } else {
          return actionManager.executeAction(actionToggleTheme);
        }
      },
      icon: appState.theme === THEME.DARK ? SunIcon : MoonIcon,
      "data-testid": "toggle-dark-mode",
      shortcut,
      "aria-label": appState.theme === THEME.DARK ? t2("buttons.lightMode") : t2("buttons.darkMode"),
      children: appState.theme === THEME.DARK ? t2("buttons.lightMode") : t2("buttons.darkMode")
    }
  );
};
ToggleTheme.displayName = "ToggleTheme";
var ChangeCanvasBackground = () => {
  const { t: t2 } = useI18n();
  const appState = useUIAppState();
  const actionManager = useExcalidrawActionManager();
  const appProps = useAppProps();
  if (appState.viewModeEnabled || !appProps.UIOptions.canvasActions.changeViewBackgroundColor) {
    return null;
  }
  return /* @__PURE__ */ jsxs57("div", { style: { marginTop: "0.5rem" }, children: [
    /* @__PURE__ */ jsx104(
      "div",
      {
        "data-testid": "canvas-background-label",
        style: { fontSize: ".75rem", marginBottom: ".5rem" },
        children: t2("labels.canvasBackground")
      }
    ),
    /* @__PURE__ */ jsx104("div", { style: { padding: "0 0.625rem" }, children: actionManager.renderAction("changeViewBackgroundColor") })
  ] });
};
ChangeCanvasBackground.displayName = "ChangeCanvasBackground";
var Export = () => {
  const { t: t2 } = useI18n();
  const setAppState = useExcalidrawSetAppState();
  return /* @__PURE__ */ jsx104(
    DropdownMenuItem_default,
    {
      icon: ExportIcon,
      onSelect: () => {
        setAppState({ openDialog: { name: "jsonExport" } });
      },
      "data-testid": "json-export-button",
      "aria-label": t2("buttons.export"),
      children: t2("buttons.export")
    }
  );
};
Export.displayName = "Export";
var Socials = () => {
  const { t: t2 } = useI18n();
  return /* @__PURE__ */ jsx104(Fragment18, {});
};
Socials.displayName = "Socials";
var LiveCollaborationTrigger = ({
  onSelect,
  isCollaborating
}) => {
  const { t: t2 } = useI18n();
  return /* @__PURE__ */ jsx104(
    DropdownMenuItem_default,
    {
      "data-testid": "collab-button",
      icon: usersIcon,
      className: clsx47({
        "active-collab": isCollaborating
      }),
      onSelect,
      children: t2("labels.liveCollaboration")
    }
  );
};
LiveCollaborationTrigger.displayName = "LiveCollaborationTrigger";

// components/main-menu/MainMenu.tsx
init_icons();

// components/hoc/withInternalFallback.tsx
init_define_import_meta_env();
import { atom as atom12, useAtom as useAtom14 } from "jotai";
import { useLayoutEffect as useLayoutEffect9, useRef as useRef28 } from "react";
import { jsx as jsx105 } from "react/jsx-runtime";
var withInternalFallback = (componentName, Component) => {
  const renderAtom = atom12(0);
  const WrapperComponent = (props) => {
    const { jotaiScope: jotaiScope2 } = useTunnels();
    const [, setCounter] = useAtom14(renderAtom, jotaiScope2);
    const metaRef = useRef28({
      // flag set on initial render to tell the fallback component to skip the
      // render until mount counter are initialized. This is because the counter
      // is initialized in an effect, and thus we could end rendering both
      // components at the same time until counter is initialized.
      preferHost: false,
      counter: 0
    });
    useLayoutEffect9(() => {
      const meta = metaRef.current;
      setCounter((c) => {
        const next = c + 1;
        meta.counter = next;
        return next;
      });
      return () => {
        setCounter((c) => {
          const next = c - 1;
          meta.counter = next;
          if (!next) {
            meta.preferHost = false;
          }
          return next;
        });
      };
    }, [setCounter]);
    if (!props.__fallback) {
      metaRef.current.preferHost = true;
    }
    if (
      // either before the counters are initialized
      !metaRef.current.counter && props.__fallback && metaRef.current.preferHost || // or after the counters are initialized, and both are rendered
      // (this is the default when host renders as well)
      metaRef.current.counter > 1 && props.__fallback
    ) {
      return null;
    }
    return /* @__PURE__ */ jsx105(Component, { ...props });
  };
  WrapperComponent.displayName = componentName;
  return WrapperComponent;
};

// components/main-menu/MainMenu.tsx
init_utils2();
import { jsx as jsx106, jsxs as jsxs58 } from "react/jsx-runtime";
var MainMenu = Object.assign(
  withInternalFallback(
    "MainMenu",
    ({
      children,
      onSelect
    }) => {
      const { MainMenuTunnel } = useTunnels();
      const device = useDevice();
      const appState = useUIAppState();
      const setAppState = useExcalidrawSetAppState();
      const onClickOutside = device.editor.isMobile ? void 0 : () => setAppState({ openMenu: null });
      return /* @__PURE__ */ jsx106(MainMenuTunnel.In, { children: /* @__PURE__ */ jsxs58(DropdownMenu_default, { open: appState.openMenu === "canvas", children: [
        /* @__PURE__ */ jsx106(
          DropdownMenu_default.Trigger,
          {
            onToggle: () => {
              setAppState({
                openMenu: appState.openMenu === "canvas" ? null : "canvas"
              });
            },
            "data-testid": "main-menu-trigger",
            className: "main-menu-trigger",
            children: HamburgerMenuIcon
          }
        ),
        /* @__PURE__ */ jsxs58(
          DropdownMenu_default.Content,
          {
            onClickOutside,
            onSelect: composeEventHandlers(onSelect, () => {
              setAppState({ openMenu: null });
            }),
            children: [
              children,
              device.editor.isMobile && appState.collaborators.size > 0 && /* @__PURE__ */ jsxs58("fieldset", { className: "UserList-Wrapper", children: [
                /* @__PURE__ */ jsx106("legend", { children: t("labels.collaborators") }),
                /* @__PURE__ */ jsx106(
                  UserList,
                  {
                    mobile: true,
                    collaborators: appState.collaborators,
                    userToFollow: appState.userToFollow?.socketId || null
                  }
                )
              ] })
            ]
          }
        )
      ] }) });
    }
  ),
  {
    Trigger: DropdownMenu_default.Trigger,
    Item: DropdownMenu_default.Item,
    ItemLink: DropdownMenu_default.ItemLink,
    ItemCustom: DropdownMenu_default.ItemCustom,
    Group: DropdownMenu_default.Group,
    Separator: DropdownMenu_default.Separator,
    DefaultItems: DefaultItems_exports
  }
);
var MainMenu_default = MainMenu;

// components/OverwriteConfirm/OverwriteConfirm.tsx
init_define_import_meta_env();
import { useAtom as useAtom15 } from "jotai";
init_icons();

// components/OverwriteConfirm/OverwriteConfirmActions.tsx
init_define_import_meta_env();
import { jsx as jsx107, jsxs as jsxs59 } from "react/jsx-runtime";
var Action = ({
  title,
  children,
  actionLabel,
  onClick
}) => {
  return /* @__PURE__ */ jsxs59("div", { className: "OverwriteConfirm__Actions__Action", children: [
    /* @__PURE__ */ jsx107("h4", { children: title }),
    /* @__PURE__ */ jsx107("div", { className: "OverwriteConfirm__Actions__Action__content", children }),
    /* @__PURE__ */ jsx107(
      FilledButton,
      {
        variant: "outlined",
        color: "muted",
        label: actionLabel,
        size: "large",
        fullWidth: true,
        onClick
      }
    )
  ] });
};
var ExportToImage = () => {
  const { t: t2 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  const setAppState = useExcalidrawSetAppState();
  return /* @__PURE__ */ jsx107(
    Action,
    {
      title: t2("overwriteConfirm.action.exportToImage.title"),
      actionLabel: t2("overwriteConfirm.action.exportToImage.button"),
      onClick: () => {
        actionManager.executeAction(actionChangeExportEmbedScene, "ui", true);
        setAppState({ openDialog: { name: "imageExport" } });
      },
      children: t2("overwriteConfirm.action.exportToImage.description")
    }
  );
};
var SaveToDisk = () => {
  const { t: t2 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  return /* @__PURE__ */ jsx107(
    Action,
    {
      title: t2("overwriteConfirm.action.saveToDisk.title"),
      actionLabel: t2("overwriteConfirm.action.saveToDisk.button"),
      onClick: () => {
        actionManager.executeAction(actionSaveFileToDisk, "ui");
      },
      children: t2("overwriteConfirm.action.saveToDisk.description")
    }
  );
};
var Actions = Object.assign(
  ({ children }) => {
    return /* @__PURE__ */ jsx107("div", { className: "OverwriteConfirm__Actions", children });
  },
  {
    ExportToImage,
    SaveToDisk
  }
);

// components/OverwriteConfirm/OverwriteConfirm.tsx
import { jsx as jsx108, jsxs as jsxs60 } from "react/jsx-runtime";
var OverwriteConfirmDialog = Object.assign(
  withInternalFallback(
    "OverwriteConfirmDialog",
    ({ children }) => {
      const { OverwriteConfirmDialogTunnel } = useTunnels();
      const [overwriteConfirmState, setState] = useAtom15(
        overwriteConfirmStateAtom,
        jotaiScope
      );
      if (!overwriteConfirmState.active) {
        return null;
      }
      const handleClose = () => {
        overwriteConfirmState.onClose();
        setState((state) => ({ ...state, active: false }));
      };
      const handleConfirm = () => {
        overwriteConfirmState.onConfirm();
        setState((state) => ({ ...state, active: false }));
      };
      return /* @__PURE__ */ jsx108(OverwriteConfirmDialogTunnel.In, { children: /* @__PURE__ */ jsx108(Dialog, { onCloseRequest: handleClose, title: false, size: 916, children: /* @__PURE__ */ jsxs60("div", { className: "OverwriteConfirm", children: [
        /* @__PURE__ */ jsx108("h3", { children: overwriteConfirmState.title }),
        /* @__PURE__ */ jsxs60(
          "div",
          {
            className: `OverwriteConfirm__Description OverwriteConfirm__Description--color-${overwriteConfirmState.color}`,
            children: [
              /* @__PURE__ */ jsx108("div", { className: "OverwriteConfirm__Description__icon", children: alertTriangleIcon }),
              /* @__PURE__ */ jsx108("div", { children: overwriteConfirmState.description }),
              /* @__PURE__ */ jsx108("div", { className: "OverwriteConfirm__Description__spacer" }),
              /* @__PURE__ */ jsx108(
                FilledButton,
                {
                  color: overwriteConfirmState.color,
                  size: "large",
                  label: overwriteConfirmState.actionLabel,
                  onClick: handleConfirm
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsx108(Actions, { children })
      ] }) }) });
    }
  ),
  {
    Actions,
    Action
  }
);

// components/LayerUI.tsx
init_appState();

// components/DefaultSidebar.tsx
init_define_import_meta_env();
init_constants();
import clsx49 from "clsx";
init_utils2();

// components/SearchMenu.tsx
init_define_import_meta_env();
init_icons();
import { Fragment as Fragment19, memo as memo3, useEffect as useEffect30, useRef as useRef29, useState as useState31 } from "react";
init_element();
init_textElement();
init_utils2();
init_keys();
import { debounce as debounce2 } from "lodash";
import clsx48 from "clsx";
import { atom as atom13, useAtom as useAtom16 } from "jotai";
init_sizeHelpers();
init_random();
init_constants();
init_math();
import { Fragment as Fragment20, jsx as jsx109, jsxs as jsxs61 } from "react/jsx-runtime";
var searchQueryAtom = atom13("");
var searchItemInFocusAtom = atom13(null);
var SEARCH_DEBOUNCE = 350;
var SearchMenu2 = () => {
  const app = useApp();
  const setAppState = useExcalidrawSetAppState();
  const searchInputRef = useRef29(null);
  const [inputValue, setInputValue] = useAtom16(searchQueryAtom, jotaiScope);
  const searchQuery = inputValue.trim();
  const [isSearching, setIsSearching] = useState31(false);
  const [searchMatches, setSearchMatches] = useState31({
    nonce: null,
    items: []
  });
  const searchedQueryRef = useRef29(null);
  const lastSceneNonceRef = useRef29(void 0);
  const [focusIndex, setFocusIndex] = useAtom16(
    searchItemInFocusAtom,
    jotaiScope
  );
  const elementsMap = app.scene.getNonDeletedElementsMap();
  useEffect30(() => {
    if (isSearching) {
      return;
    }
    if (searchQuery !== searchedQueryRef.current || app.scene.getSceneNonce() !== lastSceneNonceRef.current) {
      searchedQueryRef.current = null;
      handleSearch(searchQuery, app, (matchItems, index) => {
        setSearchMatches({
          nonce: randomInteger(),
          items: matchItems
        });
        searchedQueryRef.current = searchQuery;
        lastSceneNonceRef.current = app.scene.getSceneNonce();
        setAppState({
          searchMatches: matchItems.map((searchMatch) => ({
            id: searchMatch.textElement.id,
            focus: false,
            matchedLines: searchMatch.matchedLines
          }))
        });
      });
    }
  }, [
    isSearching,
    searchQuery,
    elementsMap,
    app,
    setAppState,
    setFocusIndex,
    lastSceneNonceRef
  ]);
  const goToNextItem = () => {
    if (searchMatches.items.length > 0) {
      setFocusIndex((focusIndex2) => {
        if (focusIndex2 === null) {
          return 0;
        }
        return (focusIndex2 + 1) % searchMatches.items.length;
      });
    }
  };
  const goToPreviousItem = () => {
    if (searchMatches.items.length > 0) {
      setFocusIndex((focusIndex2) => {
        if (focusIndex2 === null) {
          return 0;
        }
        return focusIndex2 - 1 < 0 ? searchMatches.items.length - 1 : focusIndex2 - 1;
      });
    }
  };
  useEffect30(() => {
    setAppState((state) => {
      return {
        searchMatches: state.searchMatches.map((match, index) => {
          if (index === focusIndex) {
            return { ...match, focus: true };
          }
          return { ...match, focus: false };
        })
      };
    });
  }, [focusIndex, setAppState]);
  useEffect30(() => {
    if (searchMatches.items.length > 0 && focusIndex !== null) {
      const match = searchMatches.items[focusIndex];
      if (match) {
        const zoomValue = app.state.zoom.value;
        const matchAsElement = newTextElement({
          text: match.searchQuery,
          x: match.textElement.x + (match.matchedLines[0]?.offsetX ?? 0),
          y: match.textElement.y + (match.matchedLines[0]?.offsetY ?? 0),
          width: match.matchedLines[0]?.width,
          height: match.matchedLines[0]?.height,
          fontSize: match.textElement.fontSize,
          fontFamily: match.textElement.fontFamily
        });
        const FONT_SIZE_LEGIBILITY_THRESHOLD = 14;
        const fontSize = match.textElement.fontSize;
        const isTextTiny = fontSize * zoomValue < FONT_SIZE_LEGIBILITY_THRESHOLD;
        if (!isElementCompletelyInViewport(
          [matchAsElement],
          app.canvas.width / window.devicePixelRatio,
          app.canvas.height / window.devicePixelRatio,
          {
            offsetLeft: app.state.offsetLeft,
            offsetTop: app.state.offsetTop,
            scrollX: app.state.scrollX,
            scrollY: app.state.scrollY,
            zoom: app.state.zoom
          },
          app.scene.getNonDeletedElementsMap(),
          app.getEditorUIOffsets()
        ) || isTextTiny) {
          let zoomOptions;
          if (isTextTiny) {
            if (fontSize >= FONT_SIZE_LEGIBILITY_THRESHOLD) {
              zoomOptions = { fitToContent: true };
            } else {
              zoomOptions = {
                fitToViewport: true,
                // calculate zoom level to make the fontSize ~equal to FONT_SIZE_THRESHOLD, rounded to nearest 10%
                maxZoom: round(FONT_SIZE_LEGIBILITY_THRESHOLD / fontSize, 1)
              };
            }
          } else {
            zoomOptions = { fitToContent: true };
          }
          app.scrollToContent(matchAsElement, {
            animate: true,
            duration: 300,
            ...zoomOptions,
            canvasOffsets: app.getEditorUIOffsets()
          });
        }
      }
    }
  }, [focusIndex, searchMatches, app]);
  useEffect30(() => {
    return () => {
      setFocusIndex(null);
      searchedQueryRef.current = null;
      lastSceneNonceRef.current = void 0;
      setAppState({
        searchMatches: []
      });
      setIsSearching(false);
    };
  }, [setAppState, setFocusIndex]);
  const stableState = useStable({
    goToNextItem,
    goToPreviousItem,
    searchMatches
  });
  useEffect30(() => {
    const eventHandler = (event) => {
      if (event.key === KEYS.ESCAPE && !app.state.openDialog && !app.state.openPopup) {
        event.preventDefault();
        event.stopPropagation();
        setAppState({
          openSidebar: null
        });
        return;
      }
      if (event[KEYS.CTRL_OR_CMD] && event.key === KEYS.F) {
        event.preventDefault();
        event.stopPropagation();
        if (!searchInputRef.current?.matches(":focus")) {
          if (app.state.openDialog) {
            setAppState({
              openDialog: null
            });
          }
          searchInputRef.current?.focus();
          searchInputRef.current?.select();
        } else {
          setAppState({
            openSidebar: null
          });
        }
      }
      if (event.target instanceof HTMLElement && event.target.closest(".layer-ui__search")) {
        if (stableState.searchMatches.items.length) {
          if (event.key === KEYS.ENTER) {
            event.stopPropagation();
            stableState.goToNextItem();
          }
          if (event.key === KEYS.ARROW_UP) {
            event.stopPropagation();
            stableState.goToPreviousItem();
          } else if (event.key === KEYS.ARROW_DOWN) {
            event.stopPropagation();
            stableState.goToNextItem();
          }
        }
      }
    };
    return addEventListener(window, "keydown" /* KEYDOWN */, eventHandler, {
      capture: true
    });
  }, [setAppState, stableState, app]);
  const matchCount = `${searchMatches.items.length} ${searchMatches.items.length === 1 ? t("search.singleResult") : t("search.multipleResults")}`;
  return /* @__PURE__ */ jsxs61("div", { className: "layer-ui__search", children: [
    /* @__PURE__ */ jsx109("div", { className: "layer-ui__search-header", children: /* @__PURE__ */ jsx109(
      TextField,
      {
        className: CLASSES.SEARCH_MENU_INPUT_WRAPPER,
        value: inputValue,
        ref: searchInputRef,
        placeholder: t("search.placeholder"),
        icon: searchIcon,
        onChange: (value) => {
          setInputValue(value);
          setIsSearching(true);
          const searchQuery2 = value.trim();
          handleSearch(searchQuery2, app, (matchItems, index) => {
            setSearchMatches({
              nonce: randomInteger(),
              items: matchItems
            });
            setFocusIndex(index);
            searchedQueryRef.current = searchQuery2;
            lastSceneNonceRef.current = app.scene.getSceneNonce();
            setAppState({
              searchMatches: matchItems.map((searchMatch) => ({
                id: searchMatch.textElement.id,
                focus: false,
                matchedLines: searchMatch.matchedLines
              }))
            });
            setIsSearching(false);
          });
        },
        selectOnRender: true
      }
    ) }),
    /* @__PURE__ */ jsxs61("div", { className: "layer-ui__search-count", children: [
      searchMatches.items.length > 0 && /* @__PURE__ */ jsxs61(Fragment20, { children: [
        focusIndex !== null && focusIndex > -1 ? /* @__PURE__ */ jsxs61("div", { children: [
          focusIndex + 1,
          " / ",
          matchCount
        ] }) : /* @__PURE__ */ jsx109("div", { children: matchCount }),
        /* @__PURE__ */ jsxs61("div", { className: "result-nav", children: [
          /* @__PURE__ */ jsx109(
            Button,
            {
              onSelect: () => {
                goToNextItem();
              },
              className: "result-nav-btn",
              children: collapseDownIcon
            }
          ),
          /* @__PURE__ */ jsx109(
            Button,
            {
              onSelect: () => {
                goToPreviousItem();
              },
              className: "result-nav-btn",
              children: upIcon
            }
          )
        ] })
      ] }),
      searchMatches.items.length === 0 && searchQuery && searchedQueryRef.current && /* @__PURE__ */ jsx109("div", { style: { margin: "1rem auto" }, children: t("search.noMatch") })
    ] }),
    /* @__PURE__ */ jsx109(
      MatchList,
      {
        matches: searchMatches,
        onItemClick: setFocusIndex,
        focusIndex,
        searchQuery
      }
    )
  ] });
};
var ListItem = (props) => {
  const preview = [
    props.preview.moreBefore ? "..." : "",
    props.preview.previewText.slice(0, props.preview.indexInSearchQuery),
    props.preview.previewText.slice(
      props.preview.indexInSearchQuery,
      props.preview.indexInSearchQuery + props.searchQuery.length
    ),
    props.preview.previewText.slice(
      props.preview.indexInSearchQuery + props.searchQuery.length
    ),
    props.preview.moreAfter ? "..." : ""
  ];
  return /* @__PURE__ */ jsx109(
    "div",
    {
      tabIndex: -1,
      className: clsx48("layer-ui__result-item", {
        active: props.highlighted
      }),
      onClick: props.onClick,
      ref: (ref) => {
        if (props.highlighted) {
          ref?.scrollIntoView({ behavior: "auto", block: "nearest" });
        }
      },
      children: /* @__PURE__ */ jsx109("div", { className: "preview-text", children: preview.flatMap((text, idx) => /* @__PURE__ */ jsx109(Fragment19, { children: idx === 2 ? /* @__PURE__ */ jsx109("b", { children: text }) : text }, idx)) })
    }
  );
};
var MatchListBase = (props) => {
  return /* @__PURE__ */ jsx109("div", { className: "layer-ui__search-result-container", children: props.matches.items.map((searchMatch, index) => /* @__PURE__ */ jsx109(
    ListItem,
    {
      searchQuery: props.searchQuery,
      preview: searchMatch.preview,
      highlighted: index === props.focusIndex,
      onClick: () => props.onItemClick(index)
    },
    searchMatch.textElement.id + searchMatch.index
  )) });
};
var areEqual = (prevProps, nextProps) => {
  return prevProps.matches.nonce === nextProps.matches.nonce && prevProps.focusIndex === nextProps.focusIndex;
};
var MatchList = memo3(MatchListBase, areEqual);
var getMatchPreview = (text, index, searchQuery) => {
  const WORDS_BEFORE = 2;
  const WORDS_AFTER = 5;
  const substrBeforeQuery = text.slice(0, index);
  const wordsBeforeQuery = substrBeforeQuery.split(/\s+/);
  const isQueryCompleteBefore = substrBeforeQuery.endsWith(" ");
  const startWordIndex = wordsBeforeQuery.length - WORDS_BEFORE - 1 - (isQueryCompleteBefore ? 0 : 1);
  let wordsBeforeAsString = wordsBeforeQuery.slice(startWordIndex <= 0 ? 0 : startWordIndex).join(" ") + (isQueryCompleteBefore ? " " : "");
  const MAX_ALLOWED_CHARS = 20;
  wordsBeforeAsString = wordsBeforeAsString.length > MAX_ALLOWED_CHARS ? wordsBeforeAsString.slice(-MAX_ALLOWED_CHARS) : wordsBeforeAsString;
  const substrAfterQuery = text.slice(index + searchQuery.length);
  const wordsAfter = substrAfterQuery.split(/\s+/);
  const isQueryCompleteAfter = !substrAfterQuery.startsWith(" ");
  const numberOfWordsToTake = isQueryCompleteAfter ? WORDS_AFTER + 1 : WORDS_AFTER;
  const wordsAfterAsString = (isQueryCompleteAfter ? "" : " ") + wordsAfter.slice(0, numberOfWordsToTake).join(" ");
  return {
    indexInSearchQuery: wordsBeforeAsString.length,
    previewText: wordsBeforeAsString + searchQuery + wordsAfterAsString,
    moreBefore: startWordIndex > 0,
    moreAfter: wordsAfter.length > numberOfWordsToTake
  };
};
var normalizeWrappedText = (wrappedText, originalText) => {
  const wrappedLines = wrappedText.split("\n");
  const normalizedLines = [];
  let originalIndex = 0;
  for (let i = 0; i < wrappedLines.length; i++) {
    let currentLine = wrappedLines[i];
    const nextLine = wrappedLines[i + 1];
    if (nextLine) {
      const nextLineIndexInOriginal = originalText.indexOf(
        nextLine,
        originalIndex
      );
      if (nextLineIndexInOriginal > currentLine.length + originalIndex) {
        let j = nextLineIndexInOriginal - (currentLine.length + originalIndex);
        while (j > 0) {
          currentLine += " ";
          j--;
        }
      }
    }
    normalizedLines.push(currentLine);
    originalIndex = originalIndex + currentLine.length;
  }
  return normalizedLines.join("\n");
};
var getMatchedLines = (textElement, searchQuery, index) => {
  const normalizedText = normalizeWrappedText(
    textElement.text,
    textElement.originalText
  );
  const lines = normalizedText.split("\n");
  const lineIndexRanges = [];
  let currentIndex = 0;
  let lineNumber = 0;
  for (const line of lines) {
    const startIndex2 = currentIndex;
    const endIndex = startIndex2 + line.length - 1;
    lineIndexRanges.push({
      line,
      startIndex: startIndex2,
      endIndex,
      lineNumber
    });
    currentIndex = endIndex + 1;
    lineNumber++;
  }
  let startIndex = index;
  let remainingQuery = textElement.originalText.slice(
    index,
    index + searchQuery.length
  );
  const matchedLines = [];
  for (const lineIndexRange of lineIndexRanges) {
    if (remainingQuery === "") {
      break;
    }
    if (startIndex >= lineIndexRange.startIndex && startIndex <= lineIndexRange.endIndex) {
      const matchCapacity = lineIndexRange.endIndex + 1 - startIndex;
      const textToStart = lineIndexRange.line.slice(
        0,
        startIndex - lineIndexRange.startIndex
      );
      const matchedWord = remainingQuery.slice(0, matchCapacity);
      remainingQuery = remainingQuery.slice(matchCapacity);
      const offset2 = measureText(
        textToStart,
        getFontString(textElement),
        textElement.lineHeight,
        true
      );
      if (textToStart === "") {
        offset2.width = 0;
      }
      if (textElement.textAlign !== "left" && lineIndexRange.line.length > 0) {
        const lineLength = measureText(
          lineIndexRange.line,
          getFontString(textElement),
          textElement.lineHeight,
          true
        );
        const spaceToStart = textElement.textAlign === "center" ? (textElement.width - lineLength.width) / 2 : textElement.width - lineLength.width;
        offset2.width += spaceToStart;
      }
      const { width, height } = measureText(
        matchedWord,
        getFontString(textElement),
        textElement.lineHeight
      );
      const offsetX = offset2.width;
      const offsetY = lineIndexRange.lineNumber * offset2.height;
      matchedLines.push({
        offsetX,
        offsetY,
        width,
        height
      });
      startIndex += matchCapacity;
    }
  }
  return matchedLines;
};
var escapeSpecialCharacters = (string) => {
  return string.replace(/[.*+?^${}()|[\]\\-]/g, "\\$&");
};
var handleSearch = debounce2(
  (searchQuery, app, cb) => {
    if (!searchQuery || searchQuery === "") {
      cb([], null);
      return;
    }
    const elements = app.scene.getNonDeletedElements();
    const texts = elements.filter(
      (el) => isTextElement(el)
    );
    texts.sort((a, b) => a.y - b.y);
    const matchItems = [];
    const regex = new RegExp(escapeSpecialCharacters(searchQuery), "gi");
    for (const textEl of texts) {
      let match = null;
      const text = textEl.originalText;
      while ((match = regex.exec(text)) !== null) {
        const preview = getMatchPreview(text, match.index, searchQuery);
        const matchedLines = getMatchedLines(textEl, searchQuery, match.index);
        if (matchedLines.length > 0) {
          matchItems.push({
            textElement: textEl,
            searchQuery,
            preview,
            index: match.index,
            matchedLines
          });
        }
      }
    }
    const visibleIds = new Set(
      app.visibleElements.map((visibleElement) => visibleElement.id)
    );
    const focusIndex = matchItems.findIndex(
      (matchItem) => visibleIds.has(matchItem.textElement.id)
    ) ?? null;
    cb(matchItems, focusIndex);
  },
  SEARCH_DEBOUNCE
);

// components/DefaultSidebar.tsx
init_icons();
import { jsx as jsx110, jsxs as jsxs62 } from "react/jsx-runtime";
import { createElement as createElement2 } from "react";
var DefaultSidebarTrigger = withInternalFallback(
  "DefaultSidebarTrigger",
  (props) => {
    const { DefaultSidebarTriggerTunnel } = useTunnels();
    return /* @__PURE__ */ jsx110(DefaultSidebarTriggerTunnel.In, { children: /* @__PURE__ */ jsx110(
      Sidebar.Trigger,
      {
        ...props,
        className: "default-sidebar-trigger",
        name: DEFAULT_SIDEBAR.name
      }
    ) });
  }
);
DefaultSidebarTrigger.displayName = "DefaultSidebarTrigger";
var DefaultTabTriggers = ({ children }) => {
  const { DefaultSidebarTabTriggersTunnel } = useTunnels();
  return /* @__PURE__ */ jsx110(DefaultSidebarTabTriggersTunnel.In, { children });
};
DefaultTabTriggers.displayName = "DefaultTabTriggers";
var DefaultSidebar = Object.assign(
  withInternalFallback(
    "DefaultSidebar",
    ({
      children,
      className,
      onDock,
      docked,
      ...rest
    }) => {
      const appState = useUIAppState();
      const setAppState = useExcalidrawSetAppState();
      const { DefaultSidebarTabTriggersTunnel } = useTunnels();
      const isForceDocked = appState.openSidebar?.tab === CANVAS_SEARCH_TAB;
      return /* @__PURE__ */ createElement2(
        Sidebar,
        {
          ...rest,
          name: "default",
          key: "default",
          className: clsx49("default-sidebar", className),
          docked: isForceDocked || (docked ?? appState.defaultSidebarDockedPreference),
          onDock: (
            // `onDock=false` disables docking.
            // if `docked` passed, but no onDock passed, disable manual docking.
            isForceDocked || onDock === false || !onDock && docked != null ? void 0 : (
              // compose to allow the host app to listen on default behavior
              composeEventHandlers(onDock, (docked2) => {
                setAppState({ defaultSidebarDockedPreference: docked2 });
              })
            )
          )
        },
        /* @__PURE__ */ jsxs62(Sidebar.Tabs, { children: [
          /* @__PURE__ */ jsx110(Sidebar.Header, { children: /* @__PURE__ */ jsxs62(Sidebar.TabTriggers, { children: [
            /* @__PURE__ */ jsx110(Sidebar.TabTrigger, { tab: CANVAS_SEARCH_TAB, children: searchIcon }),
            /* @__PURE__ */ jsx110(Sidebar.TabTrigger, { tab: LIBRARY_SIDEBAR_TAB, children: LibraryIcon }),
            /* @__PURE__ */ jsx110(DefaultSidebarTabTriggersTunnel.Out, {})
          ] }) }),
          /* @__PURE__ */ jsx110(Sidebar.Tab, { tab: LIBRARY_SIDEBAR_TAB, children: /* @__PURE__ */ jsx110(LibraryMenu, {}) }),
          /* @__PURE__ */ jsx110(Sidebar.Tab, { tab: CANVAS_SEARCH_TAB, children: /* @__PURE__ */ jsx110(SearchMenu2, {}) }),
          children
        ] })
      );
    }
  ),
  {
    Trigger: DefaultSidebarTrigger,
    TabTriggers: DefaultTabTriggers
  }
);

// components/LayerUI.tsx
init_mutateElement();
init_ShapeCache();
init_Scene();

// components/LaserPointerButton.tsx
init_define_import_meta_env();
init_icons();
import clsx50 from "clsx";
import { jsx as jsx111, jsxs as jsxs63 } from "react/jsx-runtime";
var DEFAULT_SIZE3 = "small";
var LaserPointerButton = (props) => {
  return /* @__PURE__ */ jsxs63(
    "label",
    {
      className: clsx50(
        "ToolIcon ToolIcon__LaserPointer",
        `ToolIcon_size_${DEFAULT_SIZE3}`,
        {
          "is-mobile": props.isMobile
        }
      ),
      title: `${props.title}`,
      children: [
        /* @__PURE__ */ jsx111(
          "input",
          {
            className: "ToolIcon_type_checkbox",
            type: "checkbox",
            name: props.name,
            onChange: props.onChange,
            checked: props.checked,
            "aria-label": props.title,
            "data-testid": "toolbar-LaserPointer"
          }
        ),
        /* @__PURE__ */ jsx111("div", { className: "ToolIcon__icon", children: laserPointerToolIcon })
      ]
    }
  );
};

// components/TTDDialog/TTDDialog.tsx
init_define_import_meta_env();

// components/TTDDialog/MermaidToExcalidraw.tsx
init_define_import_meta_env();
import { useState as useState32, useRef as useRef31, useEffect as useEffect32, useDeferredValue } from "react";
init_icons();

// components/TTDDialog/common.ts
init_define_import_meta_env();
init_constants();
init_blob();
var resetPreview = ({
  canvasRef,
  setError
}) => {
  const canvasNode = canvasRef.current;
  if (!canvasNode) {
    return;
  }
  const parent = canvasNode.parentElement;
  if (!parent) {
    return;
  }
  parent.style.background = "";
  setError(null);
  canvasNode.replaceChildren();
};
var convertMermaidToExcalidraw = async ({
  canvasRef,
  mermaidToExcalidrawLib,
  mermaidDefinition,
  setError,
  data
}) => {
  const canvasNode = canvasRef.current;
  const parent = canvasNode?.parentElement;
  if (!canvasNode || !parent) {
    return;
  }
  if (!mermaidDefinition) {
    resetPreview({ canvasRef, setError });
    return;
  }
  try {
    const api = await mermaidToExcalidrawLib.api;
    let ret;
    try {
      ret = await api.parseMermaidToExcalidraw(mermaidDefinition);
    } catch (err) {
      ret = await api.parseMermaidToExcalidraw(
        mermaidDefinition.replace(/"/g, "'")
      );
    }
    const { elements, files } = ret;
    setError(null);
    data.current = {
      elements: convertToExcalidrawElements(elements, {
        regenerateIds: true
      }),
      files
    };
    const canvas2 = await exportToCanvas2({
      elements: data.current.elements,
      files: data.current.files,
      exportPadding: DEFAULT_EXPORT_PADDING,
      maxWidthOrHeight: Math.max(parent.offsetWidth, parent.offsetHeight) * window.devicePixelRatio
    });
    try {
      await canvasToBlob(canvas2);
    } catch (e) {
      if (e.name === "CANVAS_POSSIBLY_TOO_BIG") {
        throw new Error(t("canvasError.canvasTooBig"));
      }
      throw e;
    }
    parent.style.background = "var(--default-bg-color)";
    canvasNode.replaceChildren(canvas2);
  } catch (err) {
    parent.style.background = "var(--default-bg-color)";
    if (mermaidDefinition) {
      setError(err);
    }
    throw err;
  }
};
var saveMermaidDataToStorage = (mermaidDefinition) => {
  EditorLocalStorage.set(
    EDITOR_LS_KEYS.MERMAID_TO_EXCALIDRAW,
    mermaidDefinition
  );
};
var insertToEditor = ({
  app,
  data,
  text,
  shouldSaveMermaidDataToStorage
}) => {
  const { elements: newElements, files } = data.current;
  if (!newElements.length) {
    return;
  }
  app.addElementsFromPasteOrLibrary({
    elements: newElements,
    files,
    position: "center",
    fitToContent: true
  });
  app.setOpenDialog(null);
  if (shouldSaveMermaidDataToStorage && text) {
    saveMermaidDataToStorage(text);
  }
};

// components/TTDDialog/TTDDialogPanels.tsx
init_define_import_meta_env();
import { jsx as jsx112 } from "react/jsx-runtime";
var TTDDialogPanels = ({ children }) => {
  return /* @__PURE__ */ jsx112("div", { className: "ttd-dialog-panels", children });
};

// components/TTDDialog/TTDDialogPanel.tsx
init_define_import_meta_env();
import clsx51 from "clsx";
import { jsx as jsx113, jsxs as jsxs64 } from "react/jsx-runtime";
var TTDDialogPanel = ({
  label,
  children,
  panelAction,
  panelActionDisabled = false,
  onTextSubmitInProgess,
  renderTopRight,
  renderSubmitShortcut,
  renderBottomRight
}) => {
  return /* @__PURE__ */ jsxs64("div", { className: "ttd-dialog-panel", children: [
    /* @__PURE__ */ jsxs64("div", { className: "ttd-dialog-panel__header", children: [
      /* @__PURE__ */ jsx113("label", { children: label }),
      renderTopRight?.()
    ] }),
    children,
    /* @__PURE__ */ jsxs64(
      "div",
      {
        className: clsx51("ttd-dialog-panel-button-container", {
          invisible: !panelAction
        }),
        style: { display: "flex", alignItems: "center" },
        children: [
          /* @__PURE__ */ jsxs64(
            Button,
            {
              className: "ttd-dialog-panel-button",
              onSelect: panelAction ? panelAction.action : () => {
              },
              disabled: panelActionDisabled || onTextSubmitInProgess,
              children: [
                /* @__PURE__ */ jsxs64("div", { className: clsx51({ invisible: onTextSubmitInProgess }), children: [
                  panelAction?.label,
                  panelAction?.icon && /* @__PURE__ */ jsx113("span", { children: panelAction.icon })
                ] }),
                onTextSubmitInProgess && /* @__PURE__ */ jsx113(Spinner_default, {})
              ]
            }
          ),
          !panelActionDisabled && !onTextSubmitInProgess && renderSubmitShortcut?.(),
          renderBottomRight?.()
        ]
      }
    )
  ] });
};

// components/TTDDialog/TTDDialogInput.tsx
init_define_import_meta_env();
init_constants();
init_keys();
import { useEffect as useEffect31, useRef as useRef30 } from "react";
import { jsx as jsx114 } from "react/jsx-runtime";
var TTDDialogInput = ({
  input,
  placeholder,
  onChange,
  onKeyboardSubmit
}) => {
  const ref = useRef30(null);
  const callbackRef = useRef30(onKeyboardSubmit);
  callbackRef.current = onKeyboardSubmit;
  useEffect31(() => {
    if (!callbackRef.current) {
      return;
    }
    const textarea = ref.current;
    if (textarea) {
      const handleKeyDown = (event) => {
        if (event[KEYS.CTRL_OR_CMD] && event.key === KEYS.ENTER) {
          event.preventDefault();
          callbackRef.current?.();
        }
      };
      textarea.addEventListener("keydown" /* KEYDOWN */, handleKeyDown);
      return () => {
        textarea.removeEventListener("keydown" /* KEYDOWN */, handleKeyDown);
      };
    }
  }, []);
  return /* @__PURE__ */ jsx114(
    "textarea",
    {
      className: "ttd-dialog-input",
      onChange,
      value: input,
      placeholder,
      autoFocus: true,
      ref
    }
  );
};

// components/TTDDialog/TTDDialogOutput.tsx
init_define_import_meta_env();
import { jsx as jsx115, jsxs as jsxs65 } from "react/jsx-runtime";
var ErrorComp = ({ error }) => {
  return /* @__PURE__ */ jsxs65(
    "div",
    {
      "data-testid": "ttd-dialog-output-error",
      className: "ttd-dialog-output-error",
      children: [
        "Error! ",
        /* @__PURE__ */ jsx115("p", { children: error })
      ]
    }
  );
};
var TTDDialogOutput = ({
  error,
  canvasRef,
  loaded
}) => {
  return /* @__PURE__ */ jsxs65("div", { className: "ttd-dialog-output-wrapper", children: [
    error && /* @__PURE__ */ jsx115(ErrorComp, { error: error.message }),
    loaded ? /* @__PURE__ */ jsx115(
      "div",
      {
        ref: canvasRef,
        style: { opacity: error ? "0.15" : 1 },
        className: "ttd-dialog-output-canvas-container"
      }
    ) : /* @__PURE__ */ jsx115(Spinner_default, { size: "2rem" })
  ] });
};

// components/TTDDialog/MermaidToExcalidraw.tsx
init_constants();
init_utils2();

// components/TTDDialog/TTDDialogSubmitShortcut.tsx
init_define_import_meta_env();
init_utils2();
import { jsx as jsx116, jsxs as jsxs66 } from "react/jsx-runtime";
var TTDDialogSubmitShortcut = () => {
  return /* @__PURE__ */ jsxs66("div", { className: "ttd-dialog-submit-shortcut", children: [
    /* @__PURE__ */ jsx116("div", { className: "ttd-dialog-submit-shortcut__key", children: getShortcutKey("CtrlOrCmd") }),
    /* @__PURE__ */ jsx116("div", { className: "ttd-dialog-submit-shortcut__key", children: getShortcutKey("Enter") })
  ] });
};

// components/TTDDialog/MermaidToExcalidraw.tsx
import { Fragment as Fragment21, jsx as jsx117, jsxs as jsxs67 } from "react/jsx-runtime";
var MERMAID_EXAMPLE = "flowchart TD\n A[Christmas] -->|Get money| B(Go shopping)\n B --> C{Let me think}\n C -->|One| D[Laptop]\n C -->|Two| E[iPhone]\n C -->|Three| F[Car]";
var debouncedSaveMermaidDefinition = debounce(saveMermaidDataToStorage, 300);
var MermaidToExcalidraw = ({
  mermaidToExcalidrawLib
}) => {
  const [text, setText] = useState32(
    () => EditorLocalStorage.get(EDITOR_LS_KEYS.MERMAID_TO_EXCALIDRAW) || MERMAID_EXAMPLE
  );
  const deferredText = useDeferredValue(text.trim());
  const [error, setError] = useState32(null);
  const canvasRef = useRef31(null);
  const data = useRef31({ elements: [], files: null });
  const app = useApp();
  useEffect32(() => {
    convertMermaidToExcalidraw({
      canvasRef,
      data,
      mermaidToExcalidrawLib,
      setError,
      mermaidDefinition: deferredText
    }).catch((err) => {
      if (isDevEnv()) {
        console.error("Failed to parse mermaid definition", err);
      }
    });
    debouncedSaveMermaidDefinition(deferredText);
  }, [deferredText, mermaidToExcalidrawLib]);
  useEffect32(
    () => () => {
      debouncedSaveMermaidDefinition.flush();
    },
    []
  );
  const onInsertToEditor = () => {
    insertToEditor({
      app,
      data,
      text,
      shouldSaveMermaidDataToStorage: true
    });
  };
  return /* @__PURE__ */ jsxs67(Fragment21, { children: [
    /* @__PURE__ */ jsx117("div", { className: "ttd-dialog-desc", children: /* @__PURE__ */ jsx117(
      Trans_default,
      {
        i18nKey: "mermaid.description",
        flowchartLink: (el) => /* @__PURE__ */ jsx117("a", { href: "https://mermaid.js.org/syntax/flowchart.html", children: el }),
        sequenceLink: (el) => /* @__PURE__ */ jsx117("a", { href: "https://mermaid.js.org/syntax/sequenceDiagram.html", children: el }),
        classLink: (el) => /* @__PURE__ */ jsx117("a", { href: "https://mermaid.js.org/syntax/classDiagram.html", children: el })
      }
    ) }),
    /* @__PURE__ */ jsxs67(TTDDialogPanels, { children: [
      /* @__PURE__ */ jsx117(TTDDialogPanel, { label: t("mermaid.syntax"), children: /* @__PURE__ */ jsx117(
        TTDDialogInput,
        {
          input: text,
          placeholder: "Write Mermaid diagram defintion here...",
          onChange: (event) => setText(event.target.value),
          onKeyboardSubmit: () => {
            onInsertToEditor();
          }
        }
      ) }),
      /* @__PURE__ */ jsx117(
        TTDDialogPanel,
        {
          label: t("mermaid.preview"),
          panelAction: {
            action: () => {
              onInsertToEditor();
            },
            label: t("mermaid.button"),
            icon: ArrowRightIcon
          },
          renderSubmitShortcut: () => /* @__PURE__ */ jsx117(TTDDialogSubmitShortcut, {}),
          children: /* @__PURE__ */ jsx117(
            TTDDialogOutput,
            {
              canvasRef,
              loaded: mermaidToExcalidrawLib.loaded,
              error
            }
          )
        }
      )
    ] })
  ] });
};
var MermaidToExcalidraw_default = MermaidToExcalidraw;

// components/TTDDialog/TTDDialogTabs.tsx
init_define_import_meta_env();
import * as RadixTabs5 from "@radix-ui/react-tabs";
import { useRef as useRef32 } from "react";
init_utils2();
import { jsx as jsx118 } from "react/jsx-runtime";
var TTDDialogTabs = (props) => {
  const setAppState = useExcalidrawSetAppState();
  const rootRef = useRef32(null);
  const minHeightRef = useRef32(0);
  return /* @__PURE__ */ jsx118(
    RadixTabs5.Root,
    {
      ref: rootRef,
      className: "ttd-dialog-tabs-root",
      value: props.tab,
      onValueChange: (tab) => {
        if (!tab) {
          return;
        }
        const modalContentNode = rootRef.current?.closest(".Modal__content");
        if (modalContentNode) {
          const currHeight = modalContentNode.offsetHeight || 0;
          if (currHeight > minHeightRef.current) {
            minHeightRef.current = currHeight;
            modalContentNode.style.minHeight = `min(${minHeightRef.current}px, 100%)`;
          }
        }
        if (props.dialog === "ttd" && isMemberOf(["text-to-diagram", "mermaid"], tab)) {
          setAppState({
            openDialog: { name: props.dialog, tab }
          });
        }
      },
      children: props.children
    }
  );
};
TTDDialogTabs.displayName = "TTDDialogTabs";
var TTDDialogTabs_default = TTDDialogTabs;

// components/TTDDialog/TTDDialog.tsx
import { useEffect as useEffect33, useRef as useRef33, useState as useState33 } from "react";

// components/TTDDialog/TTDDialogTabTriggers.tsx
init_define_import_meta_env();
import * as RadixTabs6 from "@radix-ui/react-tabs";
import { jsx as jsx119 } from "react/jsx-runtime";
var TTDDialogTabTriggers = ({
  children,
  ...rest
}) => {
  return /* @__PURE__ */ jsx119(RadixTabs6.List, { className: "ttd-dialog-triggers", ...rest, children });
};
TTDDialogTabTriggers.displayName = "TTDDialogTabTriggers";

// components/TTDDialog/TTDDialogTabTrigger.tsx
init_define_import_meta_env();
import * as RadixTabs7 from "@radix-ui/react-tabs";
import { jsx as jsx120 } from "react/jsx-runtime";
var TTDDialogTabTrigger = ({
  children,
  tab,
  onSelect,
  ...rest
}) => {
  return /* @__PURE__ */ jsx120(RadixTabs7.Trigger, { value: tab, asChild: true, onSelect, children: /* @__PURE__ */ jsx120("button", { type: "button", className: "ttd-dialog-tab-trigger", ...rest, children }) });
};
TTDDialogTabTrigger.displayName = "TTDDialogTabTrigger";

// components/TTDDialog/TTDDialogTab.tsx
init_define_import_meta_env();
import * as RadixTabs8 from "@radix-ui/react-tabs";
import { jsx as jsx121 } from "react/jsx-runtime";
var TTDDialogTab = ({
  tab,
  children,
  ...rest
}) => {
  return /* @__PURE__ */ jsx121(RadixTabs8.Content, { ...rest, value: tab, children });
};
TTDDialogTab.displayName = "TTDDialogTab";

// components/TTDDialog/TTDDialog.tsx
init_icons();
import { atom as atom14, useAtom as useAtom17 } from "jotai";
init_math();
import { jsx as jsx122, jsxs as jsxs68 } from "react/jsx-runtime";
var MIN_PROMPT_LENGTH = 3;
var MAX_PROMPT_LENGTH = 1e3;
var rateLimitsAtom = atom14(null);
var ttdGenerationAtom = atom14(null);
var TTDDialog = (props) => {
  const appState = useUIAppState();
  if (appState.openDialog?.name !== "ttd") {
    return null;
  }
  return /* @__PURE__ */ jsx122(TTDDialogBase, { ...props, tab: appState.openDialog.tab });
};
var TTDDialogBase = withInternalFallback(
  "TTDDialogBase",
  ({
    tab,
    ...rest
  }) => {
    const app = useApp();
    const setAppState = useExcalidrawSetAppState();
    const someRandomDivRef = useRef33(null);
    const [ttdGeneration, setTtdGeneration] = useAtom17(ttdGenerationAtom);
    const [text, setText] = useState33(ttdGeneration?.prompt ?? "");
    const prompt = text.trim();
    const handleTextChange = (event) => {
      setText(event.target.value);
      setTtdGeneration((s) => ({
        generatedResponse: s?.generatedResponse ?? null,
        prompt: event.target.value
      }));
    };
    const [onTextSubmitInProgess, setOnTextSubmitInProgess] = useState33(false);
    const [rateLimits, setRateLimits] = useAtom17(rateLimitsAtom);
    const onGenerate = async () => {
      if (prompt.length > MAX_PROMPT_LENGTH || prompt.length < MIN_PROMPT_LENGTH || onTextSubmitInProgess || rateLimits?.rateLimitRemaining === 0 || // means this is not a text-to-diagram dialog (needed for TS only)
      "__fallback" in rest) {
        if (prompt.length < MIN_PROMPT_LENGTH) {
          setError(
            new Error(
              `Prompt is too short (min ${MIN_PROMPT_LENGTH} characters)`
            )
          );
        }
        if (prompt.length > MAX_PROMPT_LENGTH) {
          setError(
            new Error(
              `Prompt is too long (max ${MAX_PROMPT_LENGTH} characters)`
            )
          );
        }
        return;
      }
      try {
        setOnTextSubmitInProgess(true);
        trackEvent("ai", "generate", "ttd");
        const { generatedResponse, error: error2, rateLimit, rateLimitRemaining } = await rest.onTextSubmit(prompt);
        if (typeof generatedResponse === "string") {
          setTtdGeneration((s) => ({
            generatedResponse,
            prompt: s?.prompt ?? null
          }));
        }
        if (isFiniteNumber(rateLimit) && isFiniteNumber(rateLimitRemaining)) {
          setRateLimits({ rateLimit, rateLimitRemaining });
        }
        if (error2) {
          setError(error2);
          return;
        }
        if (!generatedResponse) {
          setError(new Error("Generation failed"));
          return;
        }
        try {
          await convertMermaidToExcalidraw({
            canvasRef: someRandomDivRef,
            data,
            mermaidToExcalidrawLib,
            setError,
            mermaidDefinition: generatedResponse
          });
          trackEvent("ai", "mermaid parse success", "ttd");
        } catch (error3) {
          console.info(
            `%cTTD mermaid render errror: ${error3.message}`,
            "color: red"
          );
          console.info(
            `>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
TTD mermaid definition render errror: ${error3.message}`,
            "color: yellow"
          );
          trackEvent("ai", "mermaid parse failed", "ttd");
          setError(
            new Error(
              "Generated an invalid diagram :(. You may also try a different prompt."
            )
          );
        }
      } catch (error2) {
        let message = error2.message;
        if (!message || message === "Failed to fetch") {
          message = "Request failed";
        }
        setError(new Error(message));
      } finally {
        setOnTextSubmitInProgess(false);
      }
    };
    const refOnGenerate = useRef33(onGenerate);
    refOnGenerate.current = onGenerate;
    const [mermaidToExcalidrawLib, setMermaidToExcalidrawLib] = useState33({
      loaded: false,
      api: import("@excalidraw/mermaid-to-excalidraw")
    });
    useEffect33(() => {
      const fn = async () => {
        await mermaidToExcalidrawLib.api;
        setMermaidToExcalidrawLib((prev) => ({ ...prev, loaded: true }));
      };
      fn();
    }, [mermaidToExcalidrawLib.api]);
    const data = useRef33({ elements: [], files: null });
    const [error, setError] = useState33(null);
    return /* @__PURE__ */ jsx122(
      Dialog,
      {
        className: "ttd-dialog",
        onCloseRequest: () => {
          app.setOpenDialog(null);
        },
        size: 1200,
        title: false,
        ...rest,
        autofocus: false,
        children: /* @__PURE__ */ jsxs68(TTDDialogTabs_default, { dialog: "ttd", tab, children: [
          "__fallback" in rest && rest.__fallback ? /* @__PURE__ */ jsx122("p", { className: "dialog-mermaid-title", children: t("mermaid.title") }) : /* @__PURE__ */ jsxs68(TTDDialogTabTriggers, { children: [
            /* @__PURE__ */ jsx122(TTDDialogTabTrigger, { tab: "text-to-diagram", children: /* @__PURE__ */ jsxs68("div", { style: { display: "flex", alignItems: "center" }, children: [
              t("labels.textToDiagram"),
              /* @__PURE__ */ jsx122(
                "div",
                {
                  style: {
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    padding: "1px 6px",
                    marginLeft: "10px",
                    fontSize: 10,
                    borderRadius: "12px",
                    background: "var(--color-promo)",
                    color: "var(--color-surface-lowest)"
                  },
                  children: "AI Beta"
                }
              )
            ] }) }),
            /* @__PURE__ */ jsx122(TTDDialogTabTrigger, { tab: "mermaid", children: "Mermaid" })
          ] }),
          /* @__PURE__ */ jsx122(TTDDialogTab, { className: "ttd-dialog-content", tab: "mermaid", children: /* @__PURE__ */ jsx122(
            MermaidToExcalidraw_default,
            {
              mermaidToExcalidrawLib
            }
          ) }),
          !("__fallback" in rest) && /* @__PURE__ */ jsxs68(TTDDialogTab, { className: "ttd-dialog-content", tab: "text-to-diagram", children: [
            /* @__PURE__ */ jsx122("div", { className: "ttd-dialog-desc", children: "Currently we use Mermaid as a middle step, so you'll get best results if you describe a diagram, workflow, flow chart, and similar." }),
            /* @__PURE__ */ jsxs68(TTDDialogPanels, { children: [
              /* @__PURE__ */ jsx122(
                TTDDialogPanel,
                {
                  label: t("labels.prompt"),
                  panelAction: {
                    action: onGenerate,
                    label: "Generate",
                    icon: ArrowRightIcon
                  },
                  onTextSubmitInProgess,
                  panelActionDisabled: prompt.length > MAX_PROMPT_LENGTH || rateLimits?.rateLimitRemaining === 0,
                  renderTopRight: () => {
                    if (!rateLimits) {
                      return null;
                    }
                    return /* @__PURE__ */ jsxs68(
                      "div",
                      {
                        className: "ttd-dialog-rate-limit",
                        style: {
                          fontSize: 12,
                          marginLeft: "auto",
                          color: rateLimits.rateLimitRemaining === 0 ? "var(--color-danger)" : void 0
                        },
                        children: [
                          rateLimits.rateLimitRemaining,
                          " requests left today"
                        ]
                      }
                    );
                  },
                  renderSubmitShortcut: () => /* @__PURE__ */ jsx122(TTDDialogSubmitShortcut, {}),
                  renderBottomRight: () => {
                    if (typeof ttdGeneration?.generatedResponse === "string") {
                      return /* @__PURE__ */ jsxs68(
                        "div",
                        {
                          className: "excalidraw-link",
                          style: { marginLeft: "auto", fontSize: 14 },
                          onClick: () => {
                            if (typeof ttdGeneration?.generatedResponse === "string") {
                              saveMermaidDataToStorage(
                                ttdGeneration.generatedResponse
                              );
                              setAppState({
                                openDialog: { name: "ttd", tab: "mermaid" }
                              });
                            }
                          },
                          children: [
                            "View as Mermaid",
                            /* @__PURE__ */ jsx122(InlineIcon, { icon: ArrowRightIcon })
                          ]
                        }
                      );
                    }
                    const ratio = prompt.length / MAX_PROMPT_LENGTH;
                    if (ratio > 0.8) {
                      return /* @__PURE__ */ jsxs68(
                        "div",
                        {
                          style: {
                            marginLeft: "auto",
                            fontSize: 12,
                            fontFamily: "monospace",
                            color: ratio > 1 ? "var(--color-danger)" : void 0
                          },
                          children: [
                            "Length: ",
                            prompt.length,
                            "/",
                            MAX_PROMPT_LENGTH
                          ]
                        }
                      );
                    }
                    return null;
                  },
                  children: /* @__PURE__ */ jsx122(
                    TTDDialogInput,
                    {
                      onChange: handleTextChange,
                      input: text,
                      placeholder: "Describe what you want to see...",
                      onKeyboardSubmit: () => {
                        refOnGenerate.current();
                      }
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsx122(
                TTDDialogPanel,
                {
                  label: "Preview",
                  panelAction: {
                    action: () => {
                      console.info("Panel action clicked");
                      insertToEditor({ app, data });
                    },
                    label: "Insert",
                    icon: ArrowRightIcon
                  },
                  children: /* @__PURE__ */ jsx122(
                    TTDDialogOutput,
                    {
                      canvasRef: someRandomDivRef,
                      error,
                      loaded: mermaidToExcalidrawLib.loaded
                    }
                  )
                }
              )
            ] })
          ] })
        ] })
      }
    );
  }
);

// components/Stats/index.tsx
init_define_import_meta_env();
init_bounds();
import { useEffect as useEffect35, useMemo as useMemo9, useState as useState35, memo as memo4 } from "react";
init_icons();
import { throttle as throttle3 } from "lodash";

// components/Stats/Dimension.tsx
init_define_import_meta_env();

// components/Stats/DragInput.tsx
init_define_import_meta_env();
init_constants();
init_keys();
init_newElement();
import { useEffect as useEffect34, useRef as useRef34, useState as useState34 } from "react";
import clsx52 from "clsx";

// components/Stats/utils.ts
init_define_import_meta_env();
init_math();
init_binding();
init_mutateElement();
init_resizeElements();
init_textElement();
init_typeChecks();
init_groups();
init_utils2();
var SMALLEST_DELTA = 0.01;
var isPropertyEditable = (element, property) => {
  if (property === "height" && isTextElement(element)) {
    return false;
  }
  if (property === "width" && isTextElement(element)) {
    return false;
  }
  if (property === "angle" && isFrameLikeElement(element)) {
    return false;
  }
  return true;
};
var getStepSizedValue = (value, stepSize) => {
  const v = value + stepSize / 2;
  return v - v % stepSize;
};
var getElementsInAtomicUnit = (atomicUnit, elementsMap, originalElementsMap) => {
  return Object.keys(atomicUnit).map((id) => ({
    original: (originalElementsMap ?? elementsMap).get(id),
    latest: elementsMap.get(id)
  })).filter((el) => el.original !== void 0 && el.latest !== void 0);
};
var newOrigin = (x1, y1, w1, h1, w2, h2, angle) => {
  return {
    x: x1 + (w1 - w2) / 2 + (w2 - w1) / 2 * Math.cos(angle) + (h1 - h2) / 2 * Math.sin(angle),
    y: y1 + (h1 - h2) / 2 + (w2 - w1) / 2 * Math.sin(angle) + (h2 - h1) / 2 * Math.cos(angle)
  };
};
var resizeElement = (nextWidth, nextHeight, keepAspectRatio, origElement, elementsMap, elements, scene, shouldInformMutation = true) => {
  const latestElement = elementsMap.get(origElement.id);
  if (!latestElement) {
    return;
  }
  let boundTextFont = {};
  const boundTextElement = getBoundTextElement(latestElement, elementsMap);
  if (boundTextElement) {
    const minWidth = getApproxMinLineWidth(
      getFontString(boundTextElement),
      boundTextElement.lineHeight
    );
    const minHeight = getApproxMinLineHeight(
      boundTextElement.fontSize,
      boundTextElement.lineHeight
    );
    nextWidth = Math.max(nextWidth, minWidth);
    nextHeight = Math.max(nextHeight, minHeight);
  }
  const { width: oldWidth, height: oldHeight } = latestElement;
  mutateElement(
    latestElement,
    {
      ...newOrigin(
        latestElement.x,
        latestElement.y,
        latestElement.width,
        latestElement.height,
        nextWidth,
        nextHeight,
        latestElement.angle
      ),
      width: nextWidth,
      height: nextHeight,
      ...rescalePointsInElement(origElement, nextWidth, nextHeight, true)
    },
    shouldInformMutation
  );
  updateBindings(latestElement, elementsMap, elements, scene, {
    newSize: {
      width: nextWidth,
      height: nextHeight
    }
  });
  if (boundTextElement) {
    boundTextFont = {
      fontSize: boundTextElement.fontSize
    };
    if (keepAspectRatio) {
      const updatedElement = {
        ...latestElement,
        width: nextWidth,
        height: nextHeight
      };
      const nextFont = measureFontSizeFromWidth(
        boundTextElement,
        elementsMap,
        getBoundTextMaxWidth(updatedElement, boundTextElement)
      );
      boundTextFont = {
        fontSize: nextFont?.size ?? boundTextElement.fontSize
      };
    }
  }
  updateBoundElements(latestElement, elementsMap, {
    oldSize: { width: oldWidth, height: oldHeight }
  });
  if (boundTextElement && boundTextFont) {
    mutateElement(boundTextElement, {
      fontSize: boundTextFont.fontSize
    });
  }
  handleBindTextResize(latestElement, elementsMap, "e", keepAspectRatio);
};
var moveElement = (newTopLeftX, newTopLeftY, originalElement, elementsMap, elements, scene, originalElementsMap, shouldInformMutation = true) => {
  const latestElement = elementsMap.get(originalElement.id);
  if (!latestElement) {
    return;
  }
  const [cx, cy] = [
    originalElement.x + originalElement.width / 2,
    originalElement.y + originalElement.height / 2
  ];
  const [topLeftX, topLeftY] = pointRotateRads(
    pointFrom(originalElement.x, originalElement.y),
    pointFrom(cx, cy),
    originalElement.angle
  );
  const changeInX = newTopLeftX - topLeftX;
  const changeInY = newTopLeftY - topLeftY;
  const [x, y] = pointRotateRads(
    pointFrom(newTopLeftX, newTopLeftY),
    pointFrom(cx + changeInX, cy + changeInY),
    -originalElement.angle
  );
  mutateElement(
    latestElement,
    {
      x,
      y
    },
    shouldInformMutation
  );
  updateBindings(latestElement, elementsMap, elements, scene);
  const boundTextElement = getBoundTextElement(
    originalElement,
    originalElementsMap
  );
  if (boundTextElement) {
    const latestBoundTextElement = elementsMap.get(boundTextElement.id);
    latestBoundTextElement && mutateElement(
      latestBoundTextElement,
      {
        x: boundTextElement.x + changeInX,
        y: boundTextElement.y + changeInY
      },
      shouldInformMutation
    );
  }
};
var getAtomicUnits = (targetElements, appState) => {
  const selectedGroupIds = getSelectedGroupIds(appState);
  const _atomicUnits = selectedGroupIds.map((gid) => {
    return getElementsInGroup(targetElements, gid).reduce((acc, el) => {
      acc[el.id] = true;
      return acc;
    }, {});
  });
  targetElements.filter((el) => !isInGroup(el)).forEach((el) => {
    _atomicUnits.push({
      [el.id]: true
    });
  });
  return _atomicUnits;
};
var updateBindings = (latestElement, elementsMap, elements, scene, options) => {
  if (isLinearElement(latestElement)) {
    bindOrUnbindLinearElements(
      [latestElement],
      elementsMap,
      elements,
      scene,
      true,
      []
    );
  } else {
    updateBoundElements(latestElement, elementsMap, options);
  }
};

// components/Stats/DragInput.tsx
init_store();
init_utils2();
import { jsx as jsx123, jsxs as jsxs69 } from "react/jsx-runtime";
var StatsDragInput = ({
  label,
  icon,
  dragInputCallback,
  value,
  elements,
  editable = true,
  shouldKeepAspectRatio,
  property,
  scene,
  appState,
  sensitivity = 1
}) => {
  const app = useApp();
  const inputRef = useRef34(null);
  const labelRef = useRef34(null);
  const [inputValue, setInputValue] = useState34(value.toString());
  const stateRef = useRef34(null);
  if (!stateRef.current) {
    stateRef.current = {
      originalAppState: cloneJSON(appState),
      originalElements: elements,
      lastUpdatedValue: inputValue,
      updatePending: false
    };
  }
  useEffect34(() => {
    const inputValue2 = value.toString();
    setInputValue(inputValue2);
    stateRef.current.lastUpdatedValue = inputValue2;
  }, [value]);
  const handleInputValue = (updatedValue, elements2, appState2) => {
    if (!stateRef.current.updatePending) {
      return false;
    }
    stateRef.current.updatePending = false;
    const parsed = Number(updatedValue);
    if (isNaN(parsed)) {
      setInputValue(value.toString());
      return;
    }
    const rounded = Number(parsed.toFixed(2));
    const original = Number(value);
    if (isNaN(original) || Math.abs(rounded - original) >= SMALLEST_DELTA) {
      stateRef.current.lastUpdatedValue = updatedValue;
      dragInputCallback({
        accumulatedChange: 0,
        instantChange: 0,
        originalElements: elements2,
        originalElementsMap: app.scene.getNonDeletedElementsMap(),
        shouldKeepAspectRatio,
        shouldChangeByStepSize: false,
        scene,
        nextValue: rounded,
        property,
        originalAppState: appState2,
        setInputValue: (value2) => setInputValue(String(value2))
      });
      app.syncActionResult({ storeAction: StoreAction.CAPTURE });
    }
  };
  const callbacksRef = useRef34({});
  callbacksRef.current.handleInputValue = handleInputValue;
  useEffect34(() => {
    const input = inputRef.current;
    const callbacks = callbacksRef.current;
    return () => {
      const nextValue = input?.value;
      if (nextValue) {
        callbacks.handleInputValue?.(
          nextValue,
          stateRef.current.originalElements,
          stateRef.current.originalAppState
        );
      }
      window.removeEventListener(
        "pointermove" /* POINTER_MOVE */,
        callbacks.onPointerMove,
        false
      );
      window.removeEventListener(
        "pointerup" /* POINTER_UP */,
        callbacks.onPointerUp,
        false
      );
    };
  }, [
    // we need to track change of `editable` state as mount/unmount
    // because react doesn't trigger `blur` when a an input is blurred due
    // to being disabled (https://github.com/facebook/react/issues/9142).
    // As such, if we keep rendering disabled inputs, then change in selection
    // to an element that has a given property as non-editable would not trigger
    // blur/unmount and wouldn't update the value.
    editable
  ]);
  if (!editable) {
    return null;
  }
  return /* @__PURE__ */ jsxs69(
    "div",
    {
      className: clsx52("drag-input-container", !editable && "disabled"),
      "data-testid": label,
      children: [
        /* @__PURE__ */ jsx123(
          "div",
          {
            className: "drag-input-label",
            ref: labelRef,
            onPointerDown: (event) => {
              if (inputRef.current && editable) {
                document.body.classList.add("excalidraw-cursor-resize");
                let startValue = Number(inputRef.current.value);
                if (isNaN(startValue)) {
                  startValue = 0;
                }
                let lastPointer = null;
                let originalElementsMap = app.scene.getNonDeletedElements().reduce((acc, element) => {
                  acc.set(element.id, deepCopyElement(element));
                  return acc;
                }, /* @__PURE__ */ new Map());
                let originalElements = elements.map(
                  (element) => originalElementsMap.get(element.id)
                );
                const originalAppState = cloneJSON(appState);
                let accumulatedChange = 0;
                let stepChange = 0;
                const onPointerMove = (event2) => {
                  if (lastPointer && originalElementsMap !== null && originalElements !== null) {
                    const instantChange = event2.clientX - lastPointer.x;
                    if (instantChange !== 0) {
                      stepChange += instantChange;
                      if (Math.abs(stepChange) >= sensitivity) {
                        stepChange = Math.sign(stepChange) * Math.floor(Math.abs(stepChange) / sensitivity);
                        accumulatedChange += stepChange;
                        dragInputCallback({
                          accumulatedChange,
                          instantChange: stepChange,
                          originalElements,
                          originalElementsMap,
                          shouldKeepAspectRatio,
                          shouldChangeByStepSize: event2.shiftKey,
                          property,
                          scene,
                          originalAppState,
                          setInputValue: (value2) => setInputValue(String(value2))
                        });
                        stepChange = 0;
                      }
                    }
                  }
                  lastPointer = {
                    x: event2.clientX,
                    y: event2.clientY
                  };
                };
                const onPointerUp = () => {
                  window.removeEventListener(
                    "pointermove" /* POINTER_MOVE */,
                    onPointerMove,
                    false
                  );
                  app.syncActionResult({ storeAction: StoreAction.CAPTURE });
                  lastPointer = null;
                  accumulatedChange = 0;
                  stepChange = 0;
                  originalElements = null;
                  originalElementsMap = null;
                  document.body.classList.remove("excalidraw-cursor-resize");
                  window.removeEventListener("pointerup" /* POINTER_UP */, onPointerUp, false);
                };
                callbacksRef.current.onPointerMove = onPointerMove;
                callbacksRef.current.onPointerUp = onPointerUp;
                window.addEventListener("pointermove" /* POINTER_MOVE */, onPointerMove, false);
                window.addEventListener("pointerup" /* POINTER_UP */, onPointerUp, false);
              }
            },
            onPointerEnter: () => {
              if (labelRef.current) {
                labelRef.current.style.cursor = "ew-resize";
              }
            },
            children: icon ? /* @__PURE__ */ jsx123(InlineIcon, { icon }) : label
          }
        ),
        /* @__PURE__ */ jsx123(
          "input",
          {
            className: "drag-input",
            autoComplete: "off",
            spellCheck: "false",
            onKeyDown: (event) => {
              if (editable) {
                const eventTarget = event.target;
                if (eventTarget instanceof HTMLInputElement && event.key === KEYS.ENTER) {
                  handleInputValue(eventTarget.value, elements, appState);
                  app.focusContainer();
                }
              }
            },
            ref: inputRef,
            value: inputValue,
            onChange: (event) => {
              stateRef.current.updatePending = true;
              setInputValue(event.target.value);
            },
            onFocus: (event) => {
              event.target.select();
              stateRef.current.originalElements = elements;
              stateRef.current.originalAppState = cloneJSON(appState);
            },
            onBlur: (event) => {
              if (!inputValue) {
                setInputValue(value.toString());
              } else if (editable) {
                handleInputValue(
                  event.target.value,
                  stateRef.current.originalElements,
                  stateRef.current.originalAppState
                );
              }
            },
            disabled: !editable
          }
        )
      ]
    }
  );
};
var DragInput_default = StatsDragInput;

// components/Stats/Dimension.tsx
init_constants();
import { jsx as jsx124 } from "react/jsx-runtime";
var STEP_SIZE = 10;
var _shouldKeepAspectRatio = (element) => {
  return element.type === "image";
};
var handleDimensionChange = ({
  accumulatedChange,
  originalElements,
  shouldKeepAspectRatio,
  shouldChangeByStepSize,
  nextValue,
  property,
  scene
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const elements = scene.getNonDeletedElements();
  const origElement = originalElements[0];
  if (origElement) {
    const keepAspectRatio = shouldKeepAspectRatio || _shouldKeepAspectRatio(origElement);
    const aspectRatio = origElement.width / origElement.height;
    if (nextValue !== void 0) {
      const nextWidth2 = Math.max(
        property === "width" ? nextValue : keepAspectRatio ? nextValue * aspectRatio : origElement.width,
        MIN_WIDTH_OR_HEIGHT
      );
      const nextHeight2 = Math.max(
        property === "height" ? nextValue : keepAspectRatio ? nextValue / aspectRatio : origElement.height,
        MIN_WIDTH_OR_HEIGHT
      );
      resizeElement(
        nextWidth2,
        nextHeight2,
        keepAspectRatio,
        origElement,
        elementsMap,
        elements,
        scene
      );
      return;
    }
    const changeInWidth = property === "width" ? accumulatedChange : 0;
    const changeInHeight = property === "height" ? accumulatedChange : 0;
    let nextWidth = Math.max(0, origElement.width + changeInWidth);
    if (property === "width") {
      if (shouldChangeByStepSize) {
        nextWidth = getStepSizedValue(nextWidth, STEP_SIZE);
      } else {
        nextWidth = Math.round(nextWidth);
      }
    }
    let nextHeight = Math.max(0, origElement.height + changeInHeight);
    if (property === "height") {
      if (shouldChangeByStepSize) {
        nextHeight = getStepSizedValue(nextHeight, STEP_SIZE);
      } else {
        nextHeight = Math.round(nextHeight);
      }
    }
    if (keepAspectRatio) {
      if (property === "width") {
        nextHeight = Math.round(nextWidth / aspectRatio * 100) / 100;
      } else {
        nextWidth = Math.round(nextHeight * aspectRatio * 100) / 100;
      }
    }
    nextHeight = Math.max(MIN_WIDTH_OR_HEIGHT, nextHeight);
    nextWidth = Math.max(MIN_WIDTH_OR_HEIGHT, nextWidth);
    resizeElement(
      nextWidth,
      nextHeight,
      keepAspectRatio,
      origElement,
      elementsMap,
      elements,
      scene
    );
  }
};
var DimensionDragInput = ({
  property,
  element,
  scene,
  appState
}) => {
  const value = Math.round((property === "width" ? element.width : element.height) * 100) / 100;
  return /* @__PURE__ */ jsx124(
    DragInput_default,
    {
      label: property === "width" ? "W" : "H",
      elements: [element],
      dragInputCallback: handleDimensionChange,
      value,
      editable: isPropertyEditable(element, property),
      scene,
      appState,
      property
    }
  );
};
var Dimension_default = DimensionDragInput;

// components/Stats/Angle.tsx
init_define_import_meta_env();
init_mutateElement();
init_textElement();
init_typeChecks();
init_icons();
init_math();
import { jsx as jsx125 } from "react/jsx-runtime";
var STEP_SIZE2 = 15;
var handleDegreeChange = ({
  accumulatedChange,
  originalElements,
  shouldChangeByStepSize,
  nextValue,
  scene
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const elements = scene.getNonDeletedElements();
  const origElement = originalElements[0];
  if (origElement && !isElbowArrow(origElement)) {
    const latestElement = elementsMap.get(origElement.id);
    if (!latestElement) {
      return;
    }
    if (nextValue !== void 0) {
      const nextAngle2 = degreesToRadians(nextValue);
      mutateElement(latestElement, {
        angle: nextAngle2
      });
      updateBindings(latestElement, elementsMap, elements, scene);
      const boundTextElement2 = getBoundTextElement(latestElement, elementsMap);
      if (boundTextElement2 && !isArrowElement(latestElement)) {
        mutateElement(boundTextElement2, { angle: nextAngle2 });
      }
      return;
    }
    const originalAngleInDegrees = Math.round(radiansToDegrees(origElement.angle) * 100) / 100;
    const changeInDegrees = Math.round(accumulatedChange);
    let nextAngleInDegrees = (originalAngleInDegrees + changeInDegrees) % 360;
    if (shouldChangeByStepSize) {
      nextAngleInDegrees = getStepSizedValue(nextAngleInDegrees, STEP_SIZE2);
    }
    nextAngleInDegrees = nextAngleInDegrees < 0 ? nextAngleInDegrees + 360 : nextAngleInDegrees;
    const nextAngle = degreesToRadians(nextAngleInDegrees);
    mutateElement(latestElement, {
      angle: nextAngle
    });
    updateBindings(latestElement, elementsMap, elements, scene);
    const boundTextElement = getBoundTextElement(latestElement, elementsMap);
    if (boundTextElement && !isArrowElement(latestElement)) {
      mutateElement(boundTextElement, { angle: nextAngle });
    }
  }
};
var Angle = ({ element, scene, appState, property }) => {
  return /* @__PURE__ */ jsx125(
    DragInput_default,
    {
      label: "A",
      icon: angleIcon,
      value: Math.round(radiansToDegrees(element.angle) % 360 * 100) / 100,
      elements: [element],
      dragInputCallback: handleDegreeChange,
      editable: isPropertyEditable(element, "angle"),
      scene,
      appState,
      property
    }
  );
};
var Angle_default = Angle;

// components/Stats/FontSize.tsx
init_define_import_meta_env();
init_mutateElement();
init_icons();
init_element();
init_typeChecks();
init_textElement();
import { jsx as jsx126 } from "react/jsx-runtime";
var MIN_FONT_SIZE2 = 4;
var STEP_SIZE3 = 4;
var handleFontSizeChange = ({
  accumulatedChange,
  originalElements,
  shouldChangeByStepSize,
  nextValue,
  scene
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const origElement = originalElements[0];
  if (origElement) {
    const latestElement = elementsMap.get(origElement.id);
    if (!latestElement || !isTextElement(latestElement)) {
      return;
    }
    let nextFontSize;
    if (nextValue !== void 0) {
      nextFontSize = Math.max(Math.round(nextValue), MIN_FONT_SIZE2);
    } else if (origElement.type === "text") {
      const originalFontSize = Math.round(origElement.fontSize);
      const changeInFontSize = Math.round(accumulatedChange);
      nextFontSize = Math.max(
        originalFontSize + changeInFontSize,
        MIN_FONT_SIZE2
      );
      if (shouldChangeByStepSize) {
        nextFontSize = getStepSizedValue(nextFontSize, STEP_SIZE3);
      }
    }
    if (nextFontSize) {
      mutateElement(latestElement, {
        fontSize: nextFontSize
      });
      redrawTextBoundingBox(
        latestElement,
        scene.getContainerElement(latestElement),
        scene.getNonDeletedElementsMap()
      );
    }
  }
};
var FontSize = ({ element, scene, appState, property }) => {
  const _element = isTextElement(element) ? element : hasBoundTextElement(element) ? getBoundTextElement(element, scene.getNonDeletedElementsMap()) : null;
  if (!_element) {
    return null;
  }
  return /* @__PURE__ */ jsx126(
    DragInput_default,
    {
      label: "F",
      value: Math.round(_element.fontSize * 10) / 10,
      elements: [_element],
      dragInputCallback: handleFontSizeChange,
      icon: fontSizeIcon,
      appState,
      scene,
      property
    }
  );
};
var FontSize_default = FontSize;

// components/Stats/MultiDimension.tsx
init_define_import_meta_env();
init_element();
init_binding();
init_mutateElement();
init_resizeElements();
init_textElement();
import { useMemo as useMemo7 } from "react";
init_constants();
init_math();
import { jsx as jsx127 } from "react/jsx-runtime";
var STEP_SIZE4 = 10;
var getResizedUpdates = (anchorX, anchorY, scale, origElement) => {
  const offsetX = origElement.x - anchorX;
  const offsetY = origElement.y - anchorY;
  const nextWidth = origElement.width * scale;
  const nextHeight = origElement.height * scale;
  const x = anchorX + offsetX * scale;
  const y = anchorY + offsetY * scale;
  return {
    width: nextWidth,
    height: nextHeight,
    x,
    y,
    ...rescalePointsInElement(origElement, nextWidth, nextHeight, false),
    ...isTextElement(origElement) ? { fontSize: origElement.fontSize * scale } : {}
  };
};
var resizeElementInGroup = (anchorX, anchorY, property, scale, latestElement, origElement, elementsMap, originalElementsMap) => {
  const updates = getResizedUpdates(anchorX, anchorY, scale, origElement);
  const { width: oldWidth, height: oldHeight } = latestElement;
  mutateElement(latestElement, updates, false);
  const boundTextElement = getBoundTextElement(
    origElement,
    originalElementsMap
  );
  if (boundTextElement) {
    const newFontSize = boundTextElement.fontSize * scale;
    updateBoundElements(latestElement, elementsMap, {
      oldSize: { width: oldWidth, height: oldHeight }
    });
    const latestBoundTextElement = elementsMap.get(boundTextElement.id);
    if (latestBoundTextElement && isTextElement(latestBoundTextElement)) {
      mutateElement(
        latestBoundTextElement,
        {
          fontSize: newFontSize
        },
        false
      );
      handleBindTextResize(
        latestElement,
        elementsMap,
        property === "width" ? "e" : "s",
        true
      );
    }
  }
};
var resizeGroup = (nextWidth, nextHeight, initialHeight, aspectRatio, anchor, property, latestElements, originalElements, elementsMap, originalElementsMap) => {
  if (property === "width") {
    nextHeight = Math.round(nextWidth / aspectRatio * 100) / 100;
  } else {
    nextWidth = Math.round(nextHeight * aspectRatio * 100) / 100;
  }
  const scale = nextHeight / initialHeight;
  for (let i = 0; i < originalElements.length; i++) {
    const origElement = originalElements[i];
    const latestElement = latestElements[i];
    resizeElementInGroup(
      anchor[0],
      anchor[1],
      property,
      scale,
      latestElement,
      origElement,
      elementsMap,
      originalElementsMap
    );
  }
};
var handleDimensionChange2 = ({
  accumulatedChange,
  originalElements,
  originalElementsMap,
  originalAppState,
  shouldChangeByStepSize,
  nextValue,
  scene,
  property
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const elements = scene.getNonDeletedElements();
  const atomicUnits = getAtomicUnits(originalElements, originalAppState);
  if (nextValue !== void 0) {
    for (const atomicUnit of atomicUnits) {
      const elementsInUnit = getElementsInAtomicUnit(
        atomicUnit,
        elementsMap,
        originalElementsMap
      );
      if (elementsInUnit.length > 1) {
        const latestElements = elementsInUnit.map((el) => el.latest);
        const originalElements2 = elementsInUnit.map((el) => el.original);
        const [x1, y1, x2, y2] = getCommonBounds(originalElements2);
        const initialWidth = x2 - x1;
        const initialHeight = y2 - y1;
        const aspectRatio = initialWidth / initialHeight;
        const nextWidth = Math.max(
          MIN_WIDTH_OR_HEIGHT,
          property === "width" ? Math.max(0, nextValue) : initialWidth
        );
        const nextHeight = Math.max(
          MIN_WIDTH_OR_HEIGHT,
          property === "height" ? Math.max(0, nextValue) : initialHeight
        );
        resizeGroup(
          nextWidth,
          nextHeight,
          initialHeight,
          aspectRatio,
          pointFrom(x1, y1),
          property,
          latestElements,
          originalElements2,
          elementsMap,
          originalElementsMap
        );
      } else {
        const [el] = elementsInUnit;
        const latestElement = el?.latest;
        const origElement = el?.original;
        if (latestElement && origElement && isPropertyEditable(latestElement, property)) {
          let nextWidth = property === "width" ? Math.max(0, nextValue) : latestElement.width;
          if (property === "width") {
            if (shouldChangeByStepSize) {
              nextWidth = getStepSizedValue(nextWidth, STEP_SIZE4);
            } else {
              nextWidth = Math.round(nextWidth);
            }
          }
          let nextHeight = property === "height" ? Math.max(0, nextValue) : latestElement.height;
          if (property === "height") {
            if (shouldChangeByStepSize) {
              nextHeight = getStepSizedValue(nextHeight, STEP_SIZE4);
            } else {
              nextHeight = Math.round(nextHeight);
            }
          }
          nextWidth = Math.max(MIN_WIDTH_OR_HEIGHT, nextWidth);
          nextHeight = Math.max(MIN_WIDTH_OR_HEIGHT, nextHeight);
          resizeElement(
            nextWidth,
            nextHeight,
            false,
            origElement,
            elementsMap,
            elements,
            scene,
            false
          );
        }
      }
    }
    scene.triggerUpdate();
    return;
  }
  const changeInWidth = property === "width" ? accumulatedChange : 0;
  const changeInHeight = property === "height" ? accumulatedChange : 0;
  for (const atomicUnit of atomicUnits) {
    const elementsInUnit = getElementsInAtomicUnit(
      atomicUnit,
      elementsMap,
      originalElementsMap
    );
    if (elementsInUnit.length > 1) {
      const latestElements = elementsInUnit.map((el) => el.latest);
      const originalElements2 = elementsInUnit.map((el) => el.original);
      const [x1, y1, x2, y2] = getCommonBounds(originalElements2);
      const initialWidth = x2 - x1;
      const initialHeight = y2 - y1;
      const aspectRatio = initialWidth / initialHeight;
      let nextWidth = Math.max(0, initialWidth + changeInWidth);
      if (property === "width") {
        if (shouldChangeByStepSize) {
          nextWidth = getStepSizedValue(nextWidth, STEP_SIZE4);
        } else {
          nextWidth = Math.round(nextWidth);
        }
      }
      let nextHeight = Math.max(0, initialHeight + changeInHeight);
      if (property === "height") {
        if (shouldChangeByStepSize) {
          nextHeight = getStepSizedValue(nextHeight, STEP_SIZE4);
        } else {
          nextHeight = Math.round(nextHeight);
        }
      }
      nextWidth = Math.max(MIN_WIDTH_OR_HEIGHT, nextWidth);
      nextHeight = Math.max(MIN_WIDTH_OR_HEIGHT, nextHeight);
      resizeGroup(
        nextWidth,
        nextHeight,
        initialHeight,
        aspectRatio,
        pointFrom(x1, y1),
        property,
        latestElements,
        originalElements2,
        elementsMap,
        originalElementsMap
      );
    } else {
      const [el] = elementsInUnit;
      const latestElement = el?.latest;
      const origElement = el?.original;
      if (latestElement && origElement && isPropertyEditable(latestElement, property)) {
        let nextWidth = Math.max(0, origElement.width + changeInWidth);
        if (property === "width") {
          if (shouldChangeByStepSize) {
            nextWidth = getStepSizedValue(nextWidth, STEP_SIZE4);
          } else {
            nextWidth = Math.round(nextWidth);
          }
        }
        let nextHeight = Math.max(0, origElement.height + changeInHeight);
        if (property === "height") {
          if (shouldChangeByStepSize) {
            nextHeight = getStepSizedValue(nextHeight, STEP_SIZE4);
          } else {
            nextHeight = Math.round(nextHeight);
          }
        }
        nextWidth = Math.max(MIN_WIDTH_OR_HEIGHT, nextWidth);
        nextHeight = Math.max(MIN_WIDTH_OR_HEIGHT, nextHeight);
        resizeElement(
          nextWidth,
          nextHeight,
          false,
          origElement,
          elementsMap,
          elements,
          scene
        );
      }
    }
  }
  scene.triggerUpdate();
};
var MultiDimension = ({
  property,
  elements,
  elementsMap,
  atomicUnits,
  scene,
  appState
}) => {
  const sizes = useMemo7(
    () => atomicUnits.map((atomicUnit) => {
      const elementsInUnit = getElementsInAtomicUnit(atomicUnit, elementsMap);
      if (elementsInUnit.length > 1) {
        const [x1, y1, x2, y2] = getCommonBounds(
          elementsInUnit.map((el2) => el2.latest)
        );
        return Math.round((property === "width" ? x2 - x1 : y2 - y1) * 100) / 100;
      }
      const [el] = elementsInUnit;
      return Math.round(
        (property === "width" ? el.latest.width : el.latest.height) * 100
      ) / 100;
    }),
    [elementsMap, atomicUnits, property]
  );
  const value = new Set(sizes).size === 1 ? Math.round(sizes[0] * 100) / 100 : "Mixed";
  const editable = sizes.length > 0;
  return /* @__PURE__ */ jsx127(
    DragInput_default,
    {
      label: property === "width" ? "W" : "H",
      elements,
      dragInputCallback: handleDimensionChange2,
      value,
      editable,
      appState,
      property,
      scene
    }
  );
};
var MultiDimension_default = MultiDimension;

// components/Stats/index.tsx
init_groups();

// components/Stats/MultiAngle.tsx
init_define_import_meta_env();
init_mutateElement();
init_textElement();
init_typeChecks();
init_groups();
init_icons();
init_math();
import { jsx as jsx128 } from "react/jsx-runtime";
var STEP_SIZE5 = 15;
var handleDegreeChange2 = ({
  accumulatedChange,
  originalElements,
  shouldChangeByStepSize,
  nextValue,
  property,
  scene
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const editableLatestIndividualElements = originalElements.map((el) => elementsMap.get(el.id)).filter((el) => el && !isInGroup(el) && isPropertyEditable(el, property));
  const editableOriginalIndividualElements = originalElements.filter(
    (el) => !isInGroup(el) && isPropertyEditable(el, property)
  );
  if (nextValue !== void 0) {
    const nextAngle = degreesToRadians(nextValue);
    for (const element of editableLatestIndividualElements) {
      if (!element) {
        continue;
      }
      mutateElement(
        element,
        {
          angle: nextAngle
        },
        false
      );
      const boundTextElement = getBoundTextElement(element, elementsMap);
      if (boundTextElement && !isArrowElement(element)) {
        mutateElement(boundTextElement, { angle: nextAngle }, false);
      }
    }
    scene.triggerUpdate();
    return;
  }
  for (let i = 0; i < editableLatestIndividualElements.length; i++) {
    const latestElement = editableLatestIndividualElements[i];
    if (!latestElement) {
      continue;
    }
    const originalElement = editableOriginalIndividualElements[i];
    const originalAngleInDegrees = Math.round(radiansToDegrees(originalElement.angle) * 100) / 100;
    const changeInDegrees = Math.round(accumulatedChange);
    let nextAngleInDegrees = (originalAngleInDegrees + changeInDegrees) % 360;
    if (shouldChangeByStepSize) {
      nextAngleInDegrees = getStepSizedValue(nextAngleInDegrees, STEP_SIZE5);
    }
    nextAngleInDegrees = nextAngleInDegrees < 0 ? nextAngleInDegrees + 360 : nextAngleInDegrees;
    const nextAngle = degreesToRadians(nextAngleInDegrees);
    mutateElement(
      latestElement,
      {
        angle: nextAngle
      },
      false
    );
    const boundTextElement = getBoundTextElement(latestElement, elementsMap);
    if (boundTextElement && !isArrowElement(latestElement)) {
      mutateElement(boundTextElement, { angle: nextAngle }, false);
    }
  }
  scene.triggerUpdate();
};
var MultiAngle = ({
  elements,
  scene,
  appState,
  property
}) => {
  const editableLatestIndividualElements = elements.filter(
    (el) => !isInGroup(el) && isPropertyEditable(el, "angle")
  );
  const angles = editableLatestIndividualElements.map(
    (el) => Math.round(radiansToDegrees(el.angle) % 360 * 100) / 100
  );
  const value = new Set(angles).size === 1 ? angles[0] : "Mixed";
  const editable = editableLatestIndividualElements.some(
    (el) => isPropertyEditable(el, "angle")
  );
  return /* @__PURE__ */ jsx128(
    DragInput_default,
    {
      label: "A",
      icon: angleIcon,
      value,
      elements,
      dragInputCallback: handleDegreeChange2,
      editable,
      appState,
      scene,
      property
    }
  );
};
var MultiAngle_default = MultiAngle;

// components/Stats/MultiFontSize.tsx
init_define_import_meta_env();
init_element();
init_mutateElement();
init_typeChecks();
init_groups();
init_icons();
init_textElement();
import { jsx as jsx129 } from "react/jsx-runtime";
var MIN_FONT_SIZE3 = 4;
var STEP_SIZE6 = 4;
var getApplicableTextElements = (elements, elementsMap) => elements.reduce(
  (acc, el) => {
    if (!el || isInGroup(el)) {
      return acc;
    }
    if (isTextElement(el)) {
      acc.push(el);
      return acc;
    }
    if (hasBoundTextElement(el)) {
      const boundTextElement = getBoundTextElement(el, elementsMap);
      if (boundTextElement) {
        acc.push(boundTextElement);
        return acc;
      }
    }
    return acc;
  },
  []
);
var handleFontSizeChange2 = ({
  accumulatedChange,
  originalElements,
  shouldChangeByStepSize,
  nextValue,
  scene
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const latestTextElements = originalElements.map(
    (el) => elementsMap.get(el.id)
  );
  let nextFontSize;
  if (nextValue) {
    nextFontSize = Math.max(Math.round(nextValue), MIN_FONT_SIZE3);
    for (const textElement of latestTextElements) {
      mutateElement(
        textElement,
        {
          fontSize: nextFontSize
        },
        false
      );
      redrawTextBoundingBox(
        textElement,
        scene.getContainerElement(textElement),
        elementsMap,
        false
      );
    }
    scene.triggerUpdate();
  } else {
    const originalTextElements = originalElements;
    for (let i = 0; i < latestTextElements.length; i++) {
      const latestElement = latestTextElements[i];
      const originalElement = originalTextElements[i];
      const originalFontSize = Math.round(originalElement.fontSize);
      const changeInFontSize = Math.round(accumulatedChange);
      let nextFontSize2 = Math.max(
        originalFontSize + changeInFontSize,
        MIN_FONT_SIZE3
      );
      if (shouldChangeByStepSize) {
        nextFontSize2 = getStepSizedValue(nextFontSize2, STEP_SIZE6);
      }
      mutateElement(
        latestElement,
        {
          fontSize: nextFontSize2
        },
        false
      );
      redrawTextBoundingBox(
        latestElement,
        scene.getContainerElement(latestElement),
        elementsMap,
        false
      );
    }
    scene.triggerUpdate();
  }
};
var MultiFontSize = ({
  elements,
  scene,
  appState,
  property,
  elementsMap
}) => {
  const latestTextElements = getApplicableTextElements(elements, elementsMap);
  if (!latestTextElements.length) {
    return null;
  }
  const fontSizes = latestTextElements.map(
    (textEl) => Math.round(textEl.fontSize * 10) / 10
  );
  const value = new Set(fontSizes).size === 1 ? fontSizes[0] : "Mixed";
  const editable = fontSizes.length > 0;
  return /* @__PURE__ */ jsx129(
    DragInput_default,
    {
      label: "F",
      icon: fontSizeIcon,
      elements: latestTextElements,
      dragInputCallback: handleFontSizeChange2,
      value,
      editable,
      scene,
      property,
      appState
    }
  );
};
var MultiFontSize_default = MultiFontSize;

// components/Stats/Position.tsx
init_define_import_meta_env();
init_math();
import { jsx as jsx130 } from "react/jsx-runtime";
var STEP_SIZE7 = 10;
var handlePositionChange = ({
  accumulatedChange,
  originalElements,
  originalElementsMap,
  shouldChangeByStepSize,
  nextValue,
  property,
  scene
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const elements = scene.getNonDeletedElements();
  const origElement = originalElements[0];
  const [cx, cy] = [
    origElement.x + origElement.width / 2,
    origElement.y + origElement.height / 2
  ];
  const [topLeftX, topLeftY] = pointRotateRads(
    pointFrom(origElement.x, origElement.y),
    pointFrom(cx, cy),
    origElement.angle
  );
  if (nextValue !== void 0) {
    const newTopLeftX2 = property === "x" ? nextValue : topLeftX;
    const newTopLeftY2 = property === "y" ? nextValue : topLeftY;
    moveElement(
      newTopLeftX2,
      newTopLeftY2,
      origElement,
      elementsMap,
      elements,
      scene,
      originalElementsMap
    );
    return;
  }
  const changeInTopX = property === "x" ? accumulatedChange : 0;
  const changeInTopY = property === "y" ? accumulatedChange : 0;
  const newTopLeftX = property === "x" ? Math.round(
    shouldChangeByStepSize ? getStepSizedValue(origElement.x + changeInTopX, STEP_SIZE7) : topLeftX + changeInTopX
  ) : topLeftX;
  const newTopLeftY = property === "y" ? Math.round(
    shouldChangeByStepSize ? getStepSizedValue(origElement.y + changeInTopY, STEP_SIZE7) : topLeftY + changeInTopY
  ) : topLeftY;
  moveElement(
    newTopLeftX,
    newTopLeftY,
    origElement,
    elementsMap,
    elements,
    scene,
    originalElementsMap
  );
};
var Position = ({
  property,
  element,
  elementsMap,
  scene,
  appState
}) => {
  const [topLeftX, topLeftY] = pointRotateRads(
    pointFrom(element.x, element.y),
    pointFrom(element.x + element.width / 2, element.y + element.height / 2),
    element.angle
  );
  const value = Math.round((property === "x" ? topLeftX : topLeftY) * 100) / 100;
  return /* @__PURE__ */ jsx130(
    DragInput_default,
    {
      label: property === "x" ? "X" : "Y",
      elements: [element],
      dragInputCallback: handlePositionChange,
      scene,
      value,
      property,
      appState
    }
  );
};
var Position_default = Position;

// components/Stats/MultiPosition.tsx
init_define_import_meta_env();
init_element();
import { useMemo as useMemo8 } from "react";
init_math();
import { jsx as jsx131 } from "react/jsx-runtime";
var STEP_SIZE8 = 10;
var moveElements = (property, changeInTopX, changeInTopY, elements, originalElements, elementsMap, originalElementsMap, scene) => {
  for (let i = 0; i < elements.length; i++) {
    const origElement = originalElements[i];
    const [cx, cy] = [
      origElement.x + origElement.width / 2,
      origElement.y + origElement.height / 2
    ];
    const [topLeftX, topLeftY] = pointRotateRads(
      pointFrom(origElement.x, origElement.y),
      pointFrom(cx, cy),
      origElement.angle
    );
    const newTopLeftX = property === "x" ? Math.round(topLeftX + changeInTopX) : topLeftX;
    const newTopLeftY = property === "y" ? Math.round(topLeftY + changeInTopY) : topLeftY;
    moveElement(
      newTopLeftX,
      newTopLeftY,
      origElement,
      elementsMap,
      elements,
      scene,
      originalElementsMap,
      false
    );
  }
};
var moveGroupTo = (nextX, nextY, originalElements, elementsMap, elements, originalElementsMap, scene) => {
  const [x1, y1, ,] = getCommonBounds(originalElements);
  const offsetX = nextX - x1;
  const offsetY = nextY - y1;
  for (let i = 0; i < originalElements.length; i++) {
    const origElement = originalElements[i];
    const latestElement = elementsMap.get(origElement.id);
    if (!latestElement) {
      continue;
    }
    if (!isTextElement(latestElement) || !latestElement.containerId) {
      const [cx, cy] = [
        latestElement.x + latestElement.width / 2,
        latestElement.y + latestElement.height / 2
      ];
      const [topLeftX, topLeftY] = pointRotateRads(
        pointFrom(latestElement.x, latestElement.y),
        pointFrom(cx, cy),
        latestElement.angle
      );
      moveElement(
        topLeftX + offsetX,
        topLeftY + offsetY,
        origElement,
        elementsMap,
        elements,
        scene,
        originalElementsMap,
        false
      );
    }
  }
};
var handlePositionChange2 = ({
  accumulatedChange,
  originalElements,
  originalElementsMap,
  shouldChangeByStepSize,
  nextValue,
  property,
  scene,
  originalAppState
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const elements = scene.getNonDeletedElements();
  if (nextValue !== void 0) {
    for (const atomicUnit of getAtomicUnits(
      originalElements,
      originalAppState
    )) {
      const elementsInUnit = getElementsInAtomicUnit(
        atomicUnit,
        elementsMap,
        originalElementsMap
      );
      if (elementsInUnit.length > 1) {
        const [x1, y1, ,] = getCommonBounds(
          elementsInUnit.map((el) => el.latest)
        );
        const newTopLeftX = property === "x" ? nextValue : x1;
        const newTopLeftY = property === "y" ? nextValue : y1;
        moveGroupTo(
          newTopLeftX,
          newTopLeftY,
          elementsInUnit.map((el) => el.original),
          elementsMap,
          elements,
          originalElementsMap,
          scene
        );
      } else {
        const origElement = elementsInUnit[0]?.original;
        const latestElement = elementsInUnit[0]?.latest;
        if (origElement && latestElement && isPropertyEditable(latestElement, property)) {
          const [cx, cy] = [
            origElement.x + origElement.width / 2,
            origElement.y + origElement.height / 2
          ];
          const [topLeftX, topLeftY] = pointRotateRads(
            pointFrom(origElement.x, origElement.y),
            pointFrom(cx, cy),
            origElement.angle
          );
          const newTopLeftX = property === "x" ? nextValue : topLeftX;
          const newTopLeftY = property === "y" ? nextValue : topLeftY;
          moveElement(
            newTopLeftX,
            newTopLeftY,
            origElement,
            elementsMap,
            elements,
            scene,
            originalElementsMap,
            false
          );
        }
      }
    }
    scene.triggerUpdate();
    return;
  }
  const change = shouldChangeByStepSize ? getStepSizedValue(accumulatedChange, STEP_SIZE8) : accumulatedChange;
  const changeInTopX = property === "x" ? change : 0;
  const changeInTopY = property === "y" ? change : 0;
  moveElements(
    property,
    changeInTopX,
    changeInTopY,
    originalElements,
    originalElements,
    elementsMap,
    originalElementsMap,
    scene
  );
  scene.triggerUpdate();
};
var MultiPosition = ({
  property,
  elements,
  elementsMap,
  atomicUnits,
  scene,
  appState
}) => {
  const positions = useMemo8(
    () => atomicUnits.map((atomicUnit) => {
      const elementsInUnit = Object.keys(atomicUnit).map((id) => elementsMap.get(id)).filter((el2) => el2 !== void 0);
      if (elementsInUnit.length > 1) {
        const [x1, y1] = getCommonBounds(elementsInUnit);
        return Math.round((property === "x" ? x1 : y1) * 100) / 100;
      }
      const [el] = elementsInUnit;
      const [cx, cy] = [el.x + el.width / 2, el.y + el.height / 2];
      const [topLeftX, topLeftY] = pointRotateRads(
        pointFrom(el.x, el.y),
        pointFrom(cx, cy),
        el.angle
      );
      return Math.round((property === "x" ? topLeftX : topLeftY) * 100) / 100;
    }),
    [atomicUnits, elementsMap, property]
  );
  const value = new Set(positions).size === 1 ? positions[0] : "Mixed";
  return /* @__PURE__ */ jsx131(
    DragInput_default,
    {
      label: property === "x" ? "X" : "Y",
      elements,
      dragInputCallback: handlePositionChange2,
      value,
      property,
      scene,
      appState
    }
  );
};
var MultiPosition_default = MultiPosition;

// components/Stats/Collapsible.tsx
init_define_import_meta_env();
init_icons();
import { Fragment as Fragment22, jsx as jsx132, jsxs as jsxs70 } from "react/jsx-runtime";
var Collapsible = ({
  label,
  open,
  openTrigger,
  children
}) => {
  return /* @__PURE__ */ jsxs70(Fragment22, { children: [
    /* @__PURE__ */ jsxs70(
      "div",
      {
        style: {
          cursor: "pointer",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center"
        },
        onClick: openTrigger,
        children: [
          label,
          /* @__PURE__ */ jsx132(InlineIcon, { icon: open ? collapseUpIcon : collapseDownIcon })
        ]
      }
    ),
    open && /* @__PURE__ */ jsx132("div", { style: { display: "flex", flexDirection: "column" }, children })
  ] });
};
var Collapsible_default = Collapsible;

// components/Stats/index.tsx
init_constants();
init_typeChecks();

// components/Stats/CanvasGrid.tsx
init_define_import_meta_env();
init_scene();
import { jsx as jsx133 } from "react/jsx-runtime";
var STEP_SIZE9 = 5;
var CanvasGrid = ({
  property,
  scene,
  appState,
  setAppState
}) => {
  return /* @__PURE__ */ jsx133(
    DragInput_default,
    {
      label: "Grid step",
      sensitivity: 8,
      elements: [],
      dragInputCallback: ({
        nextValue,
        instantChange,
        shouldChangeByStepSize,
        setInputValue
      }) => {
        setAppState((state) => {
          let nextGridStep;
          if (nextValue) {
            nextGridStep = nextValue;
          } else if (instantChange) {
            nextGridStep = shouldChangeByStepSize ? getStepSizedValue(
              state.gridStep + STEP_SIZE9 * Math.sign(instantChange),
              STEP_SIZE9
            ) : state.gridStep + instantChange;
          }
          if (!nextGridStep) {
            setInputValue(state.gridStep);
            return null;
          }
          nextGridStep = getNormalizedGridStep(nextGridStep);
          setInputValue(nextGridStep);
          return {
            gridStep: nextGridStep
          };
        });
      },
      scene,
      value: appState.gridStep,
      property,
      appState
    }
  );
};
var CanvasGrid_default = CanvasGrid;

// components/Stats/index.tsx
import clsx53 from "clsx";
init_snapping();
import { Fragment as Fragment23, jsx as jsx134, jsxs as jsxs71 } from "react/jsx-runtime";
var STATS_TIMEOUT = 50;
var Stats = (props) => {
  const appState = useExcalidrawAppState();
  const sceneNonce = props.app.scene.getSceneNonce() || 1;
  const selectedElements = props.app.scene.getSelectedElements({
    selectedElementIds: appState.selectedElementIds,
    includeBoundTextElement: false
  });
  const gridModeEnabled = isGridModeEnabled(props.app);
  return /* @__PURE__ */ jsx134(
    StatsInner,
    {
      ...props,
      appState,
      sceneNonce,
      selectedElements,
      gridModeEnabled
    }
  );
};
var StatsRow = ({
  children,
  columns = 1,
  heading,
  style,
  ...rest
}) => /* @__PURE__ */ jsx134(
  "div",
  {
    className: clsx53("exc-stats__row", { "exc-stats__row--heading": heading }),
    style: {
      gridTemplateColumns: `repeat(${columns}, 1fr)`,
      ...style
    },
    ...rest,
    children
  }
);
StatsRow.displayName = "StatsRow";
var StatsRows = ({
  children,
  order,
  style,
  ...rest
}) => /* @__PURE__ */ jsx134("div", { className: "exc-stats__rows", style: { order, ...style }, ...rest, children });
StatsRows.displayName = "StatsRows";
Stats.StatsRow = StatsRow;
Stats.StatsRows = StatsRows;
var StatsInner = memo4(
  ({
    app,
    onClose,
    renderCustomStats,
    selectedElements,
    appState,
    sceneNonce,
    gridModeEnabled
  }) => {
    const scene = app.scene;
    const elements = scene.getNonDeletedElements();
    const elementsMap = scene.getNonDeletedElementsMap();
    const setAppState = useExcalidrawSetAppState();
    const singleElement = selectedElements.length === 1 ? selectedElements[0] : null;
    const multipleElements = selectedElements.length > 1 ? selectedElements : null;
    const [sceneDimension, setSceneDimension] = useState35({
      width: 0,
      height: 0
    });
    const throttledSetSceneDimension = useMemo9(
      () => throttle3((elements2) => {
        const boundingBox = getCommonBounds(elements2);
        setSceneDimension({
          width: Math.round(boundingBox[2]) - Math.round(boundingBox[0]),
          height: Math.round(boundingBox[3]) - Math.round(boundingBox[1])
        });
      }, STATS_TIMEOUT),
      []
    );
    useEffect35(() => {
      throttledSetSceneDimension(elements);
    }, [sceneNonce, elements, throttledSetSceneDimension]);
    useEffect35(
      () => () => throttledSetSceneDimension.cancel(),
      [throttledSetSceneDimension]
    );
    const atomicUnits = useMemo9(() => {
      return getAtomicUnits(selectedElements, appState);
    }, [selectedElements, appState]);
    return /* @__PURE__ */ jsx134("div", { className: "exc-stats", children: /* @__PURE__ */ jsxs71(Island, { padding: 3, children: [
      /* @__PURE__ */ jsxs71("div", { className: "title", children: [
        /* @__PURE__ */ jsx134("h2", { children: t("stats.title") }),
        /* @__PURE__ */ jsx134("div", { className: "close", onClick: onClose, children: CloseIcon })
      ] }),
      /* @__PURE__ */ jsxs71(
        Collapsible_default,
        {
          label: /* @__PURE__ */ jsx134("h3", { children: t("stats.generalStats") }),
          open: !!(appState.stats.panels & STATS_PANELS.generalStats),
          openTrigger: () => setAppState((state) => {
            return {
              stats: {
                open: true,
                panels: state.stats.panels ^ STATS_PANELS.generalStats
              }
            };
          }),
          children: [
            /* @__PURE__ */ jsxs71(StatsRows, { children: [
              /* @__PURE__ */ jsx134(StatsRow, { heading: true, children: t("stats.scene") }),
              /* @__PURE__ */ jsxs71(StatsRow, { columns: 2, children: [
                /* @__PURE__ */ jsx134("div", { children: t("stats.shapes") }),
                /* @__PURE__ */ jsx134("div", { children: elements.length })
              ] }),
              /* @__PURE__ */ jsxs71(StatsRow, { columns: 2, children: [
                /* @__PURE__ */ jsx134("div", { children: t("stats.width") }),
                /* @__PURE__ */ jsx134("div", { children: sceneDimension.width })
              ] }),
              /* @__PURE__ */ jsxs71(StatsRow, { columns: 2, children: [
                /* @__PURE__ */ jsx134("div", { children: t("stats.height") }),
                /* @__PURE__ */ jsx134("div", { children: sceneDimension.height })
              ] }),
              gridModeEnabled && /* @__PURE__ */ jsxs71(Fragment23, { children: [
                /* @__PURE__ */ jsx134(StatsRow, { heading: true, children: "Canvas" }),
                /* @__PURE__ */ jsx134(StatsRow, { children: /* @__PURE__ */ jsx134(
                  CanvasGrid_default,
                  {
                    property: "gridStep",
                    scene,
                    appState,
                    setAppState
                  }
                ) })
              ] })
            ] }),
            renderCustomStats?.(elements, appState)
          ]
        }
      ),
      selectedElements.length > 0 && /* @__PURE__ */ jsx134(
        "div",
        {
          id: "elementStats",
          style: {
            marginTop: 12
          },
          children: /* @__PURE__ */ jsx134(
            Collapsible_default,
            {
              label: /* @__PURE__ */ jsx134("h3", { children: t("stats.elementProperties") }),
              open: !!(appState.stats.panels & STATS_PANELS.elementProperties),
              openTrigger: () => setAppState((state) => {
                return {
                  stats: {
                    open: true,
                    panels: state.stats.panels ^ STATS_PANELS.elementProperties
                  }
                };
              }),
              children: /* @__PURE__ */ jsxs71(StatsRows, { children: [
                singleElement && /* @__PURE__ */ jsxs71(Fragment23, { children: [
                  /* @__PURE__ */ jsx134(StatsRow, { heading: true, "data-testid": "stats-element-type", children: t(`element.${singleElement.type}`) }),
                  /* @__PURE__ */ jsx134(StatsRow, { children: /* @__PURE__ */ jsx134(
                    Position_default,
                    {
                      element: singleElement,
                      property: "x",
                      elementsMap,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ jsx134(StatsRow, { children: /* @__PURE__ */ jsx134(
                    Position_default,
                    {
                      element: singleElement,
                      property: "y",
                      elementsMap,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ jsx134(StatsRow, { children: /* @__PURE__ */ jsx134(
                    Dimension_default,
                    {
                      property: "width",
                      element: singleElement,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ jsx134(StatsRow, { children: /* @__PURE__ */ jsx134(
                    Dimension_default,
                    {
                      property: "height",
                      element: singleElement,
                      scene,
                      appState
                    }
                  ) }),
                  !isElbowArrow(singleElement) && /* @__PURE__ */ jsx134(StatsRow, { children: /* @__PURE__ */ jsx134(
                    Angle_default,
                    {
                      property: "angle",
                      element: singleElement,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ jsx134(StatsRow, { children: /* @__PURE__ */ jsx134(
                    FontSize_default,
                    {
                      property: "fontSize",
                      element: singleElement,
                      scene,
                      appState
                    }
                  ) })
                ] }),
                multipleElements && /* @__PURE__ */ jsxs71(Fragment23, { children: [
                  elementsAreInSameGroup(multipleElements) && /* @__PURE__ */ jsx134(StatsRow, { heading: true, children: t("element.group") }),
                  /* @__PURE__ */ jsxs71(StatsRow, { columns: 2, style: { margin: "0.3125rem 0" }, children: [
                    /* @__PURE__ */ jsx134("div", { children: t("stats.shapes") }),
                    /* @__PURE__ */ jsx134("div", { children: selectedElements.length })
                  ] }),
                  /* @__PURE__ */ jsx134(StatsRow, { children: /* @__PURE__ */ jsx134(
                    MultiPosition_default,
                    {
                      property: "x",
                      elements: multipleElements,
                      elementsMap,
                      atomicUnits,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ jsx134(StatsRow, { children: /* @__PURE__ */ jsx134(
                    MultiPosition_default,
                    {
                      property: "y",
                      elements: multipleElements,
                      elementsMap,
                      atomicUnits,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ jsx134(StatsRow, { children: /* @__PURE__ */ jsx134(
                    MultiDimension_default,
                    {
                      property: "width",
                      elements: multipleElements,
                      elementsMap,
                      atomicUnits,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ jsx134(StatsRow, { children: /* @__PURE__ */ jsx134(
                    MultiDimension_default,
                    {
                      property: "height",
                      elements: multipleElements,
                      elementsMap,
                      atomicUnits,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ jsx134(StatsRow, { children: /* @__PURE__ */ jsx134(
                    MultiAngle_default,
                    {
                      property: "angle",
                      elements: multipleElements,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ jsx134(StatsRow, { children: /* @__PURE__ */ jsx134(
                    MultiFontSize_default,
                    {
                      property: "fontSize",
                      elements: multipleElements,
                      scene,
                      appState,
                      elementsMap
                    }
                  ) })
                ] })
              ] })
            }
          )
        }
      )
    ] }) });
  },
  (prev, next) => {
    return prev.sceneNonce === next.sceneNonce && prev.selectedElements === next.selectedElements && prev.appState.stats.panels === next.appState.stats.panels && prev.gridModeEnabled === next.gridModeEnabled && prev.appState.gridStep === next.appState.gridStep;
  }
);

// components/LayerUI.tsx
import { Fragment as Fragment24, jsx as jsx135, jsxs as jsxs72 } from "react/jsx-runtime";
var DefaultMainMenu = ({ UIOptions }) => {
  return /* @__PURE__ */ jsxs72(MainMenu_default, { __fallback: true, children: [
    /* @__PURE__ */ jsx135(MainMenu_default.DefaultItems.LoadScene, {}),
    /* @__PURE__ */ jsx135(MainMenu_default.DefaultItems.SaveToActiveFile, {}),
    UIOptions.canvasActions.export && /* @__PURE__ */ jsx135(MainMenu_default.DefaultItems.Export, {}),
    UIOptions.canvasActions.saveAsImage && /* @__PURE__ */ jsx135(MainMenu_default.DefaultItems.SaveAsImage, {}),
    /* @__PURE__ */ jsx135(MainMenu_default.DefaultItems.SearchMenu, {}),
    /* @__PURE__ */ jsx135(MainMenu_default.DefaultItems.Help, {}),
    /* @__PURE__ */ jsx135(MainMenu_default.DefaultItems.ClearCanvas, {}),
    /* @__PURE__ */ jsx135(MainMenu_default.Separator, {}),
    /* @__PURE__ */ jsx135(MainMenu_default.Group, { title: "Excalidraw links", children: /* @__PURE__ */ jsx135(MainMenu_default.DefaultItems.Socials, {}) }),
    /* @__PURE__ */ jsx135(MainMenu_default.Separator, {}),
    /* @__PURE__ */ jsx135(MainMenu_default.DefaultItems.ToggleTheme, {}),
    /* @__PURE__ */ jsx135(MainMenu_default.DefaultItems.ChangeCanvasBackground, {})
  ] });
};
var DefaultOverwriteConfirmDialog = () => {
  return /* @__PURE__ */ jsxs72(OverwriteConfirmDialog, { __fallback: true, children: [
    /* @__PURE__ */ jsx135(OverwriteConfirmDialog.Actions.SaveToDisk, {}),
    /* @__PURE__ */ jsx135(OverwriteConfirmDialog.Actions.ExportToImage, {})
  ] });
};
var LayerUI = ({
  actionManager,
  appState,
  files,
  setAppState,
  elements,
  canvas: canvas2,
  onLockToggle,
  onHandToolToggle,
  onPenModeToggle,
  showExitZenModeBtn,
  renderTopRightUI,
  renderCustomStats,
  UIOptions,
  onExportImage,
  renderWelcomeScreen,
  children,
  app,
  isCollaborating
}) => {
  const device = useDevice();
  const tunnels = useInitializeTunnels();
  const [eyeDropperState, setEyeDropperState] = useAtom18(
    activeEyeDropperAtom,
    jotaiScope
  );
  const renderJSONExportDialog = () => {
    if (!UIOptions.canvasActions.export) {
      return null;
    }
    return /* @__PURE__ */ jsx135(
      JSONExportDialog,
      {
        elements,
        appState,
        files,
        actionManager,
        exportOpts: UIOptions.canvasActions.export,
        canvas: canvas2,
        setAppState
      }
    );
  };
  const renderImageExportDialog = () => {
    if (!UIOptions.canvasActions.saveAsImage || appState.openDialog?.name !== "imageExport") {
      return null;
    }
    return /* @__PURE__ */ jsx135(
      ImageExportDialog,
      {
        elements,
        appState,
        files,
        actionManager,
        onExportImage,
        onCloseRequest: () => setAppState({ openDialog: null }),
        name: app.getName()
      }
    );
  };
  const renderCanvasActions = () => /* @__PURE__ */ jsxs72("div", { style: { position: "relative" }, children: [
    /* @__PURE__ */ jsx135(tunnels.MainMenuTunnel.Out, {}),
    renderWelcomeScreen && /* @__PURE__ */ jsx135(tunnels.WelcomeScreenMenuHintTunnel.Out, {})
  ] });
  const renderSelectedShapeActions = () => /* @__PURE__ */ jsx135(
    Section,
    {
      heading: "selectedShapeActions",
      className: clsx54("selected-shape-actions zen-mode-transition", {
        "transition-left": appState.zenModeEnabled
      }),
      children: /* @__PURE__ */ jsx135(
        Island,
        {
          className: CLASSES.SHAPE_ACTIONS_MENU,
          padding: 2,
          style: {
            // we want to make sure this doesn't overflow so subtracting the
            // approximate height of hamburgerMenu + footer
            maxHeight: `${appState.height - 166}px`
          },
          children: /* @__PURE__ */ jsx135(
            SelectedShapeActions,
            {
              appState,
              elementsMap: app.scene.getNonDeletedElementsMap(),
              renderAction: actionManager.renderAction
            }
          )
        }
      )
    }
  );
  const renderFixedSideContainer = () => {
    const shouldRenderSelectedShapeActions = showSelectedShapeActions(
      appState,
      elements
    );
    const shouldShowStats = appState.stats.open && !appState.zenModeEnabled && !appState.viewModeEnabled;
    return /* @__PURE__ */ jsx135(FixedSideContainer, { side: "left", children: /* @__PURE__ */ jsxs72("div", { className: "", children: [
      /* @__PURE__ */ jsxs72(Stack_default.Row, { gap: 6, className: clsx54(""), children: [
        renderCanvasActions(),
        shouldRenderSelectedShapeActions && renderSelectedShapeActions()
      ] }),
      !appState.viewModeEnabled && /* @__PURE__ */ jsx135(Section, { heading: "shapes", className: "", children: (heading) => /* @__PURE__ */ jsxs72("div", { children: [
        renderWelcomeScreen && /* @__PURE__ */ jsx135(tunnels.WelcomeScreenToolbarHintTunnel.Out, {}),
        /* @__PURE__ */ jsx135(Stack_default.Row, { gap: 4, children: /* @__PURE__ */ jsxs72(
          Stack_default.Row,
          {
            gap: 1,
            className: clsx54("", {
              "zen-mode": appState.zenModeEnabled
            }),
            children: [
              /* @__PURE__ */ jsxs72(
                Island,
                {
                  padding: 1,
                  style: {
                    marginTop: 60,
                    marginLeft: 7
                  },
                  className: clsx54(".App-toolbar__tools", {
                    "zen-mode": appState.zenModeEnabled
                  }),
                  children: [
                    /* @__PURE__ */ jsx135(
                      HintViewer,
                      {
                        appState,
                        isMobile: device.editor.isMobile,
                        device,
                        app
                      }
                    ),
                    heading,
                    /* @__PURE__ */ jsx135(
                      PenModeButton,
                      {
                        zenModeEnabled: appState.zenModeEnabled,
                        checked: appState.penMode,
                        onChange: () => onPenModeToggle(null),
                        title: t("toolBar.penMode"),
                        penDetected: appState.penDetected
                      }
                    ),
                    /* @__PURE__ */ jsx135(
                      LockButton,
                      {
                        checked: appState.activeTool.locked,
                        onChange: onLockToggle,
                        title: t("toolBar.lock")
                      }
                    ),
                    /* @__PURE__ */ jsx135("div", { className: "App-toolbar__divider" }),
                    /* @__PURE__ */ jsx135(
                      HandButton,
                      {
                        checked: isHandToolActive(appState),
                        onChange: () => onHandToolToggle(),
                        title: t("toolBar.hand"),
                        isMobile: true
                      }
                    ),
                    /* @__PURE__ */ jsx135(
                      ShapesSwitcher,
                      {
                        appState,
                        activeTool: appState.activeTool,
                        UIOptions,
                        app
                      }
                    )
                  ]
                }
              ),
              isCollaborating && /* @__PURE__ */ jsx135(
                Island,
                {
                  style: {
                    marginLeft: 8,
                    alignSelf: "center",
                    height: "fit-content"
                  },
                  children: /* @__PURE__ */ jsx135(
                    LaserPointerButton,
                    {
                      title: t("toolBar.laser"),
                      checked: appState.activeTool.type === TOOL_TYPE.laser,
                      onChange: () => app.setActiveTool({ type: TOOL_TYPE.laser }),
                      isMobile: true
                    }
                  )
                }
              )
            ]
          }
        ) })
      ] }) }),
      /* @__PURE__ */ jsxs72(
        "div",
        {
          className: clsx54(
            "layer-ui__wrapper__top-right zen-mode-transition",
            {
              "transition-right": appState.zenModeEnabled
            }
          ),
          children: [
            appState.collaborators.size > 0 && /* @__PURE__ */ jsx135(
              UserList,
              {
                collaborators: appState.collaborators,
                userToFollow: appState.userToFollow?.socketId || null
              }
            ),
            renderTopRightUI?.(device.editor.isMobile, appState),
            !appState.viewModeEnabled && // hide button when sidebar docked
            (!isSidebarDocked || appState.openSidebar?.name !== DEFAULT_SIDEBAR.name) && /* @__PURE__ */ jsx135(tunnels.DefaultSidebarTriggerTunnel.Out, {}),
            shouldShowStats && /* @__PURE__ */ jsx135(
              Stats,
              {
                app,
                onClose: () => {
                  actionManager.executeAction(actionToggleStats);
                },
                renderCustomStats
              }
            )
          ]
        }
      )
    ] }) });
  };
  const renderSidebars = () => {
    return /* @__PURE__ */ jsx135(
      DefaultSidebar,
      {
        __fallback: true,
        onDock: (docked) => {
          trackEvent(
            "sidebar",
            `toggleDock (${docked ? "dock" : "undock"})`,
            `(${device.editor.isMobile ? "mobile" : "desktop"})`
          );
        }
      }
    );
  };
  const isSidebarDocked = useAtomValue2(isSidebarDockedAtom, jotaiScope);
  const layerUIJSX = /* @__PURE__ */ jsxs72(Fragment24, { children: [
    children,
    /* @__PURE__ */ jsx135(DefaultMainMenu, { UIOptions }),
    /* @__PURE__ */ jsx135(DefaultOverwriteConfirmDialog, {}),
    appState.openDialog?.name === "ttd" && /* @__PURE__ */ jsx135(TTDDialog, { __fallback: true }),
    appState.isLoading && /* @__PURE__ */ jsx135(LoadingMessage, { delay: 250 }),
    appState.errorMessage && /* @__PURE__ */ jsx135(ErrorDialog, { onClose: () => setAppState({ errorMessage: null }), children: appState.errorMessage }),
    eyeDropperState && !device.editor.isMobile && /* @__PURE__ */ jsx135(
      EyeDropper,
      {
        colorPickerType: eyeDropperState.colorPickerType,
        onCancel: () => {
          setEyeDropperState(null);
        },
        onChange: (colorPickerType, color, selectedElements, { altKey }) => {
          if (colorPickerType !== "elementBackground" && colorPickerType !== "elementStroke") {
            return;
          }
          if (selectedElements.length) {
            for (const element of selectedElements) {
              mutateElement(
                element,
                {
                  [altKey && eyeDropperState.swapPreviewOnAlt ? colorPickerType === "elementBackground" ? "strokeColor" : "backgroundColor" : colorPickerType === "elementBackground" ? "backgroundColor" : "strokeColor"]: color
                },
                false
              );
              ShapeCache.delete(element);
            }
            Scene_default.getScene(selectedElements[0])?.triggerUpdate();
          } else if (colorPickerType === "elementBackground") {
            setAppState({
              currentItemBackgroundColor: color
            });
          } else {
            setAppState({ currentItemStrokeColor: color });
          }
        },
        onSelect: (color, event) => {
          setEyeDropperState((state) => {
            return state?.keepOpenOnAlt && event.altKey ? state : null;
          });
          eyeDropperState?.onSelect?.(color, event);
        }
      }
    ),
    appState.openDialog?.name === "help" && /* @__PURE__ */ jsx135(
      HelpDialog,
      {
        onClose: () => {
          setAppState({ openDialog: null });
        }
      }
    ),
    /* @__PURE__ */ jsx135(ActiveConfirmDialog, {}),
    /* @__PURE__ */ jsx135(tunnels.OverwriteConfirmDialogTunnel.Out, {}),
    renderImageExportDialog(),
    renderJSONExportDialog(),
    appState.pasteDialog.shown && /* @__PURE__ */ jsx135(
      PasteChartDialog,
      {
        setAppState,
        appState,
        onClose: () => setAppState({
          pasteDialog: { shown: false, data: null }
        })
      }
    ),
    device.editor.isMobile && /* @__PURE__ */ jsx135(
      MobileMenu,
      {
        app,
        appState,
        elements,
        actionManager,
        renderJSONExportDialog,
        renderImageExportDialog,
        setAppState,
        onLockToggle,
        onHandToolToggle,
        onPenModeToggle,
        renderTopRightUI,
        renderCustomStats,
        renderSidebars,
        device,
        renderWelcomeScreen,
        UIOptions
      }
    ),
    !device.editor.isMobile && /* @__PURE__ */ jsxs72(Fragment24, { children: [
      /* @__PURE__ */ jsxs72(
        "div",
        {
          className: "layer-ui__wrapper",
          style: appState.openSidebar && isSidebarDocked && device.editor.canFitSidebar ? { width: `calc(100% - ${LIBRARY_SIDEBAR_WIDTH}px)` } : {},
          children: [
            renderWelcomeScreen && /* @__PURE__ */ jsx135(tunnels.WelcomeScreenCenterTunnel.Out, {}),
            renderFixedSideContainer(),
            /* @__PURE__ */ jsx135(
              Footer_default,
              {
                appState,
                actionManager,
                showExitZenModeBtn,
                renderWelcomeScreen
              }
            ),
            appState.scrolledOutside && /* @__PURE__ */ jsx135(
              "button",
              {
                type: "button",
                className: "scroll-back-to-content",
                onClick: () => {
                  setAppState((appState2) => ({
                    ...calculateScrollCenter(elements, appState2)
                  }));
                },
                children: t("buttons.scrollBackToContent")
              }
            )
          ]
        }
      ),
      renderSidebars()
    ] })
  ] });
  return /* @__PURE__ */ jsx135(UIAppStateContext.Provider, { value: appState, children: /* @__PURE__ */ jsx135(Provider, { scope: tunnels.jotaiScope, children: /* @__PURE__ */ jsx135(TunnelsContext.Provider, { value: tunnels, children: layerUIJSX }) }) });
};
var stripIrrelevantAppStateProps = (appState) => {
  const {
    suggestedBindings,
    startBoundElement,
    cursorButton,
    scrollX,
    scrollY,
    ...ret
  } = appState;
  return ret;
};
var areEqual2 = (prevProps, nextProps) => {
  if (prevProps.children !== nextProps.children) {
    return false;
  }
  const { canvas: _pC, appState: prevAppState, ...prev } = prevProps;
  const { canvas: _nC, appState: nextAppState, ...next } = nextProps;
  return isShallowEqual(
    // asserting AppState because we're being passed the whole AppState
    // but resolve to only the UI-relevant props
    stripIrrelevantAppStateProps(prevAppState),
    stripIrrelevantAppStateProps(nextAppState),
    {
      selectedElementIds: isShallowEqual,
      selectedGroupIds: isShallowEqual
    }
  ) && isShallowEqual(prev, next);
};
var LayerUI_default = React40.memo(LayerUI, areEqual2);

// components/Toast.tsx
init_define_import_meta_env();
init_icons();
import { useCallback as useCallback13, useEffect as useEffect36, useRef as useRef35 } from "react";
import { jsx as jsx136, jsxs as jsxs73 } from "react/jsx-runtime";
var DEFAULT_TOAST_TIMEOUT = 5e3;
var Toast = ({
  message,
  onClose,
  closable = false,
  // To prevent autoclose, pass duration as Infinity
  duration = DEFAULT_TOAST_TIMEOUT,
  style
}) => {
  const timerRef = useRef35(0);
  const shouldAutoClose = duration !== Infinity;
  const scheduleTimeout = useCallback13(() => {
    if (!shouldAutoClose) {
      return;
    }
    timerRef.current = window.setTimeout(() => onClose(), duration);
  }, [onClose, duration, shouldAutoClose]);
  useEffect36(() => {
    if (!shouldAutoClose) {
      return;
    }
    scheduleTimeout();
    return () => clearTimeout(timerRef.current);
  }, [scheduleTimeout, message, duration, shouldAutoClose]);
  const onMouseEnter = shouldAutoClose ? () => clearTimeout(timerRef?.current) : void 0;
  const onMouseLeave = shouldAutoClose ? scheduleTimeout : void 0;
  return /* @__PURE__ */ jsxs73(
    "div",
    {
      className: "Toast",
      onMouseEnter,
      onMouseLeave,
      style,
      children: [
        /* @__PURE__ */ jsx136("p", { className: "Toast__message", children: message }),
        closable && /* @__PURE__ */ jsx136(
          ToolButton,
          {
            icon: CloseIcon,
            "aria-label": "close",
            type: "icon",
            onClick: onClose,
            className: "close"
          }
        )
      ]
    }
  );
};

// actions/actionToggleViewMode.tsx
init_define_import_meta_env();
init_icons();
init_keys();
init_store();
init_register();
var actionToggleViewMode = register({
  name: "viewMode",
  label: "labels.viewMode",
  paletteName: "Toggle view mode",
  icon: eyeIcon,
  viewMode: true,
  trackEvent: {
    category: "canvas",
    predicate: (appState) => !appState.viewModeEnabled
  },
  perform(elements, appState) {
    return {
      appState: {
        ...appState,
        viewModeEnabled: !this.checked(appState)
      },
      storeAction: StoreAction.NONE
    };
  },
  checked: (appState) => appState.viewModeEnabled,
  predicate: (elements, appState, appProps) => {
    return typeof appProps.viewModeEnabled === "undefined";
  },
  keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.R
});

// components/App.tsx
init_blob();
init_image2();
init_filesystem();
init_textElement();
import throttle4 from "lodash.throttle";
init_url();
init_transformHandles();
init_fonts();
init_frame();
init_selection();

// actions/actionFrame.ts
init_define_import_meta_env();
init_element();
init_frame();
init_frame();
init_keys();
init_utils2();
init_cursor();
init_register();
init_typeChecks();
init_icons();
init_store();
var isSingleFrameSelected = (appState, app) => {
  const selectedElements = app.scene.getSelectedElements(appState);
  return selectedElements.length === 1 && isFrameLikeElement(selectedElements[0]);
};
var actionSelectAllElementsInFrame = register({
  name: "selectAllElementsInFrame",
  label: "labels.selectAllElementsInFrame",
  trackEvent: { category: "canvas" },
  perform: (elements, appState, _, app) => {
    const selectedElement = app.scene.getSelectedElements(appState).at(0) || null;
    if (isFrameLikeElement(selectedElement)) {
      const elementsInFrame = getFrameChildren(
        getNonDeletedElements2(elements),
        selectedElement.id
      ).filter((element) => !(element.type === "text" && element.containerId));
      return {
        elements,
        appState: {
          ...appState,
          selectedElementIds: elementsInFrame.reduce((acc, element) => {
            acc[element.id] = true;
            return acc;
          }, {})
        },
        storeAction: StoreAction.CAPTURE
      };
    }
    return {
      elements,
      appState,
      storeAction: StoreAction.NONE
    };
  },
  predicate: (elements, appState, _, app) => isSingleFrameSelected(appState, app)
});
var actionRemoveAllElementsFromFrame = register({
  name: "removeAllElementsFromFrame",
  label: "labels.removeAllElementsFromFrame",
  trackEvent: { category: "history" },
  perform: (elements, appState, _, app) => {
    const selectedElement = app.scene.getSelectedElements(appState).at(0) || null;
    if (isFrameLikeElement(selectedElement)) {
      return {
        elements: removeAllElementsFromFrame(elements, selectedElement),
        appState: {
          ...appState,
          selectedElementIds: {
            [selectedElement.id]: true
          }
        },
        storeAction: StoreAction.CAPTURE
      };
    }
    return {
      elements,
      appState,
      storeAction: StoreAction.NONE
    };
  },
  predicate: (elements, appState, _, app) => isSingleFrameSelected(appState, app)
});
var actionupdateFrameRendering = register({
  name: "updateFrameRendering",
  label: "labels.updateFrameRendering",
  viewMode: true,
  trackEvent: { category: "canvas" },
  perform: (elements, appState) => {
    return {
      elements,
      appState: {
        ...appState,
        frameRendering: {
          ...appState.frameRendering,
          enabled: !appState.frameRendering.enabled
        }
      },
      storeAction: StoreAction.NONE
    };
  },
  checked: (appState) => appState.frameRendering.enabled
});
var actionSetFrameAsActiveTool = register({
  name: "setFrameAsActiveTool",
  label: "toolBar.frame",
  trackEvent: { category: "toolbar" },
  icon: frameToolIcon,
  viewMode: false,
  perform: (elements, appState, _, app) => {
    const nextActiveTool = updateActiveTool(appState, {
      type: "frame"
    });
    setCursorForShape(app.interactiveCanvas, {
      ...appState,
      activeTool: nextActiveTool
    });
    return {
      elements,
      appState: {
        ...appState,
        activeTool: updateActiveTool(appState, {
          type: "frame"
        })
      },
      storeAction: StoreAction.NONE
    };
  },
  keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && !event.shiftKey && !event.altKey && event.key.toLocaleLowerCase() === KEYS.F
});

// components/App.tsx
init_errors();
init_snapping();

// components/BraveMeasureTextError.tsx
init_define_import_meta_env();
import { jsx as jsx137, jsxs as jsxs74 } from "react/jsx-runtime";
var BraveMeasureTextError = () => {
  return /* @__PURE__ */ jsxs74("div", { "data-testid": "brave-measure-text-error", children: [
    /* @__PURE__ */ jsx137("p", { children: /* @__PURE__ */ jsx137(
      Trans_default,
      {
        i18nKey: "errors.brave_measure_text_error.line1",
        bold: (el) => /* @__PURE__ */ jsx137("span", { style: { fontWeight: 600 }, children: el })
      }
    ) }),
    /* @__PURE__ */ jsx137("p", { children: /* @__PURE__ */ jsx137(
      Trans_default,
      {
        i18nKey: "errors.brave_measure_text_error.line2",
        bold: (el) => /* @__PURE__ */ jsx137("span", { style: { fontWeight: 600 }, children: el })
      }
    ) }),
    /* @__PURE__ */ jsx137("p", { children: /* @__PURE__ */ jsx137(
      Trans_default,
      {
        i18nKey: "errors.brave_measure_text_error.line3",
        link: (el) => /* @__PURE__ */ jsx137("a", { href: "http://docs.excalidraw.com/docs/@excalidraw/excalidraw/faq#turning-off-aggresive-block-fingerprinting-in-brave-browser", children: el })
      }
    ) }),
    /* @__PURE__ */ jsx137("p", { children: /* @__PURE__ */ jsx137(
      Trans_default,
      {
        i18nKey: "errors.brave_measure_text_error.line4",
        issueLink: (el) => /* @__PURE__ */ jsx137("a", { href: "https://github.com/excalidraw/excalidraw/issues/new", children: el }),
        discordLink: (el) => /* @__PURE__ */ jsxs74("a", { href: "https://discord.gg/UexuTaE", children: [
          el,
          "."
        ] })
      }
    ) })
  ] });
};
var BraveMeasureTextError_default = BraveMeasureTextError;

// data/transform.ts
init_define_import_meta_env();
init_constants();
init_element();
init_binding();
init_newElement();
init_textElement();
init_utils2();
init_points();
init_random();
init_fractionalIndex();
init_fonts();
init_typeChecks();
init_math();
var DEFAULT_LINEAR_ELEMENT_PROPS = {
  width: 100,
  height: 0
};
var DEFAULT_DIMENSION = 100;
var bindTextToContainer = (container, textProps, elementsMap) => {
  const textElement = newTextElement({
    x: 0,
    y: 0,
    textAlign: TEXT_ALIGN.CENTER,
    verticalAlign: VERTICAL_ALIGN.MIDDLE,
    ...textProps,
    containerId: container.id,
    strokeColor: textProps.strokeColor || container.strokeColor
  });
  Object.assign(container, {
    boundElements: (container.boundElements || []).concat({
      type: "text",
      id: textElement.id
    })
  });
  redrawTextBoundingBox(textElement, container, elementsMap);
  return [container, textElement];
};
var bindLinearElementToElement = (linearElement, start2, end, elementStore, elementsMap) => {
  let startBoundElement;
  let endBoundElement;
  Object.assign(linearElement, {
    startBinding: linearElement?.startBinding || null,
    endBinding: linearElement.endBinding || null
  });
  if (start2) {
    const width = start2?.width ?? DEFAULT_DIMENSION;
    const height = start2?.height ?? DEFAULT_DIMENSION;
    let existingElement;
    if (start2.id) {
      existingElement = elementStore.getElement(start2.id);
      if (!existingElement) {
        console.error(`No element for start binding with id ${start2.id} found`);
      }
    }
    const startX = start2.x || linearElement.x - width;
    const startY = start2.y || linearElement.y - height / 2;
    const startType = existingElement ? existingElement.type : start2.type;
    if (startType) {
      if (startType === "text") {
        let text = "";
        if (existingElement && existingElement.type === "text") {
          text = existingElement.text;
        } else if (start2.type === "text") {
          text = start2.text;
        }
        if (!text) {
          console.error(
            `No text found for start binding text element for ${linearElement.id}`
          );
        }
        startBoundElement = newTextElement({
          x: startX,
          y: startY,
          type: "text",
          ...existingElement,
          ...start2,
          text
        });
        Object.assign(startBoundElement, {
          x: start2.x || linearElement.x - startBoundElement.width,
          y: start2.y || linearElement.y - startBoundElement.height / 2
        });
      } else {
        switch (startType) {
          case "rectangle":
          case "ellipse":
          case "diamond": {
            startBoundElement = newElement({
              x: startX,
              y: startY,
              width,
              height,
              ...existingElement,
              ...start2,
              type: startType
            });
            break;
          }
          default: {
            assertNever(
              linearElement,
              `Unhandled element start type "${start2.type}"`,
              true
            );
          }
        }
      }
      bindLinearElement(
        linearElement,
        startBoundElement,
        "start",
        elementsMap
      );
    }
  }
  if (end) {
    const height = end?.height ?? DEFAULT_DIMENSION;
    const width = end?.width ?? DEFAULT_DIMENSION;
    let existingElement;
    if (end.id) {
      existingElement = elementStore.getElement(end.id);
      if (!existingElement) {
        console.error(`No element for end binding with id ${end.id} found`);
      }
    }
    const endX = end.x || linearElement.x + linearElement.width;
    const endY = end.y || linearElement.y - height / 2;
    const endType = existingElement ? existingElement.type : end.type;
    if (endType) {
      if (endType === "text") {
        let text = "";
        if (existingElement && existingElement.type === "text") {
          text = existingElement.text;
        } else if (end.type === "text") {
          text = end.text;
        }
        if (!text) {
          console.error(
            `No text found for end binding text element for ${linearElement.id}`
          );
        }
        endBoundElement = newTextElement({
          x: endX,
          y: endY,
          type: "text",
          ...existingElement,
          ...end,
          text
        });
        Object.assign(endBoundElement, {
          y: end.y || linearElement.y - endBoundElement.height / 2
        });
      } else {
        switch (endType) {
          case "rectangle":
          case "ellipse":
          case "diamond": {
            endBoundElement = newElement({
              x: endX,
              y: endY,
              width,
              height,
              ...existingElement,
              ...end,
              type: endType
            });
            break;
          }
          default: {
            assertNever(
              linearElement,
              `Unhandled element end type "${endType}"`,
              true
            );
          }
        }
      }
      bindLinearElement(
        linearElement,
        endBoundElement,
        "end",
        elementsMap
      );
    }
  }
  if (linearElement.points.length < 2) {
    return {
      linearElement,
      startBoundElement,
      endBoundElement
    };
  }
  const endPointIndex = linearElement.points.length - 1;
  const delta = 0.5;
  const newPoints = cloneJSON(linearElement.points);
  if (linearElement.points[endPointIndex][0] > linearElement.points[endPointIndex - 1][0]) {
    newPoints[0][0] = delta;
    newPoints[endPointIndex][0] -= delta;
  }
  if (linearElement.points[endPointIndex][0] < linearElement.points[endPointIndex - 1][0]) {
    newPoints[0][0] = -delta;
    newPoints[endPointIndex][0] += delta;
  }
  if (linearElement.points[endPointIndex][1] > linearElement.points[endPointIndex - 1][1]) {
    newPoints[0][1] = delta;
    newPoints[endPointIndex][1] -= delta;
  }
  if (linearElement.points[endPointIndex][1] < linearElement.points[endPointIndex - 1][1]) {
    newPoints[0][1] = -delta;
    newPoints[endPointIndex][1] += delta;
  }
  Object.assign(linearElement, { points: newPoints });
  return {
    linearElement,
    startBoundElement,
    endBoundElement
  };
};
var ElementStore = class {
  excalidrawElements = /* @__PURE__ */ new Map();
  add = (ele) => {
    if (!ele) {
      return;
    }
    this.excalidrawElements.set(ele.id, ele);
  };
  getElements = () => {
    return syncInvalidIndices(Array.from(this.excalidrawElements.values()));
  };
  getElementsMap = () => {
    return toBrandedType(
      arrayToMap(this.getElements())
    );
  };
  getElement = (id) => {
    return this.excalidrawElements.get(id);
  };
};
var convertToExcalidrawElements = (elementsSkeleton, opts) => {
  if (!elementsSkeleton) {
    return [];
  }
  const elements = cloneJSON(elementsSkeleton);
  const elementStore = new ElementStore();
  const elementsWithIds = /* @__PURE__ */ new Map();
  const oldToNewElementIdMap = /* @__PURE__ */ new Map();
  for (const element of elements) {
    let excalidrawElement;
    const originalId = element.id;
    if (opts?.regenerateIds !== false) {
      Object.assign(element, { id: randomId() });
    }
    switch (element.type) {
      case "rectangle":
      case "ellipse":
      case "diamond": {
        const width = element?.label?.text && element.width === void 0 ? 0 : element?.width || DEFAULT_DIMENSION;
        const height = element?.label?.text && element.height === void 0 ? 0 : element?.height || DEFAULT_DIMENSION;
        excalidrawElement = newElement({
          ...element,
          width,
          height
        });
        break;
      }
      case "line": {
        const width = element.width || DEFAULT_LINEAR_ELEMENT_PROPS.width;
        const height = element.height || DEFAULT_LINEAR_ELEMENT_PROPS.height;
        excalidrawElement = newLinearElement({
          width,
          height,
          points: [pointFrom(0, 0), pointFrom(width, height)],
          ...element
        });
        break;
      }
      case "arrow": {
        const width = element.width || DEFAULT_LINEAR_ELEMENT_PROPS.width;
        const height = element.height || DEFAULT_LINEAR_ELEMENT_PROPS.height;
        excalidrawElement = newArrowElement({
          width,
          height,
          endArrowhead: "arrow",
          points: [pointFrom(0, 0), pointFrom(width, height)],
          ...element,
          type: "arrow"
        });
        Object.assign(
          excalidrawElement,
          getSizeFromPoints(excalidrawElement.points)
        );
        break;
      }
      case "text": {
        const fontFamily = element?.fontFamily || DEFAULT_FONT_FAMILY;
        const fontSize = element?.fontSize || DEFAULT_FONT_SIZE;
        const lineHeight = element?.lineHeight || getLineHeight(fontFamily);
        const text = element.text ?? "";
        const normalizedText = normalizeText(text);
        const metrics = measureText(
          normalizedText,
          getFontString({ fontFamily, fontSize }),
          lineHeight
        );
        excalidrawElement = newTextElement({
          width: metrics.width,
          height: metrics.height,
          fontFamily,
          fontSize,
          ...element
        });
        break;
      }
      case "image": {
        excalidrawElement = newImageElement({
          width: element?.width || DEFAULT_DIMENSION,
          height: element?.height || DEFAULT_DIMENSION,
          ...element
        });
        break;
      }
      case "frame": {
        excalidrawElement = newFrameElement({
          x: 0,
          y: 0,
          ...element
        });
        break;
      }
      case "magicframe": {
        excalidrawElement = newMagicFrameElement({
          x: 0,
          y: 0,
          ...element
        });
        break;
      }
      case "freedraw":
      case "iframe":
      case "embeddable": {
        excalidrawElement = element;
        break;
      }
      default: {
        excalidrawElement = element;
        assertNever(
          element,
          `Unhandled element type "${element.type}"`,
          true
        );
      }
    }
    const existingElement = elementStore.getElement(excalidrawElement.id);
    if (existingElement) {
      console.error(`Duplicate id found for ${excalidrawElement.id}`);
    } else {
      elementStore.add(excalidrawElement);
      elementsWithIds.set(excalidrawElement.id, element);
      if (originalId) {
        oldToNewElementIdMap.set(originalId, excalidrawElement.id);
      }
    }
  }
  const elementsMap = elementStore.getElementsMap();
  for (const [id, element] of elementsWithIds) {
    const excalidrawElement = elementStore.getElement(id);
    switch (element.type) {
      case "rectangle":
      case "ellipse":
      case "diamond":
      case "arrow": {
        if (element.label?.text) {
          let [container, text] = bindTextToContainer(
            excalidrawElement,
            element?.label,
            elementsMap
          );
          elementStore.add(container);
          elementStore.add(text);
          if (isArrowElement(container)) {
            const originalStart = element.type === "arrow" ? element?.start : void 0;
            const originalEnd = element.type === "arrow" ? element?.end : void 0;
            if (originalStart && originalStart.id) {
              const newStartId = oldToNewElementIdMap.get(originalStart.id);
              if (newStartId) {
                Object.assign(originalStart, { id: newStartId });
              }
            }
            if (originalEnd && originalEnd.id) {
              const newEndId = oldToNewElementIdMap.get(originalEnd.id);
              if (newEndId) {
                Object.assign(originalEnd, { id: newEndId });
              }
            }
            const { linearElement, startBoundElement, endBoundElement } = bindLinearElementToElement(
              container,
              originalStart,
              originalEnd,
              elementStore,
              elementsMap
            );
            container = linearElement;
            elementStore.add(linearElement);
            elementStore.add(startBoundElement);
            elementStore.add(endBoundElement);
          }
        } else {
          switch (element.type) {
            case "arrow": {
              const { start: start2, end } = element;
              if (start2 && start2.id) {
                const newStartId = oldToNewElementIdMap.get(start2.id);
                Object.assign(start2, { id: newStartId });
              }
              if (end && end.id) {
                const newEndId = oldToNewElementIdMap.get(end.id);
                Object.assign(end, { id: newEndId });
              }
              const { linearElement, startBoundElement, endBoundElement } = bindLinearElementToElement(
                excalidrawElement,
                start2,
                end,
                elementStore,
                elementsMap
              );
              elementStore.add(linearElement);
              elementStore.add(startBoundElement);
              elementStore.add(endBoundElement);
              break;
            }
          }
        }
        break;
      }
    }
  }
  for (const [id, element] of elementsWithIds) {
    if (element.type !== "frame" && element.type !== "magicframe") {
      continue;
    }
    const frame = elementStore.getElement(id);
    if (!frame) {
      throw new Error(`Excalidraw element with id ${id} doesn't exist`);
    }
    const childrenElements = [];
    element.children.forEach((id2) => {
      const newElementId = oldToNewElementIdMap.get(id2);
      if (!newElementId) {
        throw new Error(`Element with ${id2} wasn't mapped correctly`);
      }
      const elementInFrame = elementStore.getElement(newElementId);
      if (!elementInFrame) {
        throw new Error(`Frame element with id ${newElementId} doesn't exist`);
      }
      Object.assign(elementInFrame, { frameId: frame.id });
      elementInFrame?.boundElements?.forEach((boundElement) => {
        const ele = elementStore.getElement(boundElement.id);
        if (!ele) {
          throw new Error(
            `Bound element with id ${boundElement.id} doesn't exist`
          );
        }
        Object.assign(ele, { frameId: frame.id });
        childrenElements.push(ele);
      });
      childrenElements.push(elementInFrame);
    });
    let [minX, minY, maxX, maxY] = getCommonBounds(childrenElements);
    const PADDING = 10;
    minX = minX - PADDING;
    minY = minY - PADDING;
    maxX = maxX + PADDING;
    maxY = maxY + PADDING;
    const frameX = frame?.x || minX;
    const frameY = frame?.y || minY;
    const frameWidth = frame?.width || maxX - minX;
    const frameHeight = frame?.height || maxY - minY;
    Object.assign(frame, {
      x: frameX,
      y: frameY,
      width: frameWidth,
      height: frameHeight
    });
    if (isDevEnv() && element.children.length && (frame?.x || frame?.y || frame?.width || frame?.height)) {
      console.info(
        "User provided frame attributes are being considered, if you find this inaccurate, please remove any of the attributes - x, y, width and height so frame coordinates and dimensions are calculated automatically"
      );
    }
  }
  return elementStore.getElements();
};

// components/canvases/index.tsx
init_define_import_meta_env();

// components/canvases/InteractiveCanvas.tsx
init_define_import_meta_env();
init_utils2();
init_constants();
import React41, { useEffect as useEffect37, useRef as useRef36 } from "react";

// reactUtils.ts
init_define_import_meta_env();
init_utils2();
import { unstable_batchedUpdates as unstable_batchedUpdates2 } from "react-dom";
import { version as ReactVersion } from "react";
var withBatchedUpdates = (func) => (event) => {
  unstable_batchedUpdates2(func, event);
};
var withBatchedUpdatesThrottled = (func) => {
  return throttleRAF((event) => {
    unstable_batchedUpdates2(func, event);
  });
};
var isRenderThrottlingEnabled = (() => {
  let IS_REACT_18_AND_UP;
  try {
    const version = ReactVersion.split(".");
    IS_REACT_18_AND_UP = Number(version[0]) > 17;
  } catch {
    IS_REACT_18_AND_UP = false;
  }
  let hasWarned = false;
  return () => {
    if (window.EXCALIDRAW_THROTTLE_RENDER === true) {
      if (!IS_REACT_18_AND_UP) {
        if (!hasWarned) {
          hasWarned = true;
          console.warn(
            "Excalidraw: render throttling is disabled on React versions < 18."
          );
        }
        return false;
      }
      return true;
    }
    return false;
  };
})();

// renderer/interactiveScene.ts
init_define_import_meta_env();
init_element();
init_renderElement();
init_groups();
init_transformHandles();
init_utils2();
init_constants();

// renderer/renderSnaps.ts
init_define_import_meta_env();
init_math();
init_constants();
var SNAP_COLOR_LIGHT = "#ff6b6b";
var SNAP_COLOR_DARK = "#ff0000";
var SNAP_WIDTH = 1;
var SNAP_CROSS_SIZE = 2;
var renderSnaps = (context, appState) => {
  if (!appState.snapLines.length) {
    return;
  }
  const snapColor = appState.theme === THEME.LIGHT || appState.zenModeEnabled ? SNAP_COLOR_LIGHT : SNAP_COLOR_DARK;
  const snapWidth = (appState.zenModeEnabled ? SNAP_WIDTH * 1.5 : SNAP_WIDTH) / appState.zoom.value;
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  for (const snapLine of appState.snapLines) {
    if (snapLine.type === "pointer") {
      context.lineWidth = snapWidth;
      context.strokeStyle = snapColor;
      drawPointerSnapLine(snapLine, context, appState);
    } else if (snapLine.type === "gap") {
      context.lineWidth = snapWidth;
      context.strokeStyle = snapColor;
      drawGapLine(
        snapLine.points[0],
        snapLine.points[1],
        snapLine.direction,
        appState,
        context
      );
    } else if (snapLine.type === "points") {
      context.lineWidth = snapWidth;
      context.strokeStyle = snapColor;
      drawPointsSnapLine(snapLine, context, appState);
    }
  }
  context.restore();
};
var drawPointsSnapLine = (pointSnapLine, context, appState) => {
  if (!appState.zenModeEnabled) {
    const firstPoint = pointSnapLine.points[0];
    const lastPoint = pointSnapLine.points[pointSnapLine.points.length - 1];
    drawLine(firstPoint, lastPoint, context);
  }
  for (const point2 of pointSnapLine.points) {
    drawCross(point2, appState, context);
  }
};
var drawPointerSnapLine = (pointerSnapLine, context, appState) => {
  drawCross(pointerSnapLine.points[0], appState, context);
  if (!appState.zenModeEnabled) {
    drawLine(pointerSnapLine.points[0], pointerSnapLine.points[1], context);
  }
};
var drawCross = ([x, y], appState, context) => {
  context.save();
  const size = (appState.zenModeEnabled ? SNAP_CROSS_SIZE * 1.5 : SNAP_CROSS_SIZE) / appState.zoom.value;
  context.beginPath();
  context.moveTo(x - size, y - size);
  context.lineTo(x + size, y + size);
  context.moveTo(x + size, y - size);
  context.lineTo(x - size, y + size);
  context.stroke();
  context.restore();
};
var drawLine = (from3, to, context) => {
  context.beginPath();
  context.lineTo(from3[0], from3[1]);
  context.lineTo(to[0], to[1]);
  context.stroke();
};
var drawGapLine = (from3, to, direction, appState, context) => {
  const FULL = 8 / appState.zoom.value;
  const HALF = FULL / 2;
  const QUARTER = FULL / 4;
  if (direction === "horizontal") {
    const halfPoint = [(from3[0] + to[0]) / 2, from3[1]];
    if (!appState.zenModeEnabled) {
      drawLine(
        pointFrom(from3[0], from3[1] - FULL),
        pointFrom(from3[0], from3[1] + FULL),
        context
      );
    }
    drawLine(
      pointFrom(halfPoint[0] - QUARTER, halfPoint[1] - HALF),
      pointFrom(halfPoint[0] - QUARTER, halfPoint[1] + HALF),
      context
    );
    drawLine(
      pointFrom(halfPoint[0] + QUARTER, halfPoint[1] - HALF),
      pointFrom(halfPoint[0] + QUARTER, halfPoint[1] + HALF),
      context
    );
    if (!appState.zenModeEnabled) {
      drawLine(
        pointFrom(to[0], to[1] - FULL),
        pointFrom(to[0], to[1] + FULL),
        context
      );
      drawLine(from3, to, context);
    }
  } else {
    const halfPoint = [from3[0], (from3[1] + to[1]) / 2];
    if (!appState.zenModeEnabled) {
      drawLine(
        pointFrom(from3[0] - FULL, from3[1]),
        pointFrom(from3[0] + FULL, from3[1]),
        context
      );
    }
    drawLine(
      pointFrom(halfPoint[0] - HALF, halfPoint[1] - QUARTER),
      pointFrom(halfPoint[0] + HALF, halfPoint[1] - QUARTER),
      context
    );
    drawLine(
      pointFrom(halfPoint[0] - HALF, halfPoint[1] + QUARTER),
      pointFrom(halfPoint[0] + HALF, halfPoint[1] + QUARTER),
      context
    );
    if (!appState.zenModeEnabled) {
      drawLine(
        pointFrom(to[0] - FULL, to[1]),
        pointFrom(to[0] + FULL, to[1]),
        context
      );
      drawLine(from3, to, context);
    }
  }
};

// renderer/interactiveScene.ts
init_binding();
init_linearElementEditor();
init_helpers2();
init_typeChecks();
init_shapes();
import oc4 from "open-color";
var renderLinearElementPointHighlight = (context, appState, elementsMap) => {
  const { elementId, hoverPointIndex } = appState.selectedLinearElement;
  if (appState.editingLinearElement?.selectedPointsIndices?.includes(
    hoverPointIndex
  )) {
    return;
  }
  const element = LinearElementEditor.getElement(elementId, elementsMap);
  if (!element) {
    return;
  }
  const point2 = LinearElementEditor.getPointAtIndexGlobalCoordinates(
    element,
    hoverPointIndex,
    elementsMap
  );
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  highlightPoint(point2, context, appState);
  context.restore();
};
var highlightPoint = (point2, context, appState) => {
  context.fillStyle = "rgba(105, 101, 219, 0.4)";
  fillCircle(
    context,
    point2[0],
    point2[1],
    LinearElementEditor.POINT_HANDLE_SIZE / appState.zoom.value,
    false
  );
};
var strokeRectWithRotation = (context, x, y, width, height, cx, cy, angle, fill = false, radius = 0) => {
  context.save();
  context.translate(cx, cy);
  context.rotate(angle);
  if (fill) {
    context.fillRect(x - cx, y - cy, width, height);
  }
  if (radius && context.roundRect) {
    context.beginPath();
    context.roundRect(x - cx, y - cy, width, height, radius);
    context.stroke();
    context.closePath();
  } else {
    context.strokeRect(x - cx, y - cy, width, height);
  }
  context.restore();
};
var strokeDiamondWithRotation = (context, width, height, cx, cy, angle) => {
  context.save();
  context.translate(cx, cy);
  context.rotate(angle);
  context.beginPath();
  context.moveTo(0, height / 2);
  context.lineTo(width / 2, 0);
  context.lineTo(0, -height / 2);
  context.lineTo(-width / 2, 0);
  context.closePath();
  context.stroke();
  context.restore();
};
var renderSingleLinearPoint = (context, appState, point2, radius, isSelected, isPhantomPoint = false) => {
  context.strokeStyle = "#5e5ad8";
  context.setLineDash([]);
  context.fillStyle = "rgba(255, 255, 255, 0.9)";
  if (isSelected) {
    context.fillStyle = "rgba(134, 131, 226, 0.9)";
  } else if (isPhantomPoint) {
    context.fillStyle = "rgba(177, 151, 252, 0.7)";
  }
  fillCircle(
    context,
    point2[0],
    point2[1],
    radius / appState.zoom.value,
    !isPhantomPoint
  );
};
var strokeEllipseWithRotation = (context, width, height, cx, cy, angle) => {
  context.beginPath();
  context.ellipse(cx, cy, width / 2, height / 2, angle, 0, Math.PI * 2);
  context.stroke();
};
var renderBindingHighlightForBindableElement = (context, element, elementsMap) => {
  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element, elementsMap);
  const width = x2 - x1;
  const height = y2 - y1;
  const thickness = 10;
  const strokeOffset = 4;
  context.strokeStyle = "rgba(0,0,0,.05)";
  context.lineWidth = thickness - strokeOffset;
  const padding = strokeOffset / 2 + thickness / 2;
  const radius = getCornerRadius(
    Math.min(element.width, element.height),
    element
  );
  switch (element.type) {
    case "rectangle":
    case "text":
    case "image":
    case "iframe":
    case "embeddable":
    case "frame":
    case "magicframe":
      strokeRectWithRotation(
        context,
        x1 - padding,
        y1 - padding,
        width + padding * 2,
        height + padding * 2,
        x1 + width / 2,
        y1 + height / 2,
        element.angle,
        void 0,
        radius
      );
      break;
    case "diamond":
      const side = Math.hypot(width, height);
      const wPadding = padding * side / height;
      const hPadding = padding * side / width;
      strokeDiamondWithRotation(
        context,
        width + wPadding * 2,
        height + hPadding * 2,
        x1 + width / 2,
        y1 + height / 2,
        element.angle
      );
      break;
    case "ellipse":
      strokeEllipseWithRotation(
        context,
        width + padding * 2,
        height + padding * 2,
        x1 + width / 2,
        y1 + height / 2,
        element.angle
      );
      break;
  }
};
var renderBindingHighlightForSuggestedPointBinding = (context, suggestedBinding, elementsMap) => {
  const [element, startOrEnd, bindableElement] = suggestedBinding;
  const threshold = maxBindingGap(
    bindableElement,
    bindableElement.width,
    bindableElement.height
  );
  context.strokeStyle = "rgba(0,0,0,0)";
  context.fillStyle = "rgba(0,0,0,.05)";
  const pointIndices = startOrEnd === "both" ? [0, -1] : startOrEnd === "start" ? [0] : [-1];
  pointIndices.forEach((index) => {
    const [x, y] = LinearElementEditor.getPointAtIndexGlobalCoordinates(
      element,
      index,
      elementsMap
    );
    fillCircle(context, x, y, threshold);
  });
};
var renderSelectionBorder = (context, appState, elementProperties) => {
  const {
    angle,
    elementX1,
    elementY1,
    elementX2,
    elementY2,
    selectionColors,
    cx,
    cy,
    dashed,
    activeEmbeddable
  } = elementProperties;
  const elementWidth = elementX2 - elementX1;
  const elementHeight = elementY2 - elementY1;
  const padding = DEFAULT_TRANSFORM_HANDLE_SPACING * 2;
  const linePadding = padding / appState.zoom.value;
  const lineWidth = 8 / appState.zoom.value;
  const spaceWidth = 4 / appState.zoom.value;
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  context.lineWidth = (activeEmbeddable ? 4 : 1) / appState.zoom.value;
  const count = selectionColors.length;
  for (let index = 0; index < count; ++index) {
    context.strokeStyle = selectionColors[index];
    if (dashed) {
      context.setLineDash([
        lineWidth,
        spaceWidth + (lineWidth + spaceWidth) * (count - 1)
      ]);
    }
    context.lineDashOffset = (lineWidth + spaceWidth) * index;
    strokeRectWithRotation(
      context,
      elementX1 - linePadding,
      elementY1 - linePadding,
      elementWidth + linePadding * 2,
      elementHeight + linePadding * 2,
      cx,
      cy,
      angle
    );
  }
  context.restore();
};
var renderBindingHighlight = (context, appState, suggestedBinding, elementsMap) => {
  const renderHighlight = Array.isArray(suggestedBinding) ? renderBindingHighlightForSuggestedPointBinding : renderBindingHighlightForBindableElement;
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  renderHighlight(context, suggestedBinding, elementsMap);
  context.restore();
};
var renderFrameHighlight = (context, appState, frame, elementsMap) => {
  const [x1, y1, x2, y2] = getElementAbsoluteCoords(frame, elementsMap);
  const width = x2 - x1;
  const height = y2 - y1;
  context.strokeStyle = "rgb(0,118,255)";
  context.lineWidth = FRAME_STYLE.strokeWidth / appState.zoom.value;
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  strokeRectWithRotation(
    context,
    x1,
    y1,
    width,
    height,
    x1 + width / 2,
    y1 + height / 2,
    frame.angle,
    false,
    FRAME_STYLE.radius / appState.zoom.value
  );
  context.restore();
};
var renderElementsBoxHighlight = (context, appState, elements) => {
  const individualElements = elements.filter(
    (element) => element.groupIds.length === 0
  );
  const elementsInGroups = elements.filter(
    (element) => element.groupIds.length > 0
  );
  const getSelectionFromElements = (elements2) => {
    const [elementX1, elementY1, elementX2, elementY2] = getCommonBounds(elements2);
    return {
      angle: 0,
      elementX1,
      elementX2,
      elementY1,
      elementY2,
      selectionColors: ["rgb(0,118,255)"],
      dashed: false,
      cx: elementX1 + (elementX2 - elementX1) / 2,
      cy: elementY1 + (elementY2 - elementY1) / 2,
      activeEmbeddable: false
    };
  };
  const getSelectionForGroupId = (groupId) => {
    const groupElements = getElementsInGroup(elements, groupId);
    return getSelectionFromElements(groupElements);
  };
  Object.entries(selectGroupsFromGivenElements(elementsInGroups, appState)).filter(([id, isSelected]) => isSelected).map(([id, isSelected]) => id).map((groupId) => getSelectionForGroupId(groupId)).concat(
    individualElements.map((element) => getSelectionFromElements([element]))
  ).forEach(
    (selection) => renderSelectionBorder(context, appState, selection)
  );
};
var renderLinearPointHandles = (context, appState, element, elementsMap) => {
  if (!appState.selectedLinearElement) {
    return;
  }
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  context.lineWidth = 1 / appState.zoom.value;
  const points = LinearElementEditor.getPointsGlobalCoordinates(
    element,
    elementsMap
  );
  const { POINT_HANDLE_SIZE } = LinearElementEditor;
  const radius = appState.editingLinearElement ? POINT_HANDLE_SIZE : POINT_HANDLE_SIZE / 2;
  points.forEach((point2, idx) => {
    if (isElbowArrow(element) && idx !== 0 && idx !== points.length - 1) {
      return;
    }
    const isSelected = !!appState.editingLinearElement?.selectedPointsIndices?.includes(idx);
    renderSingleLinearPoint(context, appState, point2, radius, isSelected);
  });
  const midPoints = LinearElementEditor.getEditorMidPoints(
    element,
    elementsMap,
    appState
  ).filter((midPoint) => midPoint !== null);
  midPoints.forEach((segmentMidPoint) => {
    if (appState?.selectedLinearElement?.segmentMidPointHoveredCoords && LinearElementEditor.arePointsEqual(
      segmentMidPoint,
      appState.selectedLinearElement.segmentMidPointHoveredCoords
    )) {
      if (appState.editingLinearElement) {
        renderSingleLinearPoint(
          context,
          appState,
          segmentMidPoint,
          radius,
          false
        );
        highlightPoint(segmentMidPoint, context, appState);
      } else {
        highlightPoint(segmentMidPoint, context, appState);
        renderSingleLinearPoint(
          context,
          appState,
          segmentMidPoint,
          radius,
          false
        );
      }
    } else if (appState.editingLinearElement || points.length === 2) {
      renderSingleLinearPoint(
        context,
        appState,
        segmentMidPoint,
        POINT_HANDLE_SIZE / 2,
        false,
        true
      );
    }
  });
  context.restore();
};
var renderTransformHandles = (context, renderConfig, appState, transformHandles, angle) => {
  Object.keys(transformHandles).forEach((key) => {
    const transformHandle = transformHandles[key];
    if (transformHandle !== void 0) {
      const [x, y, width, height] = transformHandle;
      context.save();
      context.lineWidth = 1 / appState.zoom.value;
      if (renderConfig.selectionColor) {
        context.strokeStyle = renderConfig.selectionColor;
      }
      if (key === "rotation") {
        fillCircle(context, x + width / 2, y + height / 2, width / 2);
      } else if (context.roundRect) {
        context.beginPath();
        context.roundRect(x, y, width, height, 2 / appState.zoom.value);
        context.fill();
        context.stroke();
      } else {
        strokeRectWithRotation(
          context,
          x,
          y,
          width,
          height,
          x + width / 2,
          y + height / 2,
          angle,
          true
          // fill before stroke
        );
      }
      context.restore();
    }
  });
};
var renderTextBox = (text, context, appState, selectionColor) => {
  context.save();
  const padding = DEFAULT_TRANSFORM_HANDLE_SPACING * 2 / appState.zoom.value;
  const width = text.width + padding * 2;
  const height = text.height + padding * 2;
  const cx = text.x + width / 2;
  const cy = text.y + height / 2;
  const shiftX = -(width / 2 + padding);
  const shiftY = -(height / 2 + padding);
  context.translate(cx + appState.scrollX, cy + appState.scrollY);
  context.rotate(text.angle);
  context.lineWidth = 1 / appState.zoom.value;
  context.strokeStyle = selectionColor;
  context.strokeRect(shiftX, shiftY, width, height);
  context.restore();
};
var _renderInteractiveScene = ({
  canvas: canvas2,
  elementsMap,
  visibleElements,
  selectedElements,
  allElementsMap,
  scale,
  appState,
  renderConfig,
  device
}) => {
  if (canvas2 === null) {
    return { atLeastOneVisibleElement: false, elementsMap };
  }
  const [normalizedWidth, normalizedHeight] = getNormalizedCanvasDimensions(
    canvas2,
    scale
  );
  const context = bootstrapCanvas({
    canvas: canvas2,
    scale,
    normalizedWidth,
    normalizedHeight
  });
  context.save();
  context.scale(appState.zoom.value, appState.zoom.value);
  let editingLinearElement = void 0;
  visibleElements.forEach((element) => {
    if (appState.editingLinearElement?.elementId === element.id) {
      if (element) {
        editingLinearElement = element;
      }
    }
  });
  if (editingLinearElement) {
    renderLinearPointHandles(
      context,
      appState,
      editingLinearElement,
      elementsMap
    );
  }
  if (appState.selectionElement) {
    try {
      renderSelectionElement(
        appState.selectionElement,
        context,
        appState,
        renderConfig.selectionColor
      );
    } catch (error) {
      console.error(error);
    }
  }
  if (appState.editingTextElement && isTextElement(appState.editingTextElement)) {
    const textElement = allElementsMap.get(appState.editingTextElement.id);
    if (textElement && !textElement.autoResize) {
      renderTextBox(
        textElement,
        context,
        appState,
        renderConfig.selectionColor
      );
    }
  }
  if (appState.isBindingEnabled) {
    appState.suggestedBindings.filter((binding) => binding != null).forEach((suggestedBinding) => {
      renderBindingHighlight(
        context,
        appState,
        suggestedBinding,
        elementsMap
      );
    });
  }
  if (appState.frameToHighlight) {
    renderFrameHighlight(
      context,
      appState,
      appState.frameToHighlight,
      elementsMap
    );
  }
  if (appState.elementsToHighlight) {
    renderElementsBoxHighlight(context, appState, appState.elementsToHighlight);
  }
  const isFrameSelected = selectedElements.some(
    (element) => isFrameLikeElement(element)
  );
  if (selectedElements.length === 1 && appState.editingLinearElement?.elementId === selectedElements[0].id) {
    renderLinearPointHandles(
      context,
      appState,
      selectedElements[0],
      elementsMap
    );
  }
  if (appState.selectedLinearElement && appState.selectedLinearElement.hoverPointIndex >= 0 && !(isElbowArrow(selectedElements[0]) && appState.selectedLinearElement.hoverPointIndex > 0 && appState.selectedLinearElement.hoverPointIndex < selectedElements[0].points.length - 1)) {
    renderLinearElementPointHighlight(context, appState, elementsMap);
  }
  if (!appState.multiElement && !appState.editingLinearElement) {
    const showBoundingBox = shouldShowBoundingBox(selectedElements, appState);
    const isSingleLinearElementSelected = selectedElements.length === 1 && isLinearElement(selectedElements[0]);
    if (isSingleLinearElementSelected && appState.selectedLinearElement?.elementId === selectedElements[0].id && !selectedElements[0].locked) {
      renderLinearPointHandles(
        context,
        appState,
        selectedElements[0],
        elementsMap
      );
    }
    const selectionColor = renderConfig.selectionColor || oc4.black;
    if (showBoundingBox) {
      const locallySelectedIds = arrayToMap(selectedElements);
      const selections = [];
      for (const element of elementsMap.values()) {
        const selectionColors = [];
        const remoteClients = renderConfig.remoteSelectedElementIds.get(
          element.id
        );
        if (!// Elbow arrow elements cannot be selected when bound on either end
        (isSingleLinearElementSelected && isElbowArrow(element) && (element.startBinding || element.endBinding))) {
          if (locallySelectedIds.has(element.id) && !isSelectedViaGroup(appState, element)) {
            selectionColors.push(selectionColor);
          }
          if (remoteClients) {
            selectionColors.push(
              ...remoteClients.map((socketId) => {
                const background = getClientColor(
                  socketId,
                  appState.collaborators.get(socketId)
                );
                return background;
              })
            );
          }
        }
        if (selectionColors.length) {
          const [elementX1, elementY1, elementX2, elementY2, cx, cy] = getElementAbsoluteCoords(element, elementsMap, true);
          selections.push({
            angle: element.angle,
            elementX1,
            elementY1,
            elementX2,
            elementY2,
            selectionColors,
            dashed: !!remoteClients,
            cx,
            cy,
            activeEmbeddable: appState.activeEmbeddable?.element === element && appState.activeEmbeddable.state === "active"
          });
        }
      }
      const addSelectionForGroupId = (groupId) => {
        const groupElements = getElementsInGroup(elementsMap, groupId);
        const [elementX1, elementY1, elementX2, elementY2] = getCommonBounds(groupElements);
        selections.push({
          angle: 0,
          elementX1,
          elementX2,
          elementY1,
          elementY2,
          selectionColors: [oc4.black],
          dashed: true,
          cx: elementX1 + (elementX2 - elementX1) / 2,
          cy: elementY1 + (elementY2 - elementY1) / 2,
          activeEmbeddable: false
        });
      };
      for (const groupId of getSelectedGroupIds(appState)) {
        addSelectionForGroupId(groupId);
      }
      if (appState.editingGroupId) {
        addSelectionForGroupId(appState.editingGroupId);
      }
      selections.forEach(
        (selection) => renderSelectionBorder(context, appState, selection)
      );
    }
    context.save();
    context.translate(appState.scrollX, appState.scrollY);
    if (selectedElements.length === 1) {
      context.fillStyle = oc4.white;
      const transformHandles = getTransformHandles(
        selectedElements[0],
        appState.zoom,
        elementsMap,
        "mouse",
        // when we render we don't know which pointer type so use mouse,
        getOmitSidesForDevice(device)
      );
      if (!appState.viewModeEnabled && showBoundingBox && // do not show transform handles when text is being edited
      !isTextElement(appState.editingTextElement)) {
        renderTransformHandles(
          context,
          renderConfig,
          appState,
          transformHandles,
          selectedElements[0].angle
        );
      }
    } else if (selectedElements.length > 1 && !appState.isRotating) {
      const dashedLinePadding = DEFAULT_TRANSFORM_HANDLE_SPACING * 2 / appState.zoom.value;
      context.fillStyle = oc4.white;
      const [x1, y1, x2, y2] = getCommonBounds(selectedElements);
      const initialLineDash = context.getLineDash();
      context.setLineDash([2 / appState.zoom.value]);
      const lineWidth = context.lineWidth;
      context.lineWidth = 1 / appState.zoom.value;
      context.strokeStyle = selectionColor;
      strokeRectWithRotation(
        context,
        x1 - dashedLinePadding,
        y1 - dashedLinePadding,
        x2 - x1 + dashedLinePadding * 2,
        y2 - y1 + dashedLinePadding * 2,
        (x1 + x2) / 2,
        (y1 + y2) / 2,
        0
      );
      context.lineWidth = lineWidth;
      context.setLineDash(initialLineDash);
      const transformHandles = getTransformHandlesFromCoords(
        [x1, y1, x2, y2, (x1 + x2) / 2, (y1 + y2) / 2],
        0,
        appState.zoom,
        "mouse",
        isFrameSelected ? { ...getOmitSidesForDevice(device), rotation: true } : getOmitSidesForDevice(device)
      );
      if (selectedElements.some((element) => !element.locked)) {
        renderTransformHandles(
          context,
          renderConfig,
          appState,
          transformHandles,
          0
        );
      }
    }
    context.restore();
  }
  appState.searchMatches.forEach(({ id, focus, matchedLines }) => {
    const element = elementsMap.get(id);
    if (element && isTextElement(element)) {
      const [elementX1, elementY1, , , cx, cy] = getElementAbsoluteCoords(
        element,
        elementsMap,
        true
      );
      context.save();
      if (appState.theme === THEME.LIGHT) {
        if (focus) {
          context.fillStyle = "rgba(255, 124, 0, 0.4)";
        } else {
          context.fillStyle = "rgba(255, 226, 0, 0.4)";
        }
      } else if (focus) {
        context.fillStyle = "rgba(229, 82, 0, 0.4)";
      } else {
        context.fillStyle = "rgba(99, 52, 0, 0.4)";
      }
      context.translate(appState.scrollX, appState.scrollY);
      context.translate(cx, cy);
      context.rotate(element.angle);
      matchedLines.forEach((matchedLine) => {
        context.fillRect(
          elementX1 + matchedLine.offsetX - cx,
          elementY1 + matchedLine.offsetY - cy,
          matchedLine.width,
          matchedLine.height
        );
      });
      context.restore();
    }
  });
  renderSnaps(context, appState);
  context.restore();
  renderRemoteCursors({
    context,
    renderConfig,
    appState,
    normalizedWidth,
    normalizedHeight
  });
  let scrollBars;
  if (renderConfig.renderScrollbars) {
    scrollBars = getScrollBars(
      visibleElements,
      normalizedWidth,
      normalizedHeight,
      appState
    );
    context.save();
    context.fillStyle = SCROLLBAR_COLOR;
    context.strokeStyle = "rgba(255,255,255,0.8)";
    [scrollBars.horizontal, scrollBars.vertical].forEach((scrollBar) => {
      if (scrollBar) {
        roundRect(
          context,
          scrollBar.x,
          scrollBar.y,
          scrollBar.width,
          scrollBar.height,
          SCROLLBAR_WIDTH / 2
        );
      }
    });
    context.restore();
  }
  return {
    scrollBars,
    atLeastOneVisibleElement: visibleElements.length > 0,
    elementsMap
  };
};
var renderInteractiveSceneThrottled = throttleRAF(
  (config) => {
    const ret = _renderInteractiveScene(config);
    config.callback?.(ret);
  },
  { trailing: true }
);
var renderInteractiveScene = (renderConfig, throttle6) => {
  if (throttle6) {
    renderInteractiveSceneThrottled(renderConfig);
    return void 0;
  }
  const ret = _renderInteractiveScene(renderConfig);
  renderConfig.callback(ret);
  return ret;
};

// components/canvases/InteractiveCanvas.tsx
import { jsx as jsx138 } from "react/jsx-runtime";
var InteractiveCanvas = (props) => {
  const isComponentMounted = useRef36(false);
  useEffect37(() => {
    if (!isComponentMounted.current) {
      isComponentMounted.current = true;
      return;
    }
    const remotePointerButton = /* @__PURE__ */ new Map();
    const remotePointerViewportCoords = /* @__PURE__ */ new Map();
    const remoteSelectedElementIds = /* @__PURE__ */ new Map();
    const remotePointerUsernames = /* @__PURE__ */ new Map();
    const remotePointerUserStates = /* @__PURE__ */ new Map();
    props.appState.collaborators.forEach((user, socketId) => {
      if (user.selectedElementIds) {
        for (const id of Object.keys(user.selectedElementIds)) {
          if (!remoteSelectedElementIds.has(id)) {
            remoteSelectedElementIds.set(id, []);
          }
          remoteSelectedElementIds.get(id).push(socketId);
        }
      }
      if (!user.pointer || user.pointer.renderCursor === false) {
        return;
      }
      if (user.username) {
        remotePointerUsernames.set(socketId, user.username);
      }
      if (user.userState) {
        remotePointerUserStates.set(socketId, user.userState);
      }
      remotePointerViewportCoords.set(
        socketId,
        sceneCoordsToViewportCoords(
          {
            sceneX: user.pointer.x,
            sceneY: user.pointer.y
          },
          props.appState
        )
      );
      remotePointerButton.set(socketId, user.button);
    });
    const selectionColor = props.containerRef?.current && getComputedStyle(props.containerRef.current).getPropertyValue(
      "--color-selection"
    ) || "#6965db";
    renderInteractiveScene(
      {
        canvas: props.canvas,
        elementsMap: props.elementsMap,
        visibleElements: props.visibleElements,
        selectedElements: props.selectedElements,
        allElementsMap: props.allElementsMap,
        scale: window.devicePixelRatio,
        appState: props.appState,
        renderConfig: {
          remotePointerViewportCoords,
          remotePointerButton,
          remoteSelectedElementIds,
          remotePointerUsernames,
          remotePointerUserStates,
          selectionColor,
          renderScrollbars: false
        },
        device: props.device,
        callback: props.renderInteractiveSceneCallback
      },
      isRenderThrottlingEnabled()
    );
  });
  return /* @__PURE__ */ jsx138(
    "canvas",
    {
      className: "excalidraw__canvas interactive",
      style: {
        width: props.appState.width,
        height: props.appState.height,
        cursor: props.appState.viewModeEnabled ? CURSOR_TYPE.GRAB : CURSOR_TYPE.AUTO
      },
      width: props.appState.width * props.scale,
      height: props.appState.height * props.scale,
      ref: props.handleCanvasRef,
      onContextMenu: props.onContextMenu,
      onPointerMove: props.onPointerMove,
      onPointerUp: props.onPointerUp,
      onPointerCancel: props.onPointerCancel,
      onTouchMove: props.onTouchMove,
      onPointerDown: props.onPointerDown,
      onDoubleClick: props.appState.viewModeEnabled ? void 0 : props.onDoubleClick,
      children: t("labels.drawingCanvas")
    }
  );
};
var getRelevantAppStateProps = (appState) => ({
  zoom: appState.zoom,
  scrollX: appState.scrollX,
  scrollY: appState.scrollY,
  width: appState.width,
  height: appState.height,
  viewModeEnabled: appState.viewModeEnabled,
  editingGroupId: appState.editingGroupId,
  editingLinearElement: appState.editingLinearElement,
  selectedElementIds: appState.selectedElementIds,
  frameToHighlight: appState.frameToHighlight,
  offsetLeft: appState.offsetLeft,
  offsetTop: appState.offsetTop,
  theme: appState.theme,
  pendingImageElementId: appState.pendingImageElementId,
  selectionElement: appState.selectionElement,
  selectedGroupIds: appState.selectedGroupIds,
  selectedLinearElement: appState.selectedLinearElement,
  multiElement: appState.multiElement,
  isBindingEnabled: appState.isBindingEnabled,
  suggestedBindings: appState.suggestedBindings,
  isRotating: appState.isRotating,
  elementsToHighlight: appState.elementsToHighlight,
  collaborators: appState.collaborators,
  // Necessary for collab. sessions
  activeEmbeddable: appState.activeEmbeddable,
  snapLines: appState.snapLines,
  zenModeEnabled: appState.zenModeEnabled,
  editingTextElement: appState.editingTextElement,
  searchMatches: appState.searchMatches
});
var areEqual3 = (prevProps, nextProps) => {
  if (prevProps.selectionNonce !== nextProps.selectionNonce || prevProps.sceneNonce !== nextProps.sceneNonce || prevProps.scale !== nextProps.scale || // we need to memoize on elementsMap because they may have renewed
  // even if sceneNonce didn't change (e.g. we filter elements out based
  // on appState)
  prevProps.elementsMap !== nextProps.elementsMap || prevProps.visibleElements !== nextProps.visibleElements || prevProps.selectedElements !== nextProps.selectedElements) {
    return false;
  }
  return isShallowEqual(
    // asserting AppState because we're being passed the whole AppState
    // but resolve to only the InteractiveCanvas-relevant props
    getRelevantAppStateProps(prevProps.appState),
    getRelevantAppStateProps(nextProps.appState)
  );
};
var InteractiveCanvas_default = React41.memo(InteractiveCanvas, areEqual3);

// components/canvases/StaticCanvas.tsx
init_define_import_meta_env();
init_staticScene();
init_utils2();
import React42, { useEffect as useEffect38, useRef as useRef37 } from "react";
import { jsx as jsx139 } from "react/jsx-runtime";
var StaticCanvas = (props) => {
  const wrapperRef = useRef37(null);
  const isComponentMounted = useRef37(false);
  useEffect38(() => {
    const wrapper = wrapperRef.current;
    if (!wrapper) {
      return;
    }
    const canvas2 = props.canvas;
    if (!isComponentMounted.current) {
      isComponentMounted.current = true;
      wrapper.replaceChildren(canvas2);
      canvas2.classList.add("excalidraw__canvas", "static");
    }
    const widthString = `${props.appState.width}px`;
    const heightString = `${props.appState.height}px`;
    if (canvas2.style.width !== widthString) {
      canvas2.style.width = widthString;
    }
    if (canvas2.style.height !== heightString) {
      canvas2.style.height = heightString;
    }
    const scaledWidth = props.appState.width * props.scale;
    const scaledHeight = props.appState.height * props.scale;
    if (canvas2.width !== scaledWidth) {
      canvas2.width = scaledWidth;
    }
    if (canvas2.height !== scaledHeight) {
      canvas2.height = scaledHeight;
    }
    renderStaticScene(
      {
        canvas: canvas2,
        rc: props.rc,
        scale: props.scale,
        elementsMap: props.elementsMap,
        allElementsMap: props.allElementsMap,
        visibleElements: props.visibleElements,
        appState: props.appState,
        renderConfig: props.renderConfig
      },
      isRenderThrottlingEnabled()
    );
  });
  return /* @__PURE__ */ jsx139("div", { className: "excalidraw__canvas-wrapper", ref: wrapperRef });
};
var getRelevantAppStateProps2 = (appState) => ({
  zoom: appState.zoom,
  scrollX: appState.scrollX,
  scrollY: appState.scrollY,
  width: appState.width,
  height: appState.height,
  viewModeEnabled: appState.viewModeEnabled,
  offsetLeft: appState.offsetLeft,
  offsetTop: appState.offsetTop,
  theme: appState.theme,
  pendingImageElementId: appState.pendingImageElementId,
  shouldCacheIgnoreZoom: appState.shouldCacheIgnoreZoom,
  viewBackgroundColor: appState.viewBackgroundColor,
  exportScale: appState.exportScale,
  selectedElementsAreBeingDragged: appState.selectedElementsAreBeingDragged,
  gridSize: appState.gridSize,
  gridStep: appState.gridStep,
  frameRendering: appState.frameRendering,
  selectedElementIds: appState.selectedElementIds,
  frameToHighlight: appState.frameToHighlight,
  editingGroupId: appState.editingGroupId,
  currentHoveredFontFamily: appState.currentHoveredFontFamily
});
var areEqual4 = (prevProps, nextProps) => {
  if (prevProps.sceneNonce !== nextProps.sceneNonce || prevProps.scale !== nextProps.scale || // we need to memoize on elementsMap because they may have renewed
  // even if sceneNonce didn't change (e.g. we filter elements out based
  // on appState)
  prevProps.elementsMap !== nextProps.elementsMap || prevProps.visibleElements !== nextProps.visibleElements) {
    return false;
  }
  return isShallowEqual(
    // asserting AppState because we're being passed the whole AppState
    // but resolve to only the StaticCanvas-relevant props
    getRelevantAppStateProps2(prevProps.appState),
    getRelevantAppStateProps2(nextProps.appState)
  ) && isShallowEqual(prevProps.renderConfig, nextProps.renderConfig);
};
var StaticCanvas_default = React42.memo(StaticCanvas, areEqual4);

// scene/Renderer.ts
init_define_import_meta_env();
init_sizeHelpers();
init_typeChecks();
init_staticScene();
init_utils2();
var Renderer = class {
  scene;
  constructor(scene) {
    this.scene = scene;
  }
  getRenderableElements = (() => {
    const getVisibleCanvasElements = ({
      elementsMap,
      zoom,
      offsetLeft,
      offsetTop,
      scrollX,
      scrollY,
      height,
      width
    }) => {
      const visibleElements = [];
      for (const element of elementsMap.values()) {
        if (isElementInViewport(
          element,
          width,
          height,
          {
            zoom,
            offsetLeft,
            offsetTop,
            scrollX,
            scrollY
          },
          elementsMap
        )) {
          visibleElements.push(element);
        }
      }
      return visibleElements;
    };
    const getRenderableElements = ({
      elements,
      editingTextElement,
      newElementId,
      pendingImageElementId
    }) => {
      const elementsMap = toBrandedType(/* @__PURE__ */ new Map());
      for (const element of elements) {
        if (isImageElement(element)) {
          if (
            // => not placed on canvas yet (but in elements array)
            pendingImageElementId === element.id
          ) {
            continue;
          }
        }
        if (newElementId === element.id) {
          continue;
        }
        if (!editingTextElement || editingTextElement.type !== "text" || element.id !== editingTextElement.id) {
          elementsMap.set(element.id, element);
        }
      }
      return elementsMap;
    };
    return memoize(
      ({
        zoom,
        offsetLeft,
        offsetTop,
        scrollX,
        scrollY,
        height,
        width,
        editingTextElement,
        newElementId,
        pendingImageElementId,
        // cache-invalidation nonce
        sceneNonce: _sceneNonce
      }) => {
        const elements = this.scene.getNonDeletedElements();
        const elementsMap = getRenderableElements({
          elements,
          editingTextElement,
          newElementId,
          pendingImageElementId
        });
        const visibleElements = getVisibleCanvasElements({
          elementsMap,
          zoom,
          offsetLeft,
          offsetTop,
          scrollX,
          scrollY,
          height,
          width
        });
        return { elementsMap, visibleElements };
      }
    );
  })();
  // NOTE Doesn't destroy everything (scene, rc, etc.) because it may not be
  // safe to break TS contract here (for upstream cases)
  destroy() {
    renderInteractiveSceneThrottled.cancel();
    renderStaticSceneThrottled.cancel();
    this.getRenderableElements.clear();
  }
};

// components/App.tsx
init_ShapeCache();

// components/SVGLayer.tsx
init_define_import_meta_env();
import { useEffect as useEffect39, useRef as useRef38 } from "react";
import { jsx as jsx140 } from "react/jsx-runtime";
var SVGLayer = ({ trails }) => {
  const svgRef = useRef38(null);
  useEffect39(() => {
    if (svgRef.current) {
      for (const trail of trails) {
        trail.start(svgRef.current);
      }
    }
    return () => {
      for (const trail of trails) {
        trail.stop();
      }
    };
  }, trails);
  return /* @__PURE__ */ jsx140("div", { className: "SVGLayer", children: /* @__PURE__ */ jsx140("svg", { ref: svgRef }) });
};

// components/App.tsx
init_cursor();
init_emitter();

// element/ElementCanvasButtons.tsx
init_define_import_meta_env();
init_utils2();
init_element();
import { jsx as jsx141 } from "react/jsx-runtime";
var CONTAINER_PADDING2 = 5;
var getContainerCoords2 = (element, appState, elementsMap) => {
  const [x1, y1] = getElementAbsoluteCoords(element, elementsMap);
  const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(
    { sceneX: x1 + element.width, sceneY: y1 },
    appState
  );
  const x = viewportX - appState.offsetLeft + 10;
  const y = viewportY - appState.offsetTop;
  return { x, y };
};
var ElementCanvasButtons = ({
  children,
  element,
  elementsMap
}) => {
  const appState = useExcalidrawAppState();
  if (appState.contextMenu || appState.newElement || appState.resizingElement || appState.isRotating || appState.openMenu || appState.viewModeEnabled) {
    return null;
  }
  const { x, y } = getContainerCoords2(element, appState, elementsMap);
  return /* @__PURE__ */ jsx141(
    "div",
    {
      className: "excalidraw-canvas-buttons",
      style: {
        top: `${y}px`,
        left: `${x}px`,
        // width: CONTAINER_WIDTH,
        padding: CONTAINER_PADDING2
      },
      children
    }
  );
};

// components/App.tsx
init_colors();

// components/MagicButton.tsx
init_define_import_meta_env();
import clsx55 from "clsx";
import { jsx as jsx142, jsxs as jsxs75 } from "react/jsx-runtime";
var DEFAULT_SIZE4 = "small";
var ElementCanvasButton = (props) => {
  return /* @__PURE__ */ jsxs75(
    "label",
    {
      className: clsx55(
        "ToolIcon ToolIcon__MagicButton",
        `ToolIcon_size_${DEFAULT_SIZE4}`,
        {
          "is-mobile": props.isMobile
        }
      ),
      title: `${props.title}`,
      children: [
        /* @__PURE__ */ jsx142(
          "input",
          {
            className: "ToolIcon_type_checkbox",
            type: "checkbox",
            name: props.name,
            onChange: props.onChange,
            checked: props.checked,
            "aria-label": props.title
          }
        ),
        /* @__PURE__ */ jsx142("div", { className: "ToolIcon__icon", children: props.icon })
      ]
    }
  );
};

// components/App.tsx
init_icons();

// components/FollowMode/FollowMode.tsx
init_define_import_meta_env();
init_icons();
import { jsx as jsx143, jsxs as jsxs76 } from "react/jsx-runtime";
var FollowMode = ({
  height,
  width,
  userToFollow,
  onDisconnect
}) => {
  return /* @__PURE__ */ jsx143("div", { className: "follow-mode", style: { width, height }, children: /* @__PURE__ */ jsxs76("div", { className: "follow-mode__badge", children: [
    /* @__PURE__ */ jsxs76("div", { className: "follow-mode__badge__label", children: [
      "Following",
      " ",
      /* @__PURE__ */ jsx143(
        "span",
        {
          className: "follow-mode__badge__username",
          title: userToFollow.username,
          children: userToFollow.username
        }
      )
    ] }),
    /* @__PURE__ */ jsx143(
      "button",
      {
        type: "button",
        onClick: onDisconnect,
        className: "follow-mode__disconnect-btn",
        children: CloseIcon
      }
    )
  ] }) });
};
var FollowMode_default = FollowMode;

// components/App.tsx
init_store();

// animation-frame-handler.ts
init_define_import_meta_env();
var AnimationFrameHandler = class {
  targets = /* @__PURE__ */ new WeakMap();
  rafIds = /* @__PURE__ */ new WeakMap();
  register(key, callback) {
    this.targets.set(key, { callback, stopped: true });
  }
  start(key) {
    const target = this.targets.get(key);
    if (!target) {
      return;
    }
    if (this.rafIds.has(key)) {
      return;
    }
    this.targets.set(key, { ...target, stopped: false });
    this.scheduleFrame(key);
  }
  stop(key) {
    const target = this.targets.get(key);
    if (target && !target.stopped) {
      this.targets.set(key, { ...target, stopped: true });
    }
    this.cancelFrame(key);
  }
  constructFrame(key) {
    return (timestamp) => {
      const target = this.targets.get(key);
      if (!target) {
        return;
      }
      const shouldAbort = this.onFrame(target, timestamp);
      if (!target.stopped && !shouldAbort) {
        this.scheduleFrame(key);
      } else {
        this.cancelFrame(key);
      }
    };
  }
  scheduleFrame(key) {
    const rafId = requestAnimationFrame(this.constructFrame(key));
    this.rafIds.set(key, rafId);
  }
  cancelFrame(key) {
    if (this.rafIds.has(key)) {
      const rafId = this.rafIds.get(key);
      cancelAnimationFrame(rafId);
    }
    this.rafIds.delete(key);
  }
  onFrame(target, timestamp) {
    const shouldAbort = target.callback(timestamp);
    return shouldAbort ?? false;
  }
};

// animated-trail.ts
init_define_import_meta_env();
init_utils2();
init_constants();
import { LaserPointer } from "@excalidraw/laser-pointer";
var AnimatedTrail = class {
  constructor(animationFrameHandler, app, options) {
    this.animationFrameHandler = animationFrameHandler;
    this.app = app;
    this.options = options;
    this.animationFrameHandler.register(this, this.onFrame.bind(this));
    this.trailElement = document.createElementNS(SVG_NS, "path");
  }
  currentTrail;
  pastTrails = [];
  container;
  trailElement;
  get hasCurrentTrail() {
    return !!this.currentTrail;
  }
  hasLastPoint(x, y) {
    if (this.currentTrail) {
      const len = this.currentTrail.originalPoints.length;
      return this.currentTrail.originalPoints[len - 1][0] === x && this.currentTrail.originalPoints[len - 1][1] === y;
    }
    return false;
  }
  start(container) {
    if (container) {
      this.container = container;
    }
    if (this.trailElement.parentNode !== this.container && this.container) {
      this.container.appendChild(this.trailElement);
    }
    this.animationFrameHandler.start(this);
  }
  stop() {
    this.animationFrameHandler.stop(this);
    if (this.trailElement.parentNode === this.container) {
      this.container?.removeChild(this.trailElement);
    }
  }
  startPath(x, y) {
    this.currentTrail = new LaserPointer(this.options);
    this.currentTrail.addPoint([x, y, performance.now()]);
    this.update();
  }
  addPointToPath(x, y) {
    if (this.currentTrail) {
      this.currentTrail.addPoint([x, y, performance.now()]);
      this.update();
    }
  }
  endPath() {
    if (this.currentTrail) {
      this.currentTrail.close();
      this.currentTrail.options.keepHead = false;
      this.pastTrails.push(this.currentTrail);
      this.currentTrail = void 0;
      this.update();
    }
  }
  update() {
    this.start();
  }
  onFrame() {
    const paths = [];
    for (const trail of this.pastTrails) {
      paths.push(this.drawTrail(trail, this.app.state));
    }
    if (this.currentTrail) {
      const currentPath = this.drawTrail(this.currentTrail, this.app.state);
      paths.push(currentPath);
    }
    this.pastTrails = this.pastTrails.filter((trail) => {
      return trail.getStrokeOutline().length !== 0;
    });
    if (paths.length === 0) {
      this.stop();
    }
    const svgPaths = paths.join(" ").trim();
    this.trailElement.setAttribute("d", svgPaths);
    this.trailElement.setAttribute(
      "fill",
      (this.options.fill ?? (() => "black"))(this)
    );
  }
  drawTrail(trail, state) {
    const stroke = trail.getStrokeOutline(trail.options.size / state.zoom.value).map(([x, y]) => {
      const result = sceneCoordsToViewportCoords(
        { sceneX: x, sceneY: y },
        state
      );
      return [result.x, result.y];
    });
    return getSvgPathFromStroke(stroke, true);
  }
};

// laser-trails.ts
init_define_import_meta_env();
init_utils2();
init_constants();
var LaserTrails = class {
  constructor(animationFrameHandler, app) {
    this.animationFrameHandler = animationFrameHandler;
    this.app = app;
    this.animationFrameHandler.register(this, this.onFrame.bind(this));
    this.localTrail = new AnimatedTrail(animationFrameHandler, app, {
      ...this.getTrailOptions(),
      fill: () => DEFAULT_LASER_COLOR
    });
  }
  localTrail;
  collabTrails = /* @__PURE__ */ new Map();
  container;
  getTrailOptions() {
    return {
      simplify: 0,
      streamline: 0.4,
      sizeMapping: (c) => {
        const DECAY_TIME = 1e3;
        const DECAY_LENGTH = 50;
        const t2 = Math.max(
          0,
          1 - (performance.now() - c.pressure) / DECAY_TIME
        );
        const l = (DECAY_LENGTH - Math.min(DECAY_LENGTH, c.totalLength - c.currentIndex)) / DECAY_LENGTH;
        return Math.min(easeOut(l), easeOut(t2));
      }
    };
  }
  startPath(x, y) {
    this.localTrail.startPath(x, y);
  }
  addPointToPath(x, y) {
    this.localTrail.addPointToPath(x, y);
  }
  endPath() {
    this.localTrail.endPath();
  }
  start(container) {
    this.container = container;
    this.animationFrameHandler.start(this);
    this.localTrail.start(container);
  }
  stop() {
    this.animationFrameHandler.stop(this);
    this.localTrail.stop();
  }
  onFrame() {
    this.updateCollabTrails();
  }
  updateCollabTrails() {
    if (!this.container || this.app.state.collaborators.size === 0) {
      return;
    }
    for (const [key, collaborator] of this.app.state.collaborators.entries()) {
      let trail;
      if (!this.collabTrails.has(key)) {
        trail = new AnimatedTrail(this.animationFrameHandler, this.app, {
          ...this.getTrailOptions(),
          fill: () => collaborator.pointer?.laserColor || getClientColor(key, collaborator)
        });
        trail.start(this.container);
        this.collabTrails.set(key, trail);
      } else {
        trail = this.collabTrails.get(key);
      }
      if (collaborator.pointer && collaborator.pointer.tool === "laser") {
        if (collaborator.button === "down" && !trail.hasCurrentTrail) {
          trail.startPath(collaborator.pointer.x, collaborator.pointer.y);
        }
        if (collaborator.button === "down" && trail.hasCurrentTrail && !trail.hasLastPoint(collaborator.pointer.x, collaborator.pointer.y)) {
          trail.addPointToPath(collaborator.pointer.x, collaborator.pointer.y);
        }
        if (collaborator.button === "up" && trail.hasCurrentTrail) {
          trail.addPointToPath(collaborator.pointer.x, collaborator.pointer.y);
          trail.endPath();
        }
      }
    }
    for (const key of this.collabTrails.keys()) {
      if (!this.app.state.collaborators.has(key)) {
        const trail = this.collabTrails.get(key);
        trail.stop();
        this.collabTrails.delete(key);
      }
    }
  }
};

// components/App.tsx
init_renderElement();
init_collision2();

// element/textWysiwyg.tsx
init_define_import_meta_env();
init_keys();
init_utils2();
init_Scene();
init_typeChecks();
init_constants();
init_mutateElement();
init_textElement();
init_linearElementEditor();
init_clipboard();
init_containerCache();
var getTransform = (width, height, angle, appState, maxWidth, maxHeight) => {
  const { zoom } = appState;
  const degree = 180 * angle / Math.PI;
  let translateX = width * (zoom.value - 1) / 2;
  let translateY = height * (zoom.value - 1) / 2;
  if (width > maxWidth && zoom.value !== 1) {
    translateX = maxWidth * (zoom.value - 1) / 2;
  }
  if (height > maxHeight && zoom.value !== 1) {
    translateY = maxHeight * (zoom.value - 1) / 2;
  }
  return `translate(${translateX}px, ${translateY}px) scale(${zoom.value}) rotate(${degree}deg)`;
};
var textWysiwyg = ({
  id,
  onChange,
  onSubmit,
  getViewportCoords,
  element,
  canvas: canvas2,
  excalidrawContainer,
  app,
  autoSelect = true
}) => {
  const textPropertiesUpdated = (updatedTextElement, editable2) => {
    if (!editable2.style.fontFamily || !editable2.style.fontSize) {
      return false;
    }
    const currentFont = editable2.style.fontFamily.replace(/"/g, "");
    if (getFontFamilyString({ fontFamily: updatedTextElement.fontFamily }) !== currentFont) {
      return true;
    }
    if (`${updatedTextElement.fontSize}px` !== editable2.style.fontSize) {
      return true;
    }
    return false;
  };
  const updateWysiwygStyle = () => {
    const appState = app.state;
    const updatedTextElement = Scene_default.getScene(element)?.getElement(id);
    if (!updatedTextElement) {
      return;
    }
    const { textAlign, verticalAlign } = updatedTextElement;
    const elementsMap = app.scene.getNonDeletedElementsMap();
    if (updatedTextElement && isTextElement(updatedTextElement)) {
      let coordX = updatedTextElement.x;
      let coordY = updatedTextElement.y;
      const container = getContainerElement(
        updatedTextElement,
        app.scene.getNonDeletedElementsMap()
      );
      let width = updatedTextElement.width;
      let height = updatedTextElement.height;
      let maxWidth = updatedTextElement.width;
      let maxHeight = updatedTextElement.height;
      if (container && updatedTextElement.containerId) {
        if (isArrowElement(container)) {
          const boundTextCoords = LinearElementEditor.getBoundTextElementPosition(
            container,
            updatedTextElement,
            elementsMap
          );
          coordX = boundTextCoords.x;
          coordY = boundTextCoords.y;
        }
        const propertiesUpdated = textPropertiesUpdated(
          updatedTextElement,
          editable
        );
        let originalContainerData;
        if (propertiesUpdated) {
          originalContainerData = updateOriginalContainerCache(
            container.id,
            container.height
          );
        } else {
          originalContainerData = originalContainerCache[container.id];
          if (!originalContainerData) {
            originalContainerData = updateOriginalContainerCache(
              container.id,
              container.height
            );
          }
        }
        maxWidth = getBoundTextMaxWidth(container, updatedTextElement);
        maxHeight = getBoundTextMaxHeight(
          container,
          updatedTextElement
        );
        if (!isArrowElement(container) && height > maxHeight) {
          const targetContainerHeight = computeContainerDimensionForBoundText(
            height,
            container.type
          );
          mutateElement(container, { height: targetContainerHeight });
          return;
        } else if (
          // autoshrink container height until original container height
          // is reached when text is removed
          !isArrowElement(container) && container.height > originalContainerData.height && height < maxHeight
        ) {
          const targetContainerHeight = computeContainerDimensionForBoundText(
            height,
            container.type
          );
          mutateElement(container, { height: targetContainerHeight });
        } else {
          const { y } = computeBoundTextPosition(
            container,
            updatedTextElement,
            elementsMap
          );
          coordY = y;
        }
      }
      const [viewportX, viewportY] = getViewportCoords(coordX, coordY);
      const initialSelectionStart = editable.selectionStart;
      const initialSelectionEnd = editable.selectionEnd;
      const initialLength = editable.value.length;
      if (initialSelectionStart === initialSelectionEnd && initialSelectionEnd !== initialLength) {
        const diff = initialLength - initialSelectionEnd;
        editable.selectionStart = editable.value.length - diff;
        editable.selectionEnd = editable.value.length - diff;
      }
      if (!container) {
        maxWidth = (appState.width - 8 - viewportX) / appState.zoom.value;
        width = Math.min(width, maxWidth);
      } else {
        width += 0.5;
      }
      height *= 1.05;
      const font = getFontString(updatedTextElement);
      const padding = !isSafari ? Math.ceil(updatedTextElement.fontSize / appState.zoom.value / 2) : 0;
      const editorMaxHeight = (appState.height - viewportY) / appState.zoom.value;
      Object.assign(editable.style, {
        font,
        // must be defined *after* font \_()_/
        lineHeight: updatedTextElement.lineHeight,
        width: `${width}px`,
        height: `${height}px`,
        left: `${viewportX - padding}px`,
        top: `${viewportY}px`,
        transform: getTransform(
          width,
          height,
          getTextElementAngle(updatedTextElement, container),
          appState,
          maxWidth,
          editorMaxHeight
        ),
        padding: `0 ${padding}px`,
        textAlign,
        verticalAlign,
        color: updatedTextElement.strokeColor,
        opacity: updatedTextElement.opacity / 100,
        filter: "var(--theme-filter)",
        maxHeight: `${editorMaxHeight}px`
      });
      editable.scrollTop = 0;
      if (isTestEnv()) {
        editable.style.fontFamily = getFontFamilyString(updatedTextElement);
      }
      mutateElement(updatedTextElement, { x: coordX, y: coordY });
    }
  };
  const editable = document.createElement("textarea");
  editable.dir = "auto";
  editable.tabIndex = 0;
  editable.dataset.type = "wysiwyg";
  editable.wrap = "off";
  editable.classList.add("excalidraw-wysiwyg");
  let whiteSpace = "pre";
  let wordBreak = "normal";
  if (isBoundToContainer(element) || !element.autoResize) {
    whiteSpace = "pre-wrap";
    wordBreak = "break-word";
  }
  Object.assign(editable.style, {
    position: "absolute",
    display: "inline-block",
    minHeight: "1em",
    backfaceVisibility: "hidden",
    margin: 0,
    border: 0,
    outline: 0,
    resize: "none",
    background: "transparent",
    overflow: "hidden",
    // must be specified because in dark mode canvas creates a stacking context
    zIndex: "var(--zIndex-wysiwyg)",
    wordBreak,
    // prevent line wrapping (`whitespace: nowrap` doesn't work on FF)
    whiteSpace,
    overflowWrap: "break-word",
    boxSizing: "content-box"
  });
  editable.value = element.originalText;
  updateWysiwygStyle();
  if (onChange) {
    editable.onpaste = async (event) => {
      const clipboardData = await parseClipboard(event, true);
      if (!clipboardData.text) {
        return;
      }
      const data = normalizeText(clipboardData.text);
      if (!data) {
        return;
      }
      const container = getContainerElement(
        element,
        app.scene.getNonDeletedElementsMap()
      );
      const font = getFontString({
        fontSize: app.state.currentItemFontSize,
        fontFamily: app.state.currentItemFontFamily
      });
      if (container) {
        const boundTextElement = getBoundTextElement(
          container,
          app.scene.getNonDeletedElementsMap()
        );
        const wrappedText = wrapText(
          `${editable.value}${data}`,
          font,
          getBoundTextMaxWidth(container, boundTextElement)
        );
        const width = getTextWidth(wrappedText, font, true);
        editable.style.width = `${width}px`;
      }
    };
    editable.oninput = () => {
      const normalized2 = normalizeText(editable.value);
      if (editable.value !== normalized2) {
        const selectionStart = editable.selectionStart;
        editable.value = normalized2;
        editable.selectionStart = selectionStart;
        editable.selectionEnd = selectionStart;
      }
      onChange(editable.value);
    };
  }
  editable.onkeydown = (event) => {
    if (!event.shiftKey && actionZoomIn.keyTest(event)) {
      event.preventDefault();
      app.actionManager.executeAction(actionZoomIn);
      updateWysiwygStyle();
    } else if (!event.shiftKey && actionZoomOut.keyTest(event)) {
      event.preventDefault();
      app.actionManager.executeAction(actionZoomOut);
      updateWysiwygStyle();
    } else if (!event.shiftKey && actionResetZoom.keyTest(event)) {
      event.preventDefault();
      app.actionManager.executeAction(actionResetZoom);
      updateWysiwygStyle();
    } else if (actionDecreaseFontSize.keyTest(event)) {
      app.actionManager.executeAction(actionDecreaseFontSize);
    } else if (actionIncreaseFontSize.keyTest(event)) {
      app.actionManager.executeAction(actionIncreaseFontSize);
    } else if (event.key === KEYS.ESCAPE) {
      event.preventDefault();
      submittedViaKeyboard = true;
      handleSubmit();
    } else if (event.key === KEYS.ENTER && event[KEYS.CTRL_OR_CMD]) {
      event.preventDefault();
      if (event.isComposing || event.keyCode === 229) {
        return;
      }
      submittedViaKeyboard = true;
      handleSubmit();
    } else if (event.key === KEYS.TAB || event[KEYS.CTRL_OR_CMD] && (event.code === CODES.BRACKET_LEFT || event.code === CODES.BRACKET_RIGHT)) {
      event.preventDefault();
      if (event.isComposing) {
        return;
      } else if (event.shiftKey || event.code === CODES.BRACKET_LEFT) {
        outdent();
      } else {
        indent();
      }
      editable.dispatchEvent(new Event("input"));
    }
  };
  const TAB_SIZE = 4;
  const TAB = " ".repeat(TAB_SIZE);
  const RE_LEADING_TAB = new RegExp(`^ {1,${TAB_SIZE}}`);
  const indent = () => {
    const { selectionStart, selectionEnd } = editable;
    const linesStartIndices = getSelectedLinesStartIndices();
    let value = editable.value;
    linesStartIndices.forEach((startIndex) => {
      const startValue = value.slice(0, startIndex);
      const endValue = value.slice(startIndex);
      value = `${startValue}${TAB}${endValue}`;
    });
    editable.value = value;
    editable.selectionStart = selectionStart + TAB_SIZE;
    editable.selectionEnd = selectionEnd + TAB_SIZE * linesStartIndices.length;
  };
  const outdent = () => {
    const { selectionStart, selectionEnd } = editable;
    const linesStartIndices = getSelectedLinesStartIndices();
    const removedTabs = [];
    let value = editable.value;
    linesStartIndices.forEach((startIndex) => {
      const tabMatch = value.slice(startIndex, startIndex + TAB_SIZE).match(RE_LEADING_TAB);
      if (tabMatch) {
        const startValue = value.slice(0, startIndex);
        const endValue = value.slice(startIndex + tabMatch[0].length);
        value = `${startValue}${endValue}`;
        removedTabs.push(startIndex);
      }
    });
    editable.value = value;
    if (removedTabs.length) {
      if (selectionStart > removedTabs[removedTabs.length - 1]) {
        editable.selectionStart = Math.max(
          selectionStart - TAB_SIZE,
          removedTabs[removedTabs.length - 1]
        );
      } else {
        editable.selectionStart = selectionStart;
      }
      editable.selectionEnd = Math.max(
        editable.selectionStart,
        selectionEnd - TAB_SIZE * removedTabs.length
      );
    }
  };
  const getSelectedLinesStartIndices = () => {
    let { selectionStart, selectionEnd, value } = editable;
    const startOffset = value.slice(0, selectionStart).match(/[^\n]*$/)[0].length;
    selectionStart = selectionStart - startOffset;
    const selected = value.slice(selectionStart, selectionEnd);
    return selected.split("\n").reduce(
      (startIndices, line, idx, lines) => startIndices.concat(
        idx ? (
          // curr line index is prev line's start + prev line's length + \n
          startIndices[idx - 1] + lines[idx - 1].length + 1
        ) : (
          // first selected line
          selectionStart
        )
      ),
      []
    ).reverse();
  };
  const stopEvent = (event) => {
    if (event.target instanceof HTMLCanvasElement) {
      event.preventDefault();
      event.stopPropagation();
    }
  };
  let submittedViaKeyboard = false;
  const handleSubmit = () => {
    if (isDestroyed) {
      return;
    }
    isDestroyed = true;
    cleanup();
    const updateElement = Scene_default.getScene(element)?.getElement(
      element.id
    );
    if (!updateElement) {
      return;
    }
    const container = getContainerElement(
      updateElement,
      app.scene.getNonDeletedElementsMap()
    );
    if (container) {
      if (editable.value.trim()) {
        const boundTextElementId = getBoundTextElementId(container);
        if (!boundTextElementId || boundTextElementId !== element.id) {
          mutateElement(container, {
            boundElements: (container.boundElements || []).concat({
              type: "text",
              id: element.id
            })
          });
        } else if (isArrowElement(container)) {
          bumpVersion(container);
        }
      } else {
        mutateElement(container, {
          boundElements: container.boundElements?.filter(
            (ele) => !isTextElement(
              ele
            )
          )
        });
      }
      redrawTextBoundingBox(
        updateElement,
        container,
        app.scene.getNonDeletedElementsMap()
      );
    }
    onSubmit({
      viaKeyboard: submittedViaKeyboard,
      nextOriginalText: editable.value
    });
  };
  const cleanup = () => {
    editable.onblur = null;
    editable.oninput = null;
    editable.onkeydown = null;
    if (observer) {
      observer.disconnect();
    }
    window.removeEventListener("resize", updateWysiwygStyle);
    window.removeEventListener("wheel", stopEvent, true);
    window.removeEventListener("pointerdown", onPointerDown);
    window.removeEventListener("pointerup", bindBlurEvent);
    window.removeEventListener("blur", handleSubmit);
    window.removeEventListener("beforeunload", handleSubmit);
    unbindUpdate();
    unbindOnScroll();
    editable.remove();
  };
  const bindBlurEvent = (event) => {
    window.removeEventListener("pointerup", bindBlurEvent);
    const target = event?.target;
    const isPropertiesTrigger = target instanceof HTMLElement && target.classList.contains("properties-trigger");
    setTimeout(() => {
      editable.onblur = handleSubmit;
      if (!isPropertiesTrigger) {
        editable.focus();
      }
    });
  };
  const temporarilyDisableSubmit = () => {
    editable.onblur = null;
    window.addEventListener("pointerup", bindBlurEvent);
    window.addEventListener("blur", handleSubmit);
  };
  const onPointerDown = (event) => {
    const target = event?.target;
    if (event.button === POINTER_BUTTON.WHEEL) {
      if (target instanceof HTMLTextAreaElement) {
        event.preventDefault();
        app.handleCanvasPanUsingWheelOrSpaceDrag(event);
      }
      temporarilyDisableSubmit();
      return;
    }
    const isPropertiesTrigger = target instanceof HTMLElement && target.classList.contains("properties-trigger");
    if ((event.target instanceof HTMLElement || event.target instanceof SVGElement) && event.target.closest(
      `.${CLASSES.SHAPE_ACTIONS_MENU}, .${CLASSES.ZOOM_ACTIONS}`
    ) && !isWritableElement(event.target) || isPropertiesTrigger) {
      temporarilyDisableSubmit();
    } else if (event.target instanceof HTMLCanvasElement && // Vitest simply ignores stopPropagation, capture-mode, or rAF
    // so without introducing crazier hacks, nothing we can do
    !isTestEnv()) {
      requestAnimationFrame(() => {
        handleSubmit();
      });
    }
  };
  const unbindUpdate = app.scene.onUpdate(() => {
    updateWysiwygStyle();
    const isPopupOpened = !!document.activeElement?.closest(
      ".properties-content"
    );
    if (!isPopupOpened) {
      editable.focus();
    }
  });
  const unbindOnScroll = app.onScrollChangeEmitter.on(() => {
    updateWysiwygStyle();
  });
  let isDestroyed = false;
  if (autoSelect) {
    editable.select();
  }
  bindBlurEvent();
  let observer = null;
  if (canvas2 && "ResizeObserver" in window) {
    observer = new window.ResizeObserver(() => {
      updateWysiwygStyle();
    });
    observer.observe(canvas2);
  } else {
    window.addEventListener("resize", updateWysiwygStyle);
  }
  editable.onpointerdown = (event) => event.stopPropagation();
  requestAnimationFrame(() => {
    window.addEventListener("pointerdown", onPointerDown, { capture: true });
  });
  window.addEventListener("beforeunload", handleSubmit);
  excalidrawContainer?.querySelector(".excalidraw-textEditorContainer").appendChild(editable);
};

// components/App.tsx
init_fractionalIndex();
init_helpers();

// actions/actionTextAutoResize.ts
init_define_import_meta_env();
init_element();
init_mutateElement();
init_textElement();
init_scene();
init_store();
init_utils2();
init_register();
var actionTextAutoResize = register({
  name: "autoResize",
  label: "labels.autoResize",
  icon: null,
  trackEvent: { category: "element" },
  predicate: (elements, appState, _, app) => {
    const selectedElements = getSelectedElements(elements, appState);
    return selectedElements.length === 1 && isTextElement(selectedElements[0]) && !selectedElements[0].autoResize;
  },
  perform: (elements, appState, _, app) => {
    const selectedElements = getSelectedElements(elements, appState);
    return {
      appState,
      elements: elements.map((element) => {
        if (element.id === selectedElements[0].id && isTextElement(element)) {
          const metrics = measureText(
            element.originalText,
            getFontString(element),
            element.lineHeight
          );
          return newElementWith(element, {
            autoResize: true,
            width: metrics.width,
            height: metrics.height,
            text: element.originalText
          });
        }
        return element;
      }),
      storeAction: StoreAction.CAPTURE
    };
  }
});

// components/App.tsx
init_bounds();

// mermaid.ts
init_define_import_meta_env();
var isMaybeMermaidDefinition = (text) => {
  const chartTypes = [
    "flowchart",
    "graph",
    "sequenceDiagram",
    "classDiagram",
    "stateDiagram",
    "stateDiagram-v2",
    "erDiagram",
    "journey",
    "gantt",
    "pie",
    "quadrantChart",
    "requirementDiagram",
    "gitGraph",
    "C4Context",
    "mindmap",
    "timeline",
    "zenuml",
    "sankey",
    "xychart",
    "block"
  ];
  const re = new RegExp(
    `^(?:%%{.*?}%%[\\s\\n]*)?\\b(?:${chartTypes.map((x) => `\\s*${x}(-beta)?`).join("|")})\\b`
  );
  return re.test(text.trim());
};

// components/canvases/NewElementCanvas.tsx
init_define_import_meta_env();
import { useEffect as useEffect40, useRef as useRef39 } from "react";

// renderer/renderNewElementScene.ts
init_define_import_meta_env();
init_utils2();
init_helpers2();
init_renderElement();
var _renderNewElementScene = ({
  canvas: canvas2,
  rc,
  newElement: newElement2,
  elementsMap,
  allElementsMap,
  scale,
  appState,
  renderConfig
}) => {
  if (canvas2) {
    const [normalizedWidth, normalizedHeight] = getNormalizedCanvasDimensions(
      canvas2,
      scale
    );
    const context = bootstrapCanvas({
      canvas: canvas2,
      scale,
      normalizedWidth,
      normalizedHeight
    });
    context.save();
    context.scale(appState.zoom.value, appState.zoom.value);
    if (newElement2 && newElement2.type !== "selection") {
      renderElement(
        newElement2,
        elementsMap,
        allElementsMap,
        rc,
        context,
        renderConfig,
        appState
      );
    } else {
      context.clearRect(0, 0, normalizedWidth, normalizedHeight);
    }
  }
};
var renderNewElementSceneThrottled = throttleRAF(
  (config) => {
    _renderNewElementScene(config);
  },
  { trailing: true }
);
var renderNewElementScene = (renderConfig, throttle6) => {
  if (throttle6) {
    renderNewElementSceneThrottled(renderConfig);
    return;
  }
  _renderNewElementScene(renderConfig);
};

// components/canvases/NewElementCanvas.tsx
import { jsx as jsx144 } from "react/jsx-runtime";
var NewElementCanvas = (props) => {
  const canvasRef = useRef39(null);
  useEffect40(() => {
    if (!canvasRef.current) {
      return;
    }
    renderNewElementScene(
      {
        canvas: canvasRef.current,
        scale: props.scale,
        newElement: props.appState.newElement,
        elementsMap: props.elementsMap,
        allElementsMap: props.allElementsMap,
        rc: props.rc,
        renderConfig: props.renderConfig,
        appState: props.appState
      },
      isRenderThrottlingEnabled()
    );
  });
  return /* @__PURE__ */ jsx144(
    "canvas",
    {
      className: "excalidraw__canvas",
      style: {
        width: props.appState.width,
        height: props.appState.height
      },
      width: props.appState.width * props.scale,
      height: props.appState.height * props.scale,
      ref: canvasRef
    }
  );
};
var NewElementCanvas_default = NewElementCanvas;

// components/App.tsx
init_routing();
init_math();
import { Fragment as Fragment25, jsx as jsx145, jsxs as jsxs77 } from "react/jsx-runtime";
var AppContext = React43.createContext(null);
var AppPropsContext = React43.createContext(null);
var deviceContextInitialValue = {
  viewport: {
    isMobile: false,
    isLandscape: false
  },
  editor: {
    isMobile: false,
    canFitSidebar: false
  },
  isTouchScreen: false
};
var DeviceContext = React43.createContext(deviceContextInitialValue);
DeviceContext.displayName = "DeviceContext";
var ExcalidrawContainerContext = React43.createContext({ container: null, id: null });
ExcalidrawContainerContext.displayName = "ExcalidrawContainerContext";
var ExcalidrawElementsContext = React43.createContext([]);
ExcalidrawElementsContext.displayName = "ExcalidrawElementsContext";
var ExcalidrawAppStateContext = React43.createContext({
  ...getDefaultAppState(),
  width: 0,
  height: 0,
  offsetLeft: 0,
  offsetTop: 0
});
ExcalidrawAppStateContext.displayName = "ExcalidrawAppStateContext";
var ExcalidrawSetAppStateContext = React43.createContext(() => {
  console.warn("Uninitialized ExcalidrawSetAppStateContext context!");
});
ExcalidrawSetAppStateContext.displayName = "ExcalidrawSetAppStateContext";
var ExcalidrawActionManagerContext = React43.createContext(
  null
);
ExcalidrawActionManagerContext.displayName = "ExcalidrawActionManagerContext";
var useApp = () => useContext3(AppContext);
var useAppProps = () => useContext3(AppPropsContext);
var useDevice = () => useContext3(DeviceContext);
var useExcalidrawContainer = () => useContext3(ExcalidrawContainerContext);
var useExcalidrawElements = () => useContext3(ExcalidrawElementsContext);
var useExcalidrawAppState = () => useContext3(ExcalidrawAppStateContext);
var useExcalidrawSetAppState = () => useContext3(ExcalidrawSetAppStateContext);
var useExcalidrawActionManager = () => useContext3(ExcalidrawActionManagerContext);
var didTapTwice = false;
var tappedTwiceTimer = 0;
var isHoldingSpace = false;
var isPanning = false;
var isDraggingScrollBar = false;
var currentScrollBars = { horizontal: null, vertical: null };
var touchTimeout = 0;
var invalidateContextMenu = false;
var YOUTUBE_VIDEO_STATES = /* @__PURE__ */ new Map();
var IS_PLAIN_PASTE = false;
var IS_PLAIN_PASTE_TIMER = 0;
var PLAIN_PASTE_TOAST_SHOWN = false;
var lastPointerUp = null;
var gesture = {
  pointers: /* @__PURE__ */ new Map(),
  lastCenter: null,
  initialDistance: null,
  initialScale: null
};
var App = class _App extends React43.Component {
  canvas;
  interactiveCanvas = null;
  rc;
  unmounted = false;
  actionManager;
  device = deviceContextInitialValue;
  excalidrawContainerRef = React43.createRef();
  scene;
  fonts;
  renderer;
  visibleElements;
  resizeObserver;
  nearestScrollableContainer;
  library;
  libraryItemsFromStorage;
  id;
  store;
  history;
  excalidrawContainerValue;
  files = {};
  imageCache = /* @__PURE__ */ new Map();
  iFrameRefs = /* @__PURE__ */ new Map();
  /**
   * Indicates whether the embeddable's url has been validated for rendering.
   * If value not set, indicates that the validation is pending.
   * Initially or on url change the flag is not reset so that we can guarantee
   * the validation came from a trusted source (the editor).
   **/
  embedsValidationStatus = /* @__PURE__ */ new Map();
  /** embeds that have been inserted to DOM (as a perf optim, we don't want to
   * insert to DOM before user initially scrolls to them) */
  initializedEmbeds = /* @__PURE__ */ new Set();
  elementsPendingErasure = /* @__PURE__ */ new Set();
  flowChartCreator = new FlowChartCreator();
  flowChartNavigator = new FlowChartNavigator();
  hitLinkElement;
  lastPointerDownEvent = null;
  lastPointerUpEvent = null;
  lastPointerMoveEvent = null;
  lastViewportPosition = { x: 0, y: 0 };
  animationFrameHandler = new AnimationFrameHandler();
  laserTrails = new LaserTrails(this.animationFrameHandler, this);
  eraserTrail = new AnimatedTrail(this.animationFrameHandler, this, {
    streamline: 0.2,
    size: 5,
    keepHead: true,
    sizeMapping: (c) => {
      const DECAY_TIME = 200;
      const DECAY_LENGTH = 10;
      const t2 = Math.max(0, 1 - (performance.now() - c.pressure) / DECAY_TIME);
      const l = (DECAY_LENGTH - Math.min(DECAY_LENGTH, c.totalLength - c.currentIndex)) / DECAY_LENGTH;
      return Math.min(easeOut(l), easeOut(t2));
    },
    fill: () => this.state.theme === THEME.LIGHT ? "rgba(0, 0, 0, 0.2)" : "rgba(255, 255, 255, 0.2)"
  });
  onChangeEmitter = new Emitter();
  onPointerDownEmitter = new Emitter();
  onPointerUpEmitter = new Emitter();
  onUserFollowEmitter = new Emitter();
  onScrollChangeEmitter = new Emitter();
  missingPointerEventCleanupEmitter = new Emitter();
  onRemoveEventListenersEmitter = new Emitter();
  constructor(props) {
    super(props);
    const defaultAppState2 = getDefaultAppState();
    const {
      excalidrawAPI,
      viewModeEnabled = false,
      zenModeEnabled = false,
      gridModeEnabled = false,
      objectsSnapModeEnabled = false,
      theme = defaultAppState2.theme,
      name = `${t("labels.untitled")}-${getDateTime()}`
    } = props;
    this.state = {
      ...defaultAppState2,
      theme,
      isLoading: true,
      ...this.getCanvasOffsets(),
      viewModeEnabled,
      zenModeEnabled,
      objectsSnapModeEnabled,
      gridModeEnabled: gridModeEnabled ?? defaultAppState2.gridModeEnabled,
      name,
      width: window.innerWidth,
      height: window.innerHeight
    };
    this.id = nanoid3();
    this.library = new library_default(this);
    this.actionManager = new ActionManager(
      this.syncActionResult,
      () => this.state,
      () => this.scene.getElementsIncludingDeleted(),
      this
    );
    this.scene = new Scene_default();
    this.canvas = document.createElement("canvas");
    this.rc = rough4.canvas(this.canvas);
    this.renderer = new Renderer(this.scene);
    this.visibleElements = [];
    this.store = new Store();
    this.history = new History();
    if (excalidrawAPI) {
      const api = {
        updateScene: this.updateScene,
        updateLibrary: this.library.updateLibrary,
        addFiles: this.addFiles,
        resetScene: this.resetScene,
        getSceneElementsIncludingDeleted: this.getSceneElementsIncludingDeleted,
        history: {
          clear: this.resetHistory
        },
        scrollToContent: this.scrollToContent,
        getSceneElements: this.getSceneElements,
        getAppState: () => this.state,
        getFiles: () => this.files,
        getName: this.getName,
        registerAction: (action) => {
          this.actionManager.registerAction(action);
        },
        refresh: this.refresh,
        setToast: this.setToast,
        id: this.id,
        setActiveTool: this.setActiveTool,
        setCursor: this.setCursor,
        resetCursor: this.resetCursor,
        updateFrameRendering: this.updateFrameRendering,
        toggleSidebar: this.toggleSidebar,
        onChange: (cb) => this.onChangeEmitter.on(cb),
        onPointerDown: (cb) => this.onPointerDownEmitter.on(cb),
        onPointerUp: (cb) => this.onPointerUpEmitter.on(cb),
        onScrollChange: (cb) => this.onScrollChangeEmitter.on(cb),
        onUserFollow: (cb) => this.onUserFollowEmitter.on(cb)
      };
      if (typeof excalidrawAPI === "function") {
        excalidrawAPI(api);
      } else {
        console.error("excalidrawAPI should be a function!");
      }
    }
    this.excalidrawContainerValue = {
      container: this.excalidrawContainerRef.current,
      id: this.id
    };
    this.fonts = new Fonts({ scene: this.scene });
    this.history = new History();
    this.actionManager.registerAll(actions);
    this.actionManager.registerAction(
      createUndoAction(this.history, this.store)
    );
    this.actionManager.registerAction(
      createRedoAction(this.history, this.store)
    );
  }
  onWindowMessage(event) {
    if (event.origin !== "https://player.vimeo.com" && event.origin !== "https://www.youtube.com") {
      return;
    }
    let data = null;
    try {
      data = JSON.parse(event.data);
    } catch (e) {
    }
    if (!data) {
      return;
    }
    switch (event.origin) {
      case "https://player.vimeo.com":
        if (data.method === "paused") {
          let source = null;
          const iframes = document.body.querySelectorAll(
            "iframe.excalidraw__embeddable"
          );
          if (!iframes) {
            break;
          }
          for (const iframe of iframes) {
            if (iframe.contentWindow === event.source) {
              source = iframe.contentWindow;
            }
          }
          source?.postMessage(
            JSON.stringify({
              method: data.value ? "play" : "pause",
              value: true
            }),
            "*"
          );
        }
        break;
      case "https://www.youtube.com":
        if (data.event === "infoDelivery" && data.info && data.id && typeof data.info.playerState === "number") {
          const id = data.id;
          const playerState = data.info.playerState;
          if (Object.values(YOUTUBE_STATES).includes(playerState)) {
            YOUTUBE_VIDEO_STATES.set(
              id,
              playerState
            );
          }
        }
        break;
    }
  }
  cacheEmbeddableRef(element, ref) {
    if (ref) {
      this.iFrameRefs.set(element.id, ref);
    }
  }
  /**
   * Returns gridSize taking into account `gridModeEnabled`.
   * If disabled, returns null.
   */
  getEffectiveGridSize = () => {
    return isGridModeEnabled(this) ? this.state.gridSize : null;
  };
  getHTMLIFrameElement(element) {
    return this.iFrameRefs.get(element.id);
  }
  handleEmbeddableCenterClick(element) {
    if (this.state.activeEmbeddable?.element === element && this.state.activeEmbeddable?.state === "active") {
      return;
    }
    setTimeout(() => {
      this.setState({
        activeEmbeddable: { element, state: "active" },
        selectedElementIds: { [element.id]: true },
        newElement: null,
        selectionElement: null
      });
    }, 100);
    if (isIframeElement(element)) {
      return;
    }
    const iframe = this.getHTMLIFrameElement(element);
    if (!iframe?.contentWindow) {
      return;
    }
    if (iframe.src.includes("youtube")) {
      const state = YOUTUBE_VIDEO_STATES.get(element.id);
      if (!state) {
        YOUTUBE_VIDEO_STATES.set(element.id, YOUTUBE_STATES.UNSTARTED);
        iframe.contentWindow.postMessage(
          JSON.stringify({
            event: "listening",
            id: element.id
          }),
          "*"
        );
      }
      switch (state) {
        case YOUTUBE_STATES.PLAYING:
        case YOUTUBE_STATES.BUFFERING:
          iframe.contentWindow?.postMessage(
            JSON.stringify({
              event: "command",
              func: "pauseVideo",
              args: ""
            }),
            "*"
          );
          break;
        default:
          iframe.contentWindow?.postMessage(
            JSON.stringify({
              event: "command",
              func: "playVideo",
              args: ""
            }),
            "*"
          );
      }
    }
    if (iframe.src.includes("player.vimeo.com")) {
      iframe.contentWindow.postMessage(
        JSON.stringify({
          method: "paused"
          //video play/pause in onWindowMessage handler
        }),
        "*"
      );
    }
  }
  isIframeLikeElementCenter(el, event, sceneX, sceneY) {
    return el && !event.altKey && !event.shiftKey && !event.metaKey && !event.ctrlKey && (this.state.activeEmbeddable?.element !== el || this.state.activeEmbeddable?.state === "hover" || !this.state.activeEmbeddable) && sceneX >= el.x + el.width / 3 && sceneX <= el.x + 2 * el.width / 3 && sceneY >= el.y + el.height / 3 && sceneY <= el.y + 2 * el.height / 3;
  }
  updateEmbedValidationStatus = (element, status) => {
    this.embedsValidationStatus.set(element.id, status);
    ShapeCache.delete(element);
  };
  updateEmbeddables = () => {
    const iframeLikes = /* @__PURE__ */ new Set();
    let updated = false;
    this.scene.getNonDeletedElements().filter((element) => {
      if (isEmbeddableElement(element)) {
        iframeLikes.add(element.id);
        if (!this.embedsValidationStatus.has(element.id)) {
          updated = true;
          const validated = embeddableURLValidator(
            element.link,
            this.props.validateEmbeddable
          );
          this.updateEmbedValidationStatus(element, validated);
        }
      } else if (isIframeElement(element)) {
        iframeLikes.add(element.id);
      }
      return false;
    });
    if (updated) {
      this.scene.triggerUpdate();
    }
    this.iFrameRefs.forEach((ref, id) => {
      if (!iframeLikes.has(id)) {
        this.iFrameRefs.delete(id);
      }
    });
  };
  renderEmbeddables() {
    const scale = this.state.zoom.value;
    const normalizedWidth = this.state.width;
    const normalizedHeight = this.state.height;
    const embeddableElements = this.scene.getNonDeletedElements().filter(
      (el) => isEmbeddableElement(el) && this.embedsValidationStatus.get(el.id) === true || isIframeElement(el)
    );
    return /* @__PURE__ */ jsx145(Fragment25, { children: embeddableElements.map((el) => {
      const { x, y } = sceneCoordsToViewportCoords(
        { sceneX: el.x, sceneY: el.y },
        this.state
      );
      const isVisible = isElementInViewport(
        el,
        normalizedWidth,
        normalizedHeight,
        this.state,
        this.scene.getNonDeletedElementsMap()
      );
      const hasBeenInitialized = this.initializedEmbeds.has(el.id);
      if (isVisible && !hasBeenInitialized) {
        this.initializedEmbeds.add(el.id);
      }
      const shouldRender = isVisible || hasBeenInitialized;
      if (!shouldRender) {
        return null;
      }
      let src;
      if (isIframeElement(el)) {
        src = null;
        const data = (el.customData?.generationData ?? this.magicGenerations.get(el.id)) || {
          status: "error",
          message: "No generation data",
          code: "ERR_NO_GENERATION_DATA"
        };
        if (data.status === "done") {
          const html = data.html;
          src = {
            intrinsicSize: { w: el.width, h: el.height },
            type: "document",
            srcdoc: () => {
              return html;
            }
          };
        } else if (data.status === "pending") {
          src = {
            intrinsicSize: { w: el.width, h: el.height },
            type: "document",
            srcdoc: () => {
              return createSrcDoc(`
                    <style>
                      html, body {
                        width: 100%;
                        height: 100%;
                        color: ${this.state.theme === THEME.DARK ? "white" : "black"};
                      }
                      body {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        flex-direction: column;
                        gap: 1rem;
                      }

                      .Spinner {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        margin-left: auto;
                        margin-right: auto;
                      }

                      .Spinner svg {
                        animation: rotate 1.6s linear infinite;
                        transform-origin: center center;
                        width: 40px;
                        height: 40px;
                      }

                      .Spinner circle {
                        stroke: currentColor;
                        animation: dash 1.6s linear 0s infinite;
                        stroke-linecap: round;
                      }

                      @keyframes rotate {
                        100% {
                          transform: rotate(360deg);
                        }
                      }

                      @keyframes dash {
                        0% {
                          stroke-dasharray: 1, 300;
                          stroke-dashoffset: 0;
                        }
                        50% {
                          stroke-dasharray: 150, 300;
                          stroke-dashoffset: -200;
                        }
                        100% {
                          stroke-dasharray: 1, 300;
                          stroke-dashoffset: -280;
                        }
                      }
                    </style>
                    <div class="Spinner">
                      <svg
                        viewBox="0 0 100 100"
                      >
                        <circle
                          cx="50"
                          cy="50"
                          r="46"
                          stroke-width="8"
                          fill="none"
                          stroke-miter-limit="10"
                        />
                      </svg>
                    </div>
                    <div>Generating...</div>
                  `);
            }
          };
        } else {
          let message;
          if (data.code === "ERR_GENERATION_INTERRUPTED") {
            message = "Generation was interrupted...";
          } else {
            message = data.message || "Generation failed";
          }
          src = {
            intrinsicSize: { w: el.width, h: el.height },
            type: "document",
            srcdoc: () => {
              return createSrcDoc(`
                    <style>
                    html, body {
                      height: 100%;
                    }
                      body {
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                        color: ${COLOR_PALETTE.red[3]};
                      }
                      h1, h3 {
                        margin-top: 0;
                        margin-bottom: 0.5rem;
                      }
                    </style>
                    <h1>Error!</h1>
                    <h3>${message}</h3>
                  `);
            }
          };
        }
      } else {
        src = getEmbedLink(toValidURL(el.link || ""));
      }
      const isActive = this.state.activeEmbeddable?.element === el && this.state.activeEmbeddable?.state === "active";
      const isHovered = this.state.activeEmbeddable?.element === el && this.state.activeEmbeddable?.state === "hover";
      return /* @__PURE__ */ jsx145(
        "div",
        {
          className: clsx56("excalidraw__embeddable-container", {
            "is-hovered": isHovered
          }),
          style: {
            transform: isVisible ? `translate(${x - this.state.offsetLeft}px, ${y - this.state.offsetTop}px) scale(${scale})` : "none",
            display: isVisible ? "block" : "none",
            opacity: getRenderOpacity(
              el,
              getContainingFrame(el, this.scene.getNonDeletedElementsMap()),
              this.elementsPendingErasure,
              null
            ),
            ["--embeddable-radius"]: `${getCornerRadius(
              Math.min(el.width, el.height),
              el
            )}px`
          },
          children: /* @__PURE__ */ jsxs77(
            "div",
            {
              className: "excalidraw__embeddable-container__inner",
              style: {
                width: isVisible ? `${el.width}px` : 0,
                height: isVisible ? `${el.height}px` : 0,
                transform: isVisible ? `rotate(${el.angle}rad)` : "none",
                pointerEvents: isActive ? POINTER_EVENTS.enabled : POINTER_EVENTS.disabled
              },
              children: [
                isHovered && /* @__PURE__ */ jsx145("div", { className: "excalidraw__embeddable-hint", children: t("buttons.embeddableInteractionButton") }),
                /* @__PURE__ */ jsx145(
                  "div",
                  {
                    className: "excalidraw__embeddable__outer",
                    style: {
                      padding: `${el.strokeWidth}px`
                    },
                    children: (isEmbeddableElement(el) ? this.props.renderEmbeddable?.(el, this.state) : null) ?? /* @__PURE__ */ jsx145(
                      "iframe",
                      {
                        ref: (ref) => this.cacheEmbeddableRef(el, ref),
                        className: "excalidraw__embeddable",
                        srcDoc: src?.type === "document" ? src.srcdoc(this.state.theme) : void 0,
                        src: src?.type !== "document" ? src?.link ?? "" : void 0,
                        scrolling: "no",
                        referrerPolicy: "no-referrer-when-downgrade",
                        title: "Excalidraw Embedded Content",
                        allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",
                        allowFullScreen: true,
                        sandbox: `${src?.sandbox?.allowSameOrigin ? "allow-same-origin" : ""} allow-scripts allow-forms allow-popups allow-popups-to-escape-sandbox allow-presentation allow-downloads`
                      }
                    )
                  }
                )
              ]
            }
          )
        },
        el.id
      );
    }) });
  }
  getFrameNameDOMId = (frameElement) => {
    return `${this.id}-frame-name-${frameElement.id}`;
  };
  frameNameBoundsCache = {
    get: (frameElement) => {
      let bounds = this.frameNameBoundsCache._cache.get(frameElement.id);
      if (!bounds || bounds.zoom !== this.state.zoom.value || bounds.versionNonce !== frameElement.versionNonce) {
        const frameNameDiv = document.getElementById(
          this.getFrameNameDOMId(frameElement)
        );
        if (frameNameDiv) {
          const box = frameNameDiv.getBoundingClientRect();
          const boxSceneTopLeft = viewportCoordsToSceneCoords(
            { clientX: box.x, clientY: box.y },
            this.state
          );
          const boxSceneBottomRight = viewportCoordsToSceneCoords(
            { clientX: box.right, clientY: box.bottom },
            this.state
          );
          bounds = {
            x: boxSceneTopLeft.x,
            y: boxSceneTopLeft.y,
            width: boxSceneBottomRight.x - boxSceneTopLeft.x,
            height: boxSceneBottomRight.y - boxSceneTopLeft.y,
            angle: 0,
            zoom: this.state.zoom.value,
            versionNonce: frameElement.versionNonce
          };
          this.frameNameBoundsCache._cache.set(frameElement.id, bounds);
          return bounds;
        }
        return null;
      }
      return bounds;
    },
    /**
     * @private
     */
    _cache: /* @__PURE__ */ new Map()
  };
  renderFrameNames = () => {
    if (!this.state.frameRendering.enabled || !this.state.frameRendering.name) {
      return null;
    }
    const isDarkTheme = this.state.theme === THEME.DARK;
    return this.scene.getNonDeletedFramesLikes().map((f) => {
      if (!isElementInViewport(
        f,
        this.canvas.width / window.devicePixelRatio,
        this.canvas.height / window.devicePixelRatio,
        {
          offsetLeft: this.state.offsetLeft,
          offsetTop: this.state.offsetTop,
          scrollX: this.state.scrollX,
          scrollY: this.state.scrollY,
          zoom: this.state.zoom
        },
        this.scene.getNonDeletedElementsMap()
      )) {
        return null;
      }
      const { x: x1, y: y1 } = sceneCoordsToViewportCoords(
        { sceneX: f.x, sceneY: f.y },
        this.state
      );
      const FRAME_NAME_EDIT_PADDING = 6;
      const reset = () => {
        mutateElement(f, { name: f.name?.trim() || null });
        this.setState({ editingFrame: null });
      };
      let frameNameJSX;
      const frameName = getFrameLikeTitle(f);
      if (f.id === this.state.editingFrame) {
        const frameNameInEdit = frameName;
        frameNameJSX = /* @__PURE__ */ jsx145(
          "input",
          {
            autoFocus: true,
            value: frameNameInEdit,
            onChange: (e) => {
              mutateElement(f, {
                name: e.target.value
              });
            },
            onFocus: (e) => e.target.select(),
            onBlur: () => reset(),
            onKeyDown: (event) => {
              if (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) {
                reset();
              }
            },
            style: {
              background: this.state.viewBackgroundColor,
              filter: isDarkTheme ? THEME_FILTER : "none",
              zIndex: 2,
              border: "none",
              display: "block",
              padding: `${FRAME_NAME_EDIT_PADDING}px`,
              borderRadius: 4,
              boxShadow: "inset 0 0 0 1px var(--color-primary)",
              fontFamily: "Assistant",
              fontSize: "14px",
              transform: `translate(-${FRAME_NAME_EDIT_PADDING}px, ${FRAME_NAME_EDIT_PADDING}px)`,
              color: "var(--color-gray-80)",
              overflow: "hidden",
              maxWidth: `${document.body.clientWidth - x1 - FRAME_NAME_EDIT_PADDING}px`
            },
            size: frameNameInEdit.length + 1 || 1,
            dir: "auto",
            autoComplete: "off",
            autoCapitalize: "off",
            autoCorrect: "off"
          }
        );
      } else {
        frameNameJSX = frameName;
      }
      return /* @__PURE__ */ jsx145(
        "div",
        {
          id: this.getFrameNameDOMId(f),
          style: {
            position: "absolute",
            // Positioning from bottom so that we don't to either
            // calculate text height or adjust using transform (which)
            // messes up input position when editing the frame name.
            // This makes the positioning deterministic and we can calculate
            // the same position when rendering to canvas / svg.
            bottom: `${this.state.height + FRAME_STYLE.nameOffsetY - y1 + this.state.offsetTop}px`,
            left: `${x1 - this.state.offsetLeft}px`,
            zIndex: 2,
            fontSize: FRAME_STYLE.nameFontSize,
            color: isDarkTheme ? FRAME_STYLE.nameColorDarkTheme : FRAME_STYLE.nameColorLightTheme,
            lineHeight: FRAME_STYLE.nameLineHeight,
            width: "max-content",
            maxWidth: `${f.width}px`,
            overflow: f.id === this.state.editingFrame ? "visible" : "hidden",
            whiteSpace: "nowrap",
            textOverflow: "ellipsis",
            cursor: CURSOR_TYPE.MOVE,
            pointerEvents: this.state.viewModeEnabled ? POINTER_EVENTS.disabled : POINTER_EVENTS.enabled
          },
          onPointerDown: (event) => this.handleCanvasPointerDown(event),
          onWheel: (event) => this.handleWheel(event),
          onContextMenu: this.handleCanvasContextMenu,
          onDoubleClick: () => {
            this.setState({
              editingFrame: f.id
            });
          },
          children: frameNameJSX
        },
        f.id
      );
    });
  };
  toggleOverscrollBehavior(event) {
    document.documentElement.style.overscrollBehaviorX = event.type === "pointerenter" ? "none" : "auto";
  }
  render() {
    const selectedElements = this.scene.getSelectedElements(this.state);
    const { renderTopRightUI, renderCustomStats } = this.props;
    const sceneNonce = this.scene.getSceneNonce();
    const { elementsMap, visibleElements } = this.renderer.getRenderableElements({
      sceneNonce,
      zoom: this.state.zoom,
      offsetLeft: this.state.offsetLeft,
      offsetTop: this.state.offsetTop,
      scrollX: this.state.scrollX,
      scrollY: this.state.scrollY,
      height: this.state.height,
      width: this.state.width,
      editingTextElement: this.state.editingTextElement,
      newElementId: this.state.newElement?.id,
      pendingImageElementId: this.state.pendingImageElementId
    });
    this.visibleElements = visibleElements;
    const allElementsMap = this.scene.getNonDeletedElementsMap();
    const shouldBlockPointerEvents = this.state.selectionElement || this.state.newElement || this.state.selectedElementsAreBeingDragged || this.state.resizingElement || this.state.activeTool.type === "laser" && // technically we can just test on this once we make it more safe
    this.state.cursorButton === "down";
    const firstSelectedElement = selectedElements[0];
    return /* @__PURE__ */ jsx145(
      "div",
      {
        className: clsx56("excalidraw excalidraw-container", {
          "excalidraw--view-mode": this.state.viewModeEnabled,
          "excalidraw--mobile": this.device.editor.isMobile
        }),
        style: {
          ["--ui-pointerEvents"]: shouldBlockPointerEvents ? POINTER_EVENTS.disabled : POINTER_EVENTS.enabled
        },
        ref: this.excalidrawContainerRef,
        onDrop: this.handleAppOnDrop,
        tabIndex: 0,
        onKeyDown: this.props.handleKeyboardGlobally ? void 0 : this.onKeyDown,
        onPointerEnter: this.toggleOverscrollBehavior,
        onPointerLeave: this.toggleOverscrollBehavior,
        children: /* @__PURE__ */ jsx145(AppContext.Provider, { value: this, children: /* @__PURE__ */ jsx145(AppPropsContext.Provider, { value: this.props, children: /* @__PURE__ */ jsx145(
          ExcalidrawContainerContext.Provider,
          {
            value: this.excalidrawContainerValue,
            children: /* @__PURE__ */ jsx145(DeviceContext.Provider, { value: this.device, children: /* @__PURE__ */ jsx145(ExcalidrawSetAppStateContext.Provider, { value: this.setAppState, children: /* @__PURE__ */ jsx145(ExcalidrawAppStateContext.Provider, { value: this.state, children: /* @__PURE__ */ jsxs77(
              ExcalidrawElementsContext.Provider,
              {
                value: this.scene.getNonDeletedElements(),
                children: [
                  /* @__PURE__ */ jsxs77(
                    ExcalidrawActionManagerContext.Provider,
                    {
                      value: this.actionManager,
                      children: [
                        /* @__PURE__ */ jsx145(
                          LayerUI_default,
                          {
                            canvas: this.canvas,
                            appState: this.state,
                            files: this.files,
                            setAppState: this.setAppState,
                            actionManager: this.actionManager,
                            elements: this.scene.getNonDeletedElements(),
                            onLockToggle: this.toggleLock,
                            onPenModeToggle: this.togglePenMode,
                            onHandToolToggle: this.onHandToolToggle,
                            langCode: getLanguage().code,
                            renderTopRightUI,
                            renderCustomStats,
                            showExitZenModeBtn: typeof this.props?.zenModeEnabled === "undefined" && this.state.zenModeEnabled,
                            UIOptions: this.props.UIOptions,
                            onExportImage: this.onExportImage,
                            renderWelcomeScreen: !this.state.isLoading && this.state.showWelcomeScreen && this.state.activeTool.type === "selection" && !this.state.zenModeEnabled && !this.scene.getElementsIncludingDeleted().length,
                            app: this,
                            isCollaborating: this.props.isCollaborating,
                            children: this.props.children
                          }
                        ),
                        /* @__PURE__ */ jsx145("div", { className: "excalidraw-textEditorContainer" }),
                        /* @__PURE__ */ jsx145("div", { className: "excalidraw-contextMenuContainer" }),
                        /* @__PURE__ */ jsx145("div", { className: "excalidraw-eye-dropper-container" }),
                        /* @__PURE__ */ jsx145(
                          SVGLayer,
                          {
                            trails: [this.laserTrails, this.eraserTrail]
                          }
                        ),
                        selectedElements.length === 1 && this.state.showHyperlinkPopup && /* @__PURE__ */ jsx145(
                          Hyperlink,
                          {
                            element: firstSelectedElement,
                            elementsMap: allElementsMap,
                            setAppState: this.setAppState,
                            onLinkOpen: this.props.onLinkOpen,
                            setToast: this.setToast,
                            updateEmbedValidationStatus: this.updateEmbedValidationStatus
                          },
                          firstSelectedElement.id
                        ),
                        this.props.aiEnabled !== false && selectedElements.length === 1 && isMagicFrameElement(firstSelectedElement) && /* @__PURE__ */ jsx145(
                          ElementCanvasButtons,
                          {
                            element: firstSelectedElement,
                            elementsMap,
                            children: /* @__PURE__ */ jsx145(
                              ElementCanvasButton,
                              {
                                title: t("labels.convertToCode"),
                                icon: MagicIcon,
                                checked: false,
                                onChange: () => this.onMagicFrameGenerate(
                                  firstSelectedElement,
                                  "button"
                                )
                              }
                            )
                          }
                        ),
                        selectedElements.length === 1 && isIframeElement(firstSelectedElement) && firstSelectedElement.customData?.generationData?.status === "done" && /* @__PURE__ */ jsxs77(
                          ElementCanvasButtons,
                          {
                            element: firstSelectedElement,
                            elementsMap,
                            children: [
                              /* @__PURE__ */ jsx145(
                                ElementCanvasButton,
                                {
                                  title: t("labels.copySource"),
                                  icon: copyIcon,
                                  checked: false,
                                  onChange: () => this.onIframeSrcCopy(firstSelectedElement)
                                }
                              ),
                              /* @__PURE__ */ jsx145(
                                ElementCanvasButton,
                                {
                                  title: "Enter fullscreen",
                                  icon: fullscreenIcon,
                                  checked: false,
                                  onChange: () => {
                                    const iframe = this.getHTMLIFrameElement(
                                      firstSelectedElement
                                    );
                                    if (iframe) {
                                      try {
                                        iframe.requestFullscreen();
                                        this.setState({
                                          activeEmbeddable: {
                                            element: firstSelectedElement,
                                            state: "active"
                                          },
                                          selectedElementIds: {
                                            [firstSelectedElement.id]: true
                                          },
                                          newElement: null,
                                          selectionElement: null
                                        });
                                      } catch (err) {
                                        console.warn(err);
                                        this.setState({
                                          errorMessage: "Couldn't enter fullscreen"
                                        });
                                      }
                                    }
                                  }
                                }
                              )
                            ]
                          }
                        ),
                        this.state.toast !== null && /* @__PURE__ */ jsx145(
                          Toast,
                          {
                            message: this.state.toast.message,
                            onClose: () => this.setToast(null),
                            duration: this.state.toast.duration,
                            closable: this.state.toast.closable
                          }
                        ),
                        this.state.contextMenu && /* @__PURE__ */ jsx145(
                          ContextMenu,
                          {
                            items: this.state.contextMenu.items,
                            top: this.state.contextMenu.top,
                            left: this.state.contextMenu.left,
                            actionManager: this.actionManager,
                            onClose: (callback) => {
                              this.setState({ contextMenu: null }, () => {
                                this.focusContainer();
                                callback?.();
                              });
                            }
                          }
                        ),
                        /* @__PURE__ */ jsx145(
                          StaticCanvas_default,
                          {
                            canvas: this.canvas,
                            rc: this.rc,
                            elementsMap,
                            allElementsMap,
                            visibleElements,
                            sceneNonce,
                            selectionNonce: this.state.selectionElement?.versionNonce,
                            scale: window.devicePixelRatio,
                            appState: this.state,
                            renderConfig: {
                              imageCache: this.imageCache,
                              isExporting: false,
                              renderGrid: isGridModeEnabled(this),
                              canvasBackgroundColor: this.state.viewBackgroundColor,
                              embedsValidationStatus: this.embedsValidationStatus,
                              elementsPendingErasure: this.elementsPendingErasure,
                              pendingFlowchartNodes: this.flowChartCreator.pendingNodes
                            }
                          }
                        ),
                        this.state.newElement && /* @__PURE__ */ jsx145(
                          NewElementCanvas_default,
                          {
                            appState: this.state,
                            scale: window.devicePixelRatio,
                            rc: this.rc,
                            elementsMap,
                            allElementsMap,
                            renderConfig: {
                              imageCache: this.imageCache,
                              isExporting: false,
                              renderGrid: false,
                              canvasBackgroundColor: this.state.viewBackgroundColor,
                              embedsValidationStatus: this.embedsValidationStatus,
                              elementsPendingErasure: this.elementsPendingErasure,
                              pendingFlowchartNodes: null
                            }
                          }
                        ),
                        /* @__PURE__ */ jsx145(
                          InteractiveCanvas_default,
                          {
                            containerRef: this.excalidrawContainerRef,
                            canvas: this.interactiveCanvas,
                            elementsMap,
                            visibleElements,
                            allElementsMap,
                            selectedElements,
                            sceneNonce,
                            selectionNonce: this.state.selectionElement?.versionNonce,
                            scale: window.devicePixelRatio,
                            appState: this.state,
                            device: this.device,
                            renderInteractiveSceneCallback: this.renderInteractiveSceneCallback,
                            handleCanvasRef: this.handleInteractiveCanvasRef,
                            onContextMenu: this.handleCanvasContextMenu,
                            onPointerMove: this.handleCanvasPointerMove,
                            onPointerUp: this.handleCanvasPointerUp,
                            onPointerCancel: this.removePointer,
                            onTouchMove: this.handleTouchMove,
                            onPointerDown: this.handleCanvasPointerDown,
                            onDoubleClick: this.handleCanvasDoubleClick
                          }
                        ),
                        this.state.userToFollow && /* @__PURE__ */ jsx145(
                          FollowMode_default,
                          {
                            width: this.state.width,
                            height: this.state.height,
                            userToFollow: this.state.userToFollow,
                            onDisconnect: this.maybeUnfollowRemoteUser
                          }
                        ),
                        this.renderFrameNames()
                      ]
                    }
                  ),
                  this.renderEmbeddables()
                ]
              }
            ) }) }) })
          }
        ) }) })
      }
    );
  }
  focusContainer = () => {
    this.excalidrawContainerRef.current?.focus();
  };
  getSceneElementsIncludingDeleted = () => {
    return this.scene.getElementsIncludingDeleted();
  };
  getSceneElements = () => {
    return this.scene.getNonDeletedElements();
  };
  onInsertElements = (elements) => {
    this.addElementsFromPasteOrLibrary({
      elements,
      position: "center",
      files: null
    });
  };
  onExportImage = async (type, elements, opts) => {
    trackEvent("export", type, "ui");
    const fileHandle = await exportCanvas(
      type,
      elements,
      this.state,
      this.files,
      {
        exportBackground: this.state.exportBackground,
        name: this.getName(),
        viewBackgroundColor: this.state.viewBackgroundColor,
        exportingFrame: opts.exportingFrame
      }
    ).catch(muteFSAbortError).catch((error) => {
      console.error(error);
      this.setState({ errorMessage: error.message });
    });
    if (this.state.exportEmbedScene && fileHandle && isImageFileHandle(fileHandle)) {
      this.setState({ fileHandle });
    }
  };
  magicGenerations = /* @__PURE__ */ new Map();
  updateMagicGeneration = ({
    frameElement,
    data
  }) => {
    if (data.status === "pending") {
      mutateElement(
        frameElement,
        { customData: { generationData: void 0 } },
        false
      );
    } else {
      mutateElement(
        frameElement,
        { customData: { generationData: data } },
        false
      );
    }
    this.magicGenerations.set(frameElement.id, data);
    this.triggerRender();
  };
  plugins = {};
  setPlugins(plugins) {
    Object.assign(this.plugins, plugins);
  }
  async onMagicFrameGenerate(magicFrame, source) {
    const generateDiagramToCode = this.plugins.diagramToCode?.generate;
    if (!generateDiagramToCode) {
      this.setState({
        errorMessage: "No diagram to code plugin found"
      });
      return;
    }
    const magicFrameChildren = getElementsOverlappingFrame(
      this.scene.getNonDeletedElements(),
      magicFrame
    ).filter((el) => !isMagicFrameElement(el));
    if (!magicFrameChildren.length) {
      if (source === "button") {
        this.setState({ errorMessage: "Cannot generate from an empty frame" });
        trackEvent("ai", "generate (no-children)", "d2c");
      } else {
        this.setActiveTool({ type: "magicframe" });
      }
      return;
    }
    const frameElement = this.insertIframeElement({
      sceneX: magicFrame.x + magicFrame.width + 30,
      sceneY: magicFrame.y,
      width: magicFrame.width,
      height: magicFrame.height
    });
    if (!frameElement) {
      return;
    }
    this.updateMagicGeneration({
      frameElement,
      data: { status: "pending" }
    });
    this.setState({
      selectedElementIds: { [frameElement.id]: true }
    });
    trackEvent("ai", "generate (start)", "d2c");
    try {
      const { html } = await generateDiagramToCode({
        frame: magicFrame,
        children: magicFrameChildren
      });
      trackEvent("ai", "generate (success)", "d2c");
      if (!html.trim()) {
        this.updateMagicGeneration({
          frameElement,
          data: {
            status: "error",
            code: "ERR_OAI",
            message: "Nothing genereated :("
          }
        });
        return;
      }
      const parsedHtml = html.includes("<!DOCTYPE html>") && html.includes("</html>") ? html.slice(
        html.indexOf("<!DOCTYPE html>"),
        html.indexOf("</html>") + "</html>".length
      ) : html;
      this.updateMagicGeneration({
        frameElement,
        data: { status: "done", html: parsedHtml }
      });
    } catch (error) {
      trackEvent("ai", "generate (failed)", "d2c");
      this.updateMagicGeneration({
        frameElement,
        data: {
          status: "error",
          code: "ERR_OAI",
          message: error.message || "Unknown error during generation"
        }
      });
    }
  }
  onIframeSrcCopy(element) {
    if (element.customData?.generationData?.status === "done") {
      copyTextToSystemClipboard(element.customData.generationData.html);
      this.setToast({
        message: "copied to clipboard",
        closable: false,
        duration: 1500
      });
    }
  }
  onMagicframeToolSelect = () => {
    const selectedElements = this.scene.getSelectedElements({
      selectedElementIds: this.state.selectedElementIds
    });
    if (selectedElements.length === 0) {
      this.setActiveTool({ type: TOOL_TYPE.magicframe });
      trackEvent("ai", "tool-select (empty-selection)", "d2c");
    } else {
      const selectedMagicFrame = selectedElements.length === 1 && isMagicFrameElement(selectedElements[0]) && selectedElements[0];
      if (!selectedMagicFrame && selectedElements.some((el) => isFrameLikeElement(el) || el.frameId)) {
        this.setActiveTool({ type: TOOL_TYPE.magicframe });
        return;
      }
      trackEvent("ai", "tool-select (existing selection)", "d2c");
      let frame;
      if (selectedMagicFrame) {
        frame = selectedMagicFrame;
      } else {
        const [minX, minY, maxX, maxY] = getCommonBounds(selectedElements);
        const padding = 50;
        frame = newMagicFrameElement({
          ...FRAME_STYLE,
          x: minX - padding,
          y: minY - padding,
          width: maxX - minX + padding * 2,
          height: maxY - minY + padding * 2,
          opacity: 100,
          locked: false
        });
        this.scene.insertElement(frame);
        for (const child of selectedElements) {
          mutateElement(child, { frameId: frame.id });
        }
        this.setState({
          selectedElementIds: { [frame.id]: true }
        });
      }
      this.onMagicFrameGenerate(frame, "upstream");
    }
  };
  openEyeDropper = ({ type }) => {
    jotaiStore.set(activeEyeDropperAtom, {
      swapPreviewOnAlt: true,
      colorPickerType: type === "stroke" ? "elementStroke" : "elementBackground",
      onSelect: (color, event) => {
        const shouldUpdateStrokeColor = type === "background" && event.altKey || type === "stroke" && !event.altKey;
        const selectedElements = this.scene.getSelectedElements(this.state);
        if (!selectedElements.length || this.state.activeTool.type !== "selection") {
          if (shouldUpdateStrokeColor) {
            this.syncActionResult({
              appState: { ...this.state, currentItemStrokeColor: color },
              storeAction: StoreAction.CAPTURE
            });
          } else {
            this.syncActionResult({
              appState: { ...this.state, currentItemBackgroundColor: color },
              storeAction: StoreAction.CAPTURE
            });
          }
        } else {
          this.updateScene({
            elements: this.scene.getElementsIncludingDeleted().map((el) => {
              if (this.state.selectedElementIds[el.id]) {
                return newElementWith(el, {
                  [shouldUpdateStrokeColor ? "strokeColor" : "backgroundColor"]: color
                });
              }
              return el;
            }),
            storeAction: StoreAction.CAPTURE
          });
        }
      },
      keepOpenOnAlt: false
    });
  };
  dismissLinearEditor = () => {
    setTimeout(() => {
      this.setState({
        editingLinearElement: null
      });
    });
  };
  syncActionResult = withBatchedUpdates((actionResult) => {
    if (this.unmounted || actionResult === false) {
      return;
    }
    if (actionResult.storeAction === StoreAction.UPDATE) {
      this.store.shouldUpdateSnapshot();
    } else if (actionResult.storeAction === StoreAction.CAPTURE) {
      this.store.shouldCaptureIncrement();
    }
    let didUpdate = false;
    let editingTextElement = null;
    if (actionResult.elements) {
      this.scene.replaceAllElements(actionResult.elements);
      didUpdate = true;
    }
    if (actionResult.files) {
      this.files = actionResult.replaceFiles ? actionResult.files : { ...this.files, ...actionResult.files };
      this.addNewImagesToImageCache();
    }
    if (actionResult.appState || editingTextElement || this.state.contextMenu) {
      let viewModeEnabled = actionResult?.appState?.viewModeEnabled || false;
      let zenModeEnabled = actionResult?.appState?.zenModeEnabled || false;
      const theme = actionResult?.appState?.theme || this.props.theme || THEME.LIGHT;
      const name = actionResult?.appState?.name ?? this.state.name;
      const errorMessage = actionResult?.appState?.errorMessage ?? this.state.errorMessage;
      if (typeof this.props.viewModeEnabled !== "undefined") {
        viewModeEnabled = this.props.viewModeEnabled;
      }
      if (typeof this.props.zenModeEnabled !== "undefined") {
        zenModeEnabled = this.props.zenModeEnabled;
      }
      editingTextElement = actionResult.appState?.editingTextElement || null;
      if (actionResult.elements && editingTextElement) {
        actionResult.elements.forEach((element) => {
          if (editingTextElement?.id === element.id && editingTextElement !== element && isNonDeletedElement(element) && isTextElement(element)) {
            editingTextElement = element;
          }
        });
      }
      if (editingTextElement?.isDeleted) {
        editingTextElement = null;
      }
      this.setState((state) => {
        return Object.assign(actionResult.appState || {}, {
          // NOTE this will prevent opening context menu using an action
          // or programmatically from the host, so it will need to be
          // rewritten later
          contextMenu: null,
          editingTextElement,
          viewModeEnabled,
          zenModeEnabled,
          theme,
          name,
          errorMessage
        });
      });
      didUpdate = true;
    }
    if (!didUpdate && actionResult.storeAction !== StoreAction.NONE) {
      this.scene.triggerUpdate();
    }
  });
  // Lifecycle
  onBlur = withBatchedUpdates(() => {
    isHoldingSpace = false;
    this.setState({ isBindingEnabled: true });
  });
  onUnload = () => {
    this.onBlur();
  };
  disableEvent = (event) => {
    event.preventDefault();
  };
  resetHistory = () => {
    this.history.clear();
  };
  resetStore = () => {
    this.store.clear();
  };
  /**
   * Resets scene & history.
   * ! Do not use to clear scene user action !
   */
  resetScene = withBatchedUpdates(
    (opts) => {
      this.scene.replaceAllElements([]);
      this.setState((state) => ({
        ...getDefaultAppState(),
        isLoading: opts?.resetLoadingState ? false : state.isLoading,
        theme: this.state.theme
      }));
      this.resetStore();
      this.resetHistory();
    }
  );
  initializeScene = async () => {
    if ("launchQueue" in window && "LaunchParams" in window) {
      window.launchQueue.setConsumer(
        async (launchParams) => {
          if (!launchParams.files.length) {
            return;
          }
          const fileHandle = launchParams.files[0];
          const blob = await fileHandle.getFile();
          this.loadFileToCanvas(
            new File([blob], blob.name || "", { type: blob.type }),
            fileHandle
          );
        }
      );
    }
    if (this.props.theme) {
      this.setState({ theme: this.props.theme });
    }
    if (!this.state.isLoading) {
      this.setState({ isLoading: true });
    }
    let initialData = null;
    try {
      if (typeof this.props.initialData === "function") {
        initialData = await this.props.initialData() || null;
      } else {
        initialData = await this.props.initialData || null;
      }
      if (initialData?.libraryItems) {
        this.library.updateLibrary({
          libraryItems: initialData.libraryItems,
          merge: true
        }).catch((error) => {
          console.error(error);
        });
      }
    } catch (error) {
      console.error(error);
      initialData = {
        appState: {
          errorMessage: error.message || "Encountered an error during importing or restoring scene data"
        }
      };
    }
    const scene = restore(initialData, null, null, { repairBindings: true });
    scene.appState = {
      ...scene.appState,
      theme: this.props.theme || scene.appState.theme,
      // we're falling back to current (pre-init) state when deciding
      // whether to open the library, to handle a case where we
      // update the state outside of initialData (e.g. when loading the app
      // with a library install link, which should auto-open the library)
      openSidebar: scene.appState?.openSidebar || this.state.openSidebar,
      activeTool: scene.appState.activeTool.type === "image" ? { ...scene.appState.activeTool, type: "selection" } : scene.appState.activeTool,
      isLoading: false,
      toast: this.state.toast
    };
    if (initialData?.scrollToContent) {
      scene.appState = {
        ...scene.appState,
        ...calculateScrollCenter(scene.elements, {
          ...scene.appState,
          width: this.state.width,
          height: this.state.height,
          offsetTop: this.state.offsetTop,
          offsetLeft: this.state.offsetLeft
        })
      };
    }
    this.resetStore();
    this.resetHistory();
    this.syncActionResult({
      ...scene,
      storeAction: StoreAction.UPDATE
    });
    this.clearImageShapeCache();
    this.fonts.loadSceneFonts();
  };
  isMobileBreakpoint = (width, height) => {
    return width < MQ_MAX_WIDTH_PORTRAIT || height < MQ_MAX_HEIGHT_LANDSCAPE && width < MQ_MAX_WIDTH_LANDSCAPE;
  };
  refreshViewportBreakpoints = () => {
    const container = this.excalidrawContainerRef.current;
    if (!container) {
      return;
    }
    const { clientWidth: viewportWidth, clientHeight: viewportHeight } = document.body;
    const prevViewportState = this.device.viewport;
    const nextViewportState = updateObject(prevViewportState, {
      isLandscape: viewportWidth > viewportHeight,
      isMobile: this.isMobileBreakpoint(viewportWidth, viewportHeight)
    });
    if (prevViewportState !== nextViewportState) {
      this.device = { ...this.device, viewport: nextViewportState };
      return true;
    }
    return false;
  };
  refreshEditorBreakpoints = () => {
    const container = this.excalidrawContainerRef.current;
    if (!container) {
      return;
    }
    const { width: editorWidth, height: editorHeight } = container.getBoundingClientRect();
    const sidebarBreakpoint = this.props.UIOptions.dockedSidebarBreakpoint != null ? this.props.UIOptions.dockedSidebarBreakpoint : MQ_RIGHT_SIDEBAR_MIN_WIDTH;
    const prevEditorState = this.device.editor;
    const nextEditorState = updateObject(prevEditorState, {
      isMobile: this.isMobileBreakpoint(editorWidth, editorHeight),
      canFitSidebar: editorWidth > sidebarBreakpoint
    });
    if (prevEditorState !== nextEditorState) {
      this.device = { ...this.device, editor: nextEditorState };
      return true;
    }
    return false;
  };
  clearImageShapeCache(filesMap) {
    const files = filesMap ?? this.files;
    this.scene.getNonDeletedElements().forEach((element) => {
      if (isInitializedImageElement(element) && files[element.fileId]) {
        this.imageCache.delete(element.fileId);
        ShapeCache.delete(element);
      }
    });
  }
  async componentDidMount() {
    this.unmounted = false;
    this.excalidrawContainerValue.container = this.excalidrawContainerRef.current;
    if (define_import_meta_env_default.MODE === ENV.TEST || define_import_meta_env_default.DEV) {
      const setState = this.setState.bind(this);
      Object.defineProperties(window.h, {
        state: {
          configurable: true,
          get: () => {
            return this.state;
          }
        },
        setState: {
          configurable: true,
          value: (...args) => {
            return this.setState(...args);
          }
        },
        app: {
          configurable: true,
          value: this
        },
        history: {
          configurable: true,
          value: this.history
        },
        store: {
          configurable: true,
          value: this.store
        },
        fonts: {
          configurable: true,
          value: this.fonts
        }
      });
    }
    this.store.onStoreIncrementEmitter.on((increment) => {
      this.history.record(increment.elementsChange, increment.appStateChange);
    });
    this.scene.onUpdate(this.triggerRender);
    this.addEventListeners();
    if (this.props.autoFocus && this.excalidrawContainerRef.current) {
      this.focusContainer();
    }
    if (
      // bounding rects don't work in tests so updating
      // the state on init would result in making the test enviro run
      // in mobile breakpoint (0 width/height), making everything fail
      !isTestEnv()
    ) {
      this.refreshViewportBreakpoints();
      this.refreshEditorBreakpoints();
    }
    if (supportsResizeObserver && this.excalidrawContainerRef.current) {
      this.resizeObserver = new ResizeObserver(() => {
        this.refreshEditorBreakpoints();
        this.updateDOMRect();
      });
      this.resizeObserver?.observe(this.excalidrawContainerRef.current);
    }
    const searchParams = new URLSearchParams(window.location.search.slice(1));
    if (searchParams.has("web-share-target")) {
      this.restoreFileFromShare();
    } else {
      this.updateDOMRect(this.initializeScene);
    }
    if (isBrave() && !isMeasureTextSupported()) {
      this.setState({
        errorMessage: /* @__PURE__ */ jsx145(BraveMeasureTextError_default, {})
      });
    }
  }
  componentWillUnmount() {
    window.launchQueue?.setConsumer(() => {
    });
    this.renderer.destroy();
    this.scene.destroy();
    this.scene = new Scene_default();
    this.fonts = new Fonts({ scene: this.scene });
    this.renderer = new Renderer(this.scene);
    this.files = {};
    this.imageCache.clear();
    this.resizeObserver?.disconnect();
    this.unmounted = true;
    this.removeEventListeners();
    this.library.destroy();
    this.laserTrails.stop();
    this.eraserTrail.stop();
    this.onChangeEmitter.clear();
    this.store.onStoreIncrementEmitter.clear();
    ShapeCache.destroy();
    SnapCache.destroy();
    clearTimeout(touchTimeout);
    isSomeElementSelected.clearCache();
    selectGroupsForSelectedElements.clearCache();
    touchTimeout = 0;
    document.documentElement.style.overscrollBehaviorX = "";
  }
  onResize = withBatchedUpdates(() => {
    this.scene.getElementsIncludingDeleted().forEach((element) => ShapeCache.delete(element));
    this.refreshViewportBreakpoints();
    this.updateDOMRect();
    if (!supportsResizeObserver) {
      this.refreshEditorBreakpoints();
    }
    this.setState({});
  });
  /** generally invoked only if fullscreen was invoked programmatically */
  onFullscreenChange = () => {
    if (
      // points to the iframe element we fullscreened
      !document.fullscreenElement && this.state.activeEmbeddable?.state === "active"
    ) {
      this.setState({
        activeEmbeddable: null
      });
    }
  };
  removeEventListeners() {
    this.onRemoveEventListenersEmitter.trigger();
  }
  addEventListeners() {
    this.removeEventListeners();
    if (this.props.handleKeyboardGlobally) {
      this.onRemoveEventListenersEmitter.once(
        addEventListener(document, "keydown" /* KEYDOWN */, this.onKeyDown, false)
      );
    }
    this.onRemoveEventListenersEmitter.once(
      addEventListener(
        this.excalidrawContainerRef.current,
        "wheel" /* WHEEL */,
        this.handleWheel,
        { passive: false }
      ),
      addEventListener(window, "message" /* MESSAGE */, this.onWindowMessage, false),
      addEventListener(document, "pointerup" /* POINTER_UP */, this.removePointer),
      // #3553
      addEventListener(document, "copy" /* COPY */, this.onCopy),
      addEventListener(document, "keyup" /* KEYUP */, this.onKeyUp, { passive: true }),
      addEventListener(
        document,
        "pointermove" /* POINTER_MOVE */,
        this.updateCurrentCursorPosition
      ),
      // rerender text elements on font load to fix #637 && #1553
      addEventListener(document.fonts, "loadingdone", (event) => {
        const loadedFontFaces = event.fontfaces;
        this.fonts.onLoaded(loadedFontFaces);
      }),
      // Safari-only desktop pinch zoom
      addEventListener(
        document,
        "gesturestart" /* GESTURE_START */,
        this.onGestureStart,
        false
      ),
      addEventListener(
        document,
        "gesturechange" /* GESTURE_CHANGE */,
        this.onGestureChange,
        false
      ),
      addEventListener(
        document,
        "gestureend" /* GESTURE_END */,
        this.onGestureEnd,
        false
      ),
      addEventListener(window, "focus" /* FOCUS */, () => {
        this.maybeCleanupAfterMissingPointerUp(null);
        this.triggerRender(true);
      })
    );
    if (this.state.viewModeEnabled) {
      return;
    }
    this.onRemoveEventListenersEmitter.once(
      addEventListener(
        document,
        "fullscreenchange" /* FULLSCREENCHANGE */,
        this.onFullscreenChange
      ),
      addEventListener(document, "paste" /* PASTE */, this.pasteFromClipboard),
      addEventListener(document, "cut" /* CUT */, this.onCut),
      addEventListener(window, "resize" /* RESIZE */, this.onResize, false),
      addEventListener(window, "unload" /* UNLOAD */, this.onUnload, false),
      addEventListener(window, "blur" /* BLUR */, this.onBlur, false),
      addEventListener(
        this.excalidrawContainerRef.current,
        "wheel" /* WHEEL */,
        this.handleWheel
      ),
      addEventListener(
        this.excalidrawContainerRef.current,
        "dragover" /* DRAG_OVER */,
        this.disableEvent,
        false
      ),
      addEventListener(
        this.excalidrawContainerRef.current,
        "drop" /* DROP */,
        this.disableEvent,
        false
      )
    );
    if (this.props.detectScroll) {
      this.onRemoveEventListenersEmitter.once(
        addEventListener(
          getNearestScrollableContainer(this.excalidrawContainerRef.current),
          "scroll" /* SCROLL */,
          this.onScroll
        )
      );
    }
  }
  componentDidUpdate(prevProps, prevState) {
    this.updateEmbeddables();
    const elements = this.scene.getElementsIncludingDeleted();
    const elementsMap = this.scene.getElementsMapIncludingDeleted();
    const nonDeletedElementsMap = this.scene.getNonDeletedElementsMap();
    if (!this.state.showWelcomeScreen && !elements.length) {
      this.setState({ showWelcomeScreen: true });
    }
    if (prevProps.UIOptions.dockedSidebarBreakpoint !== this.props.UIOptions.dockedSidebarBreakpoint) {
      this.refreshEditorBreakpoints();
    }
    const hasFollowedPersonLeft = prevState.userToFollow && !this.state.collaborators.has(prevState.userToFollow.socketId);
    if (hasFollowedPersonLeft) {
      this.maybeUnfollowRemoteUser();
    }
    if (prevState.zoom.value !== this.state.zoom.value || prevState.scrollX !== this.state.scrollX || prevState.scrollY !== this.state.scrollY) {
      this.props?.onScrollChange?.(
        this.state.scrollX,
        this.state.scrollY,
        this.state.zoom
      );
      this.onScrollChangeEmitter.trigger(
        this.state.scrollX,
        this.state.scrollY,
        this.state.zoom
      );
    }
    if (prevState.userToFollow !== this.state.userToFollow) {
      if (prevState.userToFollow) {
        this.onUserFollowEmitter.trigger({
          userToFollow: prevState.userToFollow,
          action: "UNFOLLOW"
        });
      }
      if (this.state.userToFollow) {
        this.onUserFollowEmitter.trigger({
          userToFollow: this.state.userToFollow,
          action: "FOLLOW"
        });
      }
    }
    if (Object.keys(this.state.selectedElementIds).length && isEraserActive(this.state)) {
      this.setState({
        activeTool: updateActiveTool(this.state, { type: "selection" })
      });
    }
    if (this.state.activeTool.type === "eraser" && prevState.theme !== this.state.theme) {
      setEraserCursor(this.interactiveCanvas, this.state.theme);
    }
    if (prevState.activeTool.type === "selection" && this.state.activeTool.type !== "selection" && this.state.showHyperlinkPopup) {
      this.setState({ showHyperlinkPopup: false });
    }
    if (prevProps.langCode !== this.props.langCode) {
      this.updateLanguage();
    }
    if (isEraserActive(prevState) && !isEraserActive(this.state)) {
      this.eraserTrail.endPath();
    }
    if (prevProps.viewModeEnabled !== this.props.viewModeEnabled) {
      this.setState({ viewModeEnabled: !!this.props.viewModeEnabled });
    }
    if (prevState.viewModeEnabled !== this.state.viewModeEnabled) {
      this.addEventListeners();
      this.deselectElements();
    }
    if (prevProps.zenModeEnabled !== this.props.zenModeEnabled) {
      this.setState({ zenModeEnabled: !!this.props.zenModeEnabled });
    }
    if (prevProps.theme !== this.props.theme && this.props.theme) {
      this.setState({ theme: this.props.theme });
    }
    this.excalidrawContainerRef.current?.classList.toggle(
      "theme--dark",
      this.state.theme === THEME.DARK
    );
    if (this.state.editingLinearElement && !this.state.selectedElementIds[this.state.editingLinearElement.elementId]) {
      setTimeout(() => {
        this.state.editingLinearElement && this.actionManager.executeAction(actionFinalize);
      });
    }
    if (this.state.editingTextElement?.isDeleted) {
      this.setState({ editingTextElement: null });
    }
    if (this.state.selectedLinearElement && !this.state.selectedElementIds[this.state.selectedLinearElement.elementId]) {
      this.setState({ selectedLinearElement: null });
    }
    const { multiElement } = prevState;
    if (prevState.activeTool !== this.state.activeTool && multiElement != null && isBindingEnabled(this.state) && isBindingElement(multiElement, false)) {
      maybeBindLinearElement(
        multiElement,
        this.state,
        tupleToCoors(
          LinearElementEditor.getPointAtIndexGlobalCoordinates(
            multiElement,
            -1,
            nonDeletedElementsMap
          )
        ),
        this.scene.getNonDeletedElementsMap(),
        this.scene.getNonDeletedElements()
      );
    }
    this.store.commit(elementsMap, this.state);
    if (!this.state.isLoading) {
      this.props.onChange?.(elements, this.state, this.files);
      this.onChangeEmitter.trigger(elements, this.state, this.files);
    }
  }
  renderInteractiveSceneCallback = ({
    atLeastOneVisibleElement,
    scrollBars,
    elementsMap
  }) => {
    if (scrollBars) {
      currentScrollBars = scrollBars;
    }
    const scrolledOutside = (
      // hide when editing text
      this.state.editingTextElement ? false : !atLeastOneVisibleElement && elementsMap.size > 0
    );
    if (this.state.scrolledOutside !== scrolledOutside) {
      this.setState({ scrolledOutside });
    }
    this.scheduleImageRefresh();
  };
  onScroll = debounce(() => {
    const { offsetTop, offsetLeft } = this.getCanvasOffsets();
    this.setState((state) => {
      if (state.offsetLeft === offsetLeft && state.offsetTop === offsetTop) {
        return null;
      }
      return { offsetTop, offsetLeft };
    });
  }, SCROLL_TIMEOUT);
  // Copy/paste
  onCut = withBatchedUpdates((event) => {
    const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(
      document.activeElement
    );
    if (!isExcalidrawActive || isWritableElement(event.target)) {
      return;
    }
    this.actionManager.executeAction(actionCut, "keyboard", event);
    event.preventDefault();
    event.stopPropagation();
  });
  onCopy = withBatchedUpdates((event) => {
    const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(
      document.activeElement
    );
    if (!isExcalidrawActive || isWritableElement(event.target)) {
      return;
    }
    this.actionManager.executeAction(actionCopy, "keyboard", event);
    event.preventDefault();
    event.stopPropagation();
  });
  static resetTapTwice() {
    didTapTwice = false;
  }
  onTouchStart = (event) => {
    if (isIOS) {
      event.preventDefault();
    }
    if (!didTapTwice) {
      didTapTwice = true;
      clearTimeout(tappedTwiceTimer);
      tappedTwiceTimer = window.setTimeout(
        _App.resetTapTwice,
        TAP_TWICE_TIMEOUT
      );
      return;
    }
    if (didTapTwice && event.touches.length === 1) {
      const touch = event.touches[0];
      this.handleCanvasDoubleClick({
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      didTapTwice = false;
      clearTimeout(tappedTwiceTimer);
    }
    if (event.touches.length === 2) {
      this.setState({
        selectedElementIds: makeNextSelectedElementIds({}, this.state),
        activeEmbeddable: null
      });
    }
  };
  onTouchEnd = (event) => {
    this.resetContextMenuTimer();
    if (event.touches.length > 0) {
      this.setState({
        previousSelectedElementIds: {},
        selectedElementIds: makeNextSelectedElementIds(
          this.state.previousSelectedElementIds,
          this.state
        )
      });
    } else {
      gesture.pointers.clear();
    }
  };
  pasteFromClipboard = withBatchedUpdates(
    async (event) => {
      const isPlainPaste = !!IS_PLAIN_PASTE;
      const target = document.activeElement;
      const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(target);
      if (event && !isExcalidrawActive) {
        return;
      }
      const elementUnderCursor = document.elementFromPoint(
        this.lastViewportPosition.x,
        this.lastViewportPosition.y
      );
      if (event && (!(elementUnderCursor instanceof HTMLCanvasElement) || isWritableElement(target))) {
        return;
      }
      const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(
        {
          clientX: this.lastViewportPosition.x,
          clientY: this.lastViewportPosition.y
        },
        this.state
      );
      let file2 = event?.clipboardData?.files[0];
      const data = await parseClipboard(event, isPlainPaste);
      if (!file2 && !isPlainPaste) {
        if (data.mixedContent) {
          return this.addElementsFromMixedContentPaste(data.mixedContent, {
            isPlainPaste,
            sceneX,
            sceneY
          });
        } else if (data.text) {
          const string = data.text.trim();
          if (string.startsWith("<svg") && string.endsWith("</svg>")) {
            file2 = SVGStringToFile(string);
          }
        }
      }
      if (isSupportedImageFile(file2) && !data.spreadsheet) {
        if (!this.isToolSupported("image")) {
          this.setState({ errorMessage: t("errors.imageToolNotSupported") });
          return;
        }
        const imageElement = this.createImageElement({ sceneX, sceneY });
        this.insertImageElement(imageElement, file2);
        this.initializeImageDimensions(imageElement);
        this.setState({
          selectedElementIds: makeNextSelectedElementIds(
            {
              [imageElement.id]: true
            },
            this.state
          )
        });
        return;
      }
      if (this.props.onPaste) {
        try {
          if (await this.props.onPaste(data, event) === false) {
            return;
          }
        } catch (error) {
          console.error(error);
        }
      }
      if (data.errorMessage) {
        this.setState({ errorMessage: data.errorMessage });
      } else if (data.spreadsheet && !isPlainPaste) {
        this.setState({
          pasteDialog: {
            data: data.spreadsheet,
            shown: true
          }
        });
      } else if (data.elements) {
        const elements = data.programmaticAPI ? convertToExcalidrawElements(
          data.elements
        ) : data.elements;
        this.addElementsFromPasteOrLibrary({
          elements,
          files: data.files || null,
          position: "cursor",
          retainSeed: isPlainPaste
        });
      } else if (data.text) {
        if (data.text && isMaybeMermaidDefinition(data.text)) {
          const api = await import("@excalidraw/mermaid-to-excalidraw");
          try {
            const { elements: skeletonElements, files } = await api.parseMermaidToExcalidraw(data.text);
            const elements = convertToExcalidrawElements(skeletonElements, {
              regenerateIds: true
            });
            this.addElementsFromPasteOrLibrary({
              elements,
              files,
              position: "cursor"
            });
            return;
          } catch (err) {
            console.warn(
              `parsing pasted text as mermaid definition failed: ${err.message}`
            );
          }
        }
        const nonEmptyLines = normalizeEOL(data.text).split(/\n+/).map((s) => s.trim()).filter(Boolean);
        const embbeddableUrls = nonEmptyLines.map((str) => maybeParseEmbedSrc(str)).filter((string) => {
          return embeddableURLValidator(string, this.props.validateEmbeddable) && (/^(http|https):\/\/[^\s/$.?#].[^\s]*$/.test(string) || getEmbedLink(string)?.type === "video");
        });
        if (!IS_PLAIN_PASTE && embbeddableUrls.length > 0 && // if there were non-embeddable text (lines) mixed in with embeddable
        // urls, ignore and paste as text
        embbeddableUrls.length === nonEmptyLines.length) {
          const embeddables = [];
          for (const url of embbeddableUrls) {
            const prevEmbeddable = embeddables[embeddables.length - 1];
            const embeddable = this.insertEmbeddableElement({
              sceneX: prevEmbeddable ? prevEmbeddable.x + prevEmbeddable.width + 20 : sceneX,
              sceneY,
              link: normalizeLink(url)
            });
            if (embeddable) {
              embeddables.push(embeddable);
            }
          }
          if (embeddables.length) {
            this.setState({
              selectedElementIds: Object.fromEntries(
                embeddables.map((embeddable) => [embeddable.id, true])
              )
            });
          }
          return;
        }
        this.addTextFromPaste(data.text, isPlainPaste);
      }
      this.setActiveTool({ type: "selection" });
      event?.preventDefault();
    }
  );
  addElementsFromPasteOrLibrary = (opts) => {
    let elements = opts.elements.map((el, _, elements2) => {
      if (isElbowArrow(el)) {
        const startEndElements = [
          el.startBinding && elements2.find((l) => l.id === el.startBinding?.elementId),
          el.endBinding && elements2.find((l) => l.id === el.endBinding?.elementId)
        ];
        const startBinding = startEndElements[0] ? el.startBinding : null;
        const endBinding = startEndElements[1] ? el.endBinding : null;
        return {
          ...el,
          ...updateElbowArrow(
            {
              ...el,
              startBinding,
              endBinding
            },
            toBrandedType(
              new Map(
                startEndElements.filter((x2) => x2 != null).map(
                  (el2) => [el2.id, el2]
                )
              )
            ),
            [el.points[0], el.points[el.points.length - 1]]
          )
        };
      }
      return el;
    });
    elements = restoreElements(elements, null, void 0);
    const [minX, minY, maxX, maxY] = getCommonBounds(elements);
    const elementsCenterX = distance(minX, maxX) / 2;
    const elementsCenterY = distance(minY, maxY) / 2;
    const clientX = typeof opts.position === "object" ? opts.position.clientX : opts.position === "cursor" ? this.lastViewportPosition.x : this.state.width / 2 + this.state.offsetLeft;
    const clientY = typeof opts.position === "object" ? opts.position.clientY : opts.position === "cursor" ? this.lastViewportPosition.y : this.state.height / 2 + this.state.offsetTop;
    const { x, y } = viewportCoordsToSceneCoords(
      { clientX, clientY },
      this.state
    );
    const dx = x - elementsCenterX;
    const dy = y - elementsCenterY;
    const [gridX, gridY] = getGridPoint(dx, dy, this.getEffectiveGridSize());
    const newElements = duplicateElements(
      elements.map((element) => {
        return newElementWith(element, {
          x: element.x + gridX - minX,
          y: element.y + gridY - minY
        });
      }),
      {
        randomizeSeed: !opts.retainSeed
      }
    );
    const prevElements = this.scene.getElementsIncludingDeleted();
    const nextElements = [...prevElements, ...newElements];
    syncMovedIndices(nextElements, arrayToMap(newElements));
    const topLayerFrame = this.getTopLayerFrameAtSceneCoords({ x, y });
    if (topLayerFrame) {
      const eligibleElements = filterElementsEligibleAsFrameChildren(
        newElements,
        topLayerFrame
      );
      addElementsToFrame(nextElements, eligibleElements, topLayerFrame);
    }
    this.scene.replaceAllElements(nextElements);
    newElements.forEach((newElement2) => {
      if (isTextElement(newElement2) && isBoundToContainer(newElement2)) {
        const container = getContainerElement(
          newElement2,
          this.scene.getElementsMapIncludingDeleted()
        );
        redrawTextBoundingBox(
          newElement2,
          container,
          this.scene.getElementsMapIncludingDeleted()
        );
      }
    });
    if (opts.files) {
      this.files = { ...this.files, ...opts.files };
    }
    this.store.shouldCaptureIncrement();
    const nextElementsToSelect = excludeElementsInFramesFromSelection(newElements);
    this.setState(
      {
        ...this.state,
        // keep sidebar (presumably the library) open if it's docked and
        // can fit.
        //
        // Note, we should close the sidebar only if we're dropping items
        // from library, not when pasting from clipboard. Alas.
        openSidebar: this.state.openSidebar && this.device.editor.canFitSidebar && jotaiStore.get(isSidebarDockedAtom) ? this.state.openSidebar : null,
        ...selectGroupsForSelectedElements(
          {
            editingGroupId: null,
            selectedElementIds: nextElementsToSelect.reduce(
              (acc, element) => {
                if (!isBoundToContainer(element)) {
                  acc[element.id] = true;
                }
                return acc;
              },
              {}
            )
          },
          this.scene.getNonDeletedElements(),
          this.state,
          this
        )
      },
      () => {
        if (opts.files) {
          this.addNewImagesToImageCache();
        }
      }
    );
    this.setActiveTool({ type: "selection" });
    if (opts.fitToContent) {
      this.scrollToContent(newElements, {
        fitToContent: true,
        canvasOffsets: this.getEditorUIOffsets()
      });
    }
  };
  // TODO rewrite this to paste both text & images at the same time if
  // pasted data contains both
  async addElementsFromMixedContentPaste(mixedContent, {
    isPlainPaste,
    sceneX,
    sceneY
  }) {
    if (!isPlainPaste && mixedContent.some((node) => node.type === "imageUrl") && this.isToolSupported("image")) {
      const imageURLs = mixedContent.filter((node) => node.type === "imageUrl").map((node) => node.value);
      const responses = await Promise.all(
        imageURLs.map(async (url) => {
          try {
            return { file: await ImageURLToFile(url) };
          } catch (error2) {
            let errorMessage = error2.message;
            if (error2.cause === "FETCH_ERROR") {
              errorMessage = t("errors.failedToFetchImage");
            } else if (error2.cause === "UNSUPPORTED") {
              errorMessage = t("errors.unsupportedFileType");
            }
            return { errorMessage };
          }
        })
      );
      let y = sceneY;
      let firstImageYOffsetDone = false;
      const nextSelectedIds = {};
      for (const response of responses) {
        if (response.file) {
          const imageElement = this.createImageElement({
            sceneX,
            sceneY: y
          });
          const initializedImageElement = await this.insertImageElement(
            imageElement,
            response.file
          );
          if (initializedImageElement) {
            if (!firstImageYOffsetDone) {
              firstImageYOffsetDone = true;
              y -= initializedImageElement.height / 2;
            }
            mutateElement(initializedImageElement, { y }, false);
            y = imageElement.y + imageElement.height + 25;
            nextSelectedIds[imageElement.id] = true;
          }
        }
      }
      this.setState({
        selectedElementIds: makeNextSelectedElementIds(
          nextSelectedIds,
          this.state
        )
      });
      const error = responses.find((response) => !!response.errorMessage);
      if (error && error.errorMessage) {
        this.setState({ errorMessage: error.errorMessage });
      }
    } else {
      const textNodes = mixedContent.filter((node) => node.type === "text");
      if (textNodes.length) {
        this.addTextFromPaste(
          textNodes.map((node) => node.value).join("\n\n"),
          isPlainPaste
        );
      }
    }
  }
  addTextFromPaste(text, isPlainPaste = false) {
    const { x, y } = viewportCoordsToSceneCoords(
      {
        clientX: this.lastViewportPosition.x,
        clientY: this.lastViewportPosition.y
      },
      this.state
    );
    const textElementProps = {
      x,
      y,
      strokeColor: this.state.currentItemStrokeColor,
      backgroundColor: this.state.currentItemBackgroundColor,
      fillStyle: this.state.currentItemFillStyle,
      strokeWidth: this.state.currentItemStrokeWidth,
      strokeStyle: this.state.currentItemStrokeStyle,
      roundness: null,
      roughness: this.state.currentItemRoughness,
      opacity: this.state.currentItemOpacity,
      text,
      fontSize: this.state.currentItemFontSize,
      fontFamily: this.state.currentItemFontFamily,
      textAlign: DEFAULT_TEXT_ALIGN,
      verticalAlign: DEFAULT_VERTICAL_ALIGN,
      locked: false
    };
    const fontString = getFontString({
      fontSize: textElementProps.fontSize,
      fontFamily: textElementProps.fontFamily
    });
    const lineHeight = getLineHeight(textElementProps.fontFamily);
    const [x1, , x2] = getVisibleSceneBounds(this.state);
    const maxTextWidth = Math.max(Math.min((x2 - x1) * 0.5, 800), 200);
    const LINE_GAP = 10;
    let currentY = y;
    const lines = isPlainPaste ? [text] : text.split("\n");
    const textElements = lines.reduce(
      (acc, line, idx) => {
        const originalText = normalizeText(line).trim();
        if (originalText.length) {
          const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
            x,
            y: currentY
          });
          let metrics = measureText(originalText, fontString, lineHeight);
          const isTextUnwrapped = metrics.width > maxTextWidth;
          const text2 = isTextUnwrapped ? wrapText(originalText, fontString, maxTextWidth) : originalText;
          metrics = isTextUnwrapped ? measureText(text2, fontString, lineHeight) : metrics;
          const startX = x - metrics.width / 2;
          const startY = currentY - metrics.height / 2;
          const element = newTextElement({
            ...textElementProps,
            x: startX,
            y: startY,
            text: text2,
            originalText,
            lineHeight,
            autoResize: !isTextUnwrapped,
            frameId: topLayerFrame ? topLayerFrame.id : null
          });
          acc.push(element);
          currentY += element.height + LINE_GAP;
        } else {
          const prevLine = lines[idx - 1]?.trim();
          if (prevLine) {
            currentY += getLineHeightInPx(textElementProps.fontSize, lineHeight) + LINE_GAP;
          }
        }
        return acc;
      },
      []
    );
    if (textElements.length === 0) {
      return;
    }
    this.scene.insertElements(textElements);
    this.setState({
      selectedElementIds: makeNextSelectedElementIds(
        Object.fromEntries(textElements.map((el) => [el.id, true])),
        this.state
      )
    });
    if (!isPlainPaste && textElements.length > 1 && PLAIN_PASTE_TOAST_SHOWN === false && !this.device.editor.isMobile) {
      this.setToast({
        message: t("toast.pasteAsSingleElement", {
          shortcut: getShortcutKey("CtrlOrCmd+Shift+V")
        }),
        duration: 5e3
      });
      PLAIN_PASTE_TOAST_SHOWN = true;
    }
    this.store.shouldCaptureIncrement();
  }
  setAppState = (state, callback) => {
    this.setState(state, callback);
  };
  removePointer = (event) => {
    if (touchTimeout) {
      this.resetContextMenuTimer();
    }
    gesture.pointers.delete(event.pointerId);
  };
  toggleLock = (source = "ui") => {
    if (!this.state.activeTool.locked) {
      trackEvent(
        "toolbar",
        "toggleLock",
        `${source} (${this.device.editor.isMobile ? "mobile" : "desktop"})`
      );
    }
    this.setState((prevState) => {
      return {
        activeTool: {
          ...prevState.activeTool,
          ...updateActiveTool(
            this.state,
            prevState.activeTool.locked ? { type: "selection" } : prevState.activeTool
          ),
          locked: !prevState.activeTool.locked
        }
      };
    });
  };
  updateFrameRendering = (opts) => {
    this.setState((prevState) => {
      const next = typeof opts === "function" ? opts(prevState.frameRendering) : opts;
      return {
        frameRendering: {
          enabled: next?.enabled ?? prevState.frameRendering.enabled,
          clip: next?.clip ?? prevState.frameRendering.clip,
          name: next?.name ?? prevState.frameRendering.name,
          outline: next?.outline ?? prevState.frameRendering.outline
        }
      };
    });
  };
  togglePenMode = (force) => {
    this.setState((prevState) => {
      return {
        penMode: force ?? !prevState.penMode,
        penDetected: true
      };
    });
  };
  onHandToolToggle = () => {
    this.actionManager.executeAction(actionToggleHandTool);
  };
  /**
   * Zooms on canvas viewport center
   */
  zoomCanvas = (value) => {
    this.setState({
      ...getStateForZoom(
        {
          viewportX: this.state.width / 2 + this.state.offsetLeft,
          viewportY: this.state.height / 2 + this.state.offsetTop,
          nextZoom: getNormalizedZoom(value)
        },
        this.state
      )
    });
  };
  cancelInProgressAnimation = null;
  scrollToContent = (target = this.scene.getNonDeletedElements(), opts) => {
    this.cancelInProgressAnimation?.();
    const targetElements = Array.isArray(target) ? target : [target];
    let zoom = this.state.zoom;
    let scrollX = this.state.scrollX;
    let scrollY = this.state.scrollY;
    if (opts?.fitToContent || opts?.fitToViewport) {
      const { appState } = zoomToFit({
        canvasOffsets: opts.canvasOffsets,
        targetElements,
        appState: this.state,
        fitToViewport: !!opts?.fitToViewport,
        viewportZoomFactor: opts?.viewportZoomFactor,
        minZoom: opts?.minZoom,
        maxZoom: opts?.maxZoom
      });
      zoom = appState.zoom;
      scrollX = appState.scrollX;
      scrollY = appState.scrollY;
    } else {
      const scroll = calculateScrollCenter(targetElements, this.state);
      scrollX = scroll.scrollX;
      scrollY = scroll.scrollY;
    }
    if (opts?.animate) {
      const origScrollX = this.state.scrollX;
      const origScrollY = this.state.scrollY;
      const origZoom = this.state.zoom.value;
      const cancel = easeToValuesRAF({
        fromValues: {
          scrollX: origScrollX,
          scrollY: origScrollY,
          zoom: origZoom
        },
        toValues: { scrollX, scrollY, zoom: zoom.value },
        interpolateValue: (from3, to, progress, key) => {
          if (key === "zoom") {
            return from3 * Math.pow(to / from3, easeOut(progress));
          }
          return void 0;
        },
        onStep: ({ scrollX: scrollX2, scrollY: scrollY2, zoom: zoom2 }) => {
          this.setState({
            scrollX: scrollX2,
            scrollY: scrollY2,
            zoom: { value: zoom2 }
          });
        },
        onStart: () => {
          this.setState({ shouldCacheIgnoreZoom: true });
        },
        onEnd: () => {
          this.setState({ shouldCacheIgnoreZoom: false });
        },
        onCancel: () => {
          this.setState({ shouldCacheIgnoreZoom: false });
        },
        duration: opts?.duration ?? 500
      });
      this.cancelInProgressAnimation = () => {
        cancel();
        this.cancelInProgressAnimation = null;
      };
    } else {
      this.setState({ scrollX, scrollY, zoom });
    }
  };
  maybeUnfollowRemoteUser = () => {
    if (this.state.userToFollow) {
      this.setState({ userToFollow: null });
    }
  };
  /** use when changing scrollX/scrollY/zoom based on user interaction */
  translateCanvas = (state) => {
    this.cancelInProgressAnimation?.();
    this.maybeUnfollowRemoteUser();
    this.setState(state);
  };
  setToast = (toast) => {
    this.setState({ toast });
  };
  restoreFileFromShare = async () => {
    try {
      const webShareTargetCache = await caches.open("web-share-target");
      const response = await webShareTargetCache.match("shared-file");
      if (response) {
        const blob = await response.blob();
        const file2 = new File([blob], blob.name || "", { type: blob.type });
        this.loadFileToCanvas(file2, null);
        await webShareTargetCache.delete("shared-file");
        window.history.replaceState(null, APP_NAME, window.location.pathname);
      }
    } catch (error) {
      this.setState({ errorMessage: error.message });
    }
  };
  /** adds supplied files to existing files in the appState */
  addFiles = withBatchedUpdates(
    (files) => {
      const filesMap = files.reduce((acc, fileData) => {
        acc.set(fileData.id, fileData);
        return acc;
      }, /* @__PURE__ */ new Map());
      this.files = { ...this.files, ...Object.fromEntries(filesMap) };
      this.clearImageShapeCache(Object.fromEntries(filesMap));
      this.scene.triggerUpdate();
      this.addNewImagesToImageCache();
    }
  );
  updateScene = withBatchedUpdates(
    (sceneData) => {
      const nextElements = syncInvalidIndices(sceneData.elements ?? []);
      if (sceneData.storeAction && sceneData.storeAction !== StoreAction.NONE) {
        const prevCommittedAppState = this.store.snapshot.appState;
        const prevCommittedElements = this.store.snapshot.elements;
        const nextCommittedAppState = sceneData.appState ? Object.assign({}, prevCommittedAppState, sceneData.appState) : prevCommittedAppState;
        const nextCommittedElements = sceneData.elements ? this.store.filterUncomittedElements(
          this.scene.getElementsMapIncludingDeleted(),
          // Only used to detect uncomitted local elements
          arrayToMap(nextElements)
          // We expect all (already reconciled) elements
        ) : prevCommittedElements;
        if (sceneData.storeAction === StoreAction.CAPTURE) {
          this.store.captureIncrement(
            nextCommittedElements,
            nextCommittedAppState
          );
        } else if (sceneData.storeAction === StoreAction.UPDATE) {
          this.store.updateSnapshot(
            nextCommittedElements,
            nextCommittedAppState
          );
        }
      }
      if (sceneData.appState) {
        this.setState(sceneData.appState);
      }
      if (sceneData.elements) {
        this.scene.replaceAllElements(nextElements);
      }
      if (sceneData.collaborators) {
        this.setState({ collaborators: sceneData.collaborators });
      }
    }
  );
  triggerRender = (force) => {
    if (force === true) {
      this.scene.triggerUpdate();
    } else {
      this.setState({});
    }
  };
  /**
   * @returns whether the menu was toggled on or off
   */
  toggleSidebar = ({
    name,
    tab,
    force
  }) => {
    let nextName;
    if (force === void 0) {
      nextName = this.state.openSidebar?.name === name && this.state.openSidebar?.tab === tab ? null : name;
    } else {
      nextName = force ? name : null;
    }
    const nextState = nextName ? { name: nextName } : null;
    if (nextState && tab) {
      nextState.tab = tab;
    }
    this.setState({ openSidebar: nextState });
    return !!nextName;
  };
  updateCurrentCursorPosition = withBatchedUpdates(
    (event) => {
      this.lastViewportPosition.x = event.clientX;
      this.lastViewportPosition.y = event.clientY;
    }
  );
  getEditorUIOffsets = () => {
    const toolbarBottom = this.excalidrawContainerRef?.current?.querySelector(".App-toolbar")?.getBoundingClientRect()?.bottom ?? 0;
    const sidebarRect = this.excalidrawContainerRef?.current?.querySelector(".sidebar")?.getBoundingClientRect();
    const propertiesPanelRect = this.excalidrawContainerRef?.current?.querySelector(".App-menu__left")?.getBoundingClientRect();
    const PADDING = 16;
    return getLanguage().rtl ? {
      top: toolbarBottom + PADDING,
      right: Math.max(
        this.state.width - (propertiesPanelRect?.left ?? this.state.width),
        0
      ) + PADDING,
      bottom: PADDING,
      left: Math.max(sidebarRect?.right ?? 0, 0) + PADDING
    } : {
      top: toolbarBottom + PADDING,
      right: Math.max(
        this.state.width - (sidebarRect?.left ?? this.state.width) + PADDING,
        0
      ),
      bottom: PADDING,
      left: Math.max(propertiesPanelRect?.right ?? 0, 0) + PADDING
    };
  };
  // Input handling
  onKeyDown = withBatchedUpdates(
    (event) => {
      if ("Proxy" in window && (!event.shiftKey && /^[A-Z]$/.test(event.key) || event.shiftKey && /^[a-z]$/.test(event.key))) {
        event = new Proxy(event, {
          get(ev, prop) {
            const value = ev[prop];
            if (typeof value === "function") {
              return value.bind(ev);
            }
            return prop === "key" ? (
              // CapsLock inverts capitalization based on ShiftKey, so invert
              // it back
              event.shiftKey ? ev.key.toUpperCase() : ev.key.toLowerCase()
            ) : value;
          }
        });
      }
      if (!isInputLike(event.target)) {
        if (event.key === KEYS.ESCAPE && this.flowChartCreator.isCreatingChart) {
          this.flowChartCreator.clear();
          this.triggerRender(true);
          return;
        }
        const arrowKeyPressed = isArrowKey(event.key);
        if (event[KEYS.CTRL_OR_CMD] && arrowKeyPressed && !event.shiftKey) {
          event.preventDefault();
          const selectedElements = getSelectedElements(
            this.scene.getNonDeletedElementsMap(),
            this.state
          );
          if (selectedElements.length === 1 && isFlowchartNodeElement(selectedElements[0])) {
            this.flowChartCreator.createNodes(
              selectedElements[0],
              this.scene.getNonDeletedElementsMap(),
              this.state,
              getLinkDirectionFromKey(event.key)
            );
          }
          if (this.flowChartCreator.pendingNodes?.length && !isElementCompletelyInViewport(
            this.flowChartCreator.pendingNodes,
            this.canvas.width / window.devicePixelRatio,
            this.canvas.height / window.devicePixelRatio,
            {
              offsetLeft: this.state.offsetLeft,
              offsetTop: this.state.offsetTop,
              scrollX: this.state.scrollX,
              scrollY: this.state.scrollY,
              zoom: this.state.zoom
            },
            this.scene.getNonDeletedElementsMap(),
            this.getEditorUIOffsets()
          )) {
            this.scrollToContent(this.flowChartCreator.pendingNodes, {
              animate: true,
              duration: 300,
              fitToContent: true,
              canvasOffsets: this.getEditorUIOffsets()
            });
          }
          return;
        }
        if (event.altKey) {
          const selectedElements = getSelectedElements(
            this.scene.getNonDeletedElementsMap(),
            this.state
          );
          if (selectedElements.length === 1 && arrowKeyPressed) {
            event.preventDefault();
            const nextId = this.flowChartNavigator.exploreByDirection(
              selectedElements[0],
              this.scene.getNonDeletedElementsMap(),
              getLinkDirectionFromKey(event.key)
            );
            if (nextId) {
              this.setState((prevState) => ({
                selectedElementIds: makeNextSelectedElementIds(
                  {
                    [nextId]: true
                  },
                  prevState
                )
              }));
              const nextNode = this.scene.getNonDeletedElementsMap().get(nextId);
              if (nextNode && !isElementCompletelyInViewport(
                [nextNode],
                this.canvas.width / window.devicePixelRatio,
                this.canvas.height / window.devicePixelRatio,
                {
                  offsetLeft: this.state.offsetLeft,
                  offsetTop: this.state.offsetTop,
                  scrollX: this.state.scrollX,
                  scrollY: this.state.scrollY,
                  zoom: this.state.zoom
                },
                this.scene.getNonDeletedElementsMap(),
                this.getEditorUIOffsets()
              )) {
                this.scrollToContent(nextNode, {
                  animate: true,
                  duration: 300,
                  canvasOffsets: this.getEditorUIOffsets()
                });
              }
            }
            return;
          }
        }
      }
      if (event[KEYS.CTRL_OR_CMD] && event.key === KEYS.P && !event.shiftKey && !event.altKey) {
        this.setToast({
          message: t("commandPalette.shortcutHint", {
            shortcut: getShortcutFromShortcutName("commandPalette")
          })
        });
        event.preventDefault();
        return;
      }
      if (event[KEYS.CTRL_OR_CMD] && event.key.toLowerCase() === KEYS.V) {
        IS_PLAIN_PASTE = event.shiftKey;
        clearTimeout(IS_PLAIN_PASTE_TIMER);
        IS_PLAIN_PASTE_TIMER = window.setTimeout(() => {
          IS_PLAIN_PASTE = false;
        }, 100);
      }
      if (event[KEYS.CTRL_OR_CMD] && isWritableElement(event.target)) {
        if (event.code === CODES.MINUS || event.code === CODES.EQUAL) {
          event.preventDefault();
          return;
        }
      }
      if (
        // inside an input
        isWritableElement(event.target) && // unless pressing escape (finalize action)
        event.key !== KEYS.ESCAPE || // or unless using arrows (to move between buttons)
        isArrowKey(event.key) && isInputLike(event.target)
      ) {
        return;
      }
      if (event.key === KEYS.QUESTION_MARK) {
        this.setState({
          openDialog: { name: "help" }
        });
        return;
      } else if (event.key.toLowerCase() === KEYS.E && event.shiftKey && event[KEYS.CTRL_OR_CMD]) {
        event.preventDefault();
        this.setState({ openDialog: { name: "imageExport" } });
        return;
      }
      if (event.key === KEYS.PAGE_UP || event.key === KEYS.PAGE_DOWN) {
        let offset2 = (event.shiftKey ? this.state.width : this.state.height) / this.state.zoom.value;
        if (event.key === KEYS.PAGE_DOWN) {
          offset2 = -offset2;
        }
        if (event.shiftKey) {
          this.translateCanvas((state) => ({
            scrollX: state.scrollX + offset2
          }));
        } else {
          this.translateCanvas((state) => ({
            scrollY: state.scrollY + offset2
          }));
        }
      }
      if (this.actionManager.handleKeyDown(event)) {
        return;
      }
      if (this.state.viewModeEnabled) {
        return;
      }
      if (event[KEYS.CTRL_OR_CMD] && this.state.isBindingEnabled) {
        this.setState({ isBindingEnabled: false });
      }
      if (isArrowKey(event.key)) {
        let selectedElements = this.scene.getSelectedElements({
          selectedElementIds: this.state.selectedElementIds,
          includeBoundTextElement: true,
          includeElementsInFrames: true
        });
        const elbowArrow = selectedElements.find(isElbowArrow);
        const arrowIdsToRemove = /* @__PURE__ */ new Set();
        selectedElements.filter(isElbowArrow).filter((arrow) => {
          const startElementNotInSelection = arrow.startBinding && !selectedElements.some(
            (el) => el.id === arrow.startBinding?.elementId
          );
          const endElementNotInSelection = arrow.endBinding && !selectedElements.some(
            (el) => el.id === arrow.endBinding?.elementId
          );
          return startElementNotInSelection || endElementNotInSelection;
        }).forEach((arrow) => arrowIdsToRemove.add(arrow.id));
        selectedElements = selectedElements.filter(
          (el) => !arrowIdsToRemove.has(el.id)
        );
        const step = this.getEffectiveGridSize() && (event.shiftKey ? ELEMENT_TRANSLATE_AMOUNT : this.getEffectiveGridSize()) || (event.shiftKey ? ELEMENT_SHIFT_TRANSLATE_AMOUNT : ELEMENT_TRANSLATE_AMOUNT);
        let offsetX = 0;
        let offsetY = 0;
        if (event.key === KEYS.ARROW_LEFT) {
          offsetX = -step;
        } else if (event.key === KEYS.ARROW_RIGHT) {
          offsetX = step;
        } else if (event.key === KEYS.ARROW_UP) {
          offsetY = -step;
        } else if (event.key === KEYS.ARROW_DOWN) {
          offsetY = step;
        }
        selectedElements.forEach((element) => {
          mutateElement(element, {
            x: element.x + offsetX,
            y: element.y + offsetY
          });
          updateBoundElements(element, this.scene.getNonDeletedElementsMap(), {
            simultaneouslyUpdated: selectedElements
          });
        });
        this.setState({
          suggestedBindings: getSuggestedBindingsForArrows(
            selectedElements.filter(
              (element) => element.id !== elbowArrow?.id || step !== 0
            ),
            this.scene.getNonDeletedElementsMap()
          )
        });
        event.preventDefault();
      } else if (event.key === KEYS.ENTER) {
        const selectedElements = this.scene.getSelectedElements(this.state);
        if (selectedElements.length === 1) {
          const selectedElement = selectedElements[0];
          if (event[KEYS.CTRL_OR_CMD]) {
            if (isLinearElement(selectedElement)) {
              if (!this.state.editingLinearElement || this.state.editingLinearElement.elementId !== selectedElements[0].id) {
                this.store.shouldCaptureIncrement();
                if (!isElbowArrow(selectedElement)) {
                  this.setState({
                    editingLinearElement: new LinearElementEditor(
                      selectedElement
                    )
                  });
                }
              }
            }
          } else if (isTextElement(selectedElement) || isValidTextContainer(selectedElement)) {
            let container;
            if (!isTextElement(selectedElement)) {
              container = selectedElement;
            }
            const midPoint = getContainerCenter(
              selectedElement,
              this.state,
              this.scene.getNonDeletedElementsMap()
            );
            const sceneX = midPoint.x;
            const sceneY = midPoint.y;
            this.startTextEditing({
              sceneX,
              sceneY,
              container
            });
            event.preventDefault();
            return;
          } else if (isFrameLikeElement(selectedElement)) {
            this.setState({
              editingFrame: selectedElement.id
            });
          }
        }
      } else if (!event.ctrlKey && !event.altKey && !event.metaKey && !this.state.newElement && !this.state.selectionElement && !this.state.selectedElementsAreBeingDragged) {
        const shape = findShapeByKey(event.key);
        if (shape) {
          if (this.state.activeTool.type !== shape) {
            trackEvent(
              "toolbar",
              shape,
              `keyboard (${this.device.editor.isMobile ? "mobile" : "desktop"})`
            );
          }
          if (shape === "arrow" && this.state.activeTool.type === "arrow") {
            this.setState((prevState) => ({
              currentItemArrowType: prevState.currentItemArrowType === ARROW_TYPE.sharp ? ARROW_TYPE.round : prevState.currentItemArrowType === ARROW_TYPE.round ? ARROW_TYPE.elbow : ARROW_TYPE.sharp
            }));
          }
          this.setActiveTool({ type: shape });
          event.stopPropagation();
        } else if (event.key === KEYS.Q) {
          this.toggleLock("keyboard");
          event.stopPropagation();
        }
      }
      if (event.key === KEYS.SPACE && gesture.pointers.size === 0) {
        isHoldingSpace = true;
        setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);
        event.preventDefault();
      }
      if ((event.key === KEYS.G || event.key === KEYS.S) && !event.altKey && !event[KEYS.CTRL_OR_CMD]) {
        const selectedElements = this.scene.getSelectedElements(this.state);
        if (this.state.activeTool.type === "selection" && !selectedElements.length) {
          return;
        }
        if (event.key === KEYS.G && (hasBackground(this.state.activeTool.type) || selectedElements.some((element) => hasBackground(element.type)))) {
          this.setState({ openPopup: "elementBackground" });
          event.stopPropagation();
        }
        if (event.key === KEYS.S) {
          this.setState({ openPopup: "elementStroke" });
          event.stopPropagation();
        }
      }
      if (!event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key.toLowerCase() === KEYS.F) {
        const selectedElements = this.scene.getSelectedElements(this.state);
        if (this.state.activeTool.type === "selection" && !selectedElements.length) {
          return;
        }
        if (this.state.activeTool.type === "text" || selectedElements.find(
          (element) => isTextElement(element) || getBoundTextElement(
            element,
            this.scene.getNonDeletedElementsMap()
          )
        )) {
          event.preventDefault();
          this.setState({ openPopup: "fontFamily" });
        }
      }
      if (event.key === KEYS.K && !event.altKey && !event[KEYS.CTRL_OR_CMD]) {
        if (this.state.activeTool.type === "laser") {
          this.setActiveTool({ type: "selection" });
        } else {
          this.setActiveTool({ type: "laser" });
        }
        return;
      }
      if (event[KEYS.CTRL_OR_CMD] && (event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE)) {
        jotaiStore.set(activeConfirmDialogAtom, "clearCanvas");
      }
      const lowerCased = event.key.toLocaleLowerCase();
      const isPickingStroke = lowerCased === KEYS.S && event.shiftKey;
      const isPickingBackground = event.key === KEYS.I || lowerCased === KEYS.G && event.shiftKey;
      if (isPickingStroke || isPickingBackground) {
        this.openEyeDropper({
          type: isPickingStroke ? "stroke" : "background"
        });
      }
    }
  );
  onKeyUp = withBatchedUpdates((event) => {
    if (event.key === KEYS.SPACE) {
      if (this.state.viewModeEnabled) {
        setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);
      } else if (this.state.activeTool.type === "selection") {
        resetCursor(this.interactiveCanvas);
      } else {
        setCursorForShape(this.interactiveCanvas, this.state);
        this.setState({
          selectedElementIds: makeNextSelectedElementIds({}, this.state),
          selectedGroupIds: {},
          editingGroupId: null,
          activeEmbeddable: null
        });
      }
      isHoldingSpace = false;
    }
    if (!event[KEYS.CTRL_OR_CMD] && !this.state.isBindingEnabled) {
      this.setState({ isBindingEnabled: true });
    }
    if (isArrowKey(event.key)) {
      bindOrUnbindLinearElements(
        this.scene.getSelectedElements(this.state).filter(isLinearElement),
        this.scene.getNonDeletedElementsMap(),
        this.scene.getNonDeletedElements(),
        this.scene,
        isBindingEnabled(this.state),
        this.state.selectedLinearElement?.selectedPointsIndices ?? []
      );
      this.setState({ suggestedBindings: [] });
    }
    if (!event.altKey) {
      if (this.flowChartNavigator.isExploring) {
        this.flowChartNavigator.clear();
        this.syncActionResult({ storeAction: StoreAction.CAPTURE });
      }
    }
    if (!event[KEYS.CTRL_OR_CMD]) {
      if (this.flowChartCreator.isCreatingChart) {
        if (this.flowChartCreator.pendingNodes?.length) {
          this.scene.insertElements(this.flowChartCreator.pendingNodes);
        }
        const firstNode = this.flowChartCreator.pendingNodes?.[0];
        if (firstNode) {
          this.setState((prevState) => ({
            selectedElementIds: makeNextSelectedElementIds(
              {
                [firstNode.id]: true
              },
              prevState
            )
          }));
          if (!isElementCompletelyInViewport(
            [firstNode],
            this.canvas.width / window.devicePixelRatio,
            this.canvas.height / window.devicePixelRatio,
            {
              offsetLeft: this.state.offsetLeft,
              offsetTop: this.state.offsetTop,
              scrollX: this.state.scrollX,
              scrollY: this.state.scrollY,
              zoom: this.state.zoom
            },
            this.scene.getNonDeletedElementsMap(),
            this.getEditorUIOffsets()
          )) {
            this.scrollToContent(firstNode, {
              animate: true,
              duration: 300,
              canvasOffsets: this.getEditorUIOffsets()
            });
          }
        }
        this.flowChartCreator.clear();
        this.syncActionResult({ storeAction: StoreAction.CAPTURE });
      }
    }
  });
  // We purposely widen the `tool` type so this helper can be called with
  // any tool without having to type check it
  isToolSupported = (tool) => {
    return this.props.UIOptions.tools?.[tool] !== false;
  };
  setActiveTool = (tool) => {
    if (!this.isToolSupported(tool.type)) {
      console.warn(
        `"${tool.type}" tool is disabled via "UIOptions.canvasActions.tools.${tool.type}"`
      );
      return;
    }
    const nextActiveTool = updateActiveTool(this.state, tool);
    if (nextActiveTool.type === "hand") {
      setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);
    } else if (!isHoldingSpace) {
      setCursorForShape(this.interactiveCanvas, this.state);
    }
    if (isToolIcon(document.activeElement)) {
      this.focusContainer();
    }
    if (!isLinearElementType(nextActiveTool.type)) {
      this.setState({ suggestedBindings: [] });
    }
    if (nextActiveTool.type === "image") {
      this.onImageAction({
        insertOnCanvasDirectly: (tool.type === "image" && tool.insertOnCanvasDirectly) ?? false
      });
    }
    this.setState((prevState) => {
      const commonResets = {
        snapLines: prevState.snapLines.length ? [] : prevState.snapLines,
        originSnapOffset: null,
        activeEmbeddable: null
      };
      if (nextActiveTool.type === "freedraw") {
        this.store.shouldCaptureIncrement();
      }
      if (nextActiveTool.type !== "selection") {
        return {
          ...prevState,
          activeTool: nextActiveTool,
          selectedElementIds: makeNextSelectedElementIds({}, prevState),
          selectedGroupIds: makeNextSelectedElementIds({}, prevState),
          editingGroupId: null,
          multiElement: null,
          ...commonResets
        };
      }
      return {
        ...prevState,
        activeTool: nextActiveTool,
        ...commonResets
      };
    });
  };
  setOpenDialog = (dialogType) => {
    this.setState({ openDialog: dialogType });
  };
  setCursor = (cursor) => {
    setCursor(this.interactiveCanvas, cursor);
  };
  resetCursor = () => {
    resetCursor(this.interactiveCanvas);
  };
  /**
   * returns whether user is making a gesture with >= 2 fingers (points)
   * on o touch screen (not on a trackpad). Currently only relates to Darwin
   * (iOS/iPadOS,MacOS), but may work on other devices in the future if
   * GestureEvent is standardized.
   */
  isTouchScreenMultiTouchGesture = () => {
    return gesture.pointers.size >= 2;
  };
  getName = () => {
    return this.state.name || this.props.name || `${t("labels.untitled")}-${getDateTime()}`;
  };
  // fires only on Safari
  onGestureStart = withBatchedUpdates((event) => {
    event.preventDefault();
    if (this.isTouchScreenMultiTouchGesture()) {
      this.setState({
        selectedElementIds: makeNextSelectedElementIds({}, this.state),
        activeEmbeddable: null
      });
    }
    gesture.initialScale = this.state.zoom.value;
  });
  // fires only on Safari
  onGestureChange = withBatchedUpdates((event) => {
    event.preventDefault();
    if (this.isTouchScreenMultiTouchGesture()) {
      return;
    }
    const initialScale = gesture.initialScale;
    if (initialScale) {
      this.setState((state) => ({
        ...getStateForZoom(
          {
            viewportX: this.lastViewportPosition.x,
            viewportY: this.lastViewportPosition.y,
            nextZoom: getNormalizedZoom(initialScale * event.scale)
          },
          state
        )
      }));
    }
  });
  // fires only on Safari
  onGestureEnd = withBatchedUpdates((event) => {
    event.preventDefault();
    if (this.isTouchScreenMultiTouchGesture()) {
      this.setState({
        previousSelectedElementIds: {},
        selectedElementIds: makeNextSelectedElementIds(
          this.state.previousSelectedElementIds,
          this.state
        )
      });
    }
    gesture.initialScale = null;
  });
  handleTextWysiwyg(element, {
    isExistingElement = false
  }) {
    const elementsMap = this.scene.getElementsMapIncludingDeleted();
    const updateElement = (nextOriginalText, isDeleted) => {
      this.scene.replaceAllElements([
        // Not sure why we include deleted elements as well hence using deleted elements map
        ...this.scene.getElementsIncludingDeleted().map((_element) => {
          if (_element.id === element.id && isTextElement(_element)) {
            return newElementWith(_element, {
              originalText: nextOriginalText,
              isDeleted: isDeleted ?? _element.isDeleted,
              // returns (wrapped) text and new dimensions
              ...refreshTextDimensions(
                _element,
                getContainerElement(_element, elementsMap),
                elementsMap,
                nextOriginalText
              )
            });
          }
          return _element;
        })
      ]);
    };
    textWysiwyg({
      id: element.id,
      canvas: this.canvas,
      getViewportCoords: (x, y) => {
        const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(
          {
            sceneX: x,
            sceneY: y
          },
          this.state
        );
        return [
          viewportX - this.state.offsetLeft,
          viewportY - this.state.offsetTop
        ];
      },
      onChange: withBatchedUpdates((nextOriginalText) => {
        updateElement(nextOriginalText, false);
        if (isNonDeletedElement(element)) {
          updateBoundElements(element, this.scene.getNonDeletedElementsMap());
        }
      }),
      onSubmit: withBatchedUpdates(({ viaKeyboard, nextOriginalText }) => {
        const isDeleted = !nextOriginalText.trim();
        updateElement(nextOriginalText, isDeleted);
        if (!isDeleted && viaKeyboard) {
          const elementIdToSelect = element.containerId ? element.containerId : element.id;
          flushSync(() => {
            this.setState((prevState) => ({
              selectedElementIds: makeNextSelectedElementIds(
                {
                  ...prevState.selectedElementIds,
                  [elementIdToSelect]: true
                },
                prevState
              )
            }));
          });
        }
        if (isDeleted) {
          fixBindingsAfterDeletion(this.scene.getNonDeletedElements(), [
            element
          ]);
        }
        if (!isDeleted || isExistingElement) {
          this.store.shouldCaptureIncrement();
        }
        this.setState({
          newElement: null,
          editingTextElement: null
        });
        if (this.state.activeTool.locked) {
          setCursorForShape(this.interactiveCanvas, this.state);
        }
        this.focusContainer();
      }),
      element,
      excalidrawContainer: this.excalidrawContainerRef.current,
      app: this,
      // when text is selected, it's hard (at least on iOS) to re-position the
      // caret (i.e. deselect). There's not much use for always selecting
      // the text on edit anyway (and users can select-all from contextmenu
      // if needed)
      autoSelect: !this.device.isTouchScreen
    });
    this.deselectElements();
    updateElement(element.originalText, false);
  }
  deselectElements() {
    this.setState({
      selectedElementIds: makeNextSelectedElementIds({}, this.state),
      selectedGroupIds: {},
      editingGroupId: null,
      activeEmbeddable: null
    });
  }
  getTextElementAtPosition(x, y) {
    const element = this.getElementAtPosition(x, y, {
      includeBoundTextElement: true
    });
    if (element && isTextElement(element) && !element.isDeleted) {
      return element;
    }
    return null;
  }
  getElementAtPosition(x, y, opts) {
    const allHitElements = this.getElementsAtPosition(
      x,
      y,
      opts?.includeBoundTextElement,
      opts?.includeLockedElements
    );
    if (allHitElements.length > 1) {
      if (opts?.preferSelected) {
        for (let index = allHitElements.length - 1; index > -1; index--) {
          if (this.state.selectedElementIds[allHitElements[index].id]) {
            return allHitElements[index];
          }
        }
      }
      const elementWithHighestZIndex = allHitElements[allHitElements.length - 1];
      return hitElementItself({
        x,
        y,
        element: elementWithHighestZIndex,
        shape: getElementShape(
          elementWithHighestZIndex,
          this.scene.getNonDeletedElementsMap()
        ),
        // when overlapping, we would like to be more precise
        // this also avoids the need to update past tests
        threshold: this.getElementHitThreshold() / 2,
        frameNameBound: isFrameLikeElement(elementWithHighestZIndex) ? this.frameNameBoundsCache.get(elementWithHighestZIndex) : null
      }) ? elementWithHighestZIndex : allHitElements[allHitElements.length - 2];
    }
    if (allHitElements.length === 1) {
      return allHitElements[0];
    }
    return null;
  }
  getElementsAtPosition(x, y, includeBoundTextElement = false, includeLockedElements = false) {
    const iframeLikes = [];
    const elementsMap = this.scene.getNonDeletedElementsMap();
    const elements = (includeBoundTextElement && includeLockedElements ? this.scene.getNonDeletedElements() : this.scene.getNonDeletedElements().filter(
      (element) => (includeLockedElements || !element.locked) && (includeBoundTextElement || !(isTextElement(element) && element.containerId))
    )).filter((el) => this.hitElement(x, y, el)).filter((element) => {
      const containingFrame = getContainingFrame(element, elementsMap);
      return containingFrame && this.state.frameRendering.enabled && this.state.frameRendering.clip ? isCursorInFrame({ x, y }, containingFrame, elementsMap) : true;
    }).filter((el) => {
      if (isIframeElement(el)) {
        iframeLikes.push(el);
        return false;
      }
      return true;
    }).concat(iframeLikes);
    return elements;
  }
  getElementHitThreshold() {
    return DEFAULT_COLLISION_THRESHOLD / this.state.zoom.value;
  }
  hitElement(x, y, element, considerBoundingBox = true) {
    if (considerBoundingBox && this.state.selectedElementIds[element.id] && shouldShowBoundingBox([element], this.state)) {
      const selectionShape = getSelectionBoxShape(
        element,
        this.scene.getNonDeletedElementsMap(),
        this.getElementHitThreshold()
      );
      return isPointInShape(pointFrom(x, y), selectionShape);
    }
    const hitBoundTextOfElement = hitElementBoundText(
      x,
      y,
      getBoundTextShape(element, this.scene.getNonDeletedElementsMap())
    );
    if (hitBoundTextOfElement) {
      return true;
    }
    return hitElementItself({
      x,
      y,
      element,
      shape: getElementShape(element, this.scene.getNonDeletedElementsMap()),
      threshold: this.getElementHitThreshold(),
      frameNameBound: isFrameLikeElement(element) ? this.frameNameBoundsCache.get(element) : null
    });
  }
  getTextBindableContainerAtPosition(x, y) {
    const elements = this.scene.getNonDeletedElements();
    const selectedElements = this.scene.getSelectedElements(this.state);
    if (selectedElements.length === 1) {
      return isTextBindableContainer(selectedElements[0], false) ? selectedElements[0] : null;
    }
    let hitElement = null;
    for (let index = elements.length - 1; index >= 0; --index) {
      if (elements[index].isDeleted) {
        continue;
      }
      const [x1, y1, x2, y2] = getElementAbsoluteCoords(
        elements[index],
        this.scene.getNonDeletedElementsMap()
      );
      if (isArrowElement(elements[index]) && hitElementItself({
        x,
        y,
        element: elements[index],
        shape: getElementShape(
          elements[index],
          this.scene.getNonDeletedElementsMap()
        ),
        threshold: this.getElementHitThreshold()
      })) {
        hitElement = elements[index];
        break;
      } else if (x1 < x && x < x2 && y1 < y && y < y2) {
        hitElement = elements[index];
        break;
      }
    }
    return isTextBindableContainer(hitElement, false) ? hitElement : null;
  }
  startTextEditing = ({
    sceneX,
    sceneY,
    insertAtParentCenter = true,
    container,
    autoEdit = true
  }) => {
    let shouldBindToContainer = false;
    let parentCenterPosition = insertAtParentCenter && this.getTextWysiwygSnappedToCenterPosition(
      sceneX,
      sceneY,
      this.state,
      container
    );
    if (container && parentCenterPosition) {
      const boundTextElementToContainer = getBoundTextElement(
        container,
        this.scene.getNonDeletedElementsMap()
      );
      if (!boundTextElementToContainer) {
        shouldBindToContainer = true;
      }
    }
    let existingTextElement = null;
    const selectedElements = this.scene.getSelectedElements(this.state);
    if (selectedElements.length === 1) {
      if (isTextElement(selectedElements[0])) {
        existingTextElement = selectedElements[0];
      } else if (container) {
        existingTextElement = getBoundTextElement(
          selectedElements[0],
          this.scene.getNonDeletedElementsMap()
        );
      } else {
        existingTextElement = this.getTextElementAtPosition(sceneX, sceneY);
      }
    } else {
      existingTextElement = this.getTextElementAtPosition(sceneX, sceneY);
    }
    const fontFamily = existingTextElement?.fontFamily || this.state.currentItemFontFamily;
    const lineHeight = existingTextElement?.lineHeight || getLineHeight(fontFamily);
    const fontSize = this.state.currentItemFontSize;
    if (!existingTextElement && shouldBindToContainer && container && !isArrowElement(container)) {
      const fontString = {
        fontSize,
        fontFamily
      };
      const minWidth = getApproxMinLineWidth(
        getFontString(fontString),
        lineHeight
      );
      const minHeight = getApproxMinLineHeight(fontSize, lineHeight);
      const newHeight = Math.max(container.height, minHeight);
      const newWidth = Math.max(container.width, minWidth);
      mutateElement(container, { height: newHeight, width: newWidth });
      sceneX = container.x + newWidth / 2;
      sceneY = container.y + newHeight / 2;
      if (parentCenterPosition) {
        parentCenterPosition = this.getTextWysiwygSnappedToCenterPosition(
          sceneX,
          sceneY,
          this.state,
          container
        );
      }
    }
    const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
      x: sceneX,
      y: sceneY
    });
    const element = existingTextElement ? existingTextElement : newTextElement({
      x: parentCenterPosition ? parentCenterPosition.elementCenterX : sceneX,
      y: parentCenterPosition ? parentCenterPosition.elementCenterY : sceneY,
      strokeColor: this.state.currentItemStrokeColor,
      backgroundColor: this.state.currentItemBackgroundColor,
      fillStyle: this.state.currentItemFillStyle,
      strokeWidth: this.state.currentItemStrokeWidth,
      strokeStyle: this.state.currentItemStrokeStyle,
      roughness: this.state.currentItemRoughness,
      opacity: this.state.currentItemOpacity,
      text: "",
      fontSize,
      fontFamily,
      textAlign: parentCenterPosition ? "center" : this.state.currentItemTextAlign,
      verticalAlign: parentCenterPosition ? VERTICAL_ALIGN.MIDDLE : DEFAULT_VERTICAL_ALIGN,
      containerId: shouldBindToContainer ? container?.id : void 0,
      groupIds: container?.groupIds ?? [],
      lineHeight,
      angle: container?.angle ?? 0,
      frameId: topLayerFrame ? topLayerFrame.id : null
    });
    if (!existingTextElement && shouldBindToContainer && container) {
      mutateElement(container, {
        boundElements: (container.boundElements || []).concat({
          type: "text",
          id: element.id
        })
      });
    }
    this.setState({ editingTextElement: element });
    if (!existingTextElement) {
      if (container && shouldBindToContainer) {
        const containerIndex = this.scene.getElementIndex(container.id);
        this.scene.insertElementAtIndex(element, containerIndex + 1);
      } else {
        this.scene.insertElement(element);
      }
    }
    if (autoEdit || existingTextElement || container) {
      this.handleTextWysiwyg(element, {
        isExistingElement: !!existingTextElement
      });
    } else {
      this.setState({
        newElement: element,
        multiElement: null
      });
    }
  };
  handleCanvasDoubleClick = (event) => {
    if (this.state.multiElement) {
      return;
    }
    if (this.state.activeTool.type !== "selection") {
      return;
    }
    const selectedElements = this.scene.getSelectedElements(this.state);
    if (selectedElements.length === 1 && isLinearElement(selectedElements[0])) {
      if (event[KEYS.CTRL_OR_CMD] && (!this.state.editingLinearElement || this.state.editingLinearElement.elementId !== selectedElements[0].id) && !isElbowArrow(selectedElements[0])) {
        this.store.shouldCaptureIncrement();
        this.setState({
          editingLinearElement: new LinearElementEditor(selectedElements[0])
        });
        return;
      }
    }
    resetCursor(this.interactiveCanvas);
    let { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(
      event,
      this.state
    );
    const selectedGroupIds = getSelectedGroupIds(this.state);
    if (selectedGroupIds.length > 0) {
      const hitElement = this.getElementAtPosition(sceneX, sceneY);
      const selectedGroupId = hitElement && getSelectedGroupIdForElement(hitElement, this.state.selectedGroupIds);
      if (selectedGroupId) {
        this.store.shouldCaptureIncrement();
        this.setState((prevState) => ({
          ...prevState,
          ...selectGroupsForSelectedElements(
            {
              editingGroupId: selectedGroupId,
              selectedElementIds: { [hitElement.id]: true }
            },
            this.scene.getNonDeletedElements(),
            prevState,
            this
          )
        }));
        return;
      }
    }
    resetCursor(this.interactiveCanvas);
    if (!event[KEYS.CTRL_OR_CMD] && !this.state.viewModeEnabled) {
      const hitElement = this.getElementAtPosition(sceneX, sceneY);
      if (isIframeLikeElement(hitElement)) {
        this.setState({
          activeEmbeddable: { element: hitElement, state: "active" }
        });
        return;
      }
      const container = this.getTextBindableContainerAtPosition(sceneX, sceneY);
      if (container) {
        if (hasBoundTextElement(container) || !isTransparent(container.backgroundColor) || hitElementItself({
          x: sceneX,
          y: sceneY,
          element: container,
          shape: getElementShape(
            container,
            this.scene.getNonDeletedElementsMap()
          ),
          threshold: this.getElementHitThreshold()
        })) {
          const midPoint = getContainerCenter(
            container,
            this.state,
            this.scene.getNonDeletedElementsMap()
          );
          sceneX = midPoint.x;
          sceneY = midPoint.y;
        }
      }
      this.startTextEditing({
        sceneX,
        sceneY,
        insertAtParentCenter: !event.altKey,
        container
      });
    }
  };
  getElementLinkAtPosition = (scenePointer, hitElement) => {
    const elements = this.scene.getNonDeletedElements().slice().reverse();
    let hitElementIndex = Infinity;
    return elements.find((element, index) => {
      if (hitElement && element.id === hitElement.id) {
        hitElementIndex = index;
      }
      return element.link && index <= hitElementIndex && isPointHittingLink(
        element,
        this.scene.getNonDeletedElementsMap(),
        this.state,
        pointFrom(scenePointer.x, scenePointer.y),
        this.device.editor.isMobile
      );
    });
  };
  redirectToLink = (event, isTouchScreen) => {
    const draggedDistance = pointDistance(
      pointFrom(
        this.lastPointerDownEvent.clientX,
        this.lastPointerDownEvent.clientY
      ),
      pointFrom(
        this.lastPointerUpEvent.clientX,
        this.lastPointerUpEvent.clientY
      )
    );
    if (!this.hitLinkElement || // For touch screen allow dragging threshold else strict check
    isTouchScreen && draggedDistance > DRAGGING_THRESHOLD || !isTouchScreen && draggedDistance !== 0) {
      return;
    }
    const lastPointerDownCoords = viewportCoordsToSceneCoords(
      this.lastPointerDownEvent,
      this.state
    );
    const elementsMap = this.scene.getNonDeletedElementsMap();
    const lastPointerDownHittingLinkIcon = isPointHittingLink(
      this.hitLinkElement,
      elementsMap,
      this.state,
      pointFrom(lastPointerDownCoords.x, lastPointerDownCoords.y),
      this.device.editor.isMobile
    );
    const lastPointerUpCoords = viewportCoordsToSceneCoords(
      this.lastPointerUpEvent,
      this.state
    );
    const lastPointerUpHittingLinkIcon = isPointHittingLink(
      this.hitLinkElement,
      elementsMap,
      this.state,
      pointFrom(lastPointerUpCoords.x, lastPointerUpCoords.y),
      this.device.editor.isMobile
    );
    if (lastPointerDownHittingLinkIcon && lastPointerUpHittingLinkIcon) {
      let url = this.hitLinkElement.link;
      if (url) {
        url = normalizeLink(url);
        let customEvent;
        if (this.props.onLinkOpen) {
          customEvent = wrapEvent("excalidraw-link" /* EXCALIDRAW_LINK */, event.nativeEvent);
          this.props.onLinkOpen(
            {
              ...this.hitLinkElement,
              link: url
            },
            customEvent
          );
        }
        if (!customEvent?.defaultPrevented) {
          const target = isLocalLink(url) ? "_self" : "_blank";
          const newWindow = window.open(void 0, target);
          if (newWindow) {
            newWindow.opener = null;
            newWindow.location = url;
          }
        }
      }
    }
  };
  getTopLayerFrameAtSceneCoords = (sceneCoords) => {
    const elementsMap = this.scene.getNonDeletedElementsMap();
    const frames = this.scene.getNonDeletedFramesLikes().filter(
      (frame) => isCursorInFrame(sceneCoords, frame, elementsMap)
    );
    return frames.length ? frames[frames.length - 1] : null;
  };
  handleCanvasPointerMove = (event) => {
    this.savePointer(event.clientX, event.clientY, this.state.cursorButton);
    this.lastPointerMoveEvent = event.nativeEvent;
    if (gesture.pointers.has(event.pointerId)) {
      gesture.pointers.set(event.pointerId, {
        x: event.clientX,
        y: event.clientY
      });
    }
    const initialScale = gesture.initialScale;
    if (gesture.pointers.size === 2 && gesture.lastCenter && initialScale && gesture.initialDistance) {
      const center = getCenter(gesture.pointers);
      const deltaX = center.x - gesture.lastCenter.x;
      const deltaY = center.y - gesture.lastCenter.y;
      gesture.lastCenter = center;
      const distance3 = getDistance(Array.from(gesture.pointers.values()));
      const scaleFactor = this.state.activeTool.type === "freedraw" && this.state.penMode ? 1 : distance3 / gesture.initialDistance;
      const nextZoom = scaleFactor ? getNormalizedZoom(initialScale * scaleFactor) : this.state.zoom.value;
      this.setState((state) => {
        const zoomState = getStateForZoom(
          {
            viewportX: center.x,
            viewportY: center.y,
            nextZoom
          },
          state
        );
        this.translateCanvas({
          zoom: zoomState.zoom,
          // 2x multiplier is just a magic number that makes this work correctly
          // on touchscreen devices (note: if we get report that panning is slower/faster
          // than actual movement, consider swapping with devicePixelRatio)
          scrollX: zoomState.scrollX + 2 * (deltaX / nextZoom),
          scrollY: zoomState.scrollY + 2 * (deltaY / nextZoom),
          shouldCacheIgnoreZoom: true
        });
      });
      this.resetShouldCacheIgnoreZoomDebounced();
    } else {
      gesture.lastCenter = gesture.initialDistance = gesture.initialScale = null;
    }
    if (isHoldingSpace || isPanning || isDraggingScrollBar || isHandToolActive(this.state)) {
      return;
    }
    const isPointerOverScrollBars = isOverScrollBars(
      currentScrollBars,
      event.clientX - this.state.offsetLeft,
      event.clientY - this.state.offsetTop
    );
    const isOverScrollBar = isPointerOverScrollBars.isOverEither;
    if (!this.state.newElement && !this.state.selectionElement && !this.state.selectedElementsAreBeingDragged && !this.state.multiElement) {
      if (isOverScrollBar) {
        resetCursor(this.interactiveCanvas);
      } else {
        setCursorForShape(this.interactiveCanvas, this.state);
      }
    }
    const scenePointer = viewportCoordsToSceneCoords(event, this.state);
    const { x: scenePointerX, y: scenePointerY } = scenePointer;
    if (!this.state.newElement && isActiveToolNonLinearSnappable(this.state.activeTool.type)) {
      const { originOffset, snapLines } = getSnapLinesAtPointer(
        this.scene.getNonDeletedElements(),
        this,
        {
          x: scenePointerX,
          y: scenePointerY
        },
        event,
        this.scene.getNonDeletedElementsMap()
      );
      this.setState((prevState) => {
        const nextSnapLines = updateStable(prevState.snapLines, snapLines);
        const nextOriginOffset = prevState.originSnapOffset ? updateStable(prevState.originSnapOffset, originOffset) : originOffset;
        if (prevState.snapLines === nextSnapLines && prevState.originSnapOffset === nextOriginOffset) {
          return null;
        }
        return {
          snapLines: nextSnapLines,
          originSnapOffset: nextOriginOffset
        };
      });
    } else if (!this.state.newElement && !this.state.selectedElementsAreBeingDragged && !this.state.selectionElement) {
      this.setState((prevState) => {
        if (prevState.snapLines.length) {
          return {
            snapLines: []
          };
        }
        return null;
      });
    }
    if (this.state.editingLinearElement && !this.state.editingLinearElement.isDragging) {
      const editingLinearElement = LinearElementEditor.handlePointerMove(
        event,
        scenePointerX,
        scenePointerY,
        this,
        this.scene.getNonDeletedElementsMap()
      );
      if (editingLinearElement && editingLinearElement !== this.state.editingLinearElement) {
        flushSync(() => {
          this.setState({
            editingLinearElement
          });
        });
      }
      if (editingLinearElement?.lastUncommittedPoint != null) {
        this.maybeSuggestBindingAtCursor(scenePointer);
      } else {
        flushSync(() => {
          this.setState({ suggestedBindings: [] });
        });
      }
    }
    if (isBindingElementType(this.state.activeTool.type)) {
      const { newElement: newElement2 } = this.state;
      if (isBindingElement(newElement2, false)) {
        this.maybeSuggestBindingsForLinearElementAtCoords(
          newElement2,
          [scenePointer],
          this.state.startBoundElement
        );
      } else {
        this.maybeSuggestBindingAtCursor(scenePointer);
      }
    }
    if (this.state.multiElement) {
      const { multiElement } = this.state;
      const { x: rx, y: ry } = multiElement;
      const { points, lastCommittedPoint } = multiElement;
      const lastPoint = points[points.length - 1];
      setCursorForShape(this.interactiveCanvas, this.state);
      if (lastPoint === lastCommittedPoint) {
        if (pointDistance(
          pointFrom(scenePointerX - rx, scenePointerY - ry),
          lastPoint
        ) >= LINE_CONFIRM_THRESHOLD) {
          mutateElement(
            multiElement,
            {
              points: [
                ...points,
                pointFrom(scenePointerX - rx, scenePointerY - ry)
              ]
            },
            false
          );
        } else {
          setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
        }
      } else if (points.length > 2 && lastCommittedPoint && pointDistance(
        pointFrom(scenePointerX - rx, scenePointerY - ry),
        lastCommittedPoint
      ) < LINE_CONFIRM_THRESHOLD) {
        setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
        mutateElement(
          multiElement,
          {
            points: points.slice(0, -1)
          },
          false
        );
      } else {
        const [gridX, gridY] = getGridPoint(
          scenePointerX,
          scenePointerY,
          event[KEYS.CTRL_OR_CMD] || isElbowArrow(multiElement) ? null : this.getEffectiveGridSize()
        );
        const [lastCommittedX, lastCommittedY] = multiElement?.lastCommittedPoint ?? [0, 0];
        let dxFromLastCommitted = gridX - rx - lastCommittedX;
        let dyFromLastCommitted = gridY - ry - lastCommittedY;
        if (shouldRotateWithDiscreteAngle(event)) {
          ({ width: dxFromLastCommitted, height: dyFromLastCommitted } = getLockedLinearCursorAlignSize(
            // actual coordinate of the last committed point
            lastCommittedX + rx,
            lastCommittedY + ry,
            // cursor-grid coordinate
            gridX,
            gridY
          ));
        }
        if (isPathALoop(points, this.state.zoom.value)) {
          setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
        }
        if (isElbowArrow(multiElement)) {
          mutateElbowArrow(
            multiElement,
            this.scene.getNonDeletedElementsMap(),
            [
              ...points.slice(0, -1),
              pointFrom(
                lastCommittedX + dxFromLastCommitted,
                lastCommittedY + dyFromLastCommitted
              )
            ],
            void 0,
            void 0,
            {
              isDragging: true,
              informMutation: false
            }
          );
        } else {
          mutateElement(
            multiElement,
            {
              points: [
                ...points.slice(0, -1),
                pointFrom(
                  lastCommittedX + dxFromLastCommitted,
                  lastCommittedY + dyFromLastCommitted
                )
              ]
            },
            false
          );
        }
        this.triggerRender(false);
      }
      return;
    }
    const hasDeselectedButton = Boolean(event.buttons);
    if (hasDeselectedButton || this.state.activeTool.type !== "selection" && this.state.activeTool.type !== "text" && this.state.activeTool.type !== "eraser") {
      return;
    }
    const elements = this.scene.getNonDeletedElements();
    const selectedElements = this.scene.getSelectedElements(this.state);
    if (selectedElements.length === 1 && !isOverScrollBar && !this.state.editingLinearElement) {
      if (this.state.selectedLinearElement) {
        this.handleHoverSelectedLinearElement(
          this.state.selectedLinearElement,
          scenePointerX,
          scenePointerY
        );
      }
      if ((!this.state.selectedLinearElement || this.state.selectedLinearElement.hoverPointIndex === -1) && !(selectedElements.length === 1 && isElbowArrow(selectedElements[0]))) {
        const elementWithTransformHandleType = getElementWithTransformHandleType(
          elements,
          this.state,
          scenePointerX,
          scenePointerY,
          this.state.zoom,
          event.pointerType,
          this.scene.getNonDeletedElementsMap(),
          this.device
        );
        if (elementWithTransformHandleType && elementWithTransformHandleType.transformHandleType) {
          setCursor(
            this.interactiveCanvas,
            getCursorForResizingElement(elementWithTransformHandleType)
          );
          return;
        }
      }
    } else if (selectedElements.length > 1 && !isOverScrollBar) {
      const transformHandleType = getTransformHandleTypeFromCoords(
        getCommonBounds(selectedElements),
        scenePointerX,
        scenePointerY,
        this.state.zoom,
        event.pointerType,
        this.device
      );
      if (transformHandleType) {
        setCursor(
          this.interactiveCanvas,
          getCursorForResizingElement({
            transformHandleType
          })
        );
        return;
      }
    }
    const hitElement = this.getElementAtPosition(
      scenePointer.x,
      scenePointer.y
    );
    this.hitLinkElement = this.getElementLinkAtPosition(
      scenePointer,
      hitElement
    );
    if (isEraserActive(this.state)) {
      return;
    }
    if (this.hitLinkElement && !this.state.selectedElementIds[this.hitLinkElement.id]) {
      setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
      showHyperlinkTooltip(
        this.hitLinkElement,
        this.state,
        this.scene.getNonDeletedElementsMap()
      );
    } else {
      hideHyperlinkToolip();
      if (hitElement && (hitElement.link || isEmbeddableElement(hitElement)) && this.state.selectedElementIds[hitElement.id] && !this.state.contextMenu && !this.state.showHyperlinkPopup) {
        this.setState({ showHyperlinkPopup: "info" });
      } else if (this.state.activeTool.type === "text") {
        setCursor(
          this.interactiveCanvas,
          isTextElement(hitElement) ? CURSOR_TYPE.TEXT : CURSOR_TYPE.CROSSHAIR
        );
      } else if (this.state.viewModeEnabled) {
        setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);
      } else if (isOverScrollBar) {
        setCursor(this.interactiveCanvas, CURSOR_TYPE.AUTO);
      } else if (this.state.selectedLinearElement) {
        this.handleHoverSelectedLinearElement(
          this.state.selectedLinearElement,
          scenePointerX,
          scenePointerY
        );
      } else if (
        // if using cmd/ctrl, we're not dragging
        !event[KEYS.CTRL_OR_CMD]
      ) {
        if ((hitElement || this.isHittingCommonBoundingBoxOfSelectedElements(
          scenePointer,
          selectedElements
        )) && !hitElement?.locked) {
          if (hitElement && isIframeLikeElement(hitElement) && this.isIframeLikeElementCenter(
            hitElement,
            event,
            scenePointerX,
            scenePointerY
          )) {
            setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
            this.setState({
              activeEmbeddable: { element: hitElement, state: "hover" }
            });
          } else {
            setCursor(this.interactiveCanvas, CURSOR_TYPE.MOVE);
            if (this.state.activeEmbeddable?.state === "hover") {
              this.setState({ activeEmbeddable: null });
            }
          }
        }
      } else {
        setCursor(this.interactiveCanvas, CURSOR_TYPE.AUTO);
      }
    }
  };
  handleEraser = (event, pointerDownState, scenePointer) => {
    this.eraserTrail.addPointToPath(scenePointer.x, scenePointer.y);
    let didChange = false;
    const processedGroups = /* @__PURE__ */ new Set();
    const nonDeletedElements = this.scene.getNonDeletedElements();
    const processElements = (elements) => {
      for (const element of elements) {
        if (element.locked) {
          return;
        }
        if (event.altKey) {
          if (this.elementsPendingErasure.delete(element.id)) {
            didChange = true;
          }
        } else if (!this.elementsPendingErasure.has(element.id)) {
          didChange = true;
          this.elementsPendingErasure.add(element.id);
        }
        if (didChange && element.groupIds?.length) {
          const shallowestGroupId = element.groupIds.at(-1);
          if (!processedGroups.has(shallowestGroupId)) {
            processedGroups.add(shallowestGroupId);
            const elems = getElementsInGroup(
              nonDeletedElements,
              shallowestGroupId
            );
            for (const elem of elems) {
              if (event.altKey) {
                this.elementsPendingErasure.delete(elem.id);
              } else {
                this.elementsPendingErasure.add(elem.id);
              }
            }
          }
        }
      }
    };
    const distance3 = pointDistance(
      pointFrom(pointerDownState.lastCoords.x, pointerDownState.lastCoords.y),
      pointFrom(scenePointer.x, scenePointer.y)
    );
    const threshold = this.getElementHitThreshold();
    const p = { ...pointerDownState.lastCoords };
    let samplingInterval = 0;
    while (samplingInterval <= distance3) {
      const hitElements = this.getElementsAtPosition(p.x, p.y);
      processElements(hitElements);
      if (samplingInterval === distance3) {
        break;
      }
      samplingInterval = Math.min(samplingInterval + threshold, distance3);
      const distanceRatio = samplingInterval / distance3;
      const nextX = (1 - distanceRatio) * p.x + distanceRatio * scenePointer.x;
      const nextY = (1 - distanceRatio) * p.y + distanceRatio * scenePointer.y;
      p.x = nextX;
      p.y = nextY;
    }
    pointerDownState.lastCoords.x = scenePointer.x;
    pointerDownState.lastCoords.y = scenePointer.y;
    if (didChange) {
      for (const element of this.scene.getNonDeletedElements()) {
        if (isBoundToContainer(element) && (this.elementsPendingErasure.has(element.id) || this.elementsPendingErasure.has(element.containerId))) {
          if (event.altKey) {
            this.elementsPendingErasure.delete(element.id);
            this.elementsPendingErasure.delete(element.containerId);
          } else {
            this.elementsPendingErasure.add(element.id);
            this.elementsPendingErasure.add(element.containerId);
          }
        }
      }
      this.elementsPendingErasure = new Set(this.elementsPendingErasure);
      this.triggerRender();
    }
  };
  // set touch moving for mobile context menu
  handleTouchMove = (event) => {
    invalidateContextMenu = true;
  };
  handleHoverSelectedLinearElement(linearElementEditor, scenePointerX, scenePointerY) {
    const elementsMap = this.scene.getNonDeletedElementsMap();
    const element = LinearElementEditor.getElement(
      linearElementEditor.elementId,
      elementsMap
    );
    if (!element) {
      return;
    }
    if (this.state.selectedLinearElement) {
      let hoverPointIndex = -1;
      let segmentMidPointHoveredCoords = null;
      if (hitElementItself({
        x: scenePointerX,
        y: scenePointerY,
        element,
        shape: getElementShape(
          element,
          this.scene.getNonDeletedElementsMap()
        )
      })) {
        hoverPointIndex = LinearElementEditor.getPointIndexUnderCursor(
          element,
          elementsMap,
          this.state.zoom,
          scenePointerX,
          scenePointerY
        );
        segmentMidPointHoveredCoords = LinearElementEditor.getSegmentMidpointHitCoords(
          linearElementEditor,
          { x: scenePointerX, y: scenePointerY },
          this.state,
          this.scene.getNonDeletedElementsMap()
        );
        if (hoverPointIndex >= 0 || segmentMidPointHoveredCoords) {
          setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
        } else if (this.hitElement(scenePointerX, scenePointerY, element)) {
          setCursor(this.interactiveCanvas, CURSOR_TYPE.MOVE);
        }
      } else if (this.hitElement(scenePointerX, scenePointerY, element)) {
        if (!isElbowArrow(element) || !(element.startBinding || element.endBinding)) {
          setCursor(this.interactiveCanvas, CURSOR_TYPE.MOVE);
        }
      }
      if (this.state.selectedLinearElement.hoverPointIndex !== hoverPointIndex) {
        this.setState({
          selectedLinearElement: {
            ...this.state.selectedLinearElement,
            hoverPointIndex
          }
        });
      }
      if (!LinearElementEditor.arePointsEqual(
        this.state.selectedLinearElement.segmentMidPointHoveredCoords,
        segmentMidPointHoveredCoords
      )) {
        this.setState({
          selectedLinearElement: {
            ...this.state.selectedLinearElement,
            segmentMidPointHoveredCoords
          }
        });
      }
    } else {
      setCursor(this.interactiveCanvas, CURSOR_TYPE.AUTO);
    }
  }
  handleCanvasPointerDown = (event) => {
    this.maybeCleanupAfterMissingPointerUp(event.nativeEvent);
    this.maybeUnfollowRemoteUser();
    if (this.state.searchMatches) {
      this.setState((state) => ({
        searchMatches: state.searchMatches.map((searchMatch) => ({
          ...searchMatch,
          focus: false
        }))
      }));
      jotaiStore.set(searchItemInFocusAtom, null);
    }
    if (this.state.contextMenu) {
      this.setState({ contextMenu: null });
    }
    if (this.state.snapLines) {
      this.setAppState({ snapLines: [] });
    }
    this.updateGestureOnPointerDown(event);
    if (event.pointerType === "touch" && this.state.newElement && this.state.newElement.type === "freedraw") {
      const element = this.state.newElement;
      this.updateScene({
        ...element.points.length < 10 ? {
          elements: this.scene.getElementsIncludingDeleted().filter((el) => el.id !== element.id)
        } : {},
        appState: {
          newElement: null,
          editingTextElement: null,
          startBoundElement: null,
          suggestedBindings: [],
          selectedElementIds: makeNextSelectedElementIds(
            Object.keys(this.state.selectedElementIds).filter((key) => key !== element.id).reduce((obj, key) => {
              obj[key] = this.state.selectedElementIds[key];
              return obj;
            }, {}),
            this.state
          )
        },
        storeAction: StoreAction.UPDATE
      });
      return;
    }
    const selection = document.getSelection();
    if (selection?.anchorNode) {
      selection.removeAllRanges();
    }
    this.maybeOpenContextMenuAfterPointerDownOnTouchDevices(event);
    if (!this.state.penDetected && event.pointerType === "pen") {
      this.setState((prevState) => {
        return {
          penMode: true,
          penDetected: true
        };
      });
    }
    if (!this.device.isTouchScreen && ["pen", "touch"].includes(event.pointerType)) {
      this.device = updateObject(this.device, { isTouchScreen: true });
    }
    if (isPanning) {
      return;
    }
    this.lastPointerDownEvent = event;
    if (this.handleCanvasPanUsingWheelOrSpaceDrag(event)) {
      return;
    }
    this.setState({
      lastPointerDownWith: event.pointerType,
      cursorButton: "down"
    });
    this.savePointer(event.clientX, event.clientY, "down");
    if (event.button === POINTER_BUTTON.ERASER && this.state.activeTool.type !== TOOL_TYPE.eraser) {
      this.setState(
        {
          activeTool: updateActiveTool(this.state, {
            type: TOOL_TYPE.eraser,
            lastActiveToolBeforeEraser: this.state.activeTool
          })
        },
        () => {
          this.handleCanvasPointerDown(event);
          const onPointerUp2 = () => {
            unsubPointerUp();
            unsubCleanup?.();
            if (isEraserActive(this.state)) {
              this.setState({
                activeTool: updateActiveTool(this.state, {
                  ...this.state.activeTool.lastActiveTool || {
                    type: TOOL_TYPE.selection
                  },
                  lastActiveToolBeforeEraser: null
                })
              });
            }
          };
          const unsubPointerUp = addEventListener(
            window,
            "pointerup" /* POINTER_UP */,
            onPointerUp2,
            {
              once: true
            }
          );
          let unsubCleanup;
          requestAnimationFrame(() => {
            unsubCleanup = this.missingPointerEventCleanupEmitter.once(onPointerUp2);
          });
        }
      );
      return;
    }
    if (event.button !== POINTER_BUTTON.MAIN && event.button !== POINTER_BUTTON.TOUCH && event.button !== POINTER_BUTTON.ERASER) {
      return;
    }
    if (gesture.pointers.size > 1) {
      return;
    }
    const pointerDownState = this.initialPointerDownState(event);
    this.setState({
      selectedElementsAreBeingDragged: false
    });
    if (this.handleDraggingScrollBar(event, pointerDownState)) {
      return;
    }
    this.clearSelectionIfNotUsingSelection();
    this.updateBindingEnabledOnPointerMove(event);
    if (this.handleSelectionOnPointerDown(event, pointerDownState)) {
      return;
    }
    const allowOnPointerDown = !this.state.penMode || event.pointerType !== "touch" || this.state.activeTool.type === "selection" || this.state.activeTool.type === "text" || this.state.activeTool.type === "image";
    if (!allowOnPointerDown) {
      return;
    }
    if (this.state.activeTool.type === "text") {
      this.handleTextOnPointerDown(event, pointerDownState);
    } else if (this.state.activeTool.type === "arrow" || this.state.activeTool.type === "line") {
      this.handleLinearElementOnPointerDown(
        event,
        this.state.activeTool.type,
        pointerDownState
      );
    } else if (this.state.activeTool.type === "image") {
      setCursor(this.interactiveCanvas, CURSOR_TYPE.CROSSHAIR);
      const pendingImageElement = this.state.pendingImageElementId && this.scene.getElement(this.state.pendingImageElementId);
      if (!pendingImageElement) {
        return;
      }
      this.setState({
        newElement: pendingImageElement,
        pendingImageElementId: null,
        multiElement: null
      });
      const { x, y } = viewportCoordsToSceneCoords(event, this.state);
      const frame = this.getTopLayerFrameAtSceneCoords({ x, y });
      mutateElement(pendingImageElement, {
        x,
        y,
        frameId: frame ? frame.id : null
      });
    } else if (this.state.activeTool.type === "freedraw") {
      this.handleFreeDrawElementOnPointerDown(
        event,
        this.state.activeTool.type,
        pointerDownState
      );
    } else if (this.state.activeTool.type === "custom") {
      setCursorForShape(this.interactiveCanvas, this.state);
    } else if (this.state.activeTool.type === TOOL_TYPE.frame || this.state.activeTool.type === TOOL_TYPE.magicframe) {
      this.createFrameElementOnPointerDown(
        pointerDownState,
        this.state.activeTool.type
      );
    } else if (this.state.activeTool.type === "laser") {
      this.laserTrails.startPath(
        pointerDownState.lastCoords.x,
        pointerDownState.lastCoords.y
      );
    } else if (this.state.activeTool.type !== "eraser" && this.state.activeTool.type !== "hand") {
      this.createGenericElementOnPointerDown(
        this.state.activeTool.type,
        pointerDownState
      );
    }
    this.props?.onPointerDown?.(this.state.activeTool, pointerDownState);
    this.onPointerDownEmitter.trigger(
      this.state.activeTool,
      pointerDownState,
      event
    );
    if (this.state.activeTool.type === "eraser") {
      this.eraserTrail.startPath(
        pointerDownState.lastCoords.x,
        pointerDownState.lastCoords.y
      );
    }
    const onPointerMove = this.onPointerMoveFromPointerDownHandler(pointerDownState);
    const onPointerUp = this.onPointerUpFromPointerDownHandler(pointerDownState);
    const onKeyDown = this.onKeyDownFromPointerDownHandler(pointerDownState);
    const onKeyUp = this.onKeyUpFromPointerDownHandler(pointerDownState);
    this.missingPointerEventCleanupEmitter.once(
      (_event) => onPointerUp(_event || event.nativeEvent)
    );
    if (!this.state.viewModeEnabled || this.state.activeTool.type === "laser") {
      window.addEventListener("pointermove" /* POINTER_MOVE */, onPointerMove);
      window.addEventListener("pointerup" /* POINTER_UP */, onPointerUp);
      window.addEventListener("keydown" /* KEYDOWN */, onKeyDown);
      window.addEventListener("keyup" /* KEYUP */, onKeyUp);
      pointerDownState.eventListeners.onMove = onPointerMove;
      pointerDownState.eventListeners.onUp = onPointerUp;
      pointerDownState.eventListeners.onKeyUp = onKeyUp;
      pointerDownState.eventListeners.onKeyDown = onKeyDown;
    }
  };
  handleCanvasPointerUp = (event) => {
    this.removePointer(event);
    this.lastPointerUpEvent = event;
    const scenePointer = viewportCoordsToSceneCoords(
      { clientX: event.clientX, clientY: event.clientY },
      this.state
    );
    const clicklength = event.timeStamp - (this.lastPointerDownEvent?.timeStamp ?? 0);
    if (this.device.editor.isMobile && clicklength < 300) {
      const hitElement = this.getElementAtPosition(
        scenePointer.x,
        scenePointer.y
      );
      if (isIframeLikeElement(hitElement) && this.isIframeLikeElementCenter(
        hitElement,
        event,
        scenePointer.x,
        scenePointer.y
      )) {
        this.handleEmbeddableCenterClick(hitElement);
        return;
      }
    }
    if (this.device.isTouchScreen) {
      const hitElement = this.getElementAtPosition(
        scenePointer.x,
        scenePointer.y
      );
      this.hitLinkElement = this.getElementLinkAtPosition(
        scenePointer,
        hitElement
      );
    }
    if (this.hitLinkElement && !this.state.selectedElementIds[this.hitLinkElement.id]) {
      if (clicklength < 300 && isIframeLikeElement(this.hitLinkElement) && !isPointHittingLinkIcon(
        this.hitLinkElement,
        this.scene.getNonDeletedElementsMap(),
        this.state,
        pointFrom(scenePointer.x, scenePointer.y)
      )) {
        this.handleEmbeddableCenterClick(this.hitLinkElement);
      } else {
        this.redirectToLink(event, this.device.isTouchScreen);
      }
    } else if (this.state.viewModeEnabled) {
      this.setState({
        activeEmbeddable: null,
        selectedElementIds: {}
      });
    }
  };
  maybeOpenContextMenuAfterPointerDownOnTouchDevices = (event) => {
    if (event.pointerType === "touch") {
      invalidateContextMenu = false;
      if (touchTimeout) {
        invalidateContextMenu = true;
      } else {
        touchTimeout = window.setTimeout(() => {
          touchTimeout = 0;
          if (!invalidateContextMenu) {
            this.handleCanvasContextMenu(event);
          }
        }, TOUCH_CTX_MENU_TIMEOUT);
      }
    }
  };
  resetContextMenuTimer = () => {
    clearTimeout(touchTimeout);
    touchTimeout = 0;
    invalidateContextMenu = false;
  };
  /**
   * pointerup may not fire in certian cases (user tabs away...), so in order
   * to properly cleanup pointerdown state, we need to fire any hanging
   * pointerup handlers manually
   */
  maybeCleanupAfterMissingPointerUp = (event) => {
    lastPointerUp?.();
    this.missingPointerEventCleanupEmitter.trigger(event).clear();
  };
  // Returns whether the event is a panning
  handleCanvasPanUsingWheelOrSpaceDrag = (event) => {
    if (!(gesture.pointers.size <= 1 && (event.button === POINTER_BUTTON.WHEEL || event.button === POINTER_BUTTON.MAIN && isHoldingSpace || isHandToolActive(this.state) || this.state.viewModeEnabled))) {
      return false;
    }
    isPanning = true;
    this.focusContainer();
    if (!this.state.editingTextElement) {
      event.preventDefault();
    }
    let nextPastePrevented = false;
    const isLinux = typeof window === void 0 ? false : /Linux/.test(window.navigator.platform);
    setCursor(this.interactiveCanvas, CURSOR_TYPE.GRABBING);
    let { clientX: lastX, clientY: lastY } = event;
    const onPointerMove = withBatchedUpdatesThrottled((event2) => {
      const deltaX = lastX - event2.clientX;
      const deltaY = lastY - event2.clientY;
      lastX = event2.clientX;
      lastY = event2.clientY;
      if (isLinux && !nextPastePrevented && (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1)) {
        nextPastePrevented = true;
        const preventNextPaste = (event3) => {
          document.body.removeEventListener("paste" /* PASTE */, preventNextPaste);
          event3.stopPropagation();
        };
        const enableNextPaste = () => {
          setTimeout(() => {
            document.body.removeEventListener("paste" /* PASTE */, preventNextPaste);
            window.removeEventListener("pointerup" /* POINTER_UP */, enableNextPaste);
          }, 100);
        };
        document.body.addEventListener("paste" /* PASTE */, preventNextPaste);
        window.addEventListener("pointerup" /* POINTER_UP */, enableNextPaste);
      }
      this.translateCanvas({
        scrollX: this.state.scrollX - deltaX / this.state.zoom.value,
        scrollY: this.state.scrollY - deltaY / this.state.zoom.value
      });
    });
    const teardown = withBatchedUpdates(
      lastPointerUp = () => {
        lastPointerUp = null;
        isPanning = false;
        if (!isHoldingSpace) {
          if (this.state.viewModeEnabled) {
            setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);
          } else {
            setCursorForShape(this.interactiveCanvas, this.state);
          }
        }
        this.setState({
          cursorButton: "up"
        });
        this.savePointer(event.clientX, event.clientY, "up");
        window.removeEventListener("pointermove" /* POINTER_MOVE */, onPointerMove);
        window.removeEventListener("pointerup" /* POINTER_UP */, teardown);
        window.removeEventListener("blur" /* BLUR */, teardown);
        onPointerMove.flush();
      }
    );
    window.addEventListener("blur" /* BLUR */, teardown);
    window.addEventListener("pointermove" /* POINTER_MOVE */, onPointerMove, {
      passive: true
    });
    window.addEventListener("pointerup" /* POINTER_UP */, teardown);
    return true;
  };
  updateGestureOnPointerDown(event) {
    gesture.pointers.set(event.pointerId, {
      x: event.clientX,
      y: event.clientY
    });
    if (gesture.pointers.size === 2) {
      gesture.lastCenter = getCenter(gesture.pointers);
      gesture.initialScale = this.state.zoom.value;
      gesture.initialDistance = getDistance(
        Array.from(gesture.pointers.values())
      );
    }
  }
  initialPointerDownState(event) {
    const origin = viewportCoordsToSceneCoords(event, this.state);
    const selectedElements = this.scene.getSelectedElements(this.state);
    const [minX, minY, maxX, maxY] = getCommonBounds(selectedElements);
    const isElbowArrowOnly = selectedElements.findIndex(isElbowArrow) === 0;
    return {
      origin,
      withCmdOrCtrl: event[KEYS.CTRL_OR_CMD],
      originInGrid: tupleToCoors(
        getGridPoint(
          origin.x,
          origin.y,
          event[KEYS.CTRL_OR_CMD] || isElbowArrowOnly ? null : this.getEffectiveGridSize()
        )
      ),
      scrollbars: isOverScrollBars(
        currentScrollBars,
        event.clientX - this.state.offsetLeft,
        event.clientY - this.state.offsetTop
      ),
      // we need to duplicate because we'll be updating this state
      lastCoords: { ...origin },
      originalElements: this.scene.getNonDeletedElements().reduce((acc, element) => {
        acc.set(element.id, deepCopyElement(element));
        return acc;
      }, /* @__PURE__ */ new Map()),
      resize: {
        handleType: false,
        isResizing: false,
        offset: { x: 0, y: 0 },
        arrowDirection: "origin",
        center: { x: (maxX + minX) / 2, y: (maxY + minY) / 2 }
      },
      hit: {
        element: null,
        allHitElements: [],
        wasAddedToSelection: false,
        hasBeenDuplicated: false,
        hasHitCommonBoundingBoxOfSelectedElements: this.isHittingCommonBoundingBoxOfSelectedElements(
          origin,
          selectedElements
        )
      },
      drag: {
        hasOccurred: false,
        offset: null
      },
      eventListeners: {
        onMove: null,
        onUp: null,
        onKeyUp: null,
        onKeyDown: null
      },
      boxSelection: {
        hasOccurred: false
      }
    };
  }
  // Returns whether the event is a dragging a scrollbar
  handleDraggingScrollBar(event, pointerDownState) {
    if (!(pointerDownState.scrollbars.isOverEither && !this.state.multiElement)) {
      return false;
    }
    isDraggingScrollBar = true;
    pointerDownState.lastCoords.x = event.clientX;
    pointerDownState.lastCoords.y = event.clientY;
    const onPointerMove = withBatchedUpdatesThrottled((event2) => {
      const target = event2.target;
      if (!(target instanceof HTMLElement)) {
        return;
      }
      this.handlePointerMoveOverScrollbars(event2, pointerDownState);
    });
    const onPointerUp = withBatchedUpdates(() => {
      lastPointerUp = null;
      isDraggingScrollBar = false;
      setCursorForShape(this.interactiveCanvas, this.state);
      this.setState({
        cursorButton: "up"
      });
      this.savePointer(event.clientX, event.clientY, "up");
      window.removeEventListener("pointermove" /* POINTER_MOVE */, onPointerMove);
      window.removeEventListener("pointerup" /* POINTER_UP */, onPointerUp);
      onPointerMove.flush();
    });
    lastPointerUp = onPointerUp;
    window.addEventListener("pointermove" /* POINTER_MOVE */, onPointerMove);
    window.addEventListener("pointerup" /* POINTER_UP */, onPointerUp);
    return true;
  }
  clearSelectionIfNotUsingSelection = () => {
    if (this.state.activeTool.type !== "selection") {
      this.setState({
        selectedElementIds: makeNextSelectedElementIds({}, this.state),
        selectedGroupIds: {},
        editingGroupId: null,
        activeEmbeddable: null
      });
    }
  };
  /**
   * @returns whether the pointer event has been completely handled
   */
  handleSelectionOnPointerDown = (event, pointerDownState) => {
    if (this.state.activeTool.type === "selection") {
      const elements = this.scene.getNonDeletedElements();
      const elementsMap = this.scene.getNonDeletedElementsMap();
      const selectedElements = this.scene.getSelectedElements(this.state);
      if (selectedElements.length === 1 && !this.state.editingLinearElement && !(this.state.selectedLinearElement && this.state.selectedLinearElement.hoverPointIndex !== -1)) {
        const elementWithTransformHandleType = getElementWithTransformHandleType(
          elements,
          this.state,
          pointerDownState.origin.x,
          pointerDownState.origin.y,
          this.state.zoom,
          event.pointerType,
          this.scene.getNonDeletedElementsMap(),
          this.device
        );
        if (elementWithTransformHandleType != null) {
          this.setState({
            resizingElement: elementWithTransformHandleType.element
          });
          pointerDownState.resize.handleType = elementWithTransformHandleType.transformHandleType;
        }
      } else if (selectedElements.length > 1) {
        pointerDownState.resize.handleType = getTransformHandleTypeFromCoords(
          getCommonBounds(selectedElements),
          pointerDownState.origin.x,
          pointerDownState.origin.y,
          this.state.zoom,
          event.pointerType,
          this.device
        );
      }
      if (pointerDownState.resize.handleType) {
        pointerDownState.resize.isResizing = true;
        pointerDownState.resize.offset = tupleToCoors(
          getResizeOffsetXY(
            pointerDownState.resize.handleType,
            selectedElements,
            elementsMap,
            pointerDownState.origin.x,
            pointerDownState.origin.y
          )
        );
        if (selectedElements.length === 1 && isLinearElement(selectedElements[0]) && selectedElements[0].points.length === 2) {
          pointerDownState.resize.arrowDirection = getResizeArrowDirection(
            pointerDownState.resize.handleType,
            selectedElements[0]
          );
        }
      } else {
        if (this.state.selectedLinearElement) {
          const linearElementEditor = this.state.editingLinearElement || this.state.selectedLinearElement;
          const ret = LinearElementEditor.handlePointerDown(
            event,
            this,
            this.store,
            pointerDownState.origin,
            linearElementEditor,
            this.scene
          );
          if (ret.hitElement) {
            pointerDownState.hit.element = ret.hitElement;
          }
          if (ret.linearElementEditor) {
            this.setState({ selectedLinearElement: ret.linearElementEditor });
            if (this.state.editingLinearElement) {
              this.setState({ editingLinearElement: ret.linearElementEditor });
            }
          }
          if (ret.didAddPoint) {
            return true;
          }
        }
        pointerDownState.hit.element = pointerDownState.hit.element ?? this.getElementAtPosition(
          pointerDownState.origin.x,
          pointerDownState.origin.y
        );
        if (pointerDownState.hit.element) {
          const hitLinkElement = this.getElementLinkAtPosition(
            {
              x: pointerDownState.origin.x,
              y: pointerDownState.origin.y
            },
            pointerDownState.hit.element
          );
          if (hitLinkElement) {
            return false;
          }
        }
        pointerDownState.hit.allHitElements = this.getElementsAtPosition(
          pointerDownState.origin.x,
          pointerDownState.origin.y
        );
        const hitElement = pointerDownState.hit.element;
        const someHitElementIsSelected = pointerDownState.hit.allHitElements.some(
          (element) => this.isASelectedElement(element)
        );
        if ((hitElement === null || !someHitElementIsSelected) && !event.shiftKey && !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements) {
          this.clearSelection(hitElement);
        }
        if (this.state.editingLinearElement) {
          this.setState({
            selectedElementIds: makeNextSelectedElementIds(
              {
                [this.state.editingLinearElement.elementId]: true
              },
              this.state
            )
          });
        } else if (hitElement != null) {
          if (event[KEYS.CTRL_OR_CMD]) {
            if (!this.state.selectedElementIds[hitElement.id]) {
              pointerDownState.hit.wasAddedToSelection = true;
            }
            this.setState((prevState) => ({
              ...editGroupForSelectedElement(prevState, hitElement),
              previousSelectedElementIds: this.state.selectedElementIds
            }));
            return false;
          }
          if (!this.state.selectedElementIds[hitElement.id]) {
            if (this.state.editingGroupId && !isElementInGroup(hitElement, this.state.editingGroupId)) {
              this.setState({
                selectedElementIds: makeNextSelectedElementIds({}, this.state),
                selectedGroupIds: {},
                editingGroupId: null,
                activeEmbeddable: null
              });
            }
            if (!someHitElementIsSelected && !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements) {
              this.setState((prevState) => {
                const nextSelectedElementIds = {
                  ...prevState.selectedElementIds,
                  [hitElement.id]: true
                };
                const previouslySelectedElements = [];
                Object.keys(prevState.selectedElementIds).forEach((id) => {
                  const element = this.scene.getElement(id);
                  element && previouslySelectedElements.push(element);
                });
                if (isFrameLikeElement(hitElement)) {
                  getFrameChildren(
                    previouslySelectedElements,
                    hitElement.id
                  ).forEach((element) => {
                    delete nextSelectedElementIds[element.id];
                  });
                } else if (hitElement.frameId) {
                  if (nextSelectedElementIds[hitElement.frameId]) {
                    delete nextSelectedElementIds[hitElement.id];
                  }
                } else {
                  const groupIds = hitElement.groupIds;
                  const framesInGroups = new Set(
                    groupIds.flatMap(
                      (gid) => getElementsInGroup(
                        this.scene.getNonDeletedElements(),
                        gid
                      )
                    ).filter((element) => isFrameLikeElement(element)).map((frame) => frame.id)
                  );
                  if (framesInGroups.size > 0) {
                    previouslySelectedElements.forEach((element) => {
                      if (element.frameId && framesInGroups.has(element.frameId)) {
                        delete nextSelectedElementIds[element.id];
                        element.groupIds.flatMap(
                          (gid) => getElementsInGroup(
                            this.scene.getNonDeletedElements(),
                            gid
                          )
                        ).forEach((element2) => {
                          delete nextSelectedElementIds[element2.id];
                        });
                      }
                    });
                  }
                }
                return {
                  ...selectGroupsForSelectedElements(
                    {
                      editingGroupId: prevState.editingGroupId,
                      selectedElementIds: nextSelectedElementIds
                    },
                    this.scene.getNonDeletedElements(),
                    prevState,
                    this
                  ),
                  showHyperlinkPopup: hitElement.link || isEmbeddableElement(hitElement) ? "info" : false
                };
              });
              pointerDownState.hit.wasAddedToSelection = true;
            }
          }
        }
        this.setState({
          previousSelectedElementIds: this.state.selectedElementIds
        });
      }
    }
    return false;
  };
  isASelectedElement(hitElement) {
    return hitElement != null && this.state.selectedElementIds[hitElement.id];
  }
  isHittingCommonBoundingBoxOfSelectedElements(point2, selectedElements) {
    if (selectedElements.length < 2) {
      return false;
    }
    const threshold = this.getElementHitThreshold();
    const [x1, y1, x2, y2] = getCommonBounds(selectedElements);
    return point2.x > x1 - threshold && point2.x < x2 + threshold && point2.y > y1 - threshold && point2.y < y2 + threshold;
  }
  handleTextOnPointerDown = (event, pointerDownState) => {
    if (this.state.editingTextElement) {
      return;
    }
    let sceneX = pointerDownState.origin.x;
    let sceneY = pointerDownState.origin.y;
    const element = this.getElementAtPosition(sceneX, sceneY, {
      includeBoundTextElement: true
    });
    let container = this.getTextBindableContainerAtPosition(sceneX, sceneY);
    if (hasBoundTextElement(element)) {
      container = element;
      sceneX = element.x + element.width / 2;
      sceneY = element.y + element.height / 2;
    }
    this.startTextEditing({
      sceneX,
      sceneY,
      insertAtParentCenter: !event.altKey,
      container,
      autoEdit: false
    });
    resetCursor(this.interactiveCanvas);
    if (!this.state.activeTool.locked) {
      this.setState({
        activeTool: updateActiveTool(this.state, { type: "selection" })
      });
    }
  };
  handleFreeDrawElementOnPointerDown = (event, elementType, pointerDownState) => {
    const [gridX, gridY] = getGridPoint(
      pointerDownState.origin.x,
      pointerDownState.origin.y,
      null
    );
    const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
      x: gridX,
      y: gridY
    });
    const simulatePressure = event.pressure === 0.5;
    const element = newFreeDrawElement({
      type: elementType,
      x: gridX,
      y: gridY,
      strokeColor: this.state.currentItemStrokeColor,
      backgroundColor: this.state.currentItemBackgroundColor,
      fillStyle: this.state.currentItemFillStyle,
      strokeWidth: this.state.currentItemStrokeWidth,
      strokeStyle: this.state.currentItemStrokeStyle,
      roughness: this.state.currentItemRoughness,
      opacity: this.state.currentItemOpacity,
      roundness: null,
      simulatePressure,
      locked: false,
      frameId: topLayerFrame ? topLayerFrame.id : null,
      points: [pointFrom(0, 0)],
      pressures: simulatePressure ? [] : [event.pressure]
    });
    this.scene.insertElement(element);
    this.setState((prevState) => {
      const nextSelectedElementIds = {
        ...prevState.selectedElementIds
      };
      delete nextSelectedElementIds[element.id];
      return {
        selectedElementIds: makeNextSelectedElementIds(
          nextSelectedElementIds,
          prevState
        )
      };
    });
    const boundElement = getHoveredElementForBinding(
      pointerDownState.origin,
      this.scene.getNonDeletedElements(),
      this.scene.getNonDeletedElementsMap()
    );
    this.setState({
      newElement: element,
      startBoundElement: boundElement,
      suggestedBindings: []
    });
  };
  insertIframeElement = ({
    sceneX,
    sceneY,
    width,
    height
  }) => {
    const [gridX, gridY] = getGridPoint(
      sceneX,
      sceneY,
      this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
    );
    const element = newIframeElement({
      type: "iframe",
      x: gridX,
      y: gridY,
      strokeColor: "transparent",
      backgroundColor: "transparent",
      fillStyle: this.state.currentItemFillStyle,
      strokeWidth: this.state.currentItemStrokeWidth,
      strokeStyle: this.state.currentItemStrokeStyle,
      roughness: this.state.currentItemRoughness,
      roundness: this.getCurrentItemRoundness("iframe"),
      opacity: this.state.currentItemOpacity,
      locked: false,
      width,
      height
    });
    this.scene.insertElement(element);
    return element;
  };
  //create rectangle element with youtube top left on nearest grid point width / hight 640/360
  insertEmbeddableElement = ({
    sceneX,
    sceneY,
    link
  }) => {
    const [gridX, gridY] = getGridPoint(
      sceneX,
      sceneY,
      this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
    );
    const embedLink = getEmbedLink(link);
    if (!embedLink) {
      return;
    }
    if (embedLink.error instanceof URIError) {
      this.setToast({
        message: t("toast.unrecognizedLinkFormat"),
        closable: true
      });
    }
    const element = newEmbeddableElement({
      type: "embeddable",
      x: gridX,
      y: gridY,
      strokeColor: "transparent",
      backgroundColor: "transparent",
      fillStyle: this.state.currentItemFillStyle,
      strokeWidth: this.state.currentItemStrokeWidth,
      strokeStyle: this.state.currentItemStrokeStyle,
      roughness: this.state.currentItemRoughness,
      roundness: this.getCurrentItemRoundness("embeddable"),
      opacity: this.state.currentItemOpacity,
      locked: false,
      width: embedLink.intrinsicSize.w,
      height: embedLink.intrinsicSize.h,
      link
    });
    this.scene.insertElement(element);
    return element;
  };
  createImageElement = ({
    sceneX,
    sceneY,
    addToFrameUnderCursor = true
  }) => {
    const [gridX, gridY] = getGridPoint(
      sceneX,
      sceneY,
      this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
    );
    const topLayerFrame = addToFrameUnderCursor ? this.getTopLayerFrameAtSceneCoords({
      x: gridX,
      y: gridY
    }) : null;
    const element = newImageElement({
      type: "image",
      x: gridX,
      y: gridY,
      strokeColor: this.state.currentItemStrokeColor,
      backgroundColor: this.state.currentItemBackgroundColor,
      fillStyle: this.state.currentItemFillStyle,
      strokeWidth: this.state.currentItemStrokeWidth,
      strokeStyle: this.state.currentItemStrokeStyle,
      roughness: this.state.currentItemRoughness,
      roundness: null,
      opacity: this.state.currentItemOpacity,
      locked: false,
      frameId: topLayerFrame ? topLayerFrame.id : null
    });
    return element;
  };
  handleLinearElementOnPointerDown = (event, elementType, pointerDownState) => {
    if (this.state.multiElement) {
      const { multiElement } = this.state;
      if (multiElement.type === "line" && isPathALoop(multiElement.points, this.state.zoom.value)) {
        mutateElement(multiElement, {
          lastCommittedPoint: multiElement.points[multiElement.points.length - 1]
        });
        this.actionManager.executeAction(actionFinalize);
        return;
      }
      if (isElbowArrow(multiElement) && multiElement.points.length > 1) {
        mutateElement(multiElement, {
          lastCommittedPoint: multiElement.points[multiElement.points.length - 1]
        });
        this.actionManager.executeAction(actionFinalize);
        return;
      }
      const { x: rx, y: ry, lastCommittedPoint } = multiElement;
      if (multiElement.points.length > 1 && lastCommittedPoint && pointDistance(
        pointFrom(
          pointerDownState.origin.x - rx,
          pointerDownState.origin.y - ry
        ),
        lastCommittedPoint
      ) < LINE_CONFIRM_THRESHOLD) {
        this.actionManager.executeAction(actionFinalize);
        return;
      }
      this.setState((prevState) => ({
        selectedElementIds: makeNextSelectedElementIds(
          {
            ...prevState.selectedElementIds,
            [multiElement.id]: true
          },
          prevState
        )
      }));
      mutateElement(multiElement, {
        lastCommittedPoint: multiElement.points[multiElement.points.length - 1]
      });
      setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
    } else {
      const [gridX, gridY] = getGridPoint(
        pointerDownState.origin.x,
        pointerDownState.origin.y,
        event[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
      );
      const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
        x: gridX,
        y: gridY
      });
      const { currentItemStartArrowhead, currentItemEndArrowhead } = this.state;
      const [startArrowhead, endArrowhead] = elementType === "arrow" ? [currentItemStartArrowhead, currentItemEndArrowhead] : [null, null];
      const element = elementType === "arrow" ? newArrowElement({
        type: elementType,
        x: gridX,
        y: gridY,
        strokeColor: this.state.currentItemStrokeColor,
        backgroundColor: this.state.currentItemBackgroundColor,
        fillStyle: this.state.currentItemFillStyle,
        strokeWidth: this.state.currentItemStrokeWidth,
        strokeStyle: this.state.currentItemStrokeStyle,
        roughness: this.state.currentItemRoughness,
        opacity: this.state.currentItemOpacity,
        roundness: this.state.currentItemArrowType === ARROW_TYPE.round ? { type: ROUNDNESS.PROPORTIONAL_RADIUS } : (
          // note, roundness doesn't have any effect for elbow arrows,
          // but it's best to set it to null as well
          null
        ),
        startArrowhead,
        endArrowhead,
        locked: false,
        frameId: topLayerFrame ? topLayerFrame.id : null,
        elbowed: this.state.currentItemArrowType === ARROW_TYPE.elbow
      }) : newLinearElement({
        type: elementType,
        x: gridX,
        y: gridY,
        strokeColor: this.state.currentItemStrokeColor,
        backgroundColor: this.state.currentItemBackgroundColor,
        fillStyle: this.state.currentItemFillStyle,
        strokeWidth: this.state.currentItemStrokeWidth,
        strokeStyle: this.state.currentItemStrokeStyle,
        roughness: this.state.currentItemRoughness,
        opacity: this.state.currentItemOpacity,
        roundness: this.state.currentItemRoundness === "round" ? { type: ROUNDNESS.PROPORTIONAL_RADIUS } : null,
        locked: false,
        frameId: topLayerFrame ? topLayerFrame.id : null
      });
      this.setState((prevState) => {
        const nextSelectedElementIds = {
          ...prevState.selectedElementIds
        };
        delete nextSelectedElementIds[element.id];
        return {
          selectedElementIds: makeNextSelectedElementIds(
            nextSelectedElementIds,
            prevState
          )
        };
      });
      mutateElement(element, {
        points: [...element.points, pointFrom(0, 0)]
      });
      const boundElement = getHoveredElementForBinding(
        pointerDownState.origin,
        this.scene.getNonDeletedElements(),
        this.scene.getNonDeletedElementsMap(),
        isElbowArrow(element)
      );
      this.scene.insertElement(element);
      this.setState({
        newElement: element,
        startBoundElement: boundElement,
        suggestedBindings: []
      });
    }
  };
  getCurrentItemRoundness(elementType) {
    return this.state.currentItemRoundness === "round" ? {
      type: isUsingAdaptiveRadius(elementType) ? ROUNDNESS.ADAPTIVE_RADIUS : ROUNDNESS.PROPORTIONAL_RADIUS
    } : null;
  }
  createGenericElementOnPointerDown = (elementType, pointerDownState) => {
    const [gridX, gridY] = getGridPoint(
      pointerDownState.origin.x,
      pointerDownState.origin.y,
      this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
    );
    const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
      x: gridX,
      y: gridY
    });
    const baseElementAttributes = {
      x: gridX,
      y: gridY,
      strokeColor: this.state.currentItemStrokeColor,
      backgroundColor: this.state.currentItemBackgroundColor,
      fillStyle: this.state.currentItemFillStyle,
      strokeWidth: this.state.currentItemStrokeWidth,
      strokeStyle: this.state.currentItemStrokeStyle,
      roughness: this.state.currentItemRoughness,
      opacity: this.state.currentItemOpacity,
      roundness: this.getCurrentItemRoundness(elementType),
      locked: false,
      frameId: topLayerFrame ? topLayerFrame.id : null
    };
    let element;
    if (elementType === "embeddable") {
      element = newEmbeddableElement({
        type: "embeddable",
        ...baseElementAttributes
      });
    } else {
      element = newElement({
        type: elementType,
        ...baseElementAttributes
      });
    }
    if (element.type === "selection") {
      this.setState({
        selectionElement: element
      });
    } else {
      this.scene.insertElement(element);
      this.setState({
        multiElement: null,
        newElement: element
      });
    }
  };
  createFrameElementOnPointerDown = (pointerDownState, type) => {
    const [gridX, gridY] = getGridPoint(
      pointerDownState.origin.x,
      pointerDownState.origin.y,
      this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
    );
    const constructorOpts = {
      x: gridX,
      y: gridY,
      opacity: this.state.currentItemOpacity,
      locked: false,
      ...FRAME_STYLE
    };
    const frame = type === TOOL_TYPE.magicframe ? newMagicFrameElement(constructorOpts) : newFrameElement(constructorOpts);
    this.scene.insertElement(frame);
    this.setState({
      multiElement: null,
      newElement: frame
    });
  };
  maybeCacheReferenceSnapPoints(event, selectedElements, recomputeAnyways = false) {
    if (isSnappingEnabled({
      event,
      app: this,
      selectedElements
    }) && (recomputeAnyways || !SnapCache.getReferenceSnapPoints())) {
      SnapCache.setReferenceSnapPoints(
        getReferenceSnapPoints(
          this.scene.getNonDeletedElements(),
          selectedElements,
          this.state,
          this.scene.getNonDeletedElementsMap()
        )
      );
    }
  }
  maybeCacheVisibleGaps(event, selectedElements, recomputeAnyways = false) {
    if (isSnappingEnabled({
      event,
      app: this,
      selectedElements
    }) && (recomputeAnyways || !SnapCache.getVisibleGaps())) {
      SnapCache.setVisibleGaps(
        getVisibleGaps(
          this.scene.getNonDeletedElements(),
          selectedElements,
          this.state,
          this.scene.getNonDeletedElementsMap()
        )
      );
    }
  }
  onKeyDownFromPointerDownHandler(pointerDownState) {
    return withBatchedUpdates((event) => {
      if (this.maybeHandleResize(pointerDownState, event)) {
        return;
      }
      this.maybeDragNewGenericElement(pointerDownState, event);
    });
  }
  onKeyUpFromPointerDownHandler(pointerDownState) {
    return withBatchedUpdates((event) => {
      event.key === KEYS.ALT && event.preventDefault();
      if (this.maybeHandleResize(pointerDownState, event)) {
        return;
      }
      this.maybeDragNewGenericElement(pointerDownState, event);
    });
  }
  onPointerMoveFromPointerDownHandler(pointerDownState) {
    return withBatchedUpdatesThrottled((event) => {
      if (pointerDownState.drag.offset === null) {
        pointerDownState.drag.offset = tupleToCoors(
          getDragOffsetXY(
            this.scene.getSelectedElements(this.state),
            pointerDownState.origin.x,
            pointerDownState.origin.y
          )
        );
      }
      const target = event.target;
      if (!(target instanceof HTMLElement)) {
        return;
      }
      if (this.handlePointerMoveOverScrollbars(event, pointerDownState)) {
        return;
      }
      const pointerCoords = viewportCoordsToSceneCoords(event, this.state);
      if (isEraserActive(this.state)) {
        this.handleEraser(event, pointerDownState, pointerCoords);
        return;
      }
      if (this.state.activeTool.type === "laser") {
        this.laserTrails.addPointToPath(pointerCoords.x, pointerCoords.y);
      }
      const [gridX, gridY] = getGridPoint(
        pointerCoords.x,
        pointerCoords.y,
        event[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
      );
      if (!pointerDownState.drag.hasOccurred && (this.state.activeTool.type === "arrow" || this.state.activeTool.type === "line")) {
        if (pointDistance(
          pointFrom(pointerCoords.x, pointerCoords.y),
          pointFrom(pointerDownState.origin.x, pointerDownState.origin.y)
        ) < DRAGGING_THRESHOLD) {
          return;
        }
      }
      if (pointerDownState.resize.isResizing) {
        pointerDownState.lastCoords.x = pointerCoords.x;
        pointerDownState.lastCoords.y = pointerCoords.y;
        if (this.maybeHandleResize(pointerDownState, event)) {
          return true;
        }
      }
      const elementsMap = this.scene.getNonDeletedElementsMap();
      if (this.state.selectedLinearElement) {
        const linearElementEditor = this.state.editingLinearElement || this.state.selectedLinearElement;
        if (LinearElementEditor.shouldAddMidpoint(
          this.state.selectedLinearElement,
          pointerCoords,
          this.state,
          elementsMap
        )) {
          const ret = LinearElementEditor.addMidpoint(
            this.state.selectedLinearElement,
            pointerCoords,
            this,
            !event[KEYS.CTRL_OR_CMD],
            elementsMap
          );
          if (!ret) {
            return;
          }
          flushSync(() => {
            if (this.state.selectedLinearElement) {
              this.setState({
                selectedLinearElement: {
                  ...this.state.selectedLinearElement,
                  pointerDownState: ret.pointerDownState,
                  selectedPointsIndices: ret.selectedPointsIndices
                }
              });
            }
            if (this.state.editingLinearElement) {
              this.setState({
                editingLinearElement: {
                  ...this.state.editingLinearElement,
                  pointerDownState: ret.pointerDownState,
                  selectedPointsIndices: ret.selectedPointsIndices
                }
              });
            }
          });
          return;
        } else if (linearElementEditor.pointerDownState.segmentMidpoint.value !== null && !linearElementEditor.pointerDownState.segmentMidpoint.added) {
          return;
        }
        const didDrag = LinearElementEditor.handlePointDragging(
          event,
          this,
          pointerCoords.x,
          pointerCoords.y,
          (element, pointsSceneCoords) => {
            this.maybeSuggestBindingsForLinearElementAtCoords(
              element,
              pointsSceneCoords
            );
          },
          linearElementEditor,
          this.scene
        );
        if (didDrag) {
          pointerDownState.lastCoords.x = pointerCoords.x;
          pointerDownState.lastCoords.y = pointerCoords.y;
          pointerDownState.drag.hasOccurred = true;
          if (this.state.editingLinearElement && !this.state.editingLinearElement.isDragging) {
            this.setState({
              editingLinearElement: {
                ...this.state.editingLinearElement,
                isDragging: true
              }
            });
          }
          if (!this.state.selectedLinearElement.isDragging) {
            this.setState({
              selectedLinearElement: {
                ...this.state.selectedLinearElement,
                isDragging: true
              }
            });
          }
          return;
        }
      }
      const hasHitASelectedElement = pointerDownState.hit.allHitElements.some(
        (element) => this.isASelectedElement(element)
      );
      const isSelectingPointsInLineEditor = this.state.editingLinearElement && event.shiftKey && this.state.editingLinearElement.elementId === pointerDownState.hit.element?.id;
      if ((hasHitASelectedElement || pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements) && !isSelectingPointsInLineEditor) {
        const selectedElements = this.scene.getSelectedElements(this.state);
        if (selectedElements.every((element) => element.locked)) {
          return;
        }
        const selectedElementsHasAFrame = selectedElements.find(
          (e) => isFrameLikeElement(e)
        );
        const topLayerFrame = this.getTopLayerFrameAtSceneCoords(pointerCoords);
        this.setState({
          frameToHighlight: topLayerFrame && !selectedElementsHasAFrame ? topLayerFrame : null
        });
        pointerDownState.drag.hasOccurred = true;
        if (selectedElements.length > 0 && !pointerDownState.withCmdOrCtrl && !this.state.editingTextElement && this.state.activeEmbeddable?.state !== "active") {
          const dragOffset = {
            x: pointerCoords.x - pointerDownState.origin.x,
            y: pointerCoords.y - pointerDownState.origin.y
          };
          const originalElements = [
            ...pointerDownState.originalElements.values()
          ];
          const lockDirection = event.shiftKey;
          if (lockDirection) {
            const distanceX = Math.abs(dragOffset.x);
            const distanceY = Math.abs(dragOffset.y);
            const lockX = lockDirection && distanceX < distanceY;
            const lockY = lockDirection && distanceX > distanceY;
            if (lockX) {
              dragOffset.x = 0;
            }
            if (lockY) {
              dragOffset.y = 0;
            }
          }
          this.maybeCacheVisibleGaps(event, selectedElements);
          this.maybeCacheReferenceSnapPoints(event, selectedElements);
          const { snapOffset, snapLines } = snapDraggedElements(
            originalElements,
            dragOffset,
            this,
            event,
            this.scene.getNonDeletedElementsMap()
          );
          this.setState({ snapLines });
          !this.state.editingFrame && dragSelectedElements(
            pointerDownState,
            selectedElements,
            dragOffset,
            this.scene,
            snapOffset,
            event[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
          );
          this.setState({
            selectedElementsAreBeingDragged: true,
            // element is being dragged and selectionElement that was created on pointer down
            // should be removed
            selectionElement: null
          });
          if (selectedElements.length !== 1 || !isElbowArrow(selectedElements[0])) {
            this.setState({
              suggestedBindings: getSuggestedBindingsForArrows(
                selectedElements,
                this.scene.getNonDeletedElementsMap()
              )
            });
          }
          if (event.altKey && !pointerDownState.hit.hasBeenDuplicated) {
            pointerDownState.hit.hasBeenDuplicated = true;
            const nextElements = [];
            const elementsToAppend = [];
            const groupIdMap = /* @__PURE__ */ new Map();
            const oldIdToDuplicatedId = /* @__PURE__ */ new Map();
            const hitElement = pointerDownState.hit.element;
            const selectedElementIds = new Set(
              this.scene.getSelectedElements({
                selectedElementIds: this.state.selectedElementIds,
                includeBoundTextElement: true,
                includeElementsInFrames: true
              }).map((element) => element.id)
            );
            const elements = this.scene.getElementsIncludingDeleted();
            for (const element of elements) {
              if (selectedElementIds.has(element.id) || // case: the state.selectedElementIds might not have been
              // updated yet by the time this mousemove event is fired
              element.id === hitElement?.id && pointerDownState.hit.wasAddedToSelection) {
                const duplicatedElement = duplicateElement(
                  this.state.editingGroupId,
                  groupIdMap,
                  element
                );
                const origElement = pointerDownState.originalElements.get(
                  element.id
                );
                mutateElement(duplicatedElement, {
                  x: origElement.x,
                  y: origElement.y
                });
                pointerDownState.originalElements.set(
                  duplicatedElement.id,
                  duplicatedElement
                );
                nextElements.push(duplicatedElement);
                elementsToAppend.push(element);
                oldIdToDuplicatedId.set(element.id, duplicatedElement.id);
              } else {
                nextElements.push(element);
              }
            }
            const nextSceneElements = [...nextElements, ...elementsToAppend];
            syncMovedIndices(nextSceneElements, arrayToMap(elementsToAppend));
            bindTextToShapeAfterDuplication(
              nextElements,
              elementsToAppend,
              oldIdToDuplicatedId
            );
            fixBindingsAfterDuplication(
              nextSceneElements,
              elementsToAppend,
              oldIdToDuplicatedId,
              "duplicatesServeAsOld"
            );
            bindElementsToFramesAfterDuplication(
              nextSceneElements,
              elementsToAppend,
              oldIdToDuplicatedId
            );
            this.scene.replaceAllElements(nextSceneElements);
            this.maybeCacheVisibleGaps(event, selectedElements, true);
            this.maybeCacheReferenceSnapPoints(event, selectedElements, true);
          }
          return;
        }
      }
      if (this.state.selectionElement) {
        pointerDownState.lastCoords.x = pointerCoords.x;
        pointerDownState.lastCoords.y = pointerCoords.y;
        this.maybeDragNewGenericElement(pointerDownState, event);
      } else {
        const newElement2 = this.state.newElement;
        if (!newElement2) {
          return;
        }
        if (newElement2.type === "freedraw") {
          const points = newElement2.points;
          const dx = pointerCoords.x - newElement2.x;
          const dy = pointerCoords.y - newElement2.y;
          const lastPoint = points.length > 0 && points[points.length - 1];
          const discardPoint = lastPoint && lastPoint[0] === dx && lastPoint[1] === dy;
          if (!discardPoint) {
            const pressures = newElement2.simulatePressure ? newElement2.pressures : [...newElement2.pressures, event.pressure];
            mutateElement(
              newElement2,
              {
                points: [...points, pointFrom(dx, dy)],
                pressures
              },
              false
            );
            this.setState({
              newElement: newElement2
            });
          }
        } else if (isLinearElement(newElement2)) {
          pointerDownState.drag.hasOccurred = true;
          const points = newElement2.points;
          let dx = gridX - newElement2.x;
          let dy = gridY - newElement2.y;
          if (shouldRotateWithDiscreteAngle(event) && points.length === 2) {
            ({ width: dx, height: dy } = getLockedLinearCursorAlignSize(
              newElement2.x,
              newElement2.y,
              pointerCoords.x,
              pointerCoords.y
            ));
          }
          if (points.length === 1) {
            mutateElement(
              newElement2,
              {
                points: [...points, pointFrom(dx, dy)]
              },
              false
            );
          } else if (points.length > 1 && isElbowArrow(newElement2)) {
            mutateElbowArrow(
              newElement2,
              elementsMap,
              [...points.slice(0, -1), pointFrom(dx, dy)],
              vector(0, 0),
              void 0,
              {
                isDragging: true,
                informMutation: false
              }
            );
          } else if (points.length === 2) {
            mutateElement(
              newElement2,
              {
                points: [...points.slice(0, -1), pointFrom(dx, dy)]
              },
              false
            );
          }
          this.setState({
            newElement: newElement2
          });
          if (isBindingElement(newElement2, false)) {
            this.maybeSuggestBindingsForLinearElementAtCoords(
              newElement2,
              [pointerCoords],
              this.state.startBoundElement
            );
          }
        } else {
          pointerDownState.lastCoords.x = pointerCoords.x;
          pointerDownState.lastCoords.y = pointerCoords.y;
          this.maybeDragNewGenericElement(pointerDownState, event, false);
        }
      }
      if (this.state.activeTool.type === "selection") {
        pointerDownState.boxSelection.hasOccurred = true;
        const elements = this.scene.getNonDeletedElements();
        if (this.state.editingLinearElement) {
          LinearElementEditor.handleBoxSelection(
            event,
            this.state,
            this.setState.bind(this),
            this.scene.getNonDeletedElementsMap()
          );
        } else {
          let shouldReuseSelection = true;
          if (!event.shiftKey && isSomeElementSelected(elements, this.state)) {
            if (pointerDownState.withCmdOrCtrl && pointerDownState.hit.element) {
              this.setState(
                (prevState) => selectGroupsForSelectedElements(
                  {
                    ...prevState,
                    selectedElementIds: {
                      [pointerDownState.hit.element.id]: true
                    }
                  },
                  this.scene.getNonDeletedElements(),
                  prevState,
                  this
                )
              );
            } else {
              shouldReuseSelection = false;
            }
          }
          const elementsWithinSelection = this.state.selectionElement ? getElementsWithinSelection(
            elements,
            this.state.selectionElement,
            this.scene.getNonDeletedElementsMap()
          ) : [];
          this.setState((prevState) => {
            const nextSelectedElementIds = {
              ...shouldReuseSelection && prevState.selectedElementIds,
              ...elementsWithinSelection.reduce(
                (acc, element) => {
                  acc[element.id] = true;
                  return acc;
                },
                {}
              )
            };
            if (pointerDownState.hit.element) {
              if (!elementsWithinSelection.length) {
                nextSelectedElementIds[pointerDownState.hit.element.id] = true;
              } else {
                delete nextSelectedElementIds[pointerDownState.hit.element.id];
              }
            }
            prevState = !shouldReuseSelection ? { ...prevState, selectedGroupIds: {}, editingGroupId: null } : prevState;
            return {
              ...selectGroupsForSelectedElements(
                {
                  editingGroupId: prevState.editingGroupId,
                  selectedElementIds: nextSelectedElementIds
                },
                this.scene.getNonDeletedElements(),
                prevState,
                this
              ),
              // select linear element only when we haven't box-selected anything else
              selectedLinearElement: elementsWithinSelection.length === 1 && isLinearElement(elementsWithinSelection[0]) ? new LinearElementEditor(elementsWithinSelection[0]) : null,
              showHyperlinkPopup: elementsWithinSelection.length === 1 && (elementsWithinSelection[0].link || isEmbeddableElement(elementsWithinSelection[0])) ? "info" : false
            };
          });
        }
      }
    });
  }
  // Returns whether the pointer move happened over either scrollbar
  handlePointerMoveOverScrollbars(event, pointerDownState) {
    if (pointerDownState.scrollbars.isOverHorizontal) {
      const x = event.clientX;
      const dx = x - pointerDownState.lastCoords.x;
      this.translateCanvas({
        scrollX: this.state.scrollX - dx / this.state.zoom.value
      });
      pointerDownState.lastCoords.x = x;
      return true;
    }
    if (pointerDownState.scrollbars.isOverVertical) {
      const y = event.clientY;
      const dy = y - pointerDownState.lastCoords.y;
      this.translateCanvas({
        scrollY: this.state.scrollY - dy / this.state.zoom.value
      });
      pointerDownState.lastCoords.y = y;
      return true;
    }
    return false;
  }
  onPointerUpFromPointerDownHandler(pointerDownState) {
    return withBatchedUpdates((childEvent) => {
      this.removePointer(childEvent);
      if (pointerDownState.eventListeners.onMove) {
        pointerDownState.eventListeners.onMove.flush();
      }
      const {
        newElement: newElement2,
        resizingElement,
        multiElement,
        activeTool,
        isResizing,
        isRotating
      } = this.state;
      this.setState((prevState) => ({
        isResizing: false,
        isRotating: false,
        resizingElement: null,
        selectionElement: null,
        frameToHighlight: null,
        elementsToHighlight: null,
        cursorButton: "up",
        snapLines: updateStable(prevState.snapLines, []),
        originSnapOffset: null
      }));
      SnapCache.setReferenceSnapPoints(null);
      SnapCache.setVisibleGaps(null);
      this.savePointer(childEvent.clientX, childEvent.clientY, "up");
      this.setState({
        selectedElementsAreBeingDragged: false
      });
      const elementsMap = this.scene.getNonDeletedElementsMap();
      if (this.state.editingLinearElement) {
        if (!pointerDownState.boxSelection.hasOccurred && pointerDownState.hit?.element?.id !== this.state.editingLinearElement.elementId) {
          this.actionManager.executeAction(actionFinalize);
        } else {
          const editingLinearElement = LinearElementEditor.handlePointerUp(
            childEvent,
            this.state.editingLinearElement,
            this.state,
            this.scene
          );
          if (editingLinearElement !== this.state.editingLinearElement) {
            this.setState({
              editingLinearElement,
              suggestedBindings: []
            });
          }
        }
      } else if (this.state.selectedLinearElement) {
        if (pointerDownState.hit?.element?.id !== this.state.selectedLinearElement.elementId) {
          const selectedELements = this.scene.getSelectedElements(this.state);
          if (selectedELements.length > 1) {
            this.setState({ selectedLinearElement: null });
          }
        } else {
          const linearElementEditor = LinearElementEditor.handlePointerUp(
            childEvent,
            this.state.selectedLinearElement,
            this.state,
            this.scene
          );
          const { startBindingElement, endBindingElement } = linearElementEditor;
          const element = this.scene.getElement(linearElementEditor.elementId);
          if (isBindingElement(element)) {
            bindOrUnbindLinearElement(
              element,
              startBindingElement,
              endBindingElement,
              elementsMap,
              this.scene
            );
          }
          if (linearElementEditor !== this.state.selectedLinearElement) {
            this.setState({
              selectedLinearElement: {
                ...linearElementEditor,
                selectedPointsIndices: null
              },
              suggestedBindings: []
            });
          }
        }
      }
      this.missingPointerEventCleanupEmitter.clear();
      window.removeEventListener(
        "pointermove" /* POINTER_MOVE */,
        pointerDownState.eventListeners.onMove
      );
      window.removeEventListener(
        "pointerup" /* POINTER_UP */,
        pointerDownState.eventListeners.onUp
      );
      window.removeEventListener(
        "keydown" /* KEYDOWN */,
        pointerDownState.eventListeners.onKeyDown
      );
      window.removeEventListener(
        "keyup" /* KEYUP */,
        pointerDownState.eventListeners.onKeyUp
      );
      if (this.state.pendingImageElementId) {
        this.setState({ pendingImageElementId: null });
      }
      this.props?.onPointerUp?.(activeTool, pointerDownState);
      this.onPointerUpEmitter.trigger(
        this.state.activeTool,
        pointerDownState,
        childEvent
      );
      if (newElement2?.type === "freedraw") {
        const pointerCoords = viewportCoordsToSceneCoords(
          childEvent,
          this.state
        );
        const points = newElement2.points;
        let dx = pointerCoords.x - newElement2.x;
        let dy = pointerCoords.y - newElement2.y;
        if (dx === points[0][0] && dy === points[0][1]) {
          dy += 1e-4;
          dx += 1e-4;
        }
        const pressures = newElement2.simulatePressure ? [] : [...newElement2.pressures, childEvent.pressure];
        mutateElement(newElement2, {
          points: [...points, pointFrom(dx, dy)],
          pressures,
          lastCommittedPoint: pointFrom(dx, dy)
        });
        this.actionManager.executeAction(actionFinalize);
        return;
      }
      if (isImageElement(newElement2)) {
        const imageElement = newElement2;
        try {
          this.initializeImageDimensions(imageElement);
          this.setState(
            {
              selectedElementIds: makeNextSelectedElementIds(
                { [imageElement.id]: true },
                this.state
              )
            },
            () => {
              this.actionManager.executeAction(actionFinalize);
            }
          );
        } catch (error) {
          console.error(error);
          this.scene.replaceAllElements(
            this.scene.getElementsIncludingDeleted().filter((el) => el.id !== imageElement.id)
          );
          this.actionManager.executeAction(actionFinalize);
        }
        return;
      }
      if (isLinearElement(newElement2)) {
        if (newElement2.points.length > 1) {
          this.store.shouldCaptureIncrement();
        }
        const pointerCoords = viewportCoordsToSceneCoords(
          childEvent,
          this.state
        );
        if (!pointerDownState.drag.hasOccurred && newElement2 && !multiElement) {
          mutateElement(newElement2, {
            points: [
              ...newElement2.points,
              pointFrom(
                pointerCoords.x - newElement2.x,
                pointerCoords.y - newElement2.y
              )
            ]
          });
          this.setState({
            multiElement: newElement2,
            newElement: newElement2
          });
        } else if (pointerDownState.drag.hasOccurred && !multiElement) {
          if (isBindingEnabled(this.state) && isBindingElement(newElement2, false)) {
            maybeBindLinearElement(
              newElement2,
              this.state,
              pointerCoords,
              this.scene.getNonDeletedElementsMap(),
              this.scene.getNonDeletedElements()
            );
          }
          this.setState({ suggestedBindings: [], startBoundElement: null });
          if (!activeTool.locked) {
            resetCursor(this.interactiveCanvas);
            this.setState((prevState) => ({
              newElement: null,
              activeTool: updateActiveTool(this.state, {
                type: "selection"
              }),
              selectedElementIds: makeNextSelectedElementIds(
                {
                  ...prevState.selectedElementIds,
                  [newElement2.id]: true
                },
                prevState
              ),
              selectedLinearElement: new LinearElementEditor(newElement2)
            }));
          } else {
            this.setState((prevState) => ({
              newElement: null
            }));
          }
          this.scene.triggerUpdate();
        }
        return;
      }
      if (isTextElement(newElement2)) {
        const minWidth = getMinTextElementWidth(
          getFontString({
            fontSize: newElement2.fontSize,
            fontFamily: newElement2.fontFamily
          }),
          newElement2.lineHeight
        );
        if (newElement2.width < minWidth) {
          mutateElement(newElement2, {
            autoResize: true
          });
        }
        this.resetCursor();
        this.handleTextWysiwyg(newElement2, {
          isExistingElement: true
        });
      }
      if (activeTool.type !== "selection" && newElement2 && isInvisiblySmallElement(newElement2)) {
        this.updateScene({
          elements: this.scene.getElementsIncludingDeleted().filter((el) => el.id !== newElement2.id),
          appState: {
            newElement: null
          },
          storeAction: StoreAction.UPDATE
        });
        return;
      }
      if (isFrameLikeElement(newElement2)) {
        const elementsInsideFrame = getElementsInNewFrame(
          this.scene.getElementsIncludingDeleted(),
          newElement2,
          this.scene.getNonDeletedElementsMap()
        );
        this.scene.replaceAllElements(
          addElementsToFrame(
            this.scene.getElementsMapIncludingDeleted(),
            elementsInsideFrame,
            newElement2
          )
        );
      }
      if (newElement2) {
        mutateElement(newElement2, getNormalizedDimensions(newElement2));
        this.scene.triggerUpdate();
      }
      if (pointerDownState.drag.hasOccurred) {
        const sceneCoords = viewportCoordsToSceneCoords(childEvent, this.state);
        if (this.state.selectedLinearElement && this.state.selectedLinearElement.isDragging) {
          const linearElement = this.scene.getElement(
            this.state.selectedLinearElement.elementId
          );
          if (linearElement?.frameId) {
            const frame = getContainingFrame(linearElement, elementsMap);
            if (frame && linearElement) {
              if (!elementOverlapsWithFrame(
                linearElement,
                frame,
                this.scene.getNonDeletedElementsMap()
              )) {
                mutateElement(linearElement, {
                  groupIds: []
                });
                removeElementsFromFrame(
                  [linearElement],
                  this.scene.getNonDeletedElementsMap()
                );
                this.scene.triggerUpdate();
              }
            }
          }
        } else {
          const topLayerFrame = this.getTopLayerFrameAtSceneCoords(sceneCoords);
          const selectedElements = this.scene.getSelectedElements(this.state);
          let nextElements = this.scene.getElementsMapIncludingDeleted();
          const updateGroupIdsAfterEditingGroup = (elements) => {
            if (elements.length > 0) {
              for (const element of elements) {
                const index = element.groupIds.indexOf(
                  this.state.editingGroupId
                );
                mutateElement(
                  element,
                  {
                    groupIds: element.groupIds.slice(0, index)
                  },
                  false
                );
              }
              nextElements.forEach((element) => {
                if (element.groupIds.length && getElementsInGroup(
                  nextElements,
                  element.groupIds[element.groupIds.length - 1]
                ).length < 2) {
                  mutateElement(
                    element,
                    {
                      groupIds: []
                    },
                    false
                  );
                }
              });
              this.setState({
                editingGroupId: null
              });
            }
          };
          if (topLayerFrame && !this.state.selectedElementIds[topLayerFrame.id]) {
            const elementsToAdd = selectedElements.filter(
              (element) => element.frameId !== topLayerFrame.id && isElementInFrame(element, nextElements, this.state)
            );
            if (this.state.editingGroupId) {
              updateGroupIdsAfterEditingGroup(elementsToAdd);
            }
            nextElements = addElementsToFrame(
              nextElements,
              elementsToAdd,
              topLayerFrame
            );
          } else if (!topLayerFrame) {
            if (this.state.editingGroupId) {
              const elementsToRemove = selectedElements.filter(
                (element) => element.frameId && !isElementInFrame(element, nextElements, this.state)
              );
              updateGroupIdsAfterEditingGroup(elementsToRemove);
            }
          }
          nextElements = updateFrameMembershipOfSelectedElements(
            nextElements,
            this.state,
            this
          );
          this.scene.replaceAllElements(nextElements);
        }
      }
      if (resizingElement) {
        this.store.shouldCaptureIncrement();
      }
      if (resizingElement && isInvisiblySmallElement(resizingElement)) {
        this.updateScene({
          elements: this.scene.getElementsIncludingDeleted().filter((el) => el.id !== resizingElement.id),
          storeAction: StoreAction.UPDATE
        });
      }
      if (pointerDownState.resize.isResizing) {
        let nextElements = updateFrameMembershipOfSelectedElements(
          this.scene.getElementsIncludingDeleted(),
          this.state,
          this
        );
        const selectedFrames = this.scene.getSelectedElements(this.state).filter(
          (element) => isFrameLikeElement(element)
        );
        for (const frame of selectedFrames) {
          nextElements = replaceAllElementsInFrame(
            nextElements,
            getElementsInResizingFrame(
              this.scene.getElementsIncludingDeleted(),
              frame,
              this.state,
              elementsMap
            ),
            frame,
            this
          );
        }
        this.scene.replaceAllElements(nextElements);
      }
      const hitElement = pointerDownState.hit.element;
      if (this.state.selectedLinearElement?.elementId !== hitElement?.id && isLinearElement(hitElement)) {
        const selectedELements = this.scene.getSelectedElements(this.state);
        if (selectedELements.length === 1) {
          this.setState({
            selectedLinearElement: new LinearElementEditor(hitElement)
          });
        }
      }
      const pointerStart = this.lastPointerDownEvent;
      const pointerEnd = this.lastPointerUpEvent || this.lastPointerMoveEvent;
      if (isEraserActive(this.state) && pointerStart && pointerEnd) {
        this.eraserTrail.endPath();
        const draggedDistance = pointDistance(
          pointFrom(pointerStart.clientX, pointerStart.clientY),
          pointFrom(pointerEnd.clientX, pointerEnd.clientY)
        );
        if (draggedDistance === 0) {
          const scenePointer = viewportCoordsToSceneCoords(
            {
              clientX: pointerEnd.clientX,
              clientY: pointerEnd.clientY
            },
            this.state
          );
          const hitElements = this.getElementsAtPosition(
            scenePointer.x,
            scenePointer.y
          );
          hitElements.forEach(
            (hitElement2) => this.elementsPendingErasure.add(hitElement2.id)
          );
        }
        this.eraseElements();
        return;
      } else if (this.elementsPendingErasure.size) {
        this.restoreReadyToEraseElements();
      }
      if (hitElement && !pointerDownState.drag.hasOccurred && !pointerDownState.hit.wasAddedToSelection && // if we're editing a line, pointerup shouldn't switch selection if
      // box selected
      (!this.state.editingLinearElement || !pointerDownState.boxSelection.hasOccurred)) {
        if (childEvent.shiftKey && !this.state.editingLinearElement) {
          if (this.state.selectedElementIds[hitElement.id]) {
            if (isSelectedViaGroup(this.state, hitElement)) {
              this.setState((_prevState) => {
                const nextSelectedElementIds = {
                  ..._prevState.selectedElementIds
                };
                for (const groupedElement of hitElement.groupIds.flatMap(
                  (groupId) => getElementsInGroup(
                    this.scene.getNonDeletedElements(),
                    groupId
                  )
                )) {
                  delete nextSelectedElementIds[groupedElement.id];
                }
                return {
                  selectedGroupIds: {
                    ..._prevState.selectedElementIds,
                    ...hitElement.groupIds.map((gId) => ({ [gId]: false })).reduce((prev, acc) => ({ ...prev, ...acc }), {})
                  },
                  selectedElementIds: makeNextSelectedElementIds(
                    nextSelectedElementIds,
                    _prevState
                  )
                };
              });
            } else if (!this.state.selectedLinearElement?.isDragging) {
              this.setState((prevState) => {
                const newSelectedElementIds = {
                  ...prevState.selectedElementIds
                };
                delete newSelectedElementIds[hitElement.id];
                const newSelectedElements = getSelectedElements(
                  this.scene.getNonDeletedElements(),
                  { selectedElementIds: newSelectedElementIds }
                );
                return {
                  ...selectGroupsForSelectedElements(
                    {
                      editingGroupId: prevState.editingGroupId,
                      selectedElementIds: newSelectedElementIds
                    },
                    this.scene.getNonDeletedElements(),
                    prevState,
                    this
                  ),
                  // set selectedLinearElement only if thats the only element selected
                  selectedLinearElement: newSelectedElements.length === 1 && isLinearElement(newSelectedElements[0]) ? new LinearElementEditor(newSelectedElements[0]) : prevState.selectedLinearElement
                };
              });
            }
          } else if (hitElement.frameId && this.state.selectedElementIds[hitElement.frameId]) {
            this.setState((prevState) => {
              const nextSelectedElementIds = {
                ...prevState.selectedElementIds,
                [hitElement.id]: true
              };
              delete nextSelectedElementIds[hitElement.frameId];
              (this.scene.getElement(hitElement.frameId)?.groupIds ?? []).flatMap(
                (gid) => getElementsInGroup(this.scene.getNonDeletedElements(), gid)
              ).forEach((element) => {
                delete nextSelectedElementIds[element.id];
              });
              return {
                ...selectGroupsForSelectedElements(
                  {
                    editingGroupId: prevState.editingGroupId,
                    selectedElementIds: nextSelectedElementIds
                  },
                  this.scene.getNonDeletedElements(),
                  prevState,
                  this
                ),
                showHyperlinkPopup: hitElement.link || isEmbeddableElement(hitElement) ? "info" : false
              };
            });
          } else {
            this.setState((_prevState) => ({
              selectedElementIds: makeNextSelectedElementIds(
                {
                  ..._prevState.selectedElementIds,
                  [hitElement.id]: true
                },
                _prevState
              )
            }));
          }
        } else {
          this.setState((prevState) => ({
            ...selectGroupsForSelectedElements(
              {
                editingGroupId: prevState.editingGroupId,
                selectedElementIds: { [hitElement.id]: true }
              },
              this.scene.getNonDeletedElements(),
              prevState,
              this
            ),
            selectedLinearElement: isLinearElement(hitElement) && // Don't set `selectedLinearElement` if its same as the hitElement, this is mainly to prevent resetting the `hoverPointIndex` to -1.
            // Future we should update the API to take care of setting the correct `hoverPointIndex` when initialized
            prevState.selectedLinearElement?.elementId !== hitElement.id ? new LinearElementEditor(hitElement) : prevState.selectedLinearElement
          }));
        }
      }
      if (
        // not dragged
        !pointerDownState.drag.hasOccurred && // not resized
        !this.state.isResizing && // only hitting the bounding box of the previous hit element
        (hitElement && hitElementBoundingBoxOnly(
          {
            x: pointerDownState.origin.x,
            y: pointerDownState.origin.y,
            element: hitElement,
            shape: getElementShape(
              hitElement,
              this.scene.getNonDeletedElementsMap()
            ),
            threshold: this.getElementHitThreshold(),
            frameNameBound: isFrameLikeElement(hitElement) ? this.frameNameBoundsCache.get(hitElement) : null
          },
          elementsMap
        ) || !hitElement && pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements)
      ) {
        if (this.state.editingLinearElement) {
          this.setState({ editingLinearElement: null });
        } else {
          this.setState({
            selectedElementIds: makeNextSelectedElementIds({}, this.state),
            selectedGroupIds: {},
            editingGroupId: null,
            activeEmbeddable: null
          });
        }
        setCursor(this.interactiveCanvas, CURSOR_TYPE.AUTO);
        return;
      }
      if (!activeTool.locked && activeTool.type !== "freedraw" && newElement2) {
        this.setState((prevState) => ({
          selectedElementIds: makeNextSelectedElementIds(
            {
              ...prevState.selectedElementIds,
              [newElement2.id]: true
            },
            prevState
          ),
          showHyperlinkPopup: isEmbeddableElement(newElement2) && !newElement2.link ? "editor" : prevState.showHyperlinkPopup
        }));
      }
      if (activeTool.type !== "selection" || isSomeElementSelected(this.scene.getNonDeletedElements(), this.state) || !isShallowEqual(
        this.state.previousSelectedElementIds,
        this.state.selectedElementIds
      )) {
        this.store.shouldCaptureIncrement();
      }
      if (pointerDownState.drag.hasOccurred || isResizing || isRotating) {
        const linearElements = this.scene.getSelectedElements(this.state).filter(isLinearElement);
        bindOrUnbindLinearElements(
          linearElements,
          this.scene.getNonDeletedElementsMap(),
          this.scene.getNonDeletedElements(),
          this.scene,
          isBindingEnabled(this.state),
          this.state.selectedLinearElement?.selectedPointsIndices ?? []
        );
      }
      if (activeTool.type === "laser") {
        this.laserTrails.endPath();
        return;
      }
      if (!activeTool.locked && activeTool.type !== "freedraw") {
        resetCursor(this.interactiveCanvas);
        this.setState({
          newElement: null,
          suggestedBindings: [],
          activeTool: updateActiveTool(this.state, { type: "selection" })
        });
      } else {
        this.setState({
          newElement: null,
          suggestedBindings: []
        });
      }
      if (hitElement && this.lastPointerUpEvent && this.lastPointerDownEvent && this.lastPointerUpEvent.timeStamp - this.lastPointerDownEvent.timeStamp < 300 && gesture.pointers.size <= 1 && isIframeLikeElement(hitElement) && this.isIframeLikeElementCenter(
        hitElement,
        this.lastPointerUpEvent,
        pointerDownState.origin.x,
        pointerDownState.origin.y
      )) {
        this.handleEmbeddableCenterClick(hitElement);
      }
    });
  }
  restoreReadyToEraseElements = () => {
    this.elementsPendingErasure = /* @__PURE__ */ new Set();
    this.triggerRender();
  };
  eraseElements = () => {
    let didChange = false;
    const elements = this.scene.getElementsIncludingDeleted().map((ele) => {
      if (this.elementsPendingErasure.has(ele.id) || ele.frameId && this.elementsPendingErasure.has(ele.frameId) || isBoundToContainer(ele) && this.elementsPendingErasure.has(ele.containerId)) {
        didChange = true;
        return newElementWith(ele, { isDeleted: true });
      }
      return ele;
    });
    this.elementsPendingErasure = /* @__PURE__ */ new Set();
    if (didChange) {
      this.store.shouldCaptureIncrement();
      this.scene.replaceAllElements(elements);
    }
  };
  initializeImage = async ({
    imageFile,
    imageElement: _imageElement,
    showCursorImagePreview = false
  }) => {
    if (!isSupportedImageFile(imageFile)) {
      throw new Error(t("errors.unsupportedFileType"));
    }
    const mimeType = imageFile.type;
    setCursor(this.interactiveCanvas, "wait");
    if (mimeType === MIME_TYPES.svg) {
      try {
        imageFile = SVGStringToFile(
          await normalizeSVG(await imageFile.text()),
          imageFile.name
        );
      } catch (error) {
        console.warn(error);
        throw new Error(t("errors.svgImageInsertError"));
      }
    }
    const fileId = await (this.props.generateIdForFile?.(
      imageFile
    ) || generateIdFromFile(imageFile));
    if (!fileId) {
      console.warn(
        "Couldn't generate file id or the supplied `generateIdForFile` didn't resolve to one."
      );
      throw new Error(t("errors.imageInsertError"));
    }
    const existingFileData = this.files[fileId];
    if (!existingFileData?.dataURL) {
      try {
        imageFile = await resizeImageFile(imageFile, {
          maxWidthOrHeight: DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT
        });
      } catch (error) {
        console.error(
          "Error trying to resizing image file on insertion",
          error
        );
      }
      if (imageFile.size > MAX_ALLOWED_FILE_BYTES) {
        throw new Error(
          t("errors.fileTooBig", {
            maxSize: `${Math.trunc(MAX_ALLOWED_FILE_BYTES / 1024 / 1024)}MB`
          })
        );
      }
    }
    if (showCursorImagePreview) {
      const dataURL2 = this.files[fileId]?.dataURL;
      const resizedFile = dataURL2 && dataURLToFile(dataURL2);
      this.setImagePreviewCursor(resizedFile || imageFile);
    }
    const dataURL = this.files[fileId]?.dataURL || await getDataURL(imageFile);
    const imageElement = mutateElement(
      _imageElement,
      {
        fileId
      },
      false
    );
    return new Promise(
      async (resolve, reject) => {
        try {
          this.files = {
            ...this.files,
            [fileId]: {
              mimeType,
              id: fileId,
              dataURL,
              created: Date.now(),
              lastRetrieved: Date.now()
            }
          };
          const cachedImageData = this.imageCache.get(fileId);
          if (!cachedImageData) {
            this.addNewImagesToImageCache();
            await this.updateImageCache([imageElement]);
          }
          if (cachedImageData?.image instanceof Promise) {
            await cachedImageData.image;
          }
          if (this.state.pendingImageElementId !== imageElement.id && this.state.newElement?.id !== imageElement.id) {
            this.initializeImageDimensions(imageElement, true);
          }
          resolve(imageElement);
        } catch (error) {
          console.error(error);
          reject(new Error(t("errors.imageInsertError")));
        } finally {
          if (!showCursorImagePreview) {
            resetCursor(this.interactiveCanvas);
          }
        }
      }
    );
  };
  /**
   * inserts image into elements array and rerenders
   */
  insertImageElement = async (imageElement, imageFile, showCursorImagePreview) => {
    if (!this.isToolSupported("image")) {
      this.setState({ errorMessage: t("errors.imageToolNotSupported") });
      return;
    }
    this.scene.insertElement(imageElement);
    try {
      return await this.initializeImage({
        imageFile,
        imageElement,
        showCursorImagePreview
      });
    } catch (error) {
      mutateElement(imageElement, {
        isDeleted: true
      });
      this.actionManager.executeAction(actionFinalize);
      this.setState({
        errorMessage: error.message || t("errors.imageInsertError")
      });
      return null;
    }
  };
  setImagePreviewCursor = async (imageFile) => {
    const cursorImageSizePx = 96;
    let imagePreview;
    try {
      imagePreview = await resizeImageFile(imageFile, {
        maxWidthOrHeight: cursorImageSizePx
      });
    } catch (e) {
      if (e.cause === "UNSUPPORTED") {
        throw new Error(t("errors.unsupportedFileType"));
      }
      throw e;
    }
    let previewDataURL2 = await getDataURL(imagePreview);
    if (imageFile.type === MIME_TYPES.svg) {
      const img = await loadHTMLImageElement(previewDataURL2);
      let height = Math.min(img.height, cursorImageSizePx);
      let width = height * (img.width / img.height);
      if (width > cursorImageSizePx) {
        width = cursorImageSizePx;
        height = width * (img.height / img.width);
      }
      const canvas2 = document.createElement("canvas");
      canvas2.height = height;
      canvas2.width = width;
      const context = canvas2.getContext("2d");
      context.drawImage(img, 0, 0, width, height);
      previewDataURL2 = canvas2.toDataURL(MIME_TYPES.svg);
    }
    if (this.state.pendingImageElementId) {
      setCursor(this.interactiveCanvas, `url(${previewDataURL2}) 4 4, auto`);
    }
  };
  onImageAction = async ({
    insertOnCanvasDirectly
  }) => {
    try {
      const clientX = this.state.width / 2 + this.state.offsetLeft;
      const clientY = this.state.height / 2 + this.state.offsetTop;
      const { x, y } = viewportCoordsToSceneCoords(
        { clientX, clientY },
        this.state
      );
      const imageFile = await fileOpen({
        description: "Image",
        extensions: Object.keys(
          IMAGE_MIME_TYPES
        )
      });
      const imageElement = this.createImageElement({
        sceneX: x,
        sceneY: y,
        addToFrameUnderCursor: false
      });
      if (insertOnCanvasDirectly) {
        this.insertImageElement(imageElement, imageFile);
        this.initializeImageDimensions(imageElement);
        this.setState(
          {
            selectedElementIds: makeNextSelectedElementIds(
              { [imageElement.id]: true },
              this.state
            )
          },
          () => {
            this.actionManager.executeAction(actionFinalize);
          }
        );
      } else {
        this.setState(
          {
            pendingImageElementId: imageElement.id
          },
          () => {
            this.insertImageElement(
              imageElement,
              imageFile,
              /* showCursorImagePreview */
              true
            );
          }
        );
      }
    } catch (error) {
      if (error.name !== "AbortError") {
        console.error(error);
      } else {
        console.warn(error);
      }
      this.setState(
        {
          pendingImageElementId: null,
          newElement: null,
          activeTool: updateActiveTool(this.state, { type: "selection" })
        },
        () => {
          this.actionManager.executeAction(actionFinalize);
        }
      );
    }
  };
  initializeImageDimensions = (imageElement, forceNaturalSize = false) => {
    const image = isInitializedImageElement(imageElement) && this.imageCache.get(imageElement.fileId)?.image;
    if (!image || image instanceof Promise) {
      if (imageElement.width < DRAGGING_THRESHOLD / this.state.zoom.value && imageElement.height < DRAGGING_THRESHOLD / this.state.zoom.value) {
        const placeholderSize = 100 / this.state.zoom.value;
        mutateElement(imageElement, {
          x: imageElement.x - placeholderSize / 2,
          y: imageElement.y - placeholderSize / 2,
          width: placeholderSize,
          height: placeholderSize
        });
      }
      return;
    }
    if (forceNaturalSize || // if user-created bounding box is below threshold, assume the
    // intention was to click instead of drag, and use the image's
    // intrinsic size
    imageElement.width < DRAGGING_THRESHOLD / this.state.zoom.value && imageElement.height < DRAGGING_THRESHOLD / this.state.zoom.value) {
      const minHeight = Math.max(this.state.height - 120, 160);
      const maxHeight = Math.min(
        minHeight,
        Math.floor(this.state.height * 0.5) / this.state.zoom.value
      );
      const height = Math.min(image.naturalHeight, maxHeight);
      const width = height * (image.naturalWidth / image.naturalHeight);
      const x = imageElement.x + imageElement.width / 2 - width / 2;
      const y = imageElement.y + imageElement.height / 2 - height / 2;
      mutateElement(imageElement, { x, y, width, height });
    }
  };
  /** updates image cache, refreshing updated elements and/or setting status
      to error for images that fail during <img> element creation */
  updateImageCache = async (elements, files = this.files) => {
    const { updatedFiles, erroredFiles } = await updateImageCache({
      imageCache: this.imageCache,
      fileIds: elements.map((element) => element.fileId),
      files
    });
    if (updatedFiles.size || erroredFiles.size) {
      for (const element of elements) {
        if (updatedFiles.has(element.fileId)) {
          ShapeCache.delete(element);
        }
      }
    }
    if (erroredFiles.size) {
      this.scene.replaceAllElements(
        this.scene.getElementsIncludingDeleted().map((element) => {
          if (isInitializedImageElement(element) && erroredFiles.has(element.fileId)) {
            return newElementWith(element, {
              status: "error"
            });
          }
          return element;
        })
      );
    }
    return { updatedFiles, erroredFiles };
  };
  /** adds new images to imageCache and re-renders if needed */
  addNewImagesToImageCache = async (imageElements = getInitializedImageElements(
    this.scene.getNonDeletedElements()
  ), files = this.files) => {
    const uncachedImageElements = imageElements.filter(
      (element) => !element.isDeleted && !this.imageCache.has(element.fileId)
    );
    if (uncachedImageElements.length) {
      const { updatedFiles } = await this.updateImageCache(
        uncachedImageElements,
        files
      );
      if (updatedFiles.size) {
        this.scene.triggerUpdate();
      }
    }
  };
  /** generally you should use `addNewImagesToImageCache()` directly if you need
   *  to render new images. This is just a failsafe  */
  scheduleImageRefresh = throttle4(() => {
    this.addNewImagesToImageCache();
  }, IMAGE_RENDER_TIMEOUT);
  updateBindingEnabledOnPointerMove = (event) => {
    const shouldEnableBinding = shouldEnableBindingForPointerEvent(event);
    if (this.state.isBindingEnabled !== shouldEnableBinding) {
      this.setState({ isBindingEnabled: shouldEnableBinding });
    }
  };
  maybeSuggestBindingAtCursor = (pointerCoords) => {
    const hoveredBindableElement = getHoveredElementForBinding(
      pointerCoords,
      this.scene.getNonDeletedElements(),
      this.scene.getNonDeletedElementsMap()
    );
    this.setState({
      suggestedBindings: hoveredBindableElement != null ? [hoveredBindableElement] : []
    });
  };
  maybeSuggestBindingsForLinearElementAtCoords = (linearElement, pointerCoords, oppositeBindingBoundElement) => {
    if (!pointerCoords.length) {
      return;
    }
    const suggestedBindings = pointerCoords.reduce(
      (acc, coords) => {
        const hoveredBindableElement = getHoveredElementForBinding(
          coords,
          this.scene.getNonDeletedElements(),
          this.scene.getNonDeletedElementsMap(),
          isArrowElement(linearElement) && isElbowArrow(linearElement)
        );
        if (hoveredBindableElement != null && !isLinearElementSimpleAndAlreadyBound(
          linearElement,
          oppositeBindingBoundElement?.id,
          hoveredBindableElement
        )) {
          acc.push(hoveredBindableElement);
        }
        return acc;
      },
      []
    );
    this.setState({ suggestedBindings });
  };
  clearSelection(hitElement) {
    this.setState((prevState) => ({
      selectedElementIds: makeNextSelectedElementIds({}, prevState),
      activeEmbeddable: null,
      selectedGroupIds: {},
      // Continue editing the same group if the user selected a different
      // element from it
      editingGroupId: prevState.editingGroupId && hitElement != null && isElementInGroup(hitElement, prevState.editingGroupId) ? prevState.editingGroupId : null
    }));
    this.setState({
      selectedElementIds: makeNextSelectedElementIds({}, this.state),
      activeEmbeddable: null,
      previousSelectedElementIds: this.state.selectedElementIds
    });
  }
  handleInteractiveCanvasRef = (canvas2) => {
    if (canvas2 !== null) {
      this.interactiveCanvas = canvas2;
      this.interactiveCanvas.addEventListener(
        "touchstart" /* TOUCH_START */,
        this.onTouchStart
      );
      this.interactiveCanvas.addEventListener("touchend" /* TOUCH_END */, this.onTouchEnd);
    } else {
      this.interactiveCanvas?.removeEventListener(
        "touchstart" /* TOUCH_START */,
        this.onTouchStart
      );
      this.interactiveCanvas?.removeEventListener(
        "touchend" /* TOUCH_END */,
        this.onTouchEnd
      );
    }
  };
  handleAppOnDrop = async (event) => {
    const { file: file2, fileHandle } = await getFileFromEvent(event);
    const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(
      event,
      this.state
    );
    try {
      if (isSupportedImageFile(file2) && this.isToolSupported("image")) {
        if (file2?.type === MIME_TYPES.png || file2?.type === MIME_TYPES.svg) {
          try {
            const scene = await loadFromBlob(
              file2,
              this.state,
              this.scene.getElementsIncludingDeleted(),
              fileHandle
            );
            this.syncActionResult({
              ...scene,
              appState: {
                ...scene.appState || this.state,
                isLoading: false
              },
              replaceFiles: true,
              storeAction: StoreAction.CAPTURE
            });
            return;
          } catch (error) {
            if (error.name !== "EncodingError") {
              throw new Error(t("alerts.couldNotLoadInvalidFile"));
            }
          }
        }
        const imageElement = this.createImageElement({ sceneX, sceneY });
        this.insertImageElement(imageElement, file2);
        this.initializeImageDimensions(imageElement);
        this.setState({
          selectedElementIds: makeNextSelectedElementIds(
            { [imageElement.id]: true },
            this.state
          )
        });
        return;
      }
    } catch (error) {
      return this.setState({
        isLoading: false,
        errorMessage: error.message
      });
    }
    const libraryJSON = event.dataTransfer.getData(MIME_TYPES.excalidrawlib);
    if (libraryJSON && typeof libraryJSON === "string") {
      try {
        const libraryItems = parseLibraryJSON(libraryJSON);
        this.addElementsFromPasteOrLibrary({
          elements: distributeLibraryItemsOnSquareGrid(libraryItems),
          position: event,
          files: null
        });
      } catch (error) {
        this.setState({ errorMessage: error.message });
      }
      return;
    }
    if (file2) {
      await this.loadFileToCanvas(file2, fileHandle);
    }
    if (event.dataTransfer?.types?.includes("text/plain")) {
      const text = event.dataTransfer?.getData("text");
      if (text && embeddableURLValidator(text, this.props.validateEmbeddable) && (/^(http|https):\/\/[^\s/$.?#].[^\s]*$/.test(text) || getEmbedLink(text)?.type === "video")) {
        const embeddable = this.insertEmbeddableElement({
          sceneX,
          sceneY,
          link: normalizeLink(text)
        });
        if (embeddable) {
          this.setState({ selectedElementIds: { [embeddable.id]: true } });
        }
      }
    }
  };
  loadFileToCanvas = async (file2, fileHandle) => {
    file2 = await normalizeFile(file2);
    try {
      const elements = this.scene.getElementsIncludingDeleted();
      let ret;
      try {
        ret = await loadSceneOrLibraryFromBlob(
          file2,
          this.state,
          elements,
          fileHandle
        );
      } catch (error) {
        const imageSceneDataError = error instanceof ImageSceneDataError;
        if (imageSceneDataError && error.code === "IMAGE_NOT_CONTAINS_SCENE_DATA" && !this.isToolSupported("image")) {
          this.setState({
            isLoading: false,
            errorMessage: t("errors.imageToolNotSupported")
          });
          return;
        }
        const errorMessage = imageSceneDataError ? t("alerts.cannotRestoreFromImage") : t("alerts.couldNotLoadInvalidFile");
        this.setState({
          isLoading: false,
          errorMessage
        });
      }
      if (!ret) {
        return;
      }
      if (ret.type === MIME_TYPES.excalidraw) {
        syncInvalidIndices(elements.concat(ret.data.elements));
        this.store.updateSnapshot(arrayToMap(elements), this.state);
        this.setState({ isLoading: true });
        this.syncActionResult({
          ...ret.data,
          appState: {
            ...ret.data.appState || this.state,
            isLoading: false
          },
          replaceFiles: true,
          storeAction: StoreAction.CAPTURE
        });
      } else if (ret.type === MIME_TYPES.excalidrawlib) {
        await this.library.updateLibrary({
          libraryItems: file2,
          merge: true,
          openLibraryMenu: true
        }).catch((error) => {
          console.error(error);
          this.setState({ errorMessage: t("errors.importLibraryError") });
        });
      }
    } catch (error) {
      this.setState({ isLoading: false, errorMessage: error.message });
    }
  };
  handleCanvasContextMenu = (event) => {
    event.preventDefault();
    if (("pointerType" in event.nativeEvent && event.nativeEvent.pointerType === "touch" || "pointerType" in event.nativeEvent && event.nativeEvent.pointerType === "pen" && // always allow if user uses a pen secondary button
    event.button !== POINTER_BUTTON.SECONDARY) && this.state.activeTool.type !== "selection") {
      return;
    }
    const { x, y } = viewportCoordsToSceneCoords(event, this.state);
    const element = this.getElementAtPosition(x, y, {
      preferSelected: true,
      includeLockedElements: true
    });
    const selectedElements = this.scene.getSelectedElements(this.state);
    const isHittingCommonBoundBox = this.isHittingCommonBoundingBoxOfSelectedElements(
      { x, y },
      selectedElements
    );
    const type = element || isHittingCommonBoundBox ? "element" : "canvas";
    const container = this.excalidrawContainerRef.current;
    const { top: offsetTop, left: offsetLeft } = container.getBoundingClientRect();
    const left = event.clientX - offsetLeft;
    const top = event.clientY - offsetTop;
    trackEvent("contextMenu", "openContextMenu", type);
    this.setState(
      {
        ...element && !this.state.selectedElementIds[element.id] ? {
          ...this.state,
          ...selectGroupsForSelectedElements(
            {
              editingGroupId: this.state.editingGroupId,
              selectedElementIds: { [element.id]: true }
            },
            this.scene.getNonDeletedElements(),
            this.state,
            this
          ),
          selectedLinearElement: isLinearElement(element) ? new LinearElementEditor(element) : null
        } : this.state,
        showHyperlinkPopup: false
      },
      () => {
        this.setState({
          contextMenu: { top, left, items: this.getContextMenuItems(type) }
        });
      }
    );
  };
  maybeDragNewGenericElement = (pointerDownState, event, informMutation = true) => {
    const selectionElement = this.state.selectionElement;
    const pointerCoords = pointerDownState.lastCoords;
    if (selectionElement && this.state.activeTool.type !== "eraser") {
      dragNewElement({
        newElement: selectionElement,
        elementType: this.state.activeTool.type,
        originX: pointerDownState.origin.x,
        originY: pointerDownState.origin.y,
        x: pointerCoords.x,
        y: pointerCoords.y,
        width: distance(pointerDownState.origin.x, pointerCoords.x),
        height: distance(pointerDownState.origin.y, pointerCoords.y),
        shouldMaintainAspectRatio: shouldMaintainAspectRatio(event),
        shouldResizeFromCenter: shouldResizeFromCenter(event),
        zoom: this.state.zoom.value,
        informMutation
      });
      return;
    }
    const newElement2 = this.state.newElement;
    if (!newElement2) {
      return;
    }
    let [gridX, gridY] = getGridPoint(
      pointerCoords.x,
      pointerCoords.y,
      event[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
    );
    const image = isInitializedImageElement(newElement2) && this.imageCache.get(newElement2.fileId)?.image;
    const aspectRatio = image && !(image instanceof Promise) ? image.width / image.height : null;
    this.maybeCacheReferenceSnapPoints(event, [newElement2]);
    const { snapOffset, snapLines } = snapNewElement(
      newElement2,
      this,
      event,
      {
        x: pointerDownState.originInGrid.x + (this.state.originSnapOffset?.x ?? 0),
        y: pointerDownState.originInGrid.y + (this.state.originSnapOffset?.y ?? 0)
      },
      {
        x: gridX - pointerDownState.originInGrid.x,
        y: gridY - pointerDownState.originInGrid.y
      },
      this.scene.getNonDeletedElementsMap()
    );
    gridX += snapOffset.x;
    gridY += snapOffset.y;
    this.setState({
      snapLines
    });
    dragNewElement({
      newElement: newElement2,
      elementType: this.state.activeTool.type,
      originX: pointerDownState.originInGrid.x,
      originY: pointerDownState.originInGrid.y,
      x: gridX,
      y: gridY,
      width: distance(pointerDownState.originInGrid.x, gridX),
      height: distance(pointerDownState.originInGrid.y, gridY),
      shouldMaintainAspectRatio: isImageElement(newElement2) ? !shouldMaintainAspectRatio(event) : shouldMaintainAspectRatio(event),
      shouldResizeFromCenter: shouldResizeFromCenter(event),
      zoom: this.state.zoom.value,
      widthAspectRatio: aspectRatio,
      originOffset: this.state.originSnapOffset,
      informMutation
    });
    this.setState({
      newElement: newElement2
    });
    if (this.state.activeTool.type === TOOL_TYPE.frame || this.state.activeTool.type === TOOL_TYPE.magicframe) {
      this.setState({
        elementsToHighlight: getElementsInResizingFrame(
          this.scene.getNonDeletedElements(),
          newElement2,
          this.state,
          this.scene.getNonDeletedElementsMap()
        )
      });
    }
  };
  maybeHandleResize = (pointerDownState, event) => {
    const selectedElements = this.scene.getSelectedElements(this.state);
    const selectedFrames = selectedElements.filter(
      (element) => isFrameLikeElement(element)
    );
    const transformHandleType = pointerDownState.resize.handleType;
    if (
      // Frames cannot be rotated.
      selectedFrames.length > 0 && transformHandleType === "rotation" || // Elbow arrows cannot be transformed (resized or rotated).
      selectedElements.length === 1 && isElbowArrow(selectedElements[0])
    ) {
      return false;
    }
    this.setState({
      // TODO: rename this state field to "isScaling" to distinguish
      // it from the generic "isResizing" which includes scaling and
      // rotating
      isResizing: transformHandleType && transformHandleType !== "rotation",
      isRotating: transformHandleType === "rotation",
      activeEmbeddable: null
    });
    const pointerCoords = pointerDownState.lastCoords;
    let [resizeX, resizeY] = getGridPoint(
      pointerCoords.x - pointerDownState.resize.offset.x,
      pointerCoords.y - pointerDownState.resize.offset.y,
      event[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
    );
    const frameElementsOffsetsMap = /* @__PURE__ */ new Map();
    selectedFrames.forEach((frame) => {
      const elementsInFrame = getFrameChildren(
        this.scene.getNonDeletedElements(),
        frame.id
      );
      elementsInFrame.forEach((element) => {
        frameElementsOffsetsMap.set(frame.id + element.id, {
          x: element.x - frame.x,
          y: element.y - frame.y
        });
      });
    });
    if (!this.state.selectedElementsAreBeingDragged) {
      const [gridX, gridY] = getGridPoint(
        pointerCoords.x,
        pointerCoords.y,
        event[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
      );
      const dragOffset = {
        x: gridX - pointerDownState.originInGrid.x,
        y: gridY - pointerDownState.originInGrid.y
      };
      const originalElements = [...pointerDownState.originalElements.values()];
      this.maybeCacheReferenceSnapPoints(event, selectedElements);
      const { snapOffset, snapLines } = snapResizingElements(
        selectedElements,
        getSelectedElements(originalElements, this.state),
        this,
        event,
        dragOffset,
        transformHandleType
      );
      resizeX += snapOffset.x;
      resizeY += snapOffset.y;
      this.setState({
        snapLines
      });
    }
    if (transformElements(
      pointerDownState.originalElements,
      transformHandleType,
      selectedElements,
      this.scene.getElementsMapIncludingDeleted(),
      shouldRotateWithDiscreteAngle(event),
      shouldResizeFromCenter(event),
      selectedElements.some((element) => isImageElement(element)) ? !shouldMaintainAspectRatio(event) : shouldMaintainAspectRatio(event),
      resizeX,
      resizeY,
      pointerDownState.resize.center.x,
      pointerDownState.resize.center.y
    )) {
      const suggestedBindings = getSuggestedBindingsForArrows(
        selectedElements,
        this.scene.getNonDeletedElementsMap()
      );
      const elementsToHighlight = /* @__PURE__ */ new Set();
      selectedFrames.forEach((frame) => {
        getElementsInResizingFrame(
          this.scene.getNonDeletedElements(),
          frame,
          this.state,
          this.scene.getNonDeletedElementsMap()
        ).forEach((element) => elementsToHighlight.add(element));
      });
      this.setState({
        elementsToHighlight: [...elementsToHighlight],
        suggestedBindings
      });
      return true;
    }
    return false;
  };
  getContextMenuItems = (type) => {
    const options = [];
    options.push(actionCopyAsPng, actionCopyAsSvg);
    if (type === "canvas") {
      if (this.state.viewModeEnabled) {
        return [
          ...options,
          actionToggleGridMode,
          actionToggleZenMode,
          actionToggleViewMode,
          actionToggleStats
        ];
      }
      return [
        actionPaste,
        CONTEXT_MENU_SEPARATOR,
        actionCopyAsPng,
        actionCopyAsSvg,
        copyText,
        CONTEXT_MENU_SEPARATOR,
        actionSelectAll,
        actionUnlockAllElements,
        CONTEXT_MENU_SEPARATOR,
        actionToggleGridMode,
        actionToggleObjectsSnapMode,
        actionToggleZenMode,
        actionToggleViewMode,
        actionToggleStats
      ];
    }
    options.push(copyText);
    if (this.state.viewModeEnabled) {
      return [actionCopy, ...options];
    }
    return [
      CONTEXT_MENU_SEPARATOR,
      actionCut,
      actionCopy,
      actionPaste,
      actionSelectAllElementsInFrame,
      actionRemoveAllElementsFromFrame,
      CONTEXT_MENU_SEPARATOR,
      ...options,
      CONTEXT_MENU_SEPARATOR,
      actionCopyStyles,
      actionPasteStyles,
      CONTEXT_MENU_SEPARATOR,
      actionGroup,
      actionTextAutoResize,
      actionUnbindText,
      actionBindText,
      actionWrapTextInContainer,
      actionUngroup,
      CONTEXT_MENU_SEPARATOR,
      actionAddToLibrary,
      CONTEXT_MENU_SEPARATOR,
      actionSendBackward,
      actionBringForward,
      actionSendToBack,
      actionBringToFront,
      CONTEXT_MENU_SEPARATOR,
      actionFlipHorizontal,
      actionFlipVertical,
      CONTEXT_MENU_SEPARATOR,
      actionToggleLinearEditor,
      actionLink,
      actionDuplicateSelection,
      actionToggleElementLock,
      CONTEXT_MENU_SEPARATOR,
      actionDeleteSelected
    ];
  };
  handleWheel = withBatchedUpdates(
    (event) => {
      if (!(event.target instanceof HTMLCanvasElement || event.target instanceof HTMLTextAreaElement || event.target instanceof HTMLIFrameElement)) {
        if (event[KEYS.CTRL_OR_CMD]) {
          event.preventDefault();
        }
        return;
      }
      event.preventDefault();
      if (isPanning) {
        return;
      }
      const { deltaX, deltaY } = event;
      if (event.metaKey || event.ctrlKey) {
        const sign2 = Math.sign(deltaY);
        const MAX_STEP = ZOOM_STEP * 100;
        const absDelta = Math.abs(deltaY);
        let delta = deltaY;
        if (absDelta > MAX_STEP) {
          delta = MAX_STEP * sign2;
        }
        let newZoom = this.state.zoom.value - delta / 100;
        newZoom += Math.log10(Math.max(1, this.state.zoom.value)) * -sign2 * // reduced amplification for small deltas (small movements on a trackpad)
        Math.min(1, absDelta / 20);
        this.translateCanvas((state) => ({
          ...getStateForZoom(
            {
              viewportX: this.lastViewportPosition.x,
              viewportY: this.lastViewportPosition.y,
              nextZoom: getNormalizedZoom(newZoom)
            },
            state
          ),
          shouldCacheIgnoreZoom: true
        }));
        this.resetShouldCacheIgnoreZoomDebounced();
        return;
      }
      if (event.shiftKey) {
        this.translateCanvas(({ zoom, scrollX }) => ({
          // on Mac, shift+wheel tends to result in deltaX
          scrollX: scrollX - (deltaY || deltaX) / zoom.value
        }));
        return;
      }
      this.translateCanvas(({ zoom, scrollX, scrollY }) => ({
        scrollX: scrollX - deltaX / zoom.value,
        scrollY: scrollY - deltaY / zoom.value
      }));
    }
  );
  getTextWysiwygSnappedToCenterPosition(x, y, appState, container) {
    if (container) {
      let elementCenterX = container.x + container.width / 2;
      let elementCenterY = container.y + container.height / 2;
      const elementCenter = getContainerCenter(
        container,
        appState,
        this.scene.getNonDeletedElementsMap()
      );
      if (elementCenter) {
        elementCenterX = elementCenter.x;
        elementCenterY = elementCenter.y;
      }
      const distanceToCenter = Math.hypot(
        x - elementCenterX,
        y - elementCenterY
      );
      const isSnappedToCenter = distanceToCenter < TEXT_TO_CENTER_SNAP_THRESHOLD;
      if (isSnappedToCenter) {
        const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(
          { sceneX: elementCenterX, sceneY: elementCenterY },
          appState
        );
        return { viewportX, viewportY, elementCenterX, elementCenterY };
      }
    }
  }
  savePointer = (x, y, button) => {
    if (!x || !y) {
      return;
    }
    const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(
      { clientX: x, clientY: y },
      this.state
    );
    if (isNaN(sceneX) || isNaN(sceneY)) {
    }
    const pointer = {
      x: sceneX,
      y: sceneY,
      tool: this.state.activeTool.type === "laser" ? "laser" : "pointer"
    };
    this.props.onPointerUpdate?.({
      pointer,
      button,
      pointersMap: gesture.pointers
    });
  };
  resetShouldCacheIgnoreZoomDebounced = debounce(() => {
    if (!this.unmounted) {
      this.setState({ shouldCacheIgnoreZoom: false });
    }
  }, 300);
  updateDOMRect = (cb) => {
    if (this.excalidrawContainerRef?.current) {
      const excalidrawContainer = this.excalidrawContainerRef.current;
      const {
        width,
        height,
        left: offsetLeft,
        top: offsetTop
      } = excalidrawContainer.getBoundingClientRect();
      const {
        width: currentWidth,
        height: currentHeight,
        offsetTop: currentOffsetTop,
        offsetLeft: currentOffsetLeft
      } = this.state;
      if (width === currentWidth && height === currentHeight && offsetLeft === currentOffsetLeft && offsetTop === currentOffsetTop) {
        if (cb) {
          cb();
        }
        return;
      }
      this.setState(
        {
          width,
          height,
          offsetLeft,
          offsetTop
        },
        () => {
          cb && cb();
        }
      );
    }
  };
  refresh = () => {
    this.setState({ ...this.getCanvasOffsets() });
  };
  getCanvasOffsets() {
    if (this.excalidrawContainerRef?.current) {
      const excalidrawContainer = this.excalidrawContainerRef.current;
      const { left, top } = excalidrawContainer.getBoundingClientRect();
      return {
        offsetLeft: left,
        offsetTop: top
      };
    }
    return {
      offsetLeft: 0,
      offsetTop: 0
    };
  }
  async updateLanguage() {
    const currentLang2 = languages.find((lang) => lang.code === this.props.langCode) || defaultLang;
    await setLanguage(currentLang2);
    this.setAppState({});
  }
};
var createTestHook = () => {
  if (define_import_meta_env_default.MODE === ENV.TEST || define_import_meta_env_default.DEV) {
    window.h = window.h || {};
    Object.defineProperties(window.h, {
      elements: {
        configurable: true,
        get() {
          return this.app?.scene.getElementsIncludingDeleted();
        },
        set(elements) {
          return this.app?.scene.replaceAllElements(
            syncInvalidIndices(elements)
          );
        }
      },
      scene: {
        configurable: true,
        get() {
          return this.app?.scene;
        }
      }
    });
  }
};
createTestHook();
var App_default = App;

// index.tsx
init_utils2();

// polyfill.ts
init_define_import_meta_env();
var polyfill = () => {
  if (!Array.prototype.at) {
    Object.defineProperty(Array.prototype, "at", {
      value: function(n) {
        n = Math.trunc(n) || 0;
        if (n < 0) {
          n += this.length;
        }
        if (n < 0 || n >= this.length) {
          return void 0;
        }
        return this[n];
      },
      writable: true,
      enumerable: false,
      configurable: true
    });
  }
  if (!Element.prototype.replaceChildren) {
    Element.prototype.replaceChildren = function(...nodes) {
      this.innerHTML = "";
      this.append(...nodes);
    };
  }
};
var polyfill_default = polyfill;

// index.tsx
init_constants();
import { Provider as Provider2 } from "jotai";

// components/footer/FooterCenter.tsx
init_define_import_meta_env();
import clsx57 from "clsx";
import { jsx as jsx146 } from "react/jsx-runtime";
var FooterCenter = ({ children }) => {
  const { FooterCenterTunnel } = useTunnels();
  const appState = useUIAppState();
  return /* @__PURE__ */ jsx146(FooterCenterTunnel.In, { children: /* @__PURE__ */ jsx146(
    "div",
    {
      className: clsx57("footer-center zen-mode-transition", {
        "layer-ui__wrapper__footer-left--transition-bottom": appState.zenModeEnabled
      }),
      children
    }
  ) });
};
var FooterCenter_default = FooterCenter;
FooterCenter.displayName = "FooterCenter";

// components/welcome-screen/WelcomeScreen.tsx
init_define_import_meta_env();

// components/welcome-screen/WelcomeScreen.Center.tsx
init_define_import_meta_env();
init_icons();

// components/ExcalidrawLogo.tsx
init_define_import_meta_env();
import { jsx as jsx147, jsxs as jsxs78 } from "react/jsx-runtime";
var LogoIcon = () => /* @__PURE__ */ jsx147(
  "svg",
  {
    viewBox: "0 0 40 40",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: "ExcalidrawLogo-icon",
    children: /* @__PURE__ */ jsx147(
      "path",
      {
        d: "M39.9 32.889a.326.326 0 0 0-.279-.056c-2.094-3.083-4.774-6-7.343-8.833l-.419-.472a.212.212 0 0 0-.056-.139.586.586 0 0 0-.167-.111l-.084-.083-.056-.056c-.084-.167-.28-.278-.475-.167-.782.39-1.507.973-2.206 1.528-.92.722-1.842 1.445-2.708 2.25a8.405 8.405 0 0 0-.977 1.028c-.14.194-.028.361.14.444-.615.611-1.23 1.223-1.843 1.861a.315.315 0 0 0-.084.223c0 .083.056.166.111.194l1.09.833v.028c1.535 1.528 4.244 3.611 7.12 5.861.418.334.865.667 1.284 1 .195.223.39.473.558.695.084.11.28.139.391.055.056.056.14.111.196.167a.398.398 0 0 0 .167.056.255.255 0 0 0 .224-.111.394.394 0 0 0 .055-.167c.029 0 .028.028.056.028a.318.318 0 0 0 .224-.084l5.082-5.528a.309.309 0 0 0 0-.444Zm-14.63-1.917a.485.485 0 0 0 .111.14c.586.5 1.2 1 1.843 1.555l-2.569-1.945-.251-.166c-.056-.028-.112-.084-.168-.111l-.195-.167.056-.056.055-.055.112-.111c.866-.861 2.346-2.306 3.1-3.028-.81.805-2.43 3.167-2.095 3.944Zm8.767 6.89-2.122-1.612a44.713 44.713 0 0 0-2.625-2.5c1.145.861 2.122 1.611 2.262 1.75 1.117.972 1.06.806 1.815 1.445l.921.666a1.06 1.06 0 0 1-.251.25Zm.558.416-.056-.028c.084-.055.168-.111.252-.194l-.196.222ZM1.089 5.75c.055.361.14.722.195 1.056.335 1.833.67 3.5 1.284 4.75l.252.944c.084.361.223.806.363.917 1.424 1.25 3.602 3.11 5.947 4.889a.295.295 0 0 0 .363 0s0 .027.028.027a.254.254 0 0 0 .196.084.318.318 0 0 0 .223-.084c2.988-3.305 5.221-6.027 6.813-8.305.112-.111.14-.278.14-.417.111-.111.195-.25.307-.333.111-.111.111-.306 0-.39l-.028-.027c0-.055-.028-.139-.084-.167-.698-.666-1.2-1.138-1.731-1.638-.922-.862-1.871-1.75-3.881-3.75l-.028-.028c-.028-.028-.056-.056-.112-.056-.558-.194-1.703-.389-3.127-.639C6.087 2.223 3.21 1.723.614.944c0 0-.168 0-.196.028l-.083.084c-.028.027-.056.055-.224.11h.056-.056c.028.167.028.278.084.473 0 .055.112.5.112.555l.782 3.556Zm15.496 3.278-.335-.334c.084.112.196.195.335.334Zm-3.546 4.666-.056.056c0-.028.028-.056.056-.056Zm-2.038-10c.168.167.866.834 1.033.973-.726-.334-2.54-1.167-3.379-1.445.838.167 1.983.334 2.346.472ZM1.424 2.306c.419.722.754 3.222 1.089 5.666-.196-.778-.335-1.555-.503-2.278-.251-1.277-.503-2.416-.838-3.416.056 0 .14 0 .252.028Zm-.168-.584c-.112 0-.223-.028-.307-.028 0-.027 0-.055-.028-.055.14 0 .223.028.335.083Zm-1.089.222c0-.027 0-.027 0 0ZM39.453 1.333c.028-.11-.558-.61-.363-.639.42-.027.42-.666 0-.666-.558.028-1.144.166-1.675.25-.977.194-1.982.389-2.96.61-2.205.473-4.383.973-6.561 1.557-.67.194-1.424.333-2.066.666-.224.111-.196.333-.084.472-.056.028-.084.028-.14.056-.195.028-.363.056-.558.083-.168.028-.252.167-.224.334 0 .027.028.083.028.11-1.173 1.556-2.485 3.195-3.909 4.945-1.396 1.611-2.876 3.306-4.356 5.056-4.719 5.5-10.052 11.75-15.943 17.25a.268.268 0 0 0 0 .389c.028.027.056.055.084.055-.084.084-.168.14-.252.222-.056.056-.084.111-.084.167a.605.605 0 0 0-.111.139c-.112.111-.112.305.028.389.111.11.307.11.39-.028.029-.028.029-.056.056-.056a.44.44 0 0 1 .615 0c.335.362.67.723.977 1.028l-.698-.583c-.112-.111-.307-.083-.39.028-.113.11-.085.305.027.389l7.427 6.194c.056.056.112.056.196.056s.14-.028.195-.084l.168-.166c.028.027.083.027.111.027.084 0 .14-.027.196-.083 10.052-10.055 18.15-17.639 27.42-24.417.083-.055.111-.166.111-.25.112 0 .196-.083.251-.194 1.704-5.194 2.039-9.806 2.15-12.083v-.028c0-.028.028-.056.028-.083.028-.056.028-.084.028-.084a1.626 1.626 0 0 0-.111-1.028ZM21.472 9.5c.446-.5.893-1.028 1.34-1.5-2.876 3.778-7.65 9.583-14.408 16.5 4.607-5.083 9.242-10.333 13.068-15ZM5.193 35.778h.084-.084Zm3.462 3.194c-.027-.028-.027-.028 0-.028v.028Zm4.16-3.583c.224-.25.448-.472.699-.722 0 0 0 .027.028.027-.252.223-.475.445-.726.695Zm1.146-1.111c.14-.14.279-.334.446-.5l.028-.028c1.648-1.694 3.351-3.389 5.082-5.111l.028-.028c.419-.333.921-.694 1.368-1.028a379.003 379.003 0 0 0-6.952 6.695ZM24.794 6.472c-.921 1.195-1.954 2.778-2.82 4.028-2.736 3.944-11.532 13.583-11.727 13.75a1976.983 1976.983 0 0 1-8.042 7.639l-.167.167c-.14-.167-.14-.417.028-.556C14.49 19.861 22.03 10.167 25.074 5.917c-.084.194-.14.36-.28.555Zm4.83 5.695c-1.116-.64-1.646-1.64-1.34-2.611l.084-.334c.028-.083.084-.194.14-.277.307-.5.754-.917 1.257-1.167.027 0 .055 0 .083-.028-.028-.056-.028-.139-.028-.222.028-.167.14-.278.335-.278.335 0 1.369.306 1.76.639.111.083.223.194.335.305.14.167.363.445.474.667.056.028.112.306.196.445.056.222.111.472.084.694-.028.028 0 .194-.028.194a2.668 2.668 0 0 1-.363 1.028c-.028.028-.028.056-.056.084l-.028.027c-.14.223-.335.417-.53.556-.643.444-1.369.583-2.095.389 0 0-.195-.084-.28-.111Zm8.154-.834a39.098 39.098 0 0 1-.893 3.167c0 .028-.028.083 0 .111-.056 0-.084.028-.14.056-2.206 1.61-4.356 3.305-6.506 5.028 1.843-1.64 3.686-3.306 5.613-4.945.558-.5.949-1.139 1.06-1.861l.28-1.667v-.055c.14-.334.67-.195.586.166Z",
        fill: "currentColor"
      }
    )
  }
);
var LogoText = () => /* @__PURE__ */ jsxs78(
  "svg",
  {
    viewBox: "0 0 450 55",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    className: "ExcalidrawLogo-text",
    children: [
      /* @__PURE__ */ jsx147(
        "path",
        {
          d: "M429.27 96.74c2.47-1.39 4.78-3.02 6.83-4.95 1.43-1.35 2.73-2.86 3.81-4.51-.66.9-1.4 1.77-2.23 2.59-2.91 2.84-5.72 5.09-8.42 6.87h.01ZM343.6 69.36c.33 3.13.58 6.27.79 9.4.09 1.37.18 2.75.25 4.12-.12-4.46-.27-8.93-.5-13.39-.11-2.08-.24-4.16-.4-6.24-.06 1.79-.11 3.85-.13 6.11h-.01ZM378.47 98.34c.01-.37.07-1.13.01-6.51-.11 1.9-.22 3.81-.31 5.71-.07 1.42-.22 2.91-.16 4.35.39.03.78.07 1.17.1-.92-.85-.76-2.01-.72-3.66l.01.01ZM344.09 86.12c-.09-2.41-.22-4.83-.39-7.24v12.21c.15-.05.32-.09.47-.14.05-1.61-.03-3.23-.09-4.83h.01ZM440.69 66.79c-.22-.34-.45-.67-.69-.99-3.71-4.87-9.91-7.14-15.65-8.55-1.05-.26-2.12-.49-3.18-.71 2.29.59 4.48 1.26 6.64 2.02 7.19 2.54 10.57 5.41 12.88 8.23ZM305.09 72.46l1.2 3.6c.84 2.53 1.67 5.06 2.46 7.61.24.78.5 1.57.73 2.36.22-.04.44-.08.67-.12a776.9 776.9 0 0 1-5.01-13.57c-.02.04-.03.09-.05.13v-.01ZM345.49 90.25v.31c1.48-.42 3.05-.83 4.66-1.2-1.56.25-3.12.52-4.66.89ZM371.02 90.22c0-.57-.04-1.14-.11-1.71-.06-.02-.12-.04-.19-.05-.21-.05-.43-.08-.65-.11.42.16.74.88.95 1.87ZM398.93 54.23c-.13 0-.27-.01-.4-.02l.03.4c.11-.15.23-.27.37-.38ZM401.57 62.28v-.15c-1.22-.24-2.86-.61-3.23-1.25-.09-.15-.18-.51-.27-.98-.09.37-.2.73-.33 1.09 1.24.56 2.52.98 3.83 1.29ZM421.73 88.68c-2.97 1.65-6.28 3.12-9.69 3.68v.18c4.72-.14 11.63-3.85 16.33-8.38-2.04 1.75-4.33 3.24-6.63 4.53l-.01-.01ZM411.28 80.92c-.05-1.2-.09-2.4-.15-3.6-.21 5.66-.46 11.38-.47 14.51.24-.02.48-.04.71-.07.15-3.61.05-7.23-.09-10.83v-.01Z",
          transform: "translate(-144.023 -51.76)"
        }
      ),
      /* @__PURE__ */ jsx147(
        "path",
        {
          d: "M425.38 67.41c-3.5-1.45-7.19-2.57-14.06-3.62.09 1.97.06 4.88-.03 8.12.03.04.06.09.06.15.19 1.36.28 2.73.37 4.1.25 3.77.39 7.55.41 11.33 0 1.38-.01 2.76-.07 4.13 1.4-.25 2.78-.65 4.12-1.15 4.07-1.5 7.94-3.78 11.28-6.54 2.33-1.92 5.13-4.49 5.88-7.58.63-3.53-2.45-6.68-7.97-8.96l.01.02ZM411.35 92.53v-.06l-.34.03c.11.01.22.03.34.03ZM314.26 64.06c-.23-.59-.47-1.17-.7-1.75.57 1.62 1.11 3.25 1.6 4.9l.15.54 2.35 6.05c.32.82.66 1.64.98 2.46-1.38-4.1-2.83-8.17-4.39-12.2h.01ZM156.82 103.07c-.18.13-.38.23-.58.33 1.32-.03 2.66-.2 3.93-.34.86-.09 1.72-.22 2.58-.33-2.12.1-4.12.17-5.94.34h.01ZM210.14 68.88s.03.04.05.07c.18-.31.39-.64.58-.96-.21.3-.42.6-.64.89h.01ZM201.65 82.8c-.5.77-1.02 1.56-1.49 2.37 1.11-1.55 2.21-3.1 3.2-4.59-.23.23-.49.51-.75.79-.32.47-.65.95-.96 1.43ZM194.03 98.66c-.33-.4-.65-.84-1.05-1.17-.24-.2-.07-.49.17-.56-.23-.26-.42-.5-.63-.75 1.51-2.55 3.93-5.87 6.4-9.28-.17-.08-.29-.28-.2-.49.04-.09.09-.17.13-.26-1.21 1.78-2.42 3.55-3.61 5.33-.87 1.31-1.74 2.64-2.54 4-.29.5-.63 1.04-.87 1.61.81.65 1.63 1.27 2.47 1.88-.09-.11-.18-.21-.27-.32v.01ZM307.79 82.93c-1-3.17-2.05-6.32-3.1-9.48-1.62 4.08-3.69 9.17-6.16 15.19 3.32-1.04 6.77-1.87 10.27-2.5-.32-1.08-.67-2.15-1.01-3.21ZM149.5 80.7c.05-1.71.04-3.43 0-5.14-.1 2.26-.16 4.51-.22 6.77-.02.73-.03 1.46-.04 2.19.14-1.27.2-2.55.24-3.82h.02ZM228.98 98.3c.39 1.25.91 3.03.94 3.91.06-.03.12-.07.17-.1.08-1.29-.55-2.65-1.11-3.81ZM307.72 53.36c.81.5 1.53 1.04 2.07 1.49-.38-.8-.78-1.58-1.21-2.35-.17.03-.34.06-.51.11-.43.12-.86.26-1.29.41.35-.01.53.1.94.34ZM283.69 96.14c3.91-7.25 6.89-13.35 8.88-18.15l1.1-2.66c-1.27 2.64-2.56 5.27-3.83 7.9-1.53 3.15-3.06 6.31-4.58 9.47-.87 1.81-1.76 3.62-2.54 5.47.04.02.07.04.11.07.05.05.1.09.15.14.05-.73.27-1.48.71-2.24ZM289.92 103.23s-.04.01-.05.03c0-.02.04-.03.05-.04.05-.05.11-.1.16-.15l.21-.21c-.55 0-1.5-.27-2.55-.72.4.26.8.51 1.22.74.24.13.48.26.73.37.05.02.1.03.14.05a.27.27 0 0 1 .08-.07h.01ZM269.23 68.49c-.39-.19-.82-.48-1.33-.87-3.06-1.56-6.31-2.78-9.36-2.35-3.5.49-5.7 1.11-7.74 2.44 5.71-2.6 12.82-2.07 18.44.79l-.01-.01ZM177.87 53.69l1.06.03c-.96-.22-2-.25-2.89-.3-4.95-.26-9.99.33-14.86 1.19-2.44.43-4.88.95-7.28 1.59 9.09-1.76 15.69-2.77 23.97-2.51ZM219.85 55.51c-.18.12-.36.27-.56.45-.45.53-.86 1.11-1.26 1.66-1.91 2.61-3.71 5.31-5.57 7.95l-.12.18 8.05-10.11c-.18-.05-.36-.1-.55-.13h.01ZM510.71 54.1c.12-.15.29-.3.53-.45.69-.4 3.72-.63 5.87-.74-.36-.02-.73-.04-1.09-.05-1.84-.03-3.67.09-5.49.35.05.3.12.59.18.88v.01ZM510.76 86.02c1.37-3.07 2.49-6.27 3.57-9.46.55-1.64 1.12-3.3 1.6-4.97-1.59 4.01-3.67 9.14-6.2 15.3.24-.08.5-.14.74-.22.1-.22.19-.44.29-.65ZM566.95 75.76c.11-.02.23.03.31.11-.05-.13-.09-.26-.14-.39-.05.09-.11.18-.17.28ZM511.33 86.41c3.08-.89 6.24-1.62 9.46-2.14-1.51-3.98-2.98-7.96-4.39-11.87-.05.15-.09.31-.14.46-1.02 3.32-2.15 6.61-3.39 9.85-.48 1.25-.98 2.49-1.53 3.7h-.01ZM578.24 74.45c.11-.44.23-.87.35-1.31-.31.7-.64 1.39-.97 2.08.09.21.19.4.28.61.12-.46.23-.92.35-1.38h-.01ZM520.62 53.11c-.09 0-.18-.01-.28-.02.38.34.29 1.08.93 2.53l6.65 17.15c2.2 5.68 4.69 11.36 7.41 16.87l1.06 2.17c-2.95-7.05-5.92-14.08-8.87-21.13-1.58-3.79-3.16-7.59-4.7-11.4-.78-1.92-1.73-3.89-2.25-5.91-.03-.1 0-.19.04-.26h.01ZM578.78 77.87c1.45-5.77 3.07-10.43 3.58-13.36.05-.34.16-.88.31-1.55-.67 1.79-1.37 3.56-2.08 5.33-.12.43-.23.86-.35 1.29-.65 2.43-1.29 4.86-1.9 7.3.14.33.29.65.43 1l.01-.01ZM545.3 94.66c.02-.44.03-.83.05-1.12.02-1.01.05-2.02.11-3.02.03-6.66-.46-14.33-1.46-22.8-.13-.42-.27-1.24-.56-2.89 0-.02 0-.04-.01-.06.62 6.61.95 13.25 1.32 19.87.17 3.08.33 6.16.52 9.23.02.25.03.52.04.78l-.01.01ZM580.77 102.81c.13.2.27.38.37.49.27-.11.53-.22.8-.32-.43.09-.82.05-1.17-.16v-.01ZM530.48 104.07h.33c-.36-.13-.71-.32-1.04-.56.14.24.3.47.45.7.06-.08.14-.13.26-.13v-.01ZM542.63 58.82c.06.23.11.47.15.71.14-.33.36-.62.7-.86-.28.05-.57.11-.85.15ZM583.81 57.87c.15-.7.29-1.41.42-2.11-.14.45-.28.9-.42 1.34-.46 1.44-.89 2.89-1.31 4.34.44-1.19.88-2.37 1.31-3.57ZM523.62 91.48c-4.66 1.17-9.05 2.89-14.02 5.27 4.65-1.84 9.48-3.29 14.28-4.63-.09-.22-.17-.41-.26-.64ZM460.64 78.3c-.04-2.9-.11-5.81-.28-8.71-.1-1.68-.17-3.43-.5-5.09-.07.02-.14.03-.2.05.3 6.54.45 12.17.51 17.12.17-.07.34-.14.51-.2 0-1.06-.01-2.11-.03-3.17h-.01ZM470.63 63.24c-3.38-.26-6.81.32-10.1 1.1.41 2.01.47 4.14.57 6.18.18 3.55.25 7.11.27 10.67 3.31-1.38 6.5-3.12 9.3-5.35 1.96-1.56 3.86-3.41 5.02-5.66.73-1.41 1.19-3.22.26-4.65-1.09-1.7-3.46-2.14-5.32-2.29ZM460.29 63.68c1-.24 2.01-.46 3.04-.65-1.15.16-2.37.38-3.71.69v.13c.07-.02.15-.04.22-.05.11-.13.3-.18.45-.11v-.01ZM457.24 100.96c.43-.03.86-.07 1.29-.11.14-.49.27-.99.38-1.49-.44.7-1 1.23-1.67 1.6ZM482.88 104.98c-.18.23-.36.38-.55.47.14.09.27.19.4.28a70.76 70.76 0 0 0 4.37-4.63c.76-.89 1.52-1.81 2.19-2.77-.3-.27-.61-.53-.92-.79-.07 1.94-4.62 6.32-5.49 7.45v-.01Z",
          transform: "translate(-144.023 -51.76)"
        }
      ),
      /* @__PURE__ */ jsx147(
        "path",
        {
          d: "M474.36 63.31c-.4-.16-.84-.27-1.29-.37 1.56.42 3.08 1.22 3.76 2.74.62 1.4.32 2.95-.28 4.32.7-1.22.94-2.34.74-3.47-.24-1.33-1.19-2.54-2.93-3.21v-.01ZM477.34 89.18c-1.2-.81-2.4-1.62-3.6-2.42-.14.1-.26.19-.4.29 1.4.67 2.73 1.39 4 2.13ZM465.88 93.85c.37.25.74.5 1.1.75.46.32.92.65 1.38.97-1.57-1.2-2.01-1.61-2.49-1.72h.01ZM574.92 90.06c-2.28-5.21-4.93-11.13-5.67-12.26-.1-.15-1.57-3.01-1.63-3.08 0 0-.01.02-.02.02.4 1.37 1.09 2.69 1.65 3.99 2.14 4.95 4.36 9.86 6.67 14.73.6 1.26 1.21 2.52 1.83 3.78-.75-2.01-1.64-4.45-2.83-7.18ZM448.73 65.29c.1.2.22.38.34.57.22-.02.43-.06.65-.08v-.08c-.14-.05-.25 0-.99-.41ZM460.16 94.81c-.02.31-.06.59-.1.89-.03 1.71-.33 3.43-.79 5.07.15-.02.3-.03.45-.05.01-.04.02-.08.03-.11.09-.34.15-.69.2-1.03.17-1.07.25-2.16.33-3.24.05-.69.08-1.39.12-2.08-.27.1-.27.26-.24.57v-.02Z",
          transform: "translate(-144.023 -51.76)"
        }
      ),
      /* @__PURE__ */ jsx147(
        "path",
        {
          d: "m328.67 98.12-3.22-6.58c-1.29-2.63-2.53-5.29-3.72-7.97-.25-.85-.52-1.69-.79-2.53-.81-2.57-1.67-5.12-2.55-7.67-1.92-5.53-3.9-11.08-6.32-16.41-.72-1.58-1.46-3.44-2.63-4.79-.03-.17-.16-.29-.34-.36a.282.282 0 0 0-.23-.04c-.06-.01-.12 0-.18.01-.74.06-1.5.38-2.19.61-2.22.77-4.4 1.64-6.63 2.38-.03-.08-.06-.16-.09-.25-.15-.42-.82-.24-.67.19.03.09.07.19.1.28l-.18.06c-.36.11-.28.6 0 .68.18 1.18.63 2.36.98 3.49.03.09.06.17.08.26-.08.23-.17.46-.24.64-.37.98-.79 1.94-1.21 2.9-1.27 2.89-2.62 5.75-3.98 8.6-3.18 6.67-6.44 13.31-9.64 19.97-1.08 2.25-2.2 4.5-3.15 6.81-.13.32.24.5.5.37 1.34 1.33 2.84 2.5 4.4 3.57.65.44 1.31.87 2.01 1.24.4.22.86.48 1.33.5.24.01.35-.19.33-.37.11-.1.21-.21.28-.28.41-.41.81-.84 1.2-1.26.85-.92 1.69-1.87 2.5-2.84 6.31-2.34 12.6-4.31 18.71-5.84 2.14 5.3 3.43 8.43 3.97 9.58.55 1.05 1.15 1.88 1.82 2.52 1.32.56 6.96-.03 9.23-1.96.87-1.28 1.19-2.67.93-4.15-.09-.5-.22-.95-.4-1.33l-.01-.03Zm-20.09-45.61c.43.77.83 1.56 1.21 2.35-.54-.45-1.27-.99-2.07-1.49-.42-.24-.6-.35-.94-.34.43-.15.85-.29 1.29-.41.17-.05.34-.08.51-.11Zm-25.86 45.66c.78-1.85 1.67-3.66 2.54-5.47 1.51-3.16 3.05-6.31 4.58-9.47 1.28-2.63 2.56-5.26 3.83-7.9l-1.1 2.66c-1.99 4.79-4.97 10.9-8.88 18.15-.43.76-.66 1.51-.71 2.24-.05-.05-.1-.09-.15-.14a.259.259 0 0 0-.11-.07Zm6.24 4.71c-.42-.23-.82-.48-1.22-.74 1.05.45 2 .72 2.55.72l-.21.21c-.05.05-.11.1-.16.15-.01.01-.04.03-.05.04 0-.02.03-.02.05-.03a.27.27 0 0 0-.08.07c-.05-.02-.1-.03-.14-.05-.25-.1-.49-.24-.73-.37h-.01Zm15.73-29.43c1.05 3.15 2.1 6.31 3.1 9.48.34 1.06.69 2.13 1.01 3.21-3.5.63-6.95 1.46-10.27 2.5 2.48-6.03 4.54-11.11 6.16-15.19Zm4.79 12.57c-.23-.79-.49-1.58-.73-2.36-.79-2.54-1.63-5.08-2.46-7.61l-1.2-3.6c.02-.04.04-.09.05-.13 1.6 4.45 3.28 9 5.01 13.57l-.67.12v.01Zm5.83-18.27-.15-.54c-.49-1.64-1.03-3.28-1.6-4.9.23.58.47 1.17.7 1.75 1.56 4.03 3.01 8.1 4.39 12.2-.33-.82-.67-1.64-.98-2.46l-2.35-6.05h-.01ZM390.43 79.37c-.13-10.43-.22-17.5-.24-19.97-.24-1.6.21-2.88-.65-3.65-.14-.13-.32-.23-.52-.32h.03c.45 0 .45-.69 0-.7-1.75-.03-3.5-.04-5.25-.14-1.38-.08-2.76-.21-4.15-.31-.07 0-.12.01-.17.04-.21-.07-.47.03-.45.31l.03.45c-.11.14-.19.3-.22.5-.21 1.26-.32 13.67-.36 23.59-.32 5.79-.67 11.57-.97 17.36-.09 1.73-.29 3.54-.21 5.3-.39.02-.38.64.04.69v.12c.05.44.74.45.7 0v-.06c1.1.09 2.2.21 3.3.3 1.14.19 2.44.2 3.29.17 1.73-.05 2.92-.05 3.8-.37.45-.05.9-.11 1.35-.17.44-.06.25-.73-.19-.67h-.01c.24-.32.45-.72.62-1.25.66-1.84.41-6.36.34-11.33l-.13-9.9.02.01Zm-12.26 18.17c.09-1.91.2-3.81.31-5.71.06 5.38 0 6.14-.01 6.51-.05 1.65-.21 2.81.72 3.66-.39-.04-.78-.07-1.17-.1-.06-1.44.09-2.93.16-4.35l-.01-.01ZM588.97 53.85c-2.06-.25-3.17-.51-3.76-.6a.3.3 0 0 1 .04-.08c.22-.39-.39-.75-.6-.35-.56 1.02-.9 2.19-1.26 3.29-.61 1.88-1.17 3.78-1.72 5.68-.63 2.19-1.24 4.39-1.83 6.59-.81 2.03-1.67 4.05-2.61 6.03-1.7-3.64-3.11-6.04-4.03-7.57-2.26-3.74-2.85-5.48-3.57-6.08l.31-.09c.43-.12.25-.8-.19-.67-1.06.3-2.12.6-3.17.95-.93.32-1.85.69-2.76 1.07-.13.05-.19.16-.22.27-.04.02-.08.05-.11.07-.04-.06-.07-.12-.11-.18a.354.354 0 0 0-.48-.12c-.16.09-.22.32-.13.48l.33.54c0 .09.02.18.06.28.51 1.16.78 1.38.72 1.47-2.42 3.44-5.41 7.86-6.2 9.1-1.27 1.97-2.01 3.14-2.45 3.84l-.91-6.56-.43-4.1c-.19-1.85-.37-3.23-.53-4.13-.19-1.1-.3-2.15-.45-3.16-.2-1.36-.29-2.06-.47-2.42h.04c.45.02.45-.68 0-.7-3.43-.16-6.81.94-10.17 1.48-.24-.22-.73-.04-.58.32.24.59.33 1.25.43 1.87.17 1.06.29 2.13.4 3.2.32 3.09.53 6.2.74 9.3.44 6.75.77 13.51 1.17 20.26.11 1.95.13 3.96.46 5.89.05.3.37.31.55.14.74 1.71 2.87 1.27 6.13 1.27 1.34 0 2.39.04 2.99-.11.02.32.48.53.63.18 3.61-8.26 7.41-16.46 12.05-24.2.03-.05.04-.1.05-.15.3.73.64 1.45.94 2.16.97 2.26 1.97 4.52 2.98 6.76 2.26 5.03 4.54 10.07 7.09 14.96.47.9.94 1.79 1.47 2.65.2.32.4.67.66.96-.18.25 0 .68.34.54.91-.38 1.82-.75 2.76-1.07 1.04-.35 2.11-.65 3.17-.95.39-.11.28-.66-.07-.68.62-.4.95-.96.87-1.91-.3-3.34.72-7.47.86-8.52l2.14-11.43c1.75-10.74 3.13-17.51 3.23-20.86.02-.49.08-2.84.13-3.24.17-1.25.48-1-4.96-1.65l.03-.02Zm-46.19 5.67c-.04-.24-.09-.48-.15-.71l.85-.15c-.34.24-.56.53-.7.86Zm1.95 25.12c-.36-6.63-.7-13.26-1.32-19.87 0 .02 0 .04.01.06.29 1.65.44 2.47.56 2.89 1 8.46 1.5 16.14 1.46 22.8-.06.99-.1 2-.11 3.02-.01.29-.03.68-.05 1.12-.01-.26-.03-.53-.04-.78-.19-3.08-.35-6.16-.52-9.23l.01-.01Zm36.4 18.66c-.11-.11-.24-.29-.37-.49.35.21.74.26 1.17.16-.27.11-.53.22-.8.32v.01Zm-.89-33.72c.12-.43.23-.86.35-1.29.71-1.77 1.41-3.55 2.08-5.33-.15.68-.26 1.22-.31 1.55-.5 2.94-2.13 7.59-3.58 13.36-.15-.35-.29-.66-.43-1 .61-2.44 1.25-4.87 1.9-7.3l-.01.01Zm3.56-12.48c.14-.44.28-.89.42-1.34-.13.7-.27 1.41-.42 2.11-.43 1.19-.86 2.38-1.31 3.57.42-1.45.85-2.9 1.31-4.34Zm-5.22 16.05c-.11.44-.23.87-.35 1.31-.12.46-.23.92-.35 1.38-.1-.22-.19-.4-.28-.61.34-.69.66-1.38.97-2.08h.01Zm-11.64 2.62c.06-.1.12-.19.17-.28.05.13.09.26.14.39a.398.398 0 0 0-.31-.11Zm2.3 2.98c-.56-1.3-1.25-2.63-1.65-3.99 0 0 .01-.02.02-.02.06.08 1.52 2.93 1.63 3.08.73 1.13 3.38 7.04 5.67 12.26 1.2 2.73 2.08 5.17 2.83 7.18-.62-1.25-1.23-2.51-1.83-3.78-2.31-4.87-4.53-9.78-6.67-14.73ZM275.92 87.03c-1.06-2.18-1.13-3.45-2.44-2.93-1.52.57-2.94 1.3-4.5 2.1-1.4.72-2.68 1.44-3.92 2.12.01-.25-.24-.5-.51-.34-4.8 2.93-12.41 4.7-17.28 1.31-1.98-1.77-3.32-4.15-3.97-5.78-.29-.95-.49-1.94-.63-2.93-.14-3.34 1.58-6.53 3.9-9.12.8-.79 1.68-1.51 2.66-2.12 3.7-2.3 8.22-3.07 12.51-2.51 2.71.35 5.32 1.24 7.71 2.55.39.22.75-.39.35-.6-.18-.1-.37-.18-.55-.27.56.27 1.03.33 1.51.19l-.48.39c-.15.11-.23.3-.13.48.09.15.33.24.48.13 1.3-.97 2.46-2.09 3.45-3.37.37-.29.64-.6.65-.97v-.02c.08-.33-.03-.7-.21-1.08-.31-.87-.98-2.01-2.19-3.26-2.43-2.52-3.79-3.45-5.68-4.26-1.14-.49-3.12-1.06-4.42-1.23-3.28-.42-10.64-1.21-18.18 4.11-7.74 5.46-11.94 12.3-12.23 20.61-.08 2.06.04 3.98.34 5.71.74 4.18 2.57 8 5.44 11.34 4.26 4.99 9.76 7.52 16.34 7.52 4.85 0 9.69-1.77 14.89-4.62.23-.12.45-.23.68-.35 2.19-1.1 4.37-2.23 6.46-3.5.49-.3 1.03-.61 1.5-.98 1.47-.87 1.11-1.12.49-2.95-.39-1.14-.76-2.7-2.06-5.36l.02-.01Zm-17.38-21.76c3.05-.42 6.31.79 9.36 2.35.51.39.94.68 1.33.87-5.61-2.86-12.72-3.39-18.44-.79 2.05-1.33 4.24-1.95 7.74-2.44l.01.01ZM443.67 72.67c-.4-2.2-1.15-4.33-2.37-6.22-1.49-2.32-3.58-4.19-5.91-5.64-6.17-3.81-13.75-5.11-20.83-6.01-3.23-.41-6.47-.69-9.72-.92l-1.39-.12c-.85-.07-1.52-.1-2.05-.1-1.08-.06-2.17-.12-3.25-.17-.08 0-.14.02-.19.05-.1.05-.18.14-.16.3.27 2.55-.01 5.12-.92 7.52-.15.38.4.56.62.28 1.32.59 2.68 1.05 4.08 1.37 0 2.78-.14 7.58-.33 12.91 0 0 0 .02-.01.03-.61 3.66-.79 7.42-1 11.12-.23 4.01-.43 8.03-.44 12.05 0 .64 0 1.28.03 1.93.02.31 0 .68.15.96.06.11.14.16.24.17-.2.17-.21.54.11.59 3.83.67 7.78.71 11.68.25 2.3-.19 4.87-.65 7.65-1.56 1.85-.54 3.67-1.18 5.43-1.91 7.2-3.02 14.31-8.07 17.35-15.53.76-1.86 1.17-3.8 1.31-5.75.3-1.93.28-3.82-.09-5.58l.01-.02Zm-19.32-15.42c5.74 1.41 11.94 3.68 15.65 8.55.25.32.47.65.69.99-2.3-2.82-5.68-5.69-12.88-8.23-2.16-.76-4.35-1.43-6.64-2.02 1.06.21 2.13.45 3.18.71Zm-25.82-3.04c.13 0 .27.01.4.02-.14.1-.26.23-.37.38 0-.13-.02-.26-.03-.4Zm34.82 22.17c-.75 3.09-3.55 5.66-5.88 7.58-3.35 2.76-7.21 5.03-11.28 6.54-1.33.49-2.71.9-4.12 1.15.06-1.38.08-2.76.07-4.13-.02-3.78-.16-7.56-.41-11.33-.09-1.37-.18-2.74-.37-4.1 0-.06-.03-.11-.06-.15.09-3.25.12-6.16.03-8.12 6.86 1.05 10.56 2.17 14.06 3.62 5.52 2.28 8.59 5.44 7.97 8.96l-.01-.02Zm-22 16.15c-.12 0-.23-.02-.34-.03l.34-.03v.06Zm-.69-.7c0-3.13.26-8.84.47-14.51.06 1.2.11 2.41.15 3.6.15 3.6.25 7.23.09 10.83-.24.03-.48.05-.71.07v.01Zm-12.33-30.94c.37.63 2.01 1.01 3.23 1.25v.15c-1.31-.31-2.59-.73-3.83-1.29.12-.36.23-.72.33-1.09.08.48.18.84.27.98Zm13.7 31.65v-.18c3.41-.56 6.71-2.02 9.69-3.68 2.31-1.28 4.59-2.78 6.63-4.53-4.69 4.53-11.61 8.24-16.33 8.38l.01.01Zm24.07-.75c-2.05 1.93-4.37 3.56-6.83 4.95 2.7-1.78 5.52-4.03 8.42-6.87.82-.82 1.56-1.69 2.23-2.59-1.08 1.65-2.38 3.16-3.81 4.51h-.01ZM187.16 92.14c-.79-2.47-2.1-7.12-3.1-6.87-.19-.01-2.09.77-4.08 1.54-3.06 1.18-5.91 2.13-10.09 2.82-2.74.42-5.87 1.01-10.61 1.06.04-3.34.05-6.01.05-7.99 7.97-.65 12.33-2.11 16.37-3.55 1.11-.39 2.69-1.01 2.63-1.8-.08-.35-.55-1.39-1.17-2.61-.47-1.16-.98-2.31-1.61-3.38-.42-.71-1.04-1.69-1.86-2.06-.11-.08-.22-.13-.29-.12-.02 0-.04 0-.07.01-.19-.04-.39-.05-.6-.01-.17.03-.24.15-.25.28-.04.02-.09.04-.14.05-4.33 1.48-8.85 2.33-13.24 3.61a499.1 499.1 0 0 0-.31-8.19c4.51-.99 8.88-1.38 13.11-1.82 3.68-.38 6.28.12 7.47.34.59.11.9.16 1.16.18h.1c-.1.37.44.66.62.28.02-.04.03-.08.05-.13.15.2.53.22.62-.1.17-.58.19-1.21.21-1.81v-.36c.03-.15.05-.3.07-.45.52-2.47.33-5.09-.64-7.44-.11-.27-.44-.28-.6-.14-.08-.21-.15-.42-.24-.62-.19-.41-.79-.05-.6.35.03.07.05.15.09.22-.98-.42-2.15-.54-3.17-.63-2.17-.19-4.37-.14-6.54 0-5.7.35-11.4 1.3-16.91 2.79-2.08.56-4.13 1.22-6.14 2-4.54 1.05-3.79 1.51-2.17 6.07.18.51.46 1.68.54 1.94.82 2.47 1.08 2.13 3.1 2.13s0 .05 0 .08h.52c-.48 2.66-.51 5.45-.62 8.13-.15 3.48-.22 6.96-.28 10.45 0 .41-.01.82-.02 1.23-.16.29-.33.57-.51.85-.05.38-.09.77-.14 1.18-.42 3.52-.59 6.48-.52 8.8v.34c.02.47.05.76.06.87.16 1.57-.26 3.47 1.35 3.79 1.61.32 3.5.55 4.85.55.11 0 .22-.02.33-.02 1.79.24 3.67.05 5.45-.12 2.85-.28 5.69-.7 8.51-1.19 3.03-.53 6.05-1.14 9.04-1.86 2.4-.58 4.82-1.19 7.13-2.06.51-.19 1.73-.57 2.46-1.14 1.81-.68 2.18-1 1.57-2.67-.23-.62-.48-1.49-.91-2.78l-.03-.02Zm-11.12-38.71c.89.05 1.93.08 2.89.3-.33 0-.68-.02-1.06-.03-8.28-.26-14.88.75-23.97 2.51 2.41-.64 4.85-1.16 7.28-1.59 4.87-.86 9.91-1.45 14.86-1.19Zm-26.53 22.13c.03 1.71.04 3.43 0 5.14-.04 1.27-.11 2.55-.24 3.82 0-.73.02-1.46.04-2.19.05-2.26.12-4.51.22-6.77h-.02Zm6.73 27.85c.2-.1.4-.21.58-.33 1.82-.17 3.82-.24 5.94-.34-.86.11-1.72.24-2.58.33-1.27.14-2.61.31-3.93.34h-.01ZM534.48 85.44c-3.52-8.38-7.07-16.75-10.5-25.17-.63-1.54-1.25-3.09-1.86-4.65-.31-.8-.65-1.6-.87-2.43-.04-.17-.17-.24-.31-.25.1-.2 0-.51-.29-.53-1.59-.08-3.18-.22-4.78-.25-1.96-.03-3.91.13-5.84.42-.31.05-.31.38-.13.56-.03.06-.05.14-.04.22.23 1.54.63 3.06 1.16 4.53.13.35.27.7.41 1.06l-2.68 6.18c-.11.03-.2.09-.25.22-.67 1.9-1.52 3.73-2.34 5.56a536.85 536.85 0 0 1-3.9 8.45c-2.64 5.64-5.34 11.25-7.91 16.93-.44.97-.88 1.94-1.29 2.93-.2.48-.47 1-.55 1.52v.05c-.02.12.02.26.16.34 1.19.73 2.41 1.41 3.66 2.05 1.2.62 2.45 1.25 3.76 1.61.43.12.62-.55.19-.67-1.13-.31-2.2-.83-3.24-1.36 1.09.36 2.1.69 2.75.93 2.82 1.01 2.38 1.1 4.3-3.75 2.1-1.09 4.34-1.96 6.53-2.79 4.35-1.64 8.8-3.03 13.27-4.29.82 2.01 1.77 3.97 2.72 5.92.35.83.62 1.45.79 1.82.22.42.45.8.69 1.15.17.33.33.67.5 1 .42.8.84 1.63 1.4 2.35.23.29.6 0 .55-.31 1.53-.02 3.06-.07 4.58-.27.92-.12 1.82-.32 2.71-.54 1.39-.27 3.85-1.11 3.74-1.42-.67-1.96-1.55-3.87-2.34-5.78-1.57-3.78-3.16-7.56-4.75-11.33v-.01Zm-11.65-26.16c1.54 3.81 3.12 7.6 4.7 11.4 2.94 7.05 5.91 14.09 8.87 21.13l-1.06-2.17c-2.71-5.51-5.2-11.19-7.41-16.87l-6.65-17.15c-.65-1.45-.55-2.19-.93-2.53.09 0 .18.01.28.02a.29.29 0 0 0-.04.26c.52 2.02 1.47 3.98 2.25 5.91h-.01Zm-6.58 13.58c.05-.15.09-.31.14-.46 1.41 3.92 2.88 7.9 4.39 11.87-3.22.52-6.38 1.25-9.46 2.14.55-1.22 1.05-2.46 1.53-3.7 1.24-3.24 2.37-6.53 3.39-9.85h.01Zm-.23-20c.36 0 .73.03 1.09.05-2.15.1-5.18.33-5.87.74-.24.15-.41.3-.53.45-.06-.29-.13-.58-.18-.88 1.82-.26 3.65-.39 5.49-.35v-.01Zm-.09 18.72c-.49 1.67-1.05 3.33-1.6 4.97-1.07 3.19-2.19 6.38-3.57 9.46-.09.21-.19.43-.29.65-.25.07-.5.14-.74.22 2.53-6.16 4.61-11.29 6.2-15.3Zm-6.34 25.16c4.97-2.38 9.37-4.1 14.02-5.27l.26.64c-4.8 1.35-9.63 2.8-14.28 4.63Zm20.17 6.76c.33.23.68.42 1.04.56h-.33c-.12 0-.21.06-.26.13-.15-.23-.31-.45-.45-.7v.01ZM226.57 91.75c-3.55-4.74-6.68-9.11-9.31-12.99 9.2-15.25 10.05-17.81 10.35-18.38.17-.34 1.09-2.27.64-2.53-1.13-.65-1.03-.65-2.97-1.71-1.19-.65-3.04-1.61-4.53-2.12-1.71-.59-1.24-.36-3 2.77-.06.1-.11.2-.17.3-.75 1.02-1.48 2.05-2.2 3.09-1.88 2.71-3.73 5.45-5.69 8.1-3.68-4.91-6.88-8.76-9.51-11.43-.15-.15-.3-.29-.46-.42-1.27-1.28-7.24 3.53-7.93 5.58-.09.09-.19.16-.28.25-.27.26.03.64.33.58.19.65.5 1.29.94 1.91 3.85 5.06 7.19 9.76 9.94 14-1.23 2.61-3.06 5-4.67 7.38l-2.28 3.33c-.5.66-.93 1.23-1.29 1.69-.67.93-2.09 2.61-2.3 3.87-.51.85-1.16 1.84-1.29 2.83-.06.44.61.63.67.19.01-.08.04-.15.06-.22 1.36 1.08 2.76 2.11 4.19 3.11 1.3.91 2.62 1.85 4.04 2.56.21.1.4 0 .48-.17.24.07.48.14.72.2.44.1.62-.57.19-.67-2.02-.48-3.77-1.57-5.23-3.02-.47-.46-.9-.96-1.32-1.46 1.74 1.35 4.2 2.89 5.89 4.14 1.39 1.03 2.85-2.27 4.22-4.2 1.86-2.64 3.96-5.86 5.52-8.29l10.39 14.51c.67.81 1.14 1.21 1.57 1.36-.05.24.12.51.41.4 1.53-.58 3.05-1.19 4.54-1.87 1.52-.69 3.06-1.45 4.36-2.5a.28.28 0 0 0 .12-.23c1.66-1.1.81-1.74-1.41-4.91-1.13-1.58-1.71-2.36-3.7-5.01l-.03-.02Zm2.41 6.54c.56 1.15 1.19 2.52 1.11 3.81-.06.04-.12.07-.17.1-.03-.88-.55-2.66-.94-3.91Zm-16.51-32.73c1.86-2.65 3.65-5.35 5.57-7.95.4-.55.81-1.13 1.26-1.66.19-.18.38-.33.56-.45.18.03.36.08.55.13l-8.05 10.11.12-.18h-.01ZM192.7 95.48c.79-1.37 1.66-2.69 2.54-4 1.19-1.79 2.4-3.56 3.61-5.33-.04.09-.09.17-.13.26-.1.22.03.41.2.49-2.47 3.42-4.89 6.73-6.4 9.28.21.24.4.48.63.75-.24.07-.4.36-.17.56.4.33.72.77 1.05 1.17.09.11.18.21.27.32-.84-.61-1.66-1.24-2.47-1.88.24-.57.58-1.11.87-1.61v-.01Zm7.46-10.32c.47-.81.98-1.59 1.49-2.37.31-.48.64-.95.96-1.43.26-.29.52-.56.75-.79-.99 1.48-2.09 3.03-3.2 4.59Zm10.03-16.22s-.03-.05-.05-.07c.22-.29.43-.59.64-.89-.2.32-.4.65-.58.96h-.01ZM371.54 87.96c-.01-.08-.01-.16-.03-.23-.06-.38-.58-.29-.66.03-.3-.05-.6-.08-.81-.11-1.14-.15-2.29-.19-3.44-.2 1.04-.09 2.09-.18 3.14-.23.45-.02.45-.72 0-.7-6.57.35-13.14 1.23-19.65 2.11-1.53.21-3.05.42-4.57.68-.01 0-.02.01-.04.01-.04-3.33-.13-6.66-.24-9.99-.19-5.7-.4-11.41-.88-17.1-.13-1.51-.23-3.07-.49-4.58 0-.25 0-.48-.02-.68-.06-1.19-.04-2.61-.68-2.78-.16-.07-.72-.16-1.5-.24.22-.17.16-.62-.2-.63-1.19-.04-2.39.09-3.57.23-1.2.14-2.41.32-3.59.6-.16-.1-.41-.06-.5.12-.06.02-.13.03-.19.05-.35.1-.29.55-.03.66-.26.6-.19 2.27-.21 3-.02.66-.66 33.73-.9 40.3-.03.65.06 1.12.04 1.45-.16 3.05.87 4.96 6.34 3.93 1.09-.08 2.75-.77 5.36-1.43 4.13-1.04 5.78-1.52 6.2-1.65 6.43-1.69 6.78-1.97 11.72-2.43.55-.05 4.8-.38 6.03-.3.64.04 1.19.07 1.65.1.09 0 .16-.03.24-.05.1.27.56.33.66-.02.39-1.32.61-2.71.78-4.08.2-1.61.29-3.24.15-4.86.24.03.52-.23.38-.53-.09-.2-.27-.33-.49-.43v-.02Zm-.63.56c.07.57.11 1.14.11 1.71-.21-.99-.53-1.71-.95-1.87.22.03.44.06.65.11.06.01.12.04.19.05Zm-25.41 1.73c1.54-.36 3.1-.64 4.66-.89-1.61.37-3.18.77-4.66 1.2v-.31Zm-.86-7.37c-.07-1.37-.16-2.75-.25-4.12-.21-3.13-.45-6.27-.79-9.4.02-2.25.08-4.31.13-6.11.16 2.08.29 4.16.4 6.24.23 4.46.38 8.93.5 13.39h.01Zm-.94-4c.16 2.41.29 4.83.39 7.24.06 1.6.14 3.22.09 4.83-.15.05-.32.09-.47.14V78.88h-.01ZM483.72 92.83c-3.05-2.28-6.22-4.4-9.38-6.51 8.86-6.49 13.49-12.95 13.73-19.23.04-.76 0-1.5-.13-2.2-.67-3.82-3.5-6.68-8.39-8.48.13.04.27.08.4.13 3.92 1.39 7.74 4.23 8.5 8.56.34 1.95-.05 3.96-.98 5.69-.21.4.39.75.6.35 1.86-3.46 1.46-7.55-.97-10.63-3.53-4.47-9.76-5.88-15.16-6.16-2.32-.12-4.64-.04-6.95.19-6 .32-12.71 1.68-17.63 3.21-.37.11-.67.23-.92.35-.2-.17-.62.02-.57.37v.03c-.64.68-.18 1.64.48 3.21.38.91.67 1.89 1.15 2.58.32.76.68 1.51 1.13 2.19.14.21.38.19.53.07.19-.02.38-.05.57-.08v1.57c-.06.06-.1.13-.11.23-.27 4.18-.34 8.38-.48 12.57l-.3 9.03c-.24 3.91-.44 6.77-.46 7.26-.05.88-.11 1.95.07 2.81-.01.22-.02.43-.04.65 0 .11-.02.23-.03.35 0 .05-.03.27-.01.16-.05.4.5.59.64.28.05.04.12.08.2.08 1.75.13 3.5.28 5.25.3 1.69.02 3.38-.12 5.06-.32.08.23.36.39.55.15.06-.08.11-.17.16-.26.18-.09.24-.32.18-.48.05-.2.1-.4.13-.6.16-.86.25-1.74.33-2.62.11-1.17.17-2.34.23-3.51.15-.01.32-.03.52-.04.36-.03 1.73-.15 2.06-.15.39 0 .7-.02.95-.04 1.76 1.11 3.45 2.35 5.14 3.55 2.83 2.01 5.64 4.04 8.47 6.04 1.42 1 2.85 2 4.29 2.97.1.06.19.07.27.04.08 0 .17-.02.25-.1 1.61-1.56 3.15-3.18 4.6-4.88.75-.88 1.49-1.78 2.15-2.73.01.01.03.02.04.03.34.3.83-.2.49-.49-2.16-1.9-4.34-3.76-6.64-5.48l.03-.01Zm-6.38-3.65a55.72 55.72 0 0 0-4-2.13c.14-.1.26-.19.4-.29 1.2.81 2.4 1.61 3.6 2.42Zm-20.1 11.78c.67-.37 1.23-.91 1.67-1.6-.11.5-.24 1-.38 1.49-.43.04-.86.08-1.29.11Zm2.38-37.24c1.34-.31 2.56-.52 3.71-.69-1.03.19-2.04.41-3.04.65-.14-.07-.34-.02-.45.11-.07.02-.15.04-.22.05v-.13.01Zm.04.84c.07-.02.14-.03.2-.05.34 1.66.41 3.41.5 5.09.17 2.9.24 5.81.28 8.71l.03 3.17c-.17.07-.34.14-.51.2-.06-4.96-.21-10.58-.51-17.12h.01Zm16.04 5.62c-1.16 2.25-3.06 4.1-5.02 5.66-2.8 2.23-5.99 3.97-9.3 5.35-.01-3.56-.09-7.12-.27-10.67-.1-2.04-.16-4.16-.57-6.18 3.3-.78 6.72-1.36 10.1-1.1 1.85.14 4.23.59 5.32 2.29.92 1.43.46 3.24-.26 4.65Zm.85-.18c.6-1.37.9-2.92.28-4.32-.67-1.52-2.2-2.32-3.76-2.74.46.1.89.21 1.29.37 1.74.67 2.69 1.88 2.93 3.21.2 1.13-.05 2.25-.74 3.47V70Zm-27.47-4.14c-.12-.19-.23-.38-.34-.57.74.42.85.36.99.41v.08c-.22.03-.43.06-.65.08Zm11.21 30.46c-.08 1.08-.16 2.17-.33 3.24-.05.35-.11.69-.2 1.03 0 .04-.02.07-.03.11-.15.02-.3.04-.45.05.45-1.64.76-3.36.79-5.07.03-.29.08-.57.1-.89-.03-.31-.03-.47.24-.57-.04.69-.07 1.39-.12 2.08v.02Zm5.6-2.47c.48.11.92.52 2.49 1.72-.46-.32-.92-.65-1.38-.97-.37-.25-.73-.5-1.1-.75h-.01Zm21.23 7.24a70.76 70.76 0 0 1-4.37 4.63c-.14-.09-.27-.19-.4-.28.19-.09.37-.24.55-.47.87-1.14 5.43-5.51 5.49-7.45.31.26.62.53.92.79-.67.97-1.42 1.88-2.19 2.77v.01Z",
          fill: "currentColor",
          transform: "translate(-144.023 -51.76)"
        }
      )
    ]
  }
);
var ExcalidrawLogo = ({
  style,
  size = "small",
  withText
}) => {
  return /* @__PURE__ */ jsxs78("div", { className: `ExcalidrawLogo is-${size}`, style, children: [
    /* @__PURE__ */ jsx147(LogoIcon, {}),
    withText && /* @__PURE__ */ jsx147(LogoText, {})
  ] });
};

// components/welcome-screen/WelcomeScreen.Center.tsx
import { Fragment as Fragment26, jsx as jsx148, jsxs as jsxs79 } from "react/jsx-runtime";
var WelcomeScreenMenuItemContent = ({
  icon,
  shortcut,
  children
}) => {
  const device = useDevice();
  return /* @__PURE__ */ jsxs79(Fragment26, { children: [
    /* @__PURE__ */ jsx148("div", { className: "welcome-screen-menu-item__icon", children: icon }),
    /* @__PURE__ */ jsx148("div", { className: "welcome-screen-menu-item__text", children }),
    shortcut && !device.editor.isMobile && /* @__PURE__ */ jsx148("div", { className: "welcome-screen-menu-item__shortcut", children: shortcut })
  ] });
};
WelcomeScreenMenuItemContent.displayName = "WelcomeScreenMenuItemContent";
var WelcomeScreenMenuItem = ({
  onSelect,
  children,
  icon,
  shortcut,
  className = "",
  ...props
}) => {
  return /* @__PURE__ */ jsx148(
    "button",
    {
      ...props,
      type: "button",
      className: `welcome-screen-menu-item ${className}`,
      onClick: onSelect,
      children: /* @__PURE__ */ jsx148(WelcomeScreenMenuItemContent, { icon, shortcut, children })
    }
  );
};
WelcomeScreenMenuItem.displayName = "WelcomeScreenMenuItem";
var WelcomeScreenMenuItemLink = ({
  children,
  href,
  icon,
  shortcut,
  className = "",
  ...props
}) => {
  return /* @__PURE__ */ jsx148(
    "a",
    {
      ...props,
      className: `welcome-screen-menu-item ${className}`,
      href,
      target: "_blank",
      rel: "noreferrer",
      children: /* @__PURE__ */ jsx148(WelcomeScreenMenuItemContent, { icon, shortcut, children })
    }
  );
};
WelcomeScreenMenuItemLink.displayName = "WelcomeScreenMenuItemLink";
var Center = ({ children }) => {
  const { WelcomeScreenCenterTunnel } = useTunnels();
  return /* @__PURE__ */ jsx148(WelcomeScreenCenterTunnel.In, { children: /* @__PURE__ */ jsx148("div", { className: "welcome-screen-center", children: children || /* @__PURE__ */ jsxs79(Fragment26, { children: [
    /* @__PURE__ */ jsx148(Logo, {}),
    /* @__PURE__ */ jsx148(Heading, { children: t("welcomeScreen.defaults.center_heading") }),
    /* @__PURE__ */ jsxs79(Menu, { children: [
      /* @__PURE__ */ jsx148(MenuItemLoadScene, {}),
      /* @__PURE__ */ jsx148(MenuItemHelp, {})
    ] })
  ] }) }) });
};
Center.displayName = "Center";
var Logo = ({ children }) => {
  return /* @__PURE__ */ jsx148("div", { className: "welcome-screen-center__logo excalifont welcome-screen-decor", children: children || /* @__PURE__ */ jsx148(ExcalidrawLogo, { withText: true }) });
};
Logo.displayName = "Logo";
var Heading = ({ children }) => {
  return /* @__PURE__ */ jsx148("div", { className: "welcome-screen-center__heading welcome-screen-decor excalifont", children });
};
Heading.displayName = "Heading";
var Menu = ({ children }) => {
  return /* @__PURE__ */ jsx148("div", { className: "welcome-screen-menu", children });
};
Menu.displayName = "Menu";
var MenuItemHelp = () => {
  const actionManager = useExcalidrawActionManager();
  return /* @__PURE__ */ jsx148(
    WelcomeScreenMenuItem,
    {
      onSelect: () => actionManager.executeAction(actionShortcuts),
      shortcut: "?",
      icon: HelpIcon,
      children: t("helpDialog.title")
    }
  );
};
MenuItemHelp.displayName = "MenuItemHelp";
var MenuItemLoadScene = () => {
  const appState = useUIAppState();
  const actionManager = useExcalidrawActionManager();
  if (appState.viewModeEnabled) {
    return null;
  }
  return /* @__PURE__ */ jsx148(
    WelcomeScreenMenuItem,
    {
      onSelect: () => actionManager.executeAction(actionLoadScene),
      shortcut: getShortcutFromShortcutName("loadScene"),
      icon: LoadIcon,
      children: t("buttons.load")
    }
  );
};
MenuItemLoadScene.displayName = "MenuItemLoadScene";
var MenuItemLiveCollaborationTrigger = ({
  onSelect
}) => {
  const { t: t2 } = useI18n();
  return /* @__PURE__ */ jsx148(WelcomeScreenMenuItem, { shortcut: null, onSelect, icon: usersIcon, children: t2("labels.liveCollaboration") });
};
MenuItemLiveCollaborationTrigger.displayName = "MenuItemLiveCollaborationTrigger";
Center.Logo = Logo;
Center.Heading = Heading;
Center.Menu = Menu;
Center.MenuItem = WelcomeScreenMenuItem;
Center.MenuItemLink = WelcomeScreenMenuItemLink;
Center.MenuItemHelp = MenuItemHelp;
Center.MenuItemLoadScene = MenuItemLoadScene;
Center.MenuItemLiveCollaborationTrigger = MenuItemLiveCollaborationTrigger;

// components/welcome-screen/WelcomeScreen.Hints.tsx
init_define_import_meta_env();
init_icons();
import { jsx as jsx149, jsxs as jsxs80 } from "react/jsx-runtime";
var MenuHint = ({ children }) => {
  const { WelcomeScreenMenuHintTunnel } = useTunnels();
  return /* @__PURE__ */ jsx149(WelcomeScreenMenuHintTunnel.In, { children: /* @__PURE__ */ jsxs80("div", { className: "excalifont welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--menu", children: [
    WelcomeScreenMenuArrow,
    /* @__PURE__ */ jsx149("div", { className: "welcome-screen-decor-hint__label", children: children || t("welcomeScreen.defaults.menuHint") })
  ] }) });
};
MenuHint.displayName = "MenuHint";
var ToolbarHint = ({ children }) => {
  const { WelcomeScreenToolbarHintTunnel } = useTunnels();
  return /* @__PURE__ */ jsx149(WelcomeScreenToolbarHintTunnel.In, { children: /* @__PURE__ */ jsxs80("div", { className: "excalifont welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--toolbar", children: [
    /* @__PURE__ */ jsx149("div", { className: "welcome-screen-decor-hint__label", children: children || t("welcomeScreen.defaults.toolbarHint") }),
    WelcomeScreenTopToolbarArrow
  ] }) });
};
ToolbarHint.displayName = "ToolbarHint";
var HelpHint = ({ children }) => {
  const { WelcomeScreenHelpHintTunnel } = useTunnels();
  return /* @__PURE__ */ jsx149(WelcomeScreenHelpHintTunnel.In, { children: /* @__PURE__ */ jsxs80("div", { className: "excalifont welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--help", children: [
    /* @__PURE__ */ jsx149("div", { children: children || t("welcomeScreen.defaults.helpHint") }),
    WelcomeScreenHelpArrow
  ] }) });
};
HelpHint.displayName = "HelpHint";

// components/welcome-screen/WelcomeScreen.tsx
import { Fragment as Fragment27, jsx as jsx150, jsxs as jsxs81 } from "react/jsx-runtime";
var WelcomeScreen = (props) => {
  return /* @__PURE__ */ jsx150(Fragment27, { children: props.children || /* @__PURE__ */ jsxs81(Fragment27, { children: [
    /* @__PURE__ */ jsx150(Center, {}),
    /* @__PURE__ */ jsx150(MenuHint, {}),
    /* @__PURE__ */ jsx150(ToolbarHint, {}),
    /* @__PURE__ */ jsx150(HelpHint, {})
  ] }) });
};
WelcomeScreen.displayName = "WelcomeScreen";
WelcomeScreen.Center = Center;
WelcomeScreen.Hints = { MenuHint, ToolbarHint, HelpHint };
var WelcomeScreen_default = WelcomeScreen;

// components/live-collaboration/LiveCollaborationTrigger.tsx
init_define_import_meta_env();
init_icons();
import clsx58 from "clsx";
import { jsx as jsx151, jsxs as jsxs82 } from "react/jsx-runtime";
var LiveCollaborationTrigger2 = ({
  isCollaborating,
  onSelect,
  ...rest
}) => {
  const appState = useUIAppState();
  const showIconOnly = appState.width < 830;
  return /* @__PURE__ */ jsxs82(
    Button,
    {
      ...rest,
      className: clsx58("collab-button", { active: isCollaborating }),
      type: "button",
      onSelect,
      style: { position: "relative", width: showIconOnly ? void 0 : "auto" },
      title: t("labels.liveCollaboration"),
      children: [
        showIconOnly ? share : t("labels.share"),
        appState.collaborators.size > 0 && /* @__PURE__ */ jsx151("div", { className: "CollabButton-collaborators", children: appState.collaborators.size })
      ]
    }
  );
};
var LiveCollaborationTrigger_default = LiveCollaborationTrigger2;
LiveCollaborationTrigger2.displayName = "LiveCollaborationTrigger";

// index.tsx
init_element();
init_restore();

// data/reconcile.ts
init_define_import_meta_env();
init_constants();
init_fractionalIndex();
init_utils2();
import throttle5 from "lodash.throttle";
var shouldDiscardRemoteElement = (localAppState, local, remote) => {
  if (local && // local element is being edited
  (local.id === localAppState.editingTextElement?.id || local.id === localAppState.resizingElement?.id || local.id === localAppState.newElement?.id || // TODO: Is this still valid? As newElement is selection element, which is never part of the elements array
  // local element is newer
  local.version > remote.version || // resolve conflicting edits deterministically by taking the one with
  // the lowest versionNonce
  local.version === remote.version && local.versionNonce < remote.versionNonce)) {
    return true;
  }
  return false;
};
var validateIndicesThrottled2 = throttle5(
  (orderedElements, localElements, remoteElements) => {
    if (define_import_meta_env_default.DEV || define_import_meta_env_default.MODE === ENV.TEST || window?.DEBUG_FRACTIONAL_INDICES) {
      const elements = syncInvalidIndices(
        orderedElements.map((x) => ({ ...x }))
      );
      validateFractionalIndices(elements, {
        // throw in dev & test only, to remain functional on `DEBUG_FRACTIONAL_INDICES`
        shouldThrow: define_import_meta_env_default.DEV || define_import_meta_env_default.MODE === ENV.TEST,
        includeBoundTextValidation: true,
        reconciliationContext: {
          localElements,
          remoteElements
        }
      });
    }
  },
  1e3 * 60,
  { leading: true, trailing: false }
);
var reconcileElements = (localElements, remoteElements, localAppState) => {
  const localElementsMap = arrayToMap(localElements);
  const reconciledElements = [];
  const added = /* @__PURE__ */ new Set();
  for (const remoteElement of remoteElements) {
    if (!added.has(remoteElement.id)) {
      const localElement = localElementsMap.get(remoteElement.id);
      const discardRemoteElement = shouldDiscardRemoteElement(
        localAppState,
        localElement,
        remoteElement
      );
      if (localElement && discardRemoteElement) {
        reconciledElements.push(localElement);
        added.add(localElement.id);
      } else {
        reconciledElements.push(remoteElement);
        added.add(remoteElement.id);
      }
    }
  }
  for (const localElement of localElements) {
    if (!added.has(localElement.id)) {
      reconciledElements.push(localElement);
      added.add(localElement.id);
    }
  }
  const orderedElements = orderByFractionalIndex(reconciledElements);
  validateIndicesThrottled2(orderedElements, localElements, remoteElements);
  syncInvalidIndices(orderedElements);
  return orderedElements;
};

// index.tsx
init_export2();
init_json();
init_blob();
init_renderElement();
init_typeChecks();
init_constants();
init_mutateElement();
init_store();
init_utils2();

// components/TTDDialog/TTDDialogTrigger.tsx
init_define_import_meta_env();
init_icons();
import { jsx as jsx152, jsxs as jsxs83 } from "react/jsx-runtime";
var TTDDialogTrigger = ({
  children,
  icon
}) => {
  const { TTDDialogTriggerTunnel } = useTunnels();
  const setAppState = useExcalidrawSetAppState();
  return /* @__PURE__ */ jsx152(TTDDialogTriggerTunnel.In, { children: /* @__PURE__ */ jsxs83(
    DropdownMenu_default.Item,
    {
      onSelect: () => {
        trackEvent("ai", "dialog open", "ttd");
        setAppState({ openDialog: { name: "ttd", tab: "text-to-diagram" } });
      },
      icon: icon ?? brainIcon,
      children: [
        children ?? t("labels.textToDiagram"),
        /* @__PURE__ */ jsx152(DropdownMenu_default.Item.Badge, { children: "AI" })
      ]
    }
  ) });
};
TTDDialogTrigger.displayName = "TTDDialogTrigger";

// index.tsx
init_url();
init_bounds();
init_withinBounds();

// components/DiagramToCodePlugin/DiagramToCodePlugin.tsx
init_define_import_meta_env();
import { useLayoutEffect as useLayoutEffect10 } from "react";
var DiagramToCodePlugin = (props) => {
  const app = useApp();
  useLayoutEffect10(() => {
    app.setPlugins({
      diagramToCode: { generate: props.generate }
    });
  }, [app, props.generate]);
  return null;
};

// index.tsx
init_blob();
import { jsx as jsx153 } from "react/jsx-runtime";
polyfill_default();
var ExcalidrawBase = (props) => {
  const {
    onChange,
    initialData,
    excalidrawAPI,
    isCollaborating = false,
    onPointerUpdate,
    renderTopRightUI,
    langCode = defaultLang.code,
    viewModeEnabled,
    zenModeEnabled,
    gridModeEnabled,
    libraryReturnUrl,
    theme,
    name,
    renderCustomStats,
    onPaste,
    detectScroll = true,
    handleKeyboardGlobally = false,
    onLibraryChange,
    autoFocus = false,
    generateIdForFile,
    onLinkOpen,
    onPointerDown,
    onPointerUp,
    onScrollChange,
    children,
    validateEmbeddable,
    renderEmbeddable,
    aiEnabled,
    showDeprecatedFonts
  } = props;
  const canvasActions = props.UIOptions?.canvasActions;
  const UIOptions = {
    ...props.UIOptions,
    canvasActions: {
      ...DEFAULT_UI_OPTIONS.canvasActions,
      ...canvasActions
    },
    tools: {
      image: props.UIOptions?.tools?.image ?? true
    }
  };
  if (canvasActions?.export) {
    UIOptions.canvasActions.export.saveFileToDisk = canvasActions.export?.saveFileToDisk ?? DEFAULT_UI_OPTIONS.canvasActions.export.saveFileToDisk;
  }
  if (UIOptions.canvasActions.toggleTheme === null && typeof theme === "undefined") {
    UIOptions.canvasActions.toggleTheme = true;
  }
  useEffect41(() => {
    const importPolyfill = async () => {
      await import("canvas-roundrect-polyfill");
    };
    importPolyfill();
    const handleTouchMove = (event) => {
      if (typeof event.scale === "number" && event.scale !== 1) {
        event.preventDefault();
      }
    };
    document.addEventListener("touchmove", handleTouchMove, {
      passive: false
    });
    return () => {
      document.removeEventListener("touchmove", handleTouchMove);
    };
  }, []);
  return /* @__PURE__ */ jsx153(Provider2, { unstable_createStore: () => jotaiStore, scope: jotaiScope, children: /* @__PURE__ */ jsx153(InitializeApp, { langCode, theme, children: /* @__PURE__ */ jsx153(
    App_default,
    {
      onChange,
      initialData,
      excalidrawAPI,
      isCollaborating,
      onPointerUpdate,
      renderTopRightUI,
      langCode,
      viewModeEnabled,
      zenModeEnabled,
      gridModeEnabled,
      libraryReturnUrl,
      theme,
      name,
      renderCustomStats,
      UIOptions,
      onPaste,
      detectScroll,
      handleKeyboardGlobally,
      onLibraryChange,
      autoFocus,
      generateIdForFile,
      onLinkOpen,
      onPointerDown,
      onPointerUp,
      onScrollChange,
      validateEmbeddable,
      renderEmbeddable,
      aiEnabled: aiEnabled !== false,
      showDeprecatedFonts,
      children
    }
  ) }) });
};
var areEqual5 = (prevProps, nextProps) => {
  if (prevProps.children !== nextProps.children) {
    return false;
  }
  const {
    initialData: prevInitialData,
    UIOptions: prevUIOptions = {},
    ...prev
  } = prevProps;
  const {
    initialData: nextInitialData,
    UIOptions: nextUIOptions = {},
    ...next
  } = nextProps;
  const prevUIOptionsKeys = Object.keys(prevUIOptions);
  const nextUIOptionsKeys = Object.keys(nextUIOptions);
  if (prevUIOptionsKeys.length !== nextUIOptionsKeys.length) {
    return false;
  }
  const isUIOptionsSame = prevUIOptionsKeys.every((key) => {
    if (key === "canvasActions") {
      const canvasOptionKeys = Object.keys(
        prevUIOptions.canvasActions
      );
      return canvasOptionKeys.every((key2) => {
        if (key2 === "export" && prevUIOptions?.canvasActions?.export && nextUIOptions?.canvasActions?.export) {
          return prevUIOptions.canvasActions.export.saveFileToDisk === nextUIOptions.canvasActions.export.saveFileToDisk;
        }
        return prevUIOptions?.canvasActions?.[key2] === nextUIOptions?.canvasActions?.[key2];
      });
    }
    return prevUIOptions[key] === nextUIOptions[key];
  });
  return isUIOptionsSame && isShallowEqual(prev, next);
};
var Excalidraw = React44.memo(ExcalidrawBase, areEqual5);
Excalidraw.displayName = "Excalidraw";
export {
  Button,
  DEFAULT_LASER_COLOR,
  DefaultSidebar,
  DiagramToCodePlugin,
  Excalidraw,
  FONT_FAMILY,
  FooterCenter_default as Footer,
  LiveCollaborationTrigger_default as LiveCollaborationTrigger,
  MIME_TYPES,
  MainMenu_default as MainMenu,
  ROUNDNESS,
  Sidebar,
  Stats,
  StoreAction,
  THEME,
  TTDDialog,
  TTDDialogTrigger,
  WelcomeScreen_default as WelcomeScreen,
  bumpVersion,
  convertToExcalidrawElements,
  defaultLang,
  elementPartiallyOverlapsWithOrContainsBBox,
  elementsOverlappingBBox,
  exportToBlob,
  exportToCanvas2 as exportToCanvas,
  exportToClipboard,
  exportToSvg2 as exportToSvg,
  getCommonBounds,
  getDataURL,
  getFreeDrawSvgPath,
  getLibraryItemsHash,
  getNonDeletedElements2 as getNonDeletedElements,
  getSceneVersion,
  getTextFromElements,
  getVisibleSceneBounds,
  hashElementsVersion,
  hashString,
  isElementInsideBBox,
  isInvisiblySmallElement,
  isLinearElement,
  languages,
  loadFromBlob,
  loadLibraryFromBlob,
  loadSceneOrLibraryFromBlob,
  mergeLibraryItems,
  mutateElement,
  newElementWith,
  normalizeLink,
  parseLibraryTokensFromUrl,
  reconcileElements,
  restore,
  restoreAppState,
  restoreElements,
  restoreLibraryItems,
  sceneCoordsToViewportCoords,
  serializeAsJSON,
  serializeLibraryAsJSON,
  useDevice,
  useHandleLibrary,
  useI18n,
  viewportCoordsToSceneCoords,
  zoomToFitBounds
};
/**
* The following wasm module is generated with `scripts/buildWasm.js` and encoded as base64.
*
* The source of this content is taken from the package "fonteditor-core", which contains the following metadata:
* 
* @author [{"name":"kekee000","email":"kekee000@gmail.com"},{"name":"junmer","email":"junmer@foxmail.com"}] 
* @license [{"type":"MIT","url":"https://github.com/kekee000/fonteditor-core/raw/master/LICENSE"}]
* @version 2.4.0

The MIT License (MIT)

Copyright (c) 2014 ecomfe

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
/**
* The following wasm module is generated with `scripts/buildWasm.js` and encoded as base64.
*
* The source of this content is taken from the package "harfbuzzjs", which contains the following metadata:
* 
* @author Ebrahim Byagowi <ebrahim@gnu.org> 
* @license MIT
* @version 0.3.6

Apache license for Zephyr libc implementations (zephyr-string.c),
emmalloc.cpp (from emscripten project) and MIT for rest of the project

Copyright (c) 2019 Ebrahim Byagowi

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/
//# sourceMappingURL=index.js.map
