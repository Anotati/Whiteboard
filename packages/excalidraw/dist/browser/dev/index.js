import {
  APP_NAME,
  ARROW_TYPE,
  AbortError,
  AlignBottomIcon,
  AlignLeftIcon,
  AlignRightIcon,
  AlignTopIcon,
  ArrowRightIcon,
  ArrowheadArrowIcon,
  ArrowheadBarIcon,
  ArrowheadCircleIcon,
  ArrowheadCircleOutlineIcon,
  ArrowheadDiamondIcon,
  ArrowheadDiamondOutlineIcon,
  ArrowheadNoneIcon,
  ArrowheadTriangleIcon,
  ArrowheadTriangleOutlineIcon,
  BOUND_TEXT_PADDING,
  BringForwardIcon,
  BringToFrontIcon,
  CANVAS_SEARCH_TAB,
  CLASSES,
  CODES,
  COLORS_PER_ROW,
  COLOR_CHARCOAL_BLACK,
  COLOR_PALETTE,
  COLOR_VOICE_CALL,
  COLOR_WHITE,
  CURSOR_TYPE,
  CenterHorizontallyIcon,
  CenterVerticallyIcon,
  CloseIcon,
  DEFAULT_CANVAS_BACKGROUND_PICKS,
  DEFAULT_COLLISION_THRESHOLD,
  DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX,
  DEFAULT_ELEMENT_BACKGROUND_COLOR_PALETTE,
  DEFAULT_ELEMENT_BACKGROUND_PICKS,
  DEFAULT_ELEMENT_STROKE_COLOR_INDEX,
  DEFAULT_ELEMENT_STROKE_COLOR_PALETTE,
  DEFAULT_ELEMENT_STROKE_PICKS,
  DEFAULT_EXPORT_PADDING,
  DEFAULT_FILENAME,
  DEFAULT_FONT_FAMILY,
  DEFAULT_FONT_SIZE,
  DEFAULT_GRID_SIZE,
  DEFAULT_LASER_COLOR,
  DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT,
  DEFAULT_SIDEBAR,
  DEFAULT_TEXT_ALIGN,
  DEFAULT_TRANSFORM_HANDLE_SPACING,
  DEFAULT_UI_OPTIONS,
  DEFAULT_VERTICAL_ALIGN,
  DRAGGING_THRESHOLD,
  DeviceDesktopIcon,
  DistributeHorizontallyIcon,
  DistributeVerticallyIcon,
  DotsIcon,
  DuplicateIcon,
  EDITOR_LS_KEYS,
  ELEMENT_SHIFT_TRANSLATE_AMOUNT,
  ELEMENT_TRANSLATE_AMOUNT,
  ENV,
  EXPORT_DATA_TYPES,
  EXPORT_IMAGE_TYPES,
  EXPORT_SCALES,
  EXPORT_SOURCE,
  EdgeRoundIcon,
  EdgeSharpIcon,
  EmbedIcon,
  Emitter,
  ExportIcon,
  ExportImageIcon,
  FONT_FAMILY,
  FRAME_STYLE,
  FillCrossHatchIcon,
  FillHachureIcon,
  FillSolidIcon,
  FillZigZagIcon,
  FontFamilyCodeIcon,
  FontFamilyNormalIcon,
  FontSizeExtraLargeIcon,
  FontSizeLargeIcon,
  FontSizeMediumIcon,
  FontSizeSmallIcon,
  Fonts,
  FreedrawIcon,
  GroupIcon,
  HEADING_DOWN,
  HEADING_LEFT,
  HEADING_RIGHT,
  HEADING_UP,
  HYPERLINK_TOOLTIP_DELAY,
  HamburgerMenuIcon,
  HelpIcon,
  HelpIconThin,
  IMAGE_MIME_TYPES,
  IMAGE_RENDER_TIMEOUT,
  ImageSceneDataError,
  ImageURLToFile,
  KEYS,
  LIBRARY_DISABLED_TYPES,
  LIBRARY_SIDEBAR_TAB,
  LIBRARY_SIDEBAR_WIDTH,
  LINE_CONFIRM_THRESHOLD,
  LibraryIcon,
  LinearElementEditor,
  LinkIcon,
  LoadIcon,
  LockedIcon,
  MAX_ALLOWED_FILE_BYTES,
  MAX_CUSTOM_COLORS_USED_IN_CANVAS,
  MAX_ZOOM,
  MIME_TYPES,
  MIN_WIDTH_OR_HEIGHT,
  MIN_ZOOM,
  MQ_MAX_HEIGHT_LANDSCAPE,
  MQ_MAX_WIDTH_LANDSCAPE,
  MQ_MAX_WIDTH_PORTRAIT,
  MQ_RIGHT_SIDEBAR_MIN_WIDTH,
  MagicIcon,
  MoonIcon,
  POINTER_BUTTON,
  POINTER_EVENTS,
  PenModeIcon,
  PinIcon,
  PlusIcon,
  ROUNDNESS,
  RedoIcon,
  SCROLL_TIMEOUT,
  SHAPES,
  STATS_PANELS,
  STROKE_WIDTH,
  SVGStringToFile,
  SVG_NS,
  Scene_default,
  SendBackwardIcon,
  SendToBackIcon,
  ShapeCache,
  SloppinessArchitectIcon,
  SloppinessArtistIcon,
  SloppinessCartoonistIcon,
  SnapCache,
  Store,
  StoreAction,
  StrokeStyleDashedIcon,
  StrokeStyleDottedIcon,
  StrokeWidthBaseIcon,
  StrokeWidthBoldIcon,
  StrokeWidthExtraBoldIcon,
  SunIcon,
  TAP_TWICE_TIMEOUT,
  TEXT_ALIGN,
  TEXT_TO_CENTER_SNAP_THRESHOLD,
  THEME,
  THEME_FILTER,
  TOOL_TYPE,
  TOUCH_CTX_MENU_TIMEOUT,
  TextAlignBottomIcon,
  TextAlignCenterIcon,
  TextAlignLeftIcon,
  TextAlignMiddleIcon,
  TextAlignRightIcon,
  TextAlignTopIcon,
  TextIcon,
  TrashIcon,
  URL_HASH_KEYS,
  URL_QUERY_KEYS,
  UndoIcon,
  UngroupIcon,
  UnlockedIcon,
  VERSIONS,
  VERTICAL_ALIGN,
  WelcomeScreenHelpArrow,
  WelcomeScreenMenuArrow,
  WelcomeScreenTopToolbarArrow,
  YOUTUBE_STATES,
  ZOOM_STEP,
  ZoomInIcon,
  ZoomOutIcon,
  ZoomResetIcon,
  aabbForElement,
  abacusIcon,
  actions,
  addElementsToFrame,
  addEventListener,
  addToGroup,
  alertTriangleIcon,
  angleIcon,
  arrayToList,
  arrayToMap,
  arrayToMapWithIndex,
  assertNever,
  bindElementsToFramesAfterDuplication,
  bindLinearElement,
  bindOrUnbindLinearElement,
  bindOrUnbindLinearElements,
  bindPointToSnapToElementOutline,
  bindTextToShapeAfterDuplication,
  boltIcon,
  bootstrapCanvas,
  brainIcon,
  brainIconThin,
  bucketFillIcon,
  bumpVersion,
  calculateFixedPointForElbowArrowBinding,
  calculateScrollCenter,
  canApplyRoundnessTypeToElement,
  canChangeRoundness,
  canHaveArrowheads,
  canvasToBlob,
  capitalizeString,
  centerScrollOn,
  checkIcon,
  chunk,
  clamp,
  clockIcon,
  cloneJSON,
  clsx_m_default,
  coffeeIcon,
  collapseDownIcon,
  collapseUpIcon,
  compareHeading,
  composeEventHandlers,
  computeBoundTextPosition,
  computeContainerDimensionForBoundText,
  copyBlobToClipboardAsPng,
  copyIcon,
  copyTextToSystemClipboard,
  copyToClipboard,
  createPasteEvent,
  createSrcDoc,
  cutIcon,
  dataURLToFile,
  debounce,
  deepCopyElement,
  degreesToRadians,
  distance,
  done,
  downloadIcon,
  dragNewElement,
  dragSelectedElements,
  duplicateElement,
  duplicateElements,
  e,
  easeOut,
  easeToValuesRAF,
  editGroupForSelectedElement,
  elbowArrowIcon,
  elementOverlapsWithFrame,
  elementPartiallyOverlapsWithOrContainsBBox,
  elementsAreInFrameBounds,
  elementsAreInSameGroup,
  elementsOverlappingBBox,
  embeddableURLValidator,
  excludeElementsInFramesFromSelection,
  exportToBlob,
  exportToCanvas,
  exportToCanvas2,
  exportToClipboard,
  exportToFileIcon,
  exportToSvg,
  exportToSvg2,
  extraToolsIcon,
  eyeClosedIcon,
  eyeDropperIcon,
  eyeIcon,
  fileOpen,
  fileSave,
  fillCircle,
  filterElementsEligibleAsFrameChildren,
  findIndex,
  findLastIndex,
  findShapeByKey,
  fixBindingsAfterDeletion,
  fixBindingsAfterDuplication,
  flipHorizontal,
  flipVertical,
  focusNearestParent,
  fontSizeIcon,
  frameToolIcon,
  fullscreenIcon,
  generateIdFromFile,
  getApproxMinLineHeight,
  getApproxMinLineWidth,
  getBoundTextElement,
  getBoundTextElementId,
  getBoundTextMaxHeight,
  getBoundTextMaxWidth,
  getBoundTextShape,
  getCommonAttributeOfSelectedElements,
  getCommonBoundingBox,
  getCommonBounds,
  getContainerCenter,
  getContainerElement,
  getContainingFrame,
  getCornerRadius,
  getCursorForResizingElement,
  getDataURL,
  getDateTime,
  getDefaultAppState,
  getDefaultRoundnessTypeForElement,
  getDragOffsetXY,
  getElementAbsoluteCoords,
  getElementShape,
  getElementWithTransformHandleType,
  getElementsInGroup,
  getElementsInNewFrame,
  getElementsInResizingFrame,
  getElementsOverlappingFrame,
  getElementsWithinSelection,
  getEmbedLink,
  getExportSize,
  getFileFromEvent,
  getFileHandleType,
  getFontFamilyString,
  getFontString,
  getFrame,
  getFrameChildren,
  getFrameLikeElements,
  getFrameLikeTitle,
  getFreeDrawSvgPath,
  getGlobalCSSVariable,
  getGridPoint,
  getHoveredElementForBinding,
  getInitializedImageElements,
  getLineHeight,
  getLineHeightInPx,
  getLinkHandleFromCoords,
  getLockedLinearCursorAlignSize,
  getMaximumGroups,
  getMinTextElementWidth,
  getNearestScrollableContainer,
  getNonDeletedElements,
  getNormalizedCanvasDimensions,
  getNormalizedDimensions,
  getNormalizedGridStep,
  getNormalizedZoom,
  getOmitSidesForDevice,
  getOriginalContainerHeightFromCache,
  getReferenceSnapPoints,
  getRenderOpacity,
  getResizeArrowDirection,
  getResizeOffsetXY,
  getSceneVersion,
  getSelectedElements,
  getSelectedGroupForElement,
  getSelectedGroupIdForElement,
  getSelectedGroupIds,
  getSelectionBoxShape,
  getShortcutKey,
  getSizeFromPoints,
  getSnapLinesAtPointer,
  getSuggestedBindingsForArrows,
  getSvgPathFromStroke,
  getTargetElements,
  getTextElementAngle,
  getTextFromElements,
  getTextWidth,
  getTransformHandleTypeFromCoords,
  getTransformHandles,
  getTransformHandlesFromCoords,
  getVisibleGaps,
  getVisibleSceneBounds,
  gridIcon,
  groupByFrameLikes,
  handIcon,
  handleBindTextResize,
  hasBackground,
  hasBoundTextElement,
  hasStrokeColor,
  hasStrokeStyle,
  hasStrokeWidth,
  hashElementsVersion,
  hashString,
  headingForPointFromElement,
  helpIcon,
  hitElementBoundText,
  hitElementBoundingBox,
  hitElementBoundingBoxOnly,
  hitElementItself,
  invariant,
  isActiveToolNonLinearSnappable,
  isArrowElement,
  isArrowKey,
  isBindableElement,
  isBindingElement,
  isBindingElementType,
  isBindingEnabled,
  isBoundToContainer,
  isBrave,
  isCursorInFrame,
  isDarwin,
  isDevEnv,
  isElbowArrow,
  isElementCompletelyInViewport,
  isElementInFrame,
  isElementInGroup,
  isElementInViewport,
  isElementInsideBBox,
  isEmbeddableElement,
  isEraserActive,
  isExcalidrawElement,
  isFiniteNumber,
  isFirefox,
  isFlowchartNodeElement,
  isFrameElement,
  isFrameLikeElement,
  isGridModeEnabled,
  isHandToolActive,
  isIOS,
  isIframeElement,
  isIframeLikeElement,
  isImageElement,
  isImageFileHandle,
  isImageFileHandleType,
  isInGroup,
  isInitializedImageElement,
  isInputLike,
  isInteractive,
  isInvisiblySmallElement,
  isLinearElement,
  isLinearElementSimpleAndAlreadyBound,
  isLinearElementType,
  isLocalLink,
  isMagicFrameElement,
  isMeasureTextSupported,
  isMemberOf,
  isNonDeletedElement,
  isPathALoop,
  isPointHittingLink,
  isPointHittingLinkIcon,
  isPointInShape,
  isPromiseLike,
  isSafari,
  isSelectedViaGroup,
  isShallowEqual,
  isSnappingEnabled,
  isSomeElementSelected,
  isSupportedImageFile,
  isTestEnv,
  isTextBindableContainer,
  isTextElement,
  isToolIcon,
  isTransparent,
  isUsingAdaptiveRadius,
  isValidTextContainer,
  isWindows,
  isWritableElement,
  laserPointerToolIcon,
  lineEditorIcon,
  loadFromBlob,
  loadFromJSON,
  loadHTMLImageElement,
  loadLibraryFromBlob,
  loadSceneOrLibraryFromBlob,
  magnetIcon,
  makeNextSelectedElementIds,
  maxBindingGap,
  maybeBindLinearElement,
  maybeParseEmbedSrc,
  measureFontSizeFromWidth,
  measureText,
  memoize,
  mermaidLogoIcon,
  microphoneIcon,
  microphoneMutedIcon,
  mutateElbowArrow,
  mutateElement,
  muteFSAbortError,
  nanoid,
  newArrowElement,
  newElement,
  newElementWith,
  newEmbeddableElement,
  newFrameElement,
  newFreeDrawElement,
  newIframeElement,
  newImageElement,
  newLinearElement,
  newMagicFrameElement,
  newTextElement,
  normalizeEOL,
  normalizeFile,
  normalizeLink,
  normalizeSVG,
  normalizeText,
  open_color_default,
  orderByFractionalIndex,
  originalContainerCache,
  paintIcon,
  palette,
  parseClipboard,
  parseLibraryJSON,
  pngIcon,
  pointDistance,
  pointFrom,
  pointRotateRads,
  preventUnload,
  probablySupportsClipboardBlob,
  probablySupportsClipboardWriteText,
  promiseTry,
  publishIcon,
  queryFocusableElements,
  questionCircle,
  radiansToDegrees,
  randomId,
  randomInteger,
  readSystemClipboard,
  redrawTextBoundingBox,
  refreshTextDimensions,
  register,
  removeAllElementsFromFrame,
  removeElementsFromFrame,
  removeFromSelectedGroups,
  renderElement,
  renderSelectionElement,
  renderSpreadsheet,
  renderStaticScene,
  renderStaticSceneThrottled,
  replaceAllElementsInFrame,
  require_jsx_runtime,
  require_lodash,
  require_react,
  rescalePointsInElement,
  resetCursor,
  resetOriginalContainerCache,
  resizeImageFile,
  resizeMultipleElements,
  resolvablePromise,
  restore,
  restoreAppState,
  restoreElements,
  restoreLibraryItems,
  rgbToHex,
  rough_default,
  round,
  roundArrowIcon,
  roundToStep,
  save,
  saveAs,
  saveAsJSON,
  saveLibraryAsJSON,
  sceneCoordsToViewportCoords,
  searchIcon,
  selectAllIcon,
  selectGroup,
  selectGroupsForSelectedElements,
  selectGroupsFromGivenElements,
  serializeAsJSON,
  serializeLibraryAsJSON,
  setCursor,
  setCursorForShape,
  setEraserCursor,
  share,
  sharpArrowIcon,
  shouldAllowVerticalAlign,
  shouldEnableBindingForPointerEvent,
  shouldMaintainAspectRatio,
  shouldResizeFromCenter,
  shouldRotateWithDiscreteAngle,
  shouldShowBoundingBox,
  showSelectedShapeActions,
  snapDraggedElements,
  snapNewElement,
  snapResizingElements,
  supportsResizeObserver,
  suppportsHorizontalAlign,
  svgIcon,
  syncInvalidIndices,
  syncMovedIndices,
  tablerCheckIcon,
  throttleRAF,
  toBrandedType,
  toValidURL,
  toolIsArrow,
  transformElements,
  tupleToCoors,
  upIcon,
  updateActiveTool,
  updateBoundElements,
  updateElbowArrow,
  updateFrameMembershipOfSelectedElements,
  updateImageCache,
  updateObject,
  updateOriginalContainerCache,
  updateStable,
  usersIcon,
  validateFractionalIndices,
  vector,
  viewportCoordsToSceneCoords,
  wrapEvent,
  wrapText,
  zoomAreaIcon
} from "./excalidraw-assets-dev/chunk-7ZEXYAFI.js";
import {
  define_import_meta_env_default,
  init_define_import_meta_env
} from "./excalidraw-assets-dev/chunk-YRUDZAGT.js";
import {
  en_default
} from "./excalidraw-assets-dev/chunk-QCOIOEAF.js";
import {
  percentages_default
} from "./excalidraw-assets-dev/chunk-YZTYRBEQ.js";
import {
  __commonJS,
  __export,
  __glob,
  __toESM
} from "./excalidraw-assets-dev/chunk-F3UQABQJ.js";

// external-global-plugin:react-dom
var require_react_dom = __commonJS({
  "external-global-plugin:react-dom"(exports, module) {
    init_define_import_meta_env();
    module.exports = ReactDOM;
  }
});

// ../../node_modules/fuzzy/lib/fuzzy.js
var require_fuzzy = __commonJS({
  "../../node_modules/fuzzy/lib/fuzzy.js"(exports, module) {
    init_define_import_meta_env();
    (function() {
      var root = this;
      var fuzzy2 = {};
      if (typeof exports !== "undefined") {
        module.exports = fuzzy2;
      } else {
        root.fuzzy = fuzzy2;
      }
      fuzzy2.simpleFilter = function(pattern, array) {
        return array.filter(function(str) {
          return fuzzy2.test(pattern, str);
        });
      };
      fuzzy2.test = function(pattern, str) {
        return fuzzy2.match(pattern, str) !== null;
      };
      fuzzy2.match = function(pattern, str, opts) {
        opts = opts || {};
        var patternIdx = 0, result = [], len = str.length, totalScore = 0, currScore = 0, pre = opts.pre || "", post = opts.post || "", compareString = opts.caseSensitive && str || str.toLowerCase(), ch;
        pattern = opts.caseSensitive && pattern || pattern.toLowerCase();
        for (var idx = 0; idx < len; idx++) {
          ch = str[idx];
          if (compareString[idx] === pattern[patternIdx]) {
            ch = pre + ch + post;
            patternIdx += 1;
            currScore += 1 + currScore;
          } else {
            currScore = 0;
          }
          totalScore += currScore;
          result[result.length] = ch;
        }
        if (patternIdx === pattern.length) {
          totalScore = compareString === pattern ? Infinity : totalScore;
          return { rendered: result.join(""), score: totalScore };
        }
        return null;
      };
      fuzzy2.filter = function(pattern, arr, opts) {
        if (!arr || arr.length === 0) {
          return [];
        }
        if (typeof pattern !== "string") {
          return arr;
        }
        opts = opts || {};
        return arr.reduce(function(prev, element, idx, arr2) {
          var str = element;
          if (opts.extract) {
            str = opts.extract(element);
          }
          var rendered = fuzzy2.match(pattern, str, opts);
          if (rendered != null) {
            prev[prev.length] = {
              string: rendered.rendered,
              score: rendered.score,
              index: idx,
              original: element
            };
          }
          return prev;
        }, []).sort(function(a3, b3) {
          var compare = b3.score - a3.score;
          if (compare)
            return compare;
          return a3.index - b3.index;
        });
      };
    })();
  }
});

// ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    init_define_import_meta_env();
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React53 = require_react();
        var ReactSharedInternals = React53.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is(x3, y3) {
          return x3 === y3 && (x3 !== 0 || 1 / x3 === 1 / y3) || x3 !== x3 && y3 !== y3;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useState42 = React53.useState, useEffect48 = React53.useEffect, useLayoutEffect13 = React53.useLayoutEffect, useDebugValue3 = React53.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React53.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value, cachedValue)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState42({
            inst: {
              value,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect13(function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe, value, getSnapshot]);
          useEffect48(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe(handleStoreChange);
          }, [subscribe]);
          useDebugValue3(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
        var useSyncExternalStore$2 = React53.useSyncExternalStore !== void 0 ? React53.useSyncExternalStore : shim;
        exports.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// ../../node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "../../node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    init_define_import_meta_env();
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
var require_with_selector_development = __commonJS({
  "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
    "use strict";
    init_define_import_meta_env();
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React53 = require_react();
        var shim = require_shim();
        function is(x3, y3) {
          return x3 === y3 && (x3 !== 0 || 1 / x3 === 1 / y3) || x3 !== x3 && y3 !== y3;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useSyncExternalStore = shim.useSyncExternalStore;
        var useRef44 = React53.useRef, useEffect48 = React53.useEffect, useMemo12 = React53.useMemo, useDebugValue3 = React53.useDebugValue;
        function useSyncExternalStoreWithSelector2(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
          var instRef = useRef44(null);
          var inst;
          if (instRef.current === null) {
            inst = {
              hasValue: false,
              value: null
            };
            instRef.current = inst;
          } else {
            inst = instRef.current;
          }
          var _useMemo = useMemo12(function() {
            var hasMemo = false;
            var memoizedSnapshot;
            var memoizedSelection;
            var memoizedSelector = function(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                var _nextSelection = selector(nextSnapshot);
                if (isEqual !== void 0) {
                  if (inst.hasValue) {
                    var currentSelection = inst.value;
                    if (isEqual(currentSelection, _nextSelection)) {
                      memoizedSelection = currentSelection;
                      return currentSelection;
                    }
                  }
                }
                memoizedSelection = _nextSelection;
                return _nextSelection;
              }
              var prevSnapshot = memoizedSnapshot;
              var prevSelection = memoizedSelection;
              if (objectIs(prevSnapshot, nextSnapshot)) {
                return prevSelection;
              }
              var nextSelection = selector(nextSnapshot);
              if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
                return prevSelection;
              }
              memoizedSnapshot = nextSnapshot;
              memoizedSelection = nextSelection;
              return nextSelection;
            };
            var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
            var getSnapshotWithSelector = function() {
              return memoizedSelector(getSnapshot());
            };
            var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            };
            return [getSnapshotWithSelector, getServerSnapshotWithSelector];
          }, [getSnapshot, getServerSnapshot, selector, isEqual]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
          var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);
          useEffect48(function() {
            inst.hasValue = true;
            inst.value = value;
          }, [value]);
          useDebugValue3(value);
          return value;
        }
        exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// ../../node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector = __commonJS({
  "../../node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
    "use strict";
    init_define_import_meta_env();
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_with_selector_development();
    }
  }
});

// ../../node_modules/lodash/lodash.js
var require_lodash2 = __commonJS({
  "../../node_modules/lodash/lodash.js"(exports, module) {
    init_define_import_meta_env();
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin2 = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange2 = "\\u0300-\\u036f", reComboHalfMarksRange2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange2 = "\\u20d0-\\u20ff", rsComboRange2 = rsComboMarksRange2 + reComboHalfMarksRange2 + rsComboSymbolsRange2, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo2 = "[" + rsComboRange2 + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo2 + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo2 + "?", rsCombo2, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark2 = RegExp(rsCombo2, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange2 + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters2 = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e3) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          var value = array[index2];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (iteratee(array[index2], index2, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (!predicate(array[index2], index2, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index2 < length) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (comparator(value, array[index2])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index2 < length) {
          result[index2] = iteratee(array[index2], index2, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index2 = -1, length = values.length, offset = array.length;
        while (++index2 < length) {
          array[offset + index2] = values[index2];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index2 = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index2];
        }
        while (++index2 < length) {
          accumulator = iteratee(accumulator, array[index2], index2, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index2-- : ++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index2 = fromIndex - 1, length = array.length;
        while (++index2 < length) {
          if (comparator(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index2, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index2 = -1, length = array.length;
        while (++index2 < length) {
          var current = iteratee(array[index2]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n3, iteratee) {
        var index2 = -1, result = Array(n3);
        while (++index2 < n3) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index2 = -1, length = strSymbols.length;
        while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index2 = strSymbols.length;
        while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters2);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index2 = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index2] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index2 = -1, length = array.length, resIndex = 0, result = [];
        while (++index2 < length) {
          var value = array[index2];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index2] = PLACEHOLDER;
            result[resIndex++] = index2;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index2 = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index2 = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index2] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index2 = fromIndex - 1, length = array.length;
        while (++index2 < length) {
          if (array[index2] === value) {
            return index2;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index2 = fromIndex + 1;
        while (index2--) {
          if (array[index2] === value) {
            return index2;
          }
        }
        return index2;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index2 = string.length;
        while (index2-- && reWhitespace.test(string.charAt(index2))) {
        }
        return index2;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter2 = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e3) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index2 += dir;
              var iterIndex = -1, value = array[index2];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index2 == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index2, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          return index2 < 0 ? undefined2 : data[index2][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index2][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index2 = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index2 < length) {
            this.add(values2[index2]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n3) {
          return shuffleSelf(copyArray(array), baseClamp(n3, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index2 < length) {
            result2[index2] = skip ? undefined2 : get(object, paths[index2]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index2 < length) {
              var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index2, collection2) {
            result2 = !!predicate(value, index2, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index2 = -1, length = array.length;
          while (++index2 < length) {
            var value = array[index2], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index2, collection2) {
            if (predicate(value, index2, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index2 = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index2 < length) {
            var value = array[index2];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index2 = 0, length = path.length;
          while (object != null && index2 < length) {
            object = object[toKey(path[index2++])];
          }
          return index2 && index2 == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches2 = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches2[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index2 = -1, seen = caches2[0];
          outer:
            while (++index2 < length && result2.length < maxLength) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches2[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index2 = matchData.length, length = index2, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index2--) {
            var data = matchData[index2];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index2 < length) {
            data = matchData[index2];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity2;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index2] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n3) {
          var length = array.length;
          if (!length) {
            return;
          }
          n3 += n3 < 0 ? length : 0;
          return isIndex(n3, length) ? array[n3] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity2];
          }
          var index2 = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index2, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index2 = -1, length = paths.length, result2 = {};
          while (++index2 < length) {
            var path = paths[index2], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index2 < length) {
            var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index2 = indexes[length];
            if (length == lastIndex || index2 !== previous) {
              var previous = index2;
              if (isIndex(index2)) {
                splice.call(array, index2, 1);
              } else {
                baseUnset(array, index2);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index2] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n3) {
          var result2 = "";
          if (!string || n3 < 1 || n3 > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n3 % 2) {
              result2 += string;
            }
            n3 = nativeFloor(n3 / 2);
            if (n3) {
              string += string;
            }
          } while (n3);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity2), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n3) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n3, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index2 < length) {
            var key = toKey(path[index2]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index2 != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity2 : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity2 : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index2 = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index2 < length) {
            result2[index2] = array[index2 + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index2, collection2) {
            result2 = predicate(value, index2, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity2, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index2 = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index2 < length) {
            var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
            if (!index2 || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index2 < length) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index2 = fromRight ? length : -1;
          while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
        }
        function baseWrapperValue(value, actions2) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions2, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index2 = -1, result2 = Array2(length);
          while (++index2 < length) {
            var array = arrays[index2], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index2) {
                result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index2 < length) {
            var value = index2 < valsLength ? values2[index2] : undefined2;
            assignFunc(result2, props[index2], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity2;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array(result2).set(new Uint8Array(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index2 < length) {
            var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
            if (result2) {
              if (index2 >= ordersLength) {
                return result2;
              }
              var order = orders[index2];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index2 = -1, length = source.length;
          array || (array = Array2(length));
          while (++index2 < length) {
            array[index2] = source[index2];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index2 = -1, length = props.length;
          while (++index2 < length) {
            var key = props[index2];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index2 < length) {
              var source = sources[index2];
              if (source) {
                assigner(object, source, index2, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index2-- : ++index2 < length) {
              if (iteratee2(iterable[index2], index2, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index2];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr2(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
            while (index2--) {
              args[index2] = arguments[index2];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index2 = findIndexFunc(collection, predicate, fromIndex);
            return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index2--) {
              var func = funcs[index2];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index2 = wrapper ? index2 : length;
            while (++index2 < length) {
              func = funcs[index2];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
              while (++index3 < length) {
                result2 = funcs[index3].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index2 = length;
            while (index2--) {
              args[index2] = arguments[index2];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index2 < arrLength) {
            var arrValue = array[index2], othValue = other[index2];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index2 = objLength;
          while (index2--) {
            var key = objProps[index2];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index2 < objLength) {
            key = objProps[index2];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e3) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index2 = -1, length = transforms.length;
          while (++index2 < length) {
            var data = transforms[index2], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index2 = -1, length = path.length, result2 = false;
          while (++index2 < length) {
            var key = toKey(path[index2]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index2 != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index2, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index2;
          if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
            return eq(object[index2], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize2(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index2 < length) {
              array[index2] = args[start + index2];
            }
            index2 = -1;
            var otherArgs = Array2(start + 1);
            while (++index2 < start) {
              otherArgs[index2] = args[index2];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index2 = indexes[length];
            array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index2 = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index2 < size2) {
            var rand = baseRandom(index2, lastIndex), value = array[rand];
            array[rand] = array[index2];
            array[index2] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e3) {
            }
            try {
              return func + "";
            } catch (e3) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk2(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index2 < length) {
            result2[resIndex++] = baseSlice(array, index2, index2 += size2);
          }
          return result2;
        }
        function compact(array) {
          var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index2 < length) {
            var value = array[index2];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index2 = length;
          while (index2--) {
            args[index2 - 1] = arguments[index2];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n3, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
          return baseSlice(array, n3 < 0 ? 0 : n3, length);
        }
        function dropRight(array, n3, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
          n3 = length - n3;
          return baseSlice(array, 0, n3 < 0 ? 0 : n3);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex2(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax(length + index2, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index2);
        }
        function findLastIndex2(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = length - 1;
          if (fromIndex !== undefined2) {
            index2 = toInteger(fromIndex);
            index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index2 < length) {
            var pair = pairs[index2];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax(length + index2, 0);
          }
          return baseIndexOf(array, value, index2);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = length;
          if (fromIndex !== undefined2) {
            index2 = toInteger(fromIndex);
            index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
        }
        function nth(array, n3) {
          return array && array.length ? baseNth(array, toInteger(n3)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index2) {
            return isIndex(index2, length) ? +index2 : index2;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index2 = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index2 < length) {
            var value = array[index2];
            if (predicate(value, index2, array)) {
              result2.push(value);
              indexes.push(index2);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index2 = baseSortedIndex(array, value);
            if (index2 < length && eq(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index2 = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n3, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
          return baseSlice(array, 0, n3 < 0 ? 0 : n3);
        }
        function takeRight(array, n3, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n3 = guard || n3 === undefined2 ? 1 : toInteger(n3);
          n3 = length - n3;
          return baseSlice(array, n3 < 0 ? 0 : n3, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index2) {
            return arrayMap(array, baseProperty(index2));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done2 = this.__index__ >= this.__values__.length, value = done2 ? undefined2 : this.__values__[this.__index__++];
          return { "done": done2, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex2);
        var findLast = createFind(findLastIndex2);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index2] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n3, guard) {
          if (guard ? isIterateeCall(collection, n3, guard) : n3 === undefined2) {
            n3 = 1;
          } else {
            n3 = toInteger(n3);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n3);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n3, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n3 = toInteger(n3);
          return function() {
            if (--n3 < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n3, guard) {
          n3 = guard ? undefined2 : n3;
          n3 = func && n3 == null ? func.length : n3;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n3);
        }
        function before(n3, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n3 = toInteger(n3);
          return function() {
            if (--n3 > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n3 <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce3(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize2(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize2.Cache || MapCache)();
          return memoized;
        }
        memoize2.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index2 = -1, length = nativeMin(args.length, funcsLength);
            while (++index2 < length) {
              args[index2] = transforms[index2].call(this, args[index2]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle5(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce3(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create2(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index2 = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index2 < length) {
            var source = sources[index2];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity2));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index2 = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index2 < length) {
            var value = object == null ? undefined2 : object[toKey(path[index2])];
            if (value === undefined2) {
              index2 = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
            return iteratee2(accumulator, value, index2, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp2(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index2) {
          word = word.toLowerCase();
          return result2 + (index2 ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr2(string) {
          string = toString(string);
          return string && string.replace(reLatin2, deburrLetter).replace(reComboMark2, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n3, guard) {
          if (guard ? isIterateeCall(string, n3, guard) : n3 === undefined2) {
            n3 = 1;
          } else {
            n3 = toInteger(n3);
          }
          return baseRepeat(toString(string), n3);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index2 = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index2 = result2.lastIndexOf(separator);
            if (index2 > -1) {
              result2 = result2.slice(0, index2);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e3) {
            return isError(e3) ? e3 : new Error2(e3);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index2 = -1;
            while (++index2 < length) {
              var pair = pairs[index2];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity2(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions2 = result2.__actions__ = copyArray(this.__actions__);
                  actions2.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n3) {
          n3 = toInteger(n3);
          return baseRest(function(args) {
            return baseNth(args, n3);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n3, iteratee2) {
          n3 = toInteger(n3);
          if (n3 < 1 || n3 > MAX_SAFE_INTEGER) {
            return [];
          }
          var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n3, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n3 -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index2 < n3) {
            iteratee2(index2);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter2;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity2);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round2 = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum2(array) {
          return array && array.length ? baseSum(array, identity2) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk2;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create2;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce3;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize2;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle5;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp2;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr2;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex2;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex2;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity2;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round2;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum2;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index2) {
          LazyWrapper.prototype[methodName] = function(n3) {
            n3 = n3 === undefined2 ? 1 : nativeMax(toInteger(n3), 0);
            var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n3, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n3, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n3) {
            return this.reverse()[methodName](n3).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
          var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index2) {
          var takeName = "take" + (index2 ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index2) {
          var dropName = "drop" + (index2 ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity2);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports);
  }
});

// index.tsx
init_define_import_meta_env();
var import_react116 = __toESM(require_react(), 1);

// components/InitializeApp.tsx
init_define_import_meta_env();
var import_react5 = __toESM(require_react(), 1);

// components/LoadingMessage.tsx
init_define_import_meta_env();

// i18n.ts
init_define_import_meta_env();

// jotai.ts
init_define_import_meta_env();

// ../../node_modules/jotai/esm/index.mjs
init_define_import_meta_env();
var import_react = __toESM(require_react(), 1);

// ../../node_modules/jotai/esm/vanilla.mjs
init_define_import_meta_env();
var keyCount = 0;
function atom(read, write) {
  const key = `atom${++keyCount}`;
  const config = {
    toString: () => key
  };
  if (typeof read === "function") {
    config.read = read;
  } else {
    config.init = read;
    config.read = (get) => get(config);
    config.write = (get, set, arg) => set(
      config,
      typeof arg === "function" ? arg(get(config)) : arg
    );
  }
  if (write) {
    config.write = write;
  }
  return config;
}

// ../../node_modules/jotai/esm/index.mjs
var SUSPENSE_PROMISE = Symbol();
var isSuspensePromise = (promise) => !!promise[SUSPENSE_PROMISE];
var isSuspensePromiseAlreadyCancelled = (suspensePromise) => !suspensePromise[SUSPENSE_PROMISE].c;
var cancelSuspensePromise = (suspensePromise) => {
  var _a;
  const { b: basePromise, c: cancelPromise } = suspensePromise[SUSPENSE_PROMISE];
  if (cancelPromise) {
    cancelPromise();
    (_a = promiseAbortMap.get(basePromise)) == null ? void 0 : _a();
  }
};
var isEqualSuspensePromise = (oldSuspensePromise, newSuspensePromise) => {
  const oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;
  const newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;
  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);
};
var createSuspensePromise = (basePromise, promise) => {
  const suspensePromiseExtra = {
    b: basePromise,
    o: promise,
    c: null
  };
  const suspensePromise = new Promise((resolve) => {
    suspensePromiseExtra.c = () => {
      suspensePromiseExtra.c = null;
      resolve();
    };
    promise.finally(suspensePromiseExtra.c);
  });
  suspensePromise[SUSPENSE_PROMISE] = suspensePromiseExtra;
  return suspensePromise;
};
var copySuspensePromise = (suspensePromise) => createSuspensePromise(
  suspensePromise[SUSPENSE_PROMISE].b,
  suspensePromise[SUSPENSE_PROMISE].o
);
var promiseAbortMap = /* @__PURE__ */ new WeakMap();
var hasInitialValue = (atom3) => "init" in atom3;
var READ_ATOM = "r";
var WRITE_ATOM = "w";
var COMMIT_ATOM = "c";
var SUBSCRIBE_ATOM = "s";
var RESTORE_ATOMS = "h";
var DEV_SUBSCRIBE_STATE = "n";
var DEV_GET_MOUNTED_ATOMS = "l";
var DEV_GET_ATOM_STATE = "a";
var DEV_GET_MOUNTED = "m";
var createStore = (initialValues) => {
  const committedAtomStateMap = /* @__PURE__ */ new WeakMap();
  const mountedMap = /* @__PURE__ */ new WeakMap();
  const pendingMap = /* @__PURE__ */ new Map();
  let stateListeners;
  let mountedAtoms;
  if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production") {
    stateListeners = /* @__PURE__ */ new Set();
    mountedAtoms = /* @__PURE__ */ new Set();
  }
  if (initialValues) {
    for (const [atom3, value] of initialValues) {
      const atomState = {
        v: value,
        r: 0,
        y: true,
        // not invalidated
        d: /* @__PURE__ */ new Map()
      };
      if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production") {
        Object.freeze(atomState);
        if (!hasInitialValue(atom3)) {
          console.warn(
            "Found initial value for derived atom which can cause unexpected behavior",
            atom3
          );
        }
      }
      committedAtomStateMap.set(atom3, atomState);
    }
  }
  const suspensePromiseCacheMap = /* @__PURE__ */ new WeakMap();
  const addSuspensePromiseToCache = (version, atom3, suspensePromise) => {
    let cache = suspensePromiseCacheMap.get(atom3);
    if (!cache) {
      cache = /* @__PURE__ */ new Map();
      suspensePromiseCacheMap.set(atom3, cache);
    }
    suspensePromise.then(() => {
      if (cache.get(version) === suspensePromise) {
        cache.delete(version);
        if (!cache.size) {
          suspensePromiseCacheMap.delete(atom3);
        }
      }
    });
    cache.set(version, suspensePromise);
  };
  const cancelAllSuspensePromiseInCache = (atom3) => {
    const versionSet = /* @__PURE__ */ new Set();
    const cache = suspensePromiseCacheMap.get(atom3);
    if (cache) {
      suspensePromiseCacheMap.delete(atom3);
      cache.forEach((suspensePromise, version) => {
        cancelSuspensePromise(suspensePromise);
        versionSet.add(version);
      });
    }
    return versionSet;
  };
  const versionedAtomStateMapMap = /* @__PURE__ */ new WeakMap();
  const getVersionedAtomStateMap = (version) => {
    let versionedAtomStateMap = versionedAtomStateMapMap.get(version);
    if (!versionedAtomStateMap) {
      versionedAtomStateMap = /* @__PURE__ */ new Map();
      versionedAtomStateMapMap.set(version, versionedAtomStateMap);
    }
    return versionedAtomStateMap;
  };
  const getAtomState = (version, atom3) => {
    if (version) {
      const versionedAtomStateMap = getVersionedAtomStateMap(version);
      let atomState = versionedAtomStateMap.get(atom3);
      if (!atomState) {
        atomState = getAtomState(version.p, atom3);
        if (atomState && "p" in atomState && isSuspensePromiseAlreadyCancelled(atomState.p)) {
          atomState = void 0;
        }
        if (atomState) {
          versionedAtomStateMap.set(atom3, atomState);
        }
      }
      return atomState;
    }
    return committedAtomStateMap.get(atom3);
  };
  const setAtomState = (version, atom3, atomState) => {
    if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production") {
      Object.freeze(atomState);
    }
    if (version) {
      const versionedAtomStateMap = getVersionedAtomStateMap(version);
      versionedAtomStateMap.set(atom3, atomState);
    } else {
      const prevAtomState = committedAtomStateMap.get(atom3);
      committedAtomStateMap.set(atom3, atomState);
      if (!pendingMap.has(atom3)) {
        pendingMap.set(atom3, prevAtomState);
      }
    }
  };
  const createReadDependencies = (version, prevReadDependencies = /* @__PURE__ */ new Map(), dependencies) => {
    if (!dependencies) {
      return prevReadDependencies;
    }
    const readDependencies = /* @__PURE__ */ new Map();
    let changed = false;
    dependencies.forEach((atom3) => {
      var _a;
      const revision = ((_a = getAtomState(version, atom3)) == null ? void 0 : _a.r) || 0;
      readDependencies.set(atom3, revision);
      if (prevReadDependencies.get(atom3) !== revision) {
        changed = true;
      }
    });
    if (prevReadDependencies.size === readDependencies.size && !changed) {
      return prevReadDependencies;
    }
    return readDependencies;
  };
  const setAtomValue = (version, atom3, value, dependencies, suspensePromise) => {
    const atomState = getAtomState(version, atom3);
    if (atomState) {
      if (suspensePromise && (!("p" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {
        return atomState;
      }
      if ("p" in atomState) {
        cancelSuspensePromise(atomState.p);
      }
    }
    const nextAtomState = {
      v: value,
      r: (atomState == null ? void 0 : atomState.r) || 0,
      y: true,
      // not invalidated
      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)
    };
    let changed = !(atomState == null ? void 0 : atomState.y);
    if (!atomState || !("v" in atomState) || // new value, or
    !Object.is(atomState.v, value)) {
      changed = true;
      ++nextAtomState.r;
      if (nextAtomState.d.has(atom3)) {
        nextAtomState.d = new Map(nextAtomState.d).set(atom3, nextAtomState.r);
      }
    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every((a3) => atomState.d.has(a3)))) {
      changed = true;
      Promise.resolve().then(() => {
        flushPending(version);
      });
    }
    if (atomState && !changed) {
      return atomState;
    }
    setAtomState(version, atom3, nextAtomState);
    return nextAtomState;
  };
  const setAtomReadError = (version, atom3, error, dependencies, suspensePromise) => {
    const atomState = getAtomState(version, atom3);
    if (atomState) {
      if (suspensePromise && (!("p" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {
        return atomState;
      }
      if ("p" in atomState) {
        cancelSuspensePromise(atomState.p);
      }
    }
    const nextAtomState = {
      e: error,
      // set read error
      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,
      y: true,
      // not invalidated
      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)
    };
    setAtomState(version, atom3, nextAtomState);
    return nextAtomState;
  };
  const setAtomSuspensePromise = (version, atom3, suspensePromise, dependencies) => {
    const atomState = getAtomState(version, atom3);
    if (atomState && "p" in atomState) {
      if (isEqualSuspensePromise(atomState.p, suspensePromise) && !isSuspensePromiseAlreadyCancelled(atomState.p)) {
        if (!atomState.y) {
          return { ...atomState, y: true };
        }
        return atomState;
      }
      cancelSuspensePromise(atomState.p);
    }
    addSuspensePromiseToCache(version, atom3, suspensePromise);
    const nextAtomState = {
      p: suspensePromise,
      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,
      y: true,
      // not invalidated
      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)
    };
    setAtomState(version, atom3, nextAtomState);
    return nextAtomState;
  };
  const setAtomPromiseOrValue = (version, atom3, promiseOrValue, dependencies) => {
    if (promiseOrValue instanceof Promise) {
      const suspensePromise = createSuspensePromise(
        promiseOrValue,
        promiseOrValue.then((value) => {
          setAtomValue(version, atom3, value, dependencies, suspensePromise);
        }).catch((e3) => {
          if (e3 instanceof Promise) {
            if (isSuspensePromise(e3)) {
              return e3.then(() => {
                readAtomState(version, atom3, true);
              });
            }
            return e3;
          }
          setAtomReadError(version, atom3, e3, dependencies, suspensePromise);
        })
      );
      return setAtomSuspensePromise(
        version,
        atom3,
        suspensePromise,
        dependencies
      );
    }
    return setAtomValue(
      version,
      atom3,
      promiseOrValue,
      dependencies
    );
  };
  const setAtomInvalidated = (version, atom3) => {
    const atomState = getAtomState(version, atom3);
    if (atomState) {
      const nextAtomState = {
        ...atomState,
        // copy everything
        y: false
        // invalidated
      };
      setAtomState(version, atom3, nextAtomState);
    } else if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production") {
      console.warn("[Bug] could not invalidate non existing atom", atom3);
    }
  };
  const readAtomState = (version, atom3, force) => {
    if (!force) {
      const atomState = getAtomState(version, atom3);
      if (atomState) {
        if (atomState.y && // not invalidated
        "p" in atomState && !isSuspensePromiseAlreadyCancelled(atomState.p)) {
          return atomState;
        }
        atomState.d.forEach((_, a3) => {
          if (a3 !== atom3) {
            if (!mountedMap.has(a3)) {
              readAtomState(version, a3);
            } else {
              const aState = getAtomState(version, a3);
              if (aState && !aState.y) {
                readAtomState(version, a3);
              }
            }
          }
        });
        if (Array.from(atomState.d).every(([a3, r3]) => {
          const aState = getAtomState(version, a3);
          return aState && !("p" in aState) && // has no suspense promise
          aState.r === r3;
        })) {
          if (!atomState.y) {
            return { ...atomState, y: true };
          }
          return atomState;
        }
      }
    }
    const dependencies = /* @__PURE__ */ new Set();
    try {
      const promiseOrValue = atom3.read((a3) => {
        dependencies.add(a3);
        const aState = a3 === atom3 ? getAtomState(version, a3) : readAtomState(version, a3);
        if (aState) {
          if ("e" in aState) {
            throw aState.e;
          }
          if ("p" in aState) {
            throw aState.p;
          }
          return aState.v;
        }
        if (hasInitialValue(a3)) {
          return a3.init;
        }
        throw new Error("no atom init");
      });
      return setAtomPromiseOrValue(version, atom3, promiseOrValue, dependencies);
    } catch (errorOrPromise) {
      if (errorOrPromise instanceof Promise) {
        const suspensePromise = isSuspensePromise(errorOrPromise) && isSuspensePromiseAlreadyCancelled(errorOrPromise) ? copySuspensePromise(errorOrPromise) : createSuspensePromise(errorOrPromise, errorOrPromise);
        return setAtomSuspensePromise(
          version,
          atom3,
          suspensePromise,
          dependencies
        );
      }
      return setAtomReadError(version, atom3, errorOrPromise, dependencies);
    }
  };
  const readAtom = (readingAtom, version) => {
    const atomState = readAtomState(version, readingAtom);
    return atomState;
  };
  const addAtom = (version, addingAtom) => {
    let mounted = mountedMap.get(addingAtom);
    if (!mounted) {
      mounted = mountAtom(version, addingAtom);
    }
    return mounted;
  };
  const canUnmountAtom = (atom3, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom3));
  const delAtom = (version, deletingAtom) => {
    const mounted = mountedMap.get(deletingAtom);
    if (mounted && canUnmountAtom(deletingAtom, mounted)) {
      unmountAtom(version, deletingAtom);
    }
  };
  const invalidateDependents = (version, atom3) => {
    const mounted = mountedMap.get(atom3);
    mounted == null ? void 0 : mounted.t.forEach((dependent) => {
      if (dependent !== atom3) {
        setAtomInvalidated(version, dependent);
        invalidateDependents(version, dependent);
      }
    });
  };
  const writeAtomState = (version, atom3, update) => {
    let isSync = true;
    const writeGetter = (a3, options) => {
      const aState = readAtomState(version, a3);
      if ("e" in aState) {
        throw aState.e;
      }
      if ("p" in aState) {
        if (options == null ? void 0 : options.unstable_promise) {
          return aState.p.then(() => {
            const s3 = getAtomState(version, a3);
            if (s3 && "p" in s3 && s3.p === aState.p) {
              return new Promise((resolve) => setTimeout(resolve)).then(
                () => writeGetter(a3, options)
              );
            }
            return writeGetter(a3, options);
          });
        }
        if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production") {
          console.info(
            "Reading pending atom state in write operation. We throw a promise for now.",
            a3
          );
        }
        throw aState.p;
      }
      if ("v" in aState) {
        return aState.v;
      }
      if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production") {
        console.warn(
          "[Bug] no value found while reading atom in write operation. This is probably a bug.",
          a3
        );
      }
      throw new Error("no value found");
    };
    const setter = (a3, v3) => {
      let promiseOrVoid2;
      if (a3 === atom3) {
        if (!hasInitialValue(a3)) {
          throw new Error("atom not writable");
        }
        const versionSet = cancelAllSuspensePromiseInCache(a3);
        versionSet.forEach((cancelledVersion) => {
          if (cancelledVersion !== version) {
            setAtomPromiseOrValue(cancelledVersion, a3, v3);
          }
        });
        const prevAtomState = getAtomState(version, a3);
        const nextAtomState = setAtomPromiseOrValue(version, a3, v3);
        if (prevAtomState !== nextAtomState) {
          invalidateDependents(version, a3);
        }
      } else {
        promiseOrVoid2 = writeAtomState(version, a3, v3);
      }
      if (!isSync) {
        flushPending(version);
      }
      return promiseOrVoid2;
    };
    const promiseOrVoid = atom3.write(writeGetter, setter, update);
    isSync = false;
    return promiseOrVoid;
  };
  const writeAtom = (writingAtom, update, version) => {
    const promiseOrVoid = writeAtomState(version, writingAtom, update);
    flushPending(version);
    return promiseOrVoid;
  };
  const isActuallyWritableAtom = (atom3) => !!atom3.write;
  const mountAtom = (version, atom3, initialDependent) => {
    const mounted = {
      t: new Set(initialDependent && [initialDependent]),
      l: /* @__PURE__ */ new Set()
    };
    mountedMap.set(atom3, mounted);
    if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production") {
      mountedAtoms.add(atom3);
    }
    const atomState = readAtomState(void 0, atom3);
    atomState.d.forEach((_, a3) => {
      const aMounted = mountedMap.get(a3);
      if (aMounted) {
        aMounted.t.add(atom3);
      } else {
        if (a3 !== atom3) {
          mountAtom(version, a3, atom3);
        }
      }
    });
    if (isActuallyWritableAtom(atom3) && atom3.onMount) {
      const setAtom = (update) => writeAtom(atom3, update, version);
      const onUnmount = atom3.onMount(setAtom);
      version = void 0;
      if (onUnmount) {
        mounted.u = onUnmount;
      }
    }
    return mounted;
  };
  const unmountAtom = (version, atom3) => {
    var _a;
    const onUnmount = (_a = mountedMap.get(atom3)) == null ? void 0 : _a.u;
    if (onUnmount) {
      onUnmount();
    }
    mountedMap.delete(atom3);
    if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production") {
      mountedAtoms.delete(atom3);
    }
    const atomState = getAtomState(version, atom3);
    if (atomState) {
      if ("p" in atomState) {
        cancelSuspensePromise(atomState.p);
      }
      atomState.d.forEach((_, a3) => {
        if (a3 !== atom3) {
          const mounted = mountedMap.get(a3);
          if (mounted) {
            mounted.t.delete(atom3);
            if (canUnmountAtom(a3, mounted)) {
              unmountAtom(version, a3);
            }
          }
        }
      });
    } else if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production") {
      console.warn("[Bug] could not find atom state to unmount", atom3);
    }
  };
  const mountDependencies = (version, atom3, atomState, prevReadDependencies) => {
    const dependencies = new Set(atomState.d.keys());
    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach((_, a3) => {
      if (dependencies.has(a3)) {
        dependencies.delete(a3);
        return;
      }
      const mounted = mountedMap.get(a3);
      if (mounted) {
        mounted.t.delete(atom3);
        if (canUnmountAtom(a3, mounted)) {
          unmountAtom(version, a3);
        }
      }
    });
    dependencies.forEach((a3) => {
      const mounted = mountedMap.get(a3);
      if (mounted) {
        mounted.t.add(atom3);
      } else if (mountedMap.has(atom3)) {
        mountAtom(version, a3, atom3);
      }
    });
  };
  const flushPending = (version) => {
    if (version) {
      const versionedAtomStateMap = getVersionedAtomStateMap(version);
      versionedAtomStateMap.forEach((atomState, atom3) => {
        const committedAtomState = committedAtomStateMap.get(atom3);
        if (atomState !== committedAtomState) {
          const mounted = mountedMap.get(atom3);
          mounted == null ? void 0 : mounted.l.forEach((listener) => listener(version));
        }
      });
      return;
    }
    while (pendingMap.size) {
      const pending = Array.from(pendingMap);
      pendingMap.clear();
      pending.forEach(([atom3, prevAtomState]) => {
        const atomState = getAtomState(void 0, atom3);
        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {
          mountDependencies(void 0, atom3, atomState, prevAtomState == null ? void 0 : prevAtomState.d);
        }
        if (prevAtomState && !prevAtomState.y && // invalidated
        (atomState == null ? void 0 : atomState.y)) {
          return;
        }
        const mounted = mountedMap.get(atom3);
        mounted == null ? void 0 : mounted.l.forEach((listener) => listener());
      });
    }
    if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production") {
      stateListeners.forEach((l3) => l3());
    }
  };
  const commitVersionedAtomStateMap = (version) => {
    const versionedAtomStateMap = getVersionedAtomStateMap(version);
    versionedAtomStateMap.forEach((atomState, atom3) => {
      const prevAtomState = committedAtomStateMap.get(atom3);
      if (!prevAtomState || atomState.r > prevAtomState.r || atomState.y !== prevAtomState.y || atomState.r === prevAtomState.r && atomState.d !== prevAtomState.d) {
        committedAtomStateMap.set(atom3, atomState);
        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {
          mountDependencies(version, atom3, atomState, prevAtomState == null ? void 0 : prevAtomState.d);
        }
      }
    });
  };
  const commitAtom = (_atom, version) => {
    if (version) {
      commitVersionedAtomStateMap(version);
    }
    flushPending(void 0);
  };
  const subscribeAtom = (atom3, callback, version) => {
    const mounted = addAtom(version, atom3);
    const listeners = mounted.l;
    listeners.add(callback);
    return () => {
      listeners.delete(callback);
      delAtom(version, atom3);
    };
  };
  const restoreAtoms = (values, version) => {
    for (const [atom3, value] of values) {
      if (hasInitialValue(atom3)) {
        setAtomPromiseOrValue(version, atom3, value);
        invalidateDependents(version, atom3);
      }
    }
    flushPending(version);
  };
  if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production") {
    return {
      [READ_ATOM]: readAtom,
      [WRITE_ATOM]: writeAtom,
      [COMMIT_ATOM]: commitAtom,
      [SUBSCRIBE_ATOM]: subscribeAtom,
      [RESTORE_ATOMS]: restoreAtoms,
      [DEV_SUBSCRIBE_STATE]: (l3) => {
        stateListeners.add(l3);
        return () => {
          stateListeners.delete(l3);
        };
      },
      [DEV_GET_MOUNTED_ATOMS]: () => mountedAtoms.values(),
      [DEV_GET_ATOM_STATE]: (a3) => committedAtomStateMap.get(a3),
      [DEV_GET_MOUNTED]: (a3) => mountedMap.get(a3)
    };
  }
  return {
    [READ_ATOM]: readAtom,
    [WRITE_ATOM]: writeAtom,
    [COMMIT_ATOM]: commitAtom,
    [SUBSCRIBE_ATOM]: subscribeAtom,
    [RESTORE_ATOMS]: restoreAtoms
  };
};
var createStoreForExport = (initialValues) => {
  const store = createStore(initialValues);
  const get = (atom3) => {
    const atomState = store[READ_ATOM](atom3);
    if ("e" in atomState) {
      throw atomState.e;
    }
    if ("p" in atomState) {
      return void 0;
    }
    return atomState.v;
  };
  const asyncGet = (atom3) => new Promise((resolve, reject) => {
    const atomState = store[READ_ATOM](atom3);
    if ("e" in atomState) {
      reject(atomState.e);
    } else if ("p" in atomState) {
      resolve(atomState.p.then(() => asyncGet(atom3)));
    } else {
      resolve(atomState.v);
    }
  });
  const set = (atom3, update) => store[WRITE_ATOM](atom3, update);
  const sub = (atom3, callback) => store[SUBSCRIBE_ATOM](atom3, callback);
  return {
    get,
    asyncGet,
    set,
    sub,
    SECRET_INTERNAL_store: store
  };
};
var createScopeContainer = (initialValues, unstable_createStore) => {
  const store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);
  return { s: store };
};
var ScopeContextMap = /* @__PURE__ */ new Map();
var getScopeContext = (scope) => {
  if (!ScopeContextMap.has(scope)) {
    ScopeContextMap.set(scope, (0, import_react.createContext)(createScopeContainer()));
  }
  return ScopeContextMap.get(scope);
};
var Provider = ({
  children,
  initialValues,
  scope,
  unstable_createStore,
  unstable_enableVersionedWrite
}) => {
  const [version, setVersion] = (0, import_react.useState)({});
  (0, import_react.useEffect)(() => {
    const scopeContainer = scopeContainerRef.current;
    if (scopeContainer.w) {
      scopeContainer.s[COMMIT_ATOM](null, version);
      delete version.p;
      scopeContainer.v = version;
    }
  }, [version]);
  const scopeContainerRef = (0, import_react.useRef)();
  if (!scopeContainerRef.current) {
    const scopeContainer = createScopeContainer(
      initialValues,
      unstable_createStore
    );
    if (unstable_enableVersionedWrite) {
      let retrying = 0;
      scopeContainer.w = (write) => {
        setVersion((parentVersion) => {
          const nextVersion = retrying ? parentVersion : { p: parentVersion };
          write(nextVersion);
          return nextVersion;
        });
      };
      scopeContainer.v = version;
      scopeContainer.r = (fn) => {
        ++retrying;
        fn();
        --retrying;
      };
    }
    scopeContainerRef.current = scopeContainer;
  }
  const ScopeContainerContext = getScopeContext(scope);
  return (0, import_react.createElement)(
    ScopeContainerContext.Provider,
    {
      value: scopeContainerRef.current
    },
    children
  );
};
function atom2(read, write) {
  return atom(read, write);
}
function useAtomValue(atom3, scope) {
  const ScopeContext = getScopeContext(scope);
  const scopeContainer = (0, import_react.useContext)(ScopeContext);
  const { s: store, v: versionFromProvider } = scopeContainer;
  const getAtomValue = (version2) => {
    const atomState = store[READ_ATOM](atom3, version2);
    if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production" && !atomState.y) {
      throw new Error("should not be invalidated");
    }
    if ("e" in atomState) {
      throw atomState.e;
    }
    if ("p" in atomState) {
      throw atomState.p;
    }
    if ("v" in atomState) {
      return atomState.v;
    }
    throw new Error("no atom value");
  };
  const [[version, valueFromReducer, atomFromReducer], rerenderIfChanged] = (0, import_react.useReducer)(
    (prev, nextVersion) => {
      const nextValue = getAtomValue(nextVersion);
      if (Object.is(prev[1], nextValue) && prev[2] === atom3) {
        return prev;
      }
      return [nextVersion, nextValue, atom3];
    },
    versionFromProvider,
    (initialVersion) => {
      const initialValue = getAtomValue(initialVersion);
      return [initialVersion, initialValue, atom3];
    }
  );
  let value = valueFromReducer;
  if (atomFromReducer !== atom3) {
    rerenderIfChanged(version);
    value = getAtomValue(version);
  }
  (0, import_react.useEffect)(() => {
    const { v: versionFromProvider2 } = scopeContainer;
    if (versionFromProvider2) {
      store[COMMIT_ATOM](atom3, versionFromProvider2);
    }
    const unsubscribe = store[SUBSCRIBE_ATOM](
      atom3,
      rerenderIfChanged,
      versionFromProvider2
    );
    rerenderIfChanged(versionFromProvider2);
    return unsubscribe;
  }, [store, atom3, scopeContainer]);
  (0, import_react.useEffect)(() => {
    store[COMMIT_ATOM](atom3, version);
  });
  (0, import_react.useDebugValue)(value);
  return value;
}
function useSetAtom(atom3, scope) {
  const ScopeContext = getScopeContext(scope);
  const { s: store, w: versionedWrite } = (0, import_react.useContext)(ScopeContext);
  const setAtom = (0, import_react.useCallback)(
    (update) => {
      if ((define_import_meta_env_default && define_import_meta_env_default.MODE) !== "production" && !("write" in atom3)) {
        throw new Error("not writable atom");
      }
      const write = (version) => store[WRITE_ATOM](atom3, update, version);
      return versionedWrite ? versionedWrite(write) : write();
    },
    [store, versionedWrite, atom3]
  );
  return setAtom;
}
function useAtom(atom3, scope) {
  if ("scope" in atom3) {
    console.warn(
      "atom.scope is deprecated. Please do useAtom(atom, scope) instead."
    );
    scope = atom3.scope;
  }
  return [
    useAtomValue(atom3, scope),
    // We do wrong type assertion here, which results in throwing an error.
    useSetAtom(atom3, scope)
  ];
}

// jotai.ts
var import_react2 = __toESM(require_react(), 1);
var jotaiScope = Symbol();
var jotaiStore = createStoreForExport();

// import("./locales/**/*.json") in i18n.ts
var globImport_locales_json = __glob({
  "./locales/ar-SA.json": () => import("./excalidraw-assets-dev/ar-SA-JUOY75SY.js"),
  "./locales/az-AZ.json": () => import("./excalidraw-assets-dev/az-AZ-ZTGDEBNA.js"),
  "./locales/bg-BG.json": () => import("./excalidraw-assets-dev/bg-BG-UCJKL6IW.js"),
  "./locales/bn-BD.json": () => import("./excalidraw-assets-dev/bn-BD-D7HJKN5C.js"),
  "./locales/ca-ES.json": () => import("./excalidraw-assets-dev/ca-ES-RPGW7GTT.js"),
  "./locales/cs-CZ.json": () => import("./excalidraw-assets-dev/cs-CZ-XLNNHX2P.js"),
  "./locales/da-DK.json": () => import("./excalidraw-assets-dev/da-DK-6OKJ2GQ6.js"),
  "./locales/de-DE.json": () => import("./excalidraw-assets-dev/de-DE-BD5ICOQ2.js"),
  "./locales/el-GR.json": () => import("./excalidraw-assets-dev/el-GR-JFDBTDHS.js"),
  "./locales/en.json": () => import("./excalidraw-assets-dev/en-INTYX6HQ.js"),
  "./locales/es-ES.json": () => import("./excalidraw-assets-dev/es-ES-CBBTGYGR.js"),
  "./locales/eu-ES.json": () => import("./excalidraw-assets-dev/eu-ES-CHAPMSLE.js"),
  "./locales/fa-IR.json": () => import("./excalidraw-assets-dev/fa-IR-LOJOKEJO.js"),
  "./locales/fi-FI.json": () => import("./excalidraw-assets-dev/fi-FI-F3V5AS4L.js"),
  "./locales/fr-FR.json": () => import("./excalidraw-assets-dev/fr-FR-2N7S6WX3.js"),
  "./locales/gl-ES.json": () => import("./excalidraw-assets-dev/gl-ES-6IHRWREV.js"),
  "./locales/he-IL.json": () => import("./excalidraw-assets-dev/he-IL-LVFJXEFL.js"),
  "./locales/hi-IN.json": () => import("./excalidraw-assets-dev/hi-IN-ID6TO5TY.js"),
  "./locales/hu-HU.json": () => import("./excalidraw-assets-dev/hu-HU-HJRHONHJ.js"),
  "./locales/id-ID.json": () => import("./excalidraw-assets-dev/id-ID-PEJQFNAQ.js"),
  "./locales/it-IT.json": () => import("./excalidraw-assets-dev/it-IT-BBUUF24S.js"),
  "./locales/ja-JP.json": () => import("./excalidraw-assets-dev/ja-JP-FFP3KIX2.js"),
  "./locales/kaa.json": () => import("./excalidraw-assets-dev/kaa-BLBL2DQS.js"),
  "./locales/kab-KAB.json": () => import("./excalidraw-assets-dev/kab-KAB-MISJR6YA.js"),
  "./locales/kk-KZ.json": () => import("./excalidraw-assets-dev/kk-KZ-SZHAXTWQ.js"),
  "./locales/km-KH.json": () => import("./excalidraw-assets-dev/km-KH-DH4CBSZO.js"),
  "./locales/ko-KR.json": () => import("./excalidraw-assets-dev/ko-KR-X46ENAO4.js"),
  "./locales/ku-TR.json": () => import("./excalidraw-assets-dev/ku-TR-KIRZJOQG.js"),
  "./locales/lt-LT.json": () => import("./excalidraw-assets-dev/lt-LT-LYH376GX.js"),
  "./locales/lv-LV.json": () => import("./excalidraw-assets-dev/lv-LV-GW6O7VJB.js"),
  "./locales/mr-IN.json": () => import("./excalidraw-assets-dev/mr-IN-C46Q25TT.js"),
  "./locales/my-MM.json": () => import("./excalidraw-assets-dev/my-MM-6APSZS7C.js"),
  "./locales/nb-NO.json": () => import("./excalidraw-assets-dev/nb-NO-3TYKHCL6.js"),
  "./locales/nl-NL.json": () => import("./excalidraw-assets-dev/nl-NL-EKYDNS5D.js"),
  "./locales/nn-NO.json": () => import("./excalidraw-assets-dev/nn-NO-DGVU75VO.js"),
  "./locales/oc-FR.json": () => import("./excalidraw-assets-dev/oc-FR-L6C7AUZC.js"),
  "./locales/pa-IN.json": () => import("./excalidraw-assets-dev/pa-IN-SRCTDUL7.js"),
  "./locales/percentages.json": () => import("./excalidraw-assets-dev/percentages-O23NFS3D.js"),
  "./locales/pl-PL.json": () => import("./excalidraw-assets-dev/pl-PL-HINSTGCG.js"),
  "./locales/pt-BR.json": () => import("./excalidraw-assets-dev/pt-BR-QVI2MAA2.js"),
  "./locales/pt-PT.json": () => import("./excalidraw-assets-dev/pt-PT-WP2IPC2Q.js"),
  "./locales/ro-RO.json": () => import("./excalidraw-assets-dev/ro-RO-5FIUYQWO.js"),
  "./locales/ru-RU.json": () => import("./excalidraw-assets-dev/ru-RU-L5TOVN4H.js"),
  "./locales/si-LK.json": () => import("./excalidraw-assets-dev/si-LK-P2R2SZBE.js"),
  "./locales/sk-SK.json": () => import("./excalidraw-assets-dev/sk-SK-6EAZ2WVJ.js"),
  "./locales/sl-SI.json": () => import("./excalidraw-assets-dev/sl-SI-GK5NVQ52.js"),
  "./locales/sv-SE.json": () => import("./excalidraw-assets-dev/sv-SE-5NZCZIXB.js"),
  "./locales/ta-IN.json": () => import("./excalidraw-assets-dev/ta-IN-4JINQRFX.js"),
  "./locales/th-TH.json": () => import("./excalidraw-assets-dev/th-TH-H2WCSL7D.js"),
  "./locales/tr-TR.json": () => import("./excalidraw-assets-dev/tr-TR-A3JSCHA5.js"),
  "./locales/uk-UA.json": () => import("./excalidraw-assets-dev/uk-UA-UGR35JOU.js"),
  "./locales/vi-VN.json": () => import("./excalidraw-assets-dev/vi-VN-NU5HK63V.js"),
  "./locales/zh-CN.json": () => import("./excalidraw-assets-dev/zh-CN-O3LIEVWE.js"),
  "./locales/zh-HK.json": () => import("./excalidraw-assets-dev/zh-HK-B6N3R6IG.js"),
  "./locales/zh-TW.json": () => import("./excalidraw-assets-dev/zh-TW-5ZFVGP3Q.js")
});

// i18n.ts
var COMPLETION_THRESHOLD = 85;
var defaultLang = { code: "en", label: "English" };
var languages = [
  defaultLang,
  ...[
    { code: "ar-SA", label: "\u0627\u0644\u0639\u0631\u0628\u064A\u0629", rtl: true },
    { code: "bg-BG", label: "\u0411\u044A\u043B\u0433\u0430\u0440\u0441\u043A\u0438" },
    { code: "ca-ES", label: "Catal\xE0" },
    { code: "cs-CZ", label: "\u010Cesky" },
    { code: "de-DE", label: "Deutsch" },
    { code: "el-GR", label: "\u0395\u03BB\u03BB\u03B7\u03BD\u03B9\u03BA\u03AC" },
    { code: "es-ES", label: "Espa\xF1ol" },
    { code: "eu-ES", label: "Euskara" },
    { code: "fa-IR", label: "\u0641\u0627\u0631\u0633\u06CC", rtl: true },
    { code: "fi-FI", label: "Suomi" },
    { code: "fr-FR", label: "Fran\xE7ais" },
    { code: "gl-ES", label: "Galego" },
    { code: "he-IL", label: "\u05E2\u05D1\u05E8\u05D9\u05EA", rtl: true },
    { code: "hi-IN", label: "\u0939\u093F\u0928\u094D\u0926\u0940" },
    { code: "hu-HU", label: "Magyar" },
    { code: "id-ID", label: "Bahasa Indonesia" },
    { code: "it-IT", label: "Italiano" },
    { code: "ja-JP", label: "\u65E5\u672C\u8A9E" },
    { code: "kab-KAB", label: "Taqbaylit" },
    { code: "kk-KZ", label: "\u049A\u0430\u0437\u0430\u049B \u0442\u0456\u043B\u0456" },
    { code: "ko-KR", label: "\uD55C\uAD6D\uC5B4" },
    { code: "ku-TR", label: "Kurd\xEE" },
    { code: "lt-LT", label: "Lietuvi\u0173" },
    { code: "lv-LV", label: "Latvie\u0161u" },
    { code: "my-MM", label: "Burmese" },
    { code: "nb-NO", label: "Norsk bokm\xE5l" },
    { code: "nl-NL", label: "Nederlands" },
    { code: "nn-NO", label: "Norsk nynorsk" },
    { code: "oc-FR", label: "Occitan" },
    { code: "pa-IN", label: "\u0A2A\u0A70\u0A1C\u0A3E\u0A2C\u0A40" },
    { code: "pl-PL", label: "Polski" },
    { code: "pt-BR", label: "Portugu\xEAs Brasileiro" },
    { code: "pt-PT", label: "Portugu\xEAs" },
    { code: "ro-RO", label: "Rom\xE2n\u0103" },
    { code: "ru-RU", label: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439" },
    { code: "sk-SK", label: "Sloven\u010Dina" },
    { code: "sv-SE", label: "Svenska" },
    { code: "sl-SI", label: "Sloven\u0161\u010Dina" },
    { code: "tr-TR", label: "T\xFCrk\xE7e" },
    { code: "uk-UA", label: "\u0423\u043A\u0440\u0430\u0457\u043D\u0441\u044C\u043A\u0430" },
    { code: "zh-CN", label: "\u7B80\u4F53\u4E2D\u6587" },
    { code: "zh-TW", label: "\u7E41\u9AD4\u4E2D\u6587" },
    { code: "vi-VN", label: "Ti\u1EBFng Vi\u1EC7t" },
    { code: "mr-IN", label: "\u092E\u0930\u093E\u0920\u0940" }
  ].filter(
    (lang) => percentages_default[lang.code] >= COMPLETION_THRESHOLD
  ).sort((left, right) => left.label > right.label ? 1 : -1)
];
var TEST_LANG_CODE = "__test__";
if (define_import_meta_env_default.DEV) {
  languages.unshift(
    { code: TEST_LANG_CODE, label: "test language" },
    {
      code: `${TEST_LANG_CODE}.rtl`,
      label: "\u202Atest language (rtl)\u202C",
      rtl: true
    }
  );
}
var currentLang = defaultLang;
var currentLangData = {};
var setLanguage = async (lang) => {
  currentLang = lang;
  document.documentElement.dir = currentLang.rtl ? "rtl" : "ltr";
  document.documentElement.lang = currentLang.code;
  if (lang.code.startsWith(TEST_LANG_CODE)) {
    currentLangData = {};
  } else {
    try {
      currentLangData = await globImport_locales_json(`./locales/${currentLang.code}.json`);
    } catch (error) {
      console.error(`Failed to load language ${lang.code}:`, error.message);
      currentLangData = en_default;
    }
  }
  jotaiStore.set(editorLangCodeAtom, lang.code);
};
var getLanguage = () => currentLang;
var findPartsForData = (data, parts) => {
  for (let index2 = 0; index2 < parts.length; ++index2) {
    const part = parts[index2];
    if (data[part] === void 0) {
      return void 0;
    }
    data = data[part];
  }
  if (typeof data !== "string") {
    return void 0;
  }
  return data;
};
var t = (path, replacement, fallback) => {
  if (currentLang.code.startsWith(TEST_LANG_CODE)) {
    const name = replacement ? `${path}(${JSON.stringify(replacement).slice(1, -1)})` : path;
    return `\u202A[[${name}]]\u202C`;
  }
  const parts = path.split(".");
  let translation = findPartsForData(currentLangData, parts) || findPartsForData(en_default, parts) || fallback;
  if (translation === void 0) {
    const errorMessage = `Can't find translation for ${path}`;
    if (define_import_meta_env_default.PROD) {
      console.warn(errorMessage);
      return "";
    }
    throw new Error(errorMessage);
  }
  if (replacement) {
    for (const key in replacement) {
      translation = translation.replace(`{{${key}}}`, String(replacement[key]));
    }
  }
  return translation;
};
var editorLangCodeAtom = atom2(defaultLang.code);
var useI18n = () => {
  const langCode = useAtomValue(editorLangCodeAtom, jotaiScope);
  return { t, langCode };
};

// components/LoadingMessage.tsx
var import_react4 = __toESM(require_react(), 1);

// components/Spinner.tsx
init_define_import_meta_env();
var import_react3 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var Spinner = ({
  size = "1em",
  circleWidth = 8,
  synchronized = false,
  className = ""
}) => {
  const mountTime = import_react3.default.useRef(Date.now());
  const mountDelay = -(mountTime.current % 1600);
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { className: `Spinner ${className}`, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "svg",
    {
      viewBox: "0 0 100 100",
      style: {
        width: size,
        height: size,
        // fix for remounting causing spinner flicker
        ["--spinner-delay"]: synchronized ? `${mountDelay}ms` : 0
      },
      children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "circle",
        {
          cx: "50",
          cy: "50",
          r: 50 - circleWidth / 2,
          strokeWidth: circleWidth,
          fill: "none",
          strokeMiterlimit: "10"
        }
      )
    }
  ) });
};
var Spinner_default = Spinner;

// components/LoadingMessage.tsx
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var LoadingMessage = ({
  delay,
  theme
}) => {
  const [isWaiting, setIsWaiting] = (0, import_react4.useState)(!!delay);
  (0, import_react4.useEffect)(() => {
    if (!delay) {
      return;
    }
    const timer = setTimeout(() => {
      setIsWaiting(false);
    }, delay);
    return () => clearTimeout(timer);
  }, [delay]);
  if (isWaiting) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(
    "div",
    {
      className: clsx_m_default("LoadingMessage", {
        "LoadingMessage--dark": theme === THEME.DARK
      }),
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Spinner_default, {}) }),
        /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { className: "LoadingMessage-text", children: t("labels.loadingScene") })
      ]
    }
  );
};

// components/InitializeApp.tsx
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var InitializeApp = (props) => {
  const [loading, setLoading] = (0, import_react5.useState)(true);
  (0, import_react5.useEffect)(() => {
    const updateLang = async () => {
      await setLanguage(currentLang2);
      setLoading(false);
    };
    const currentLang2 = languages.find((lang) => lang.code === props.langCode) || defaultLang;
    updateLang();
  }, [props.langCode]);
  return loading ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(LoadingMessage, { theme: props.theme }) : props.children;
};

// components/App.tsx
init_define_import_meta_env();
var import_react114 = __toESM(require_react(), 1);
var import_react_dom9 = __toESM(require_react_dom(), 1);

// actions/index.ts
init_define_import_meta_env();

// actions/actionDeleteSelected.tsx
init_define_import_meta_env();

// components/ToolButton.tsx
init_define_import_meta_env();
var import_react6 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var ToolButton = import_react6.default.forwardRef((props, ref) => {
  const { id: excalId } = useExcalidrawContainer();
  const innerRef = import_react6.default.useRef(null);
  import_react6.default.useImperativeHandle(ref, () => innerRef.current);
  const sizeCn = `ToolIcon_size_${props.size}`;
  const [isLoading, setIsLoading] = (0, import_react6.useState)(false);
  const isMountedRef = (0, import_react6.useRef)(true);
  const onClick = async (event) => {
    const ret = "onClick" in props && props.onClick?.(event);
    if (isPromiseLike(ret)) {
      try {
        setIsLoading(true);
        await ret;
      } catch (error) {
        if (!(error instanceof AbortError)) {
          throw error;
        } else {
          console.warn(error);
        }
      } finally {
        if (isMountedRef.current) {
          setIsLoading(false);
        }
      }
    }
  };
  (0, import_react6.useEffect)(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  const lastPointerTypeRef = (0, import_react6.useRef)(null);
  if (props.type === "button" || props.type === "icon" || props.type === "submit") {
    const type = props.type === "icon" ? "button" : props.type;
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(
      "button",
      {
        className: clsx_m_default(
          "ToolIcon_type_button",
          sizeCn,
          props.className,
          props.visible && !props.hidden ? "ToolIcon_type_button--show" : "ToolIcon_type_button--hide",
          {
            ToolIcon: !props.hidden,
            "ToolIcon--selected": props.selected,
            "ToolIcon--plain": props.type === "icon"
          }
        ),
        style: props.style,
        "data-testid": props["data-testid"],
        hidden: props.hidden,
        title: props.title,
        "aria-label": props["aria-label"],
        type,
        onClick,
        ref: innerRef,
        disabled: isLoading || props.isLoading || !!props.disabled,
        children: [
          (props.icon || props.label) && /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(
            "div",
            {
              className: "ToolIcon__icon",
              "aria-hidden": "true",
              "aria-disabled": !!props.disabled,
              children: [
                props.icon || props.label,
                props.keyBindingLabel && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("span", { className: "ToolIcon__keybinding", children: props.keyBindingLabel }),
                props.isLoading && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Spinner_default, {})
              ]
            }
          ),
          props.showAriaLabel && /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("div", { className: "ToolIcon__label", children: [
            props["aria-label"],
            " ",
            isLoading && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(Spinner_default, {})
          ] }),
          props.children
        ]
      }
    );
  }
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(
    "label",
    {
      className: clsx_m_default("ToolIcon", props.className),
      title: props.title,
      onPointerDown: (event) => {
        lastPointerTypeRef.current = event.pointerType || null;
        props.onPointerDown?.({ pointerType: event.pointerType || null });
      },
      onPointerUp: () => {
        requestAnimationFrame(() => {
          lastPointerTypeRef.current = null;
        });
      },
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
          "input",
          {
            className: `ToolIcon_type_radio ${sizeCn}`,
            type: "radio",
            name: props.name,
            "aria-label": props["aria-label"],
            "aria-keyshortcuts": props["aria-keyshortcuts"],
            "data-testid": props["data-testid"],
            id: `${excalId}-${props.id}`,
            onChange: () => {
              props.onChange?.({ pointerType: lastPointerTypeRef.current });
            },
            checked: props.checked,
            ref: innerRef
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("div", { className: "ToolIcon__icon", children: [
          props.icon,
          props.keyBindingLabel && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("span", { className: "ToolIcon__keybinding", children: props.keyBindingLabel })
        ] })
      ]
    }
  );
});
ToolButton.defaultProps = {
  visible: true,
  className: "",
  size: "medium"
};
ToolButton.displayName = "ToolButton";

// actions/actionDeleteSelected.tsx
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var deleteSelectedElements = (elements, appState, app) => {
  const elementsMap = app.scene.getNonDeletedElementsMap();
  const framesToBeDeleted = new Set(
    getSelectedElements(
      elements.filter((el) => isFrameLikeElement(el)),
      appState
    ).map((el) => el.id)
  );
  return {
    elements: elements.map((el) => {
      if (appState.selectedElementIds[el.id]) {
        if (el.boundElements) {
          el.boundElements.forEach((candidate) => {
            const bound = app.scene.getNonDeletedElementsMap().get(candidate.id);
            if (bound && isElbowArrow(bound)) {
              mutateElement(bound, {
                startBinding: el.id === bound.startBinding?.elementId ? null : bound.startBinding,
                endBinding: el.id === bound.endBinding?.elementId ? null : bound.endBinding
              });
              mutateElbowArrow(bound, elementsMap, bound.points);
            }
          });
        }
        return newElementWith(el, { isDeleted: true });
      }
      if (el.frameId && framesToBeDeleted.has(el.frameId)) {
        return newElementWith(el, { isDeleted: true });
      }
      if (isBoundToContainer(el) && appState.selectedElementIds[el.containerId]) {
        return newElementWith(el, { isDeleted: true });
      }
      return el;
    }),
    appState: {
      ...appState,
      selectedElementIds: {},
      selectedGroupIds: {}
    }
  };
};
var handleGroupEditingState = (appState, elements) => {
  if (appState.editingGroupId) {
    const siblingElements = getElementsInGroup(
      getNonDeletedElements(elements),
      appState.editingGroupId
    );
    if (siblingElements.length) {
      return {
        ...appState,
        selectedElementIds: { [siblingElements[0].id]: true }
      };
    }
  }
  return appState;
};
var actionDeleteSelected = register({
  name: "deleteSelectedElements",
  label: "labels.delete",
  icon: TrashIcon,
  trackEvent: { category: "element", action: "delete" },
  perform: (elements, appState, formData, app) => {
    if (appState.editingLinearElement) {
      const {
        elementId,
        selectedPointsIndices,
        startBindingElement,
        endBindingElement
      } = appState.editingLinearElement;
      const elementsMap = app.scene.getNonDeletedElementsMap();
      const element = LinearElementEditor.getElement(elementId, elementsMap);
      if (!element) {
        return false;
      }
      if (selectedPointsIndices == null) {
        return false;
      }
      if (element.points.length < 2) {
        const nextElements2 = elements.map((el) => {
          if (el.id === element.id) {
            return newElementWith(el, { isDeleted: true });
          }
          return el;
        });
        const nextAppState2 = handleGroupEditingState(appState, nextElements2);
        return {
          elements: nextElements2,
          appState: {
            ...nextAppState2,
            editingLinearElement: null
          },
          storeAction: StoreAction.CAPTURE
        };
      }
      const binding = {
        startBindingElement: selectedPointsIndices?.includes(0) ? null : startBindingElement,
        endBindingElement: selectedPointsIndices?.includes(
          element.points.length - 1
        ) ? null : endBindingElement
      };
      LinearElementEditor.deletePoints(
        element,
        selectedPointsIndices,
        elementsMap
      );
      return {
        elements,
        appState: {
          ...appState,
          editingLinearElement: {
            ...appState.editingLinearElement,
            ...binding,
            selectedPointsIndices: selectedPointsIndices?.[0] > 0 ? [selectedPointsIndices[0] - 1] : [0]
          }
        },
        storeAction: StoreAction.CAPTURE
      };
    }
    let { elements: nextElements, appState: nextAppState } = deleteSelectedElements(elements, appState, app);
    fixBindingsAfterDeletion(
      nextElements,
      elements.filter(({ id }) => appState.selectedElementIds[id])
    );
    nextAppState = handleGroupEditingState(nextAppState, nextElements);
    return {
      elements: nextElements,
      appState: {
        ...nextAppState,
        activeTool: updateActiveTool(appState, { type: "selection" }),
        multiElement: null,
        activeEmbeddable: null
      },
      storeAction: isSomeElementSelected(
        getNonDeletedElements(elements),
        appState
      ) ? StoreAction.CAPTURE : StoreAction.NONE
    };
  },
  keyTest: (event, appState, elements) => (event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE) && !event[KEYS.CTRL_OR_CMD],
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
    ToolButton,
    {
      type: "button",
      icon: TrashIcon,
      title: t("labels.delete"),
      "aria-label": t("labels.delete"),
      onClick: () => updateData(null),
      visible: isSomeElementSelected(getNonDeletedElements(elements), appState)
    }
  )
});

// actions/actionZindex.tsx
init_define_import_meta_env();

// zindex.ts
init_define_import_meta_env();
var isOfTargetFrame = (element, frameId) => {
  return element.frameId === frameId || element.id === frameId;
};
var getIndicesToMove = (elements, appState, elementsToBeMoved) => {
  let selectedIndices = [];
  let deletedIndices = [];
  let includeDeletedIndex = null;
  let index2 = -1;
  const selectedElementIds = arrayToMap(
    elementsToBeMoved ? elementsToBeMoved : getSelectedElements(elements, appState, {
      includeBoundTextElement: true,
      includeElementsInFrames: true
    })
  );
  while (++index2 < elements.length) {
    const element = elements[index2];
    if (selectedElementIds.get(element.id)) {
      if (deletedIndices.length) {
        selectedIndices = selectedIndices.concat(deletedIndices);
        deletedIndices = [];
      }
      selectedIndices.push(index2);
      includeDeletedIndex = index2 + 1;
    } else if (element.isDeleted && includeDeletedIndex === index2) {
      includeDeletedIndex = index2 + 1;
      deletedIndices.push(index2);
    } else {
      deletedIndices = [];
    }
  }
  return selectedIndices;
};
var toContiguousGroups = (array) => {
  let cursor = 0;
  return array.reduce((acc, value, index2) => {
    if (index2 > 0 && array[index2 - 1] !== value - 1) {
      cursor = ++cursor;
    }
    (acc[cursor] || (acc[cursor] = [])).push(value);
    return acc;
  }, []);
};
var getTargetIndexAccountingForBinding = (nextElement, elements, direction) => {
  if ("containerId" in nextElement && nextElement.containerId) {
    const containerElement = Scene_default.getScene(nextElement).getElement(
      nextElement.containerId
    );
    if (containerElement) {
      return direction === "left" ? Math.min(
        elements.indexOf(containerElement),
        elements.indexOf(nextElement)
      ) : Math.max(
        elements.indexOf(containerElement),
        elements.indexOf(nextElement)
      );
    }
  } else {
    const boundElementId = nextElement.boundElements?.find(
      (binding) => binding.type !== "arrow"
    )?.id;
    if (boundElementId) {
      const boundTextElement = Scene_default.getScene(nextElement).getElement(boundElementId);
      if (boundTextElement) {
        return direction === "left" ? Math.min(
          elements.indexOf(boundTextElement),
          elements.indexOf(nextElement)
        ) : Math.max(
          elements.indexOf(boundTextElement),
          elements.indexOf(nextElement)
        );
      }
    }
  }
};
var getContiguousFrameRangeElements = (allElements, frameId) => {
  let rangeStart = -1;
  let rangeEnd = -1;
  allElements.forEach((element, index2) => {
    if (isOfTargetFrame(element, frameId)) {
      if (rangeStart === -1) {
        rangeStart = index2;
      }
      rangeEnd = index2;
    }
  });
  if (rangeStart === -1) {
    return [];
  }
  return allElements.slice(rangeStart, rangeEnd + 1);
};
var getTargetIndex = (appState, elements, boundaryIndex, direction, containingFrame) => {
  const sourceElement = elements[boundaryIndex];
  const indexFilter = (element) => {
    if (element.isDeleted) {
      return false;
    }
    if (containingFrame) {
      return element.frameId === containingFrame;
    }
    if (appState.editingGroupId) {
      return element.groupIds.includes(appState.editingGroupId);
    }
    return true;
  };
  const candidateIndex = direction === "left" ? findLastIndex(
    elements,
    (el) => indexFilter(el),
    Math.max(0, boundaryIndex - 1)
  ) : findIndex(elements, (el) => indexFilter(el), boundaryIndex + 1);
  const nextElement = elements[candidateIndex];
  if (!nextElement) {
    return -1;
  }
  if (appState.editingGroupId) {
    if (
      // candidate element is a sibling in current editing group  return
      sourceElement?.groupIds.join("") === nextElement?.groupIds.join("")
    ) {
      return getTargetIndexAccountingForBinding(nextElement, elements, direction) ?? candidateIndex;
    } else if (!nextElement?.groupIds.includes(appState.editingGroupId)) {
      return -1;
    }
  }
  if (!containingFrame && (nextElement.frameId || isFrameLikeElement(nextElement))) {
    const frameElements = getContiguousFrameRangeElements(
      elements,
      nextElement.frameId || nextElement.id
    );
    return direction === "left" ? elements.indexOf(frameElements[0]) : elements.indexOf(frameElements[frameElements.length - 1]);
  }
  if (!nextElement.groupIds.length) {
    return getTargetIndexAccountingForBinding(nextElement, elements, direction) ?? candidateIndex;
  }
  const siblingGroupId = appState.editingGroupId ? nextElement.groupIds[nextElement.groupIds.indexOf(appState.editingGroupId) - 1] : nextElement.groupIds[nextElement.groupIds.length - 1];
  const elementsInSiblingGroup = getElementsInGroup(elements, siblingGroupId);
  if (elementsInSiblingGroup.length) {
    return direction === "left" ? elements.indexOf(elementsInSiblingGroup[0]) : elements.indexOf(
      elementsInSiblingGroup[elementsInSiblingGroup.length - 1]
    );
  }
  return candidateIndex;
};
var getTargetElementsMap = (elements, indices) => {
  return indices.reduce((acc, index2) => {
    const element = elements[index2];
    acc.set(element.id, element);
    return acc;
  }, /* @__PURE__ */ new Map());
};
var shiftElementsByOne = (elements, appState, direction) => {
  const indicesToMove = getIndicesToMove(elements, appState);
  const targetElementsMap = getTargetElementsMap(elements, indicesToMove);
  let groupedIndices = toContiguousGroups(indicesToMove);
  if (direction === "right") {
    groupedIndices = groupedIndices.reverse();
  }
  const selectedFrames = new Set(
    indicesToMove.filter((idx) => isFrameLikeElement(elements[idx])).map((idx) => elements[idx].id)
  );
  groupedIndices.forEach((indices, i3) => {
    const leadingIndex = indices[0];
    const trailingIndex = indices[indices.length - 1];
    const boundaryIndex = direction === "left" ? leadingIndex : trailingIndex;
    const containingFrame = indices.some((idx) => {
      const el = elements[idx];
      return el.frameId && selectedFrames.has(el.frameId);
    }) ? null : elements[boundaryIndex]?.frameId;
    const targetIndex = getTargetIndex(
      appState,
      elements,
      boundaryIndex,
      direction,
      containingFrame
    );
    if (targetIndex === -1 || boundaryIndex === targetIndex) {
      return;
    }
    const leadingElements = direction === "left" ? elements.slice(0, targetIndex) : elements.slice(0, leadingIndex);
    const targetElements = elements.slice(leadingIndex, trailingIndex + 1);
    const displacedElements = direction === "left" ? elements.slice(targetIndex, leadingIndex) : elements.slice(trailingIndex + 1, targetIndex + 1);
    const trailingElements = direction === "left" ? elements.slice(trailingIndex + 1) : elements.slice(targetIndex + 1);
    elements = direction === "left" ? [
      ...leadingElements,
      ...targetElements,
      ...displacedElements,
      ...trailingElements
    ] : [
      ...leadingElements,
      ...displacedElements,
      ...targetElements,
      ...trailingElements
    ];
  });
  syncMovedIndices(elements, targetElementsMap);
  return elements;
};
var shiftElementsToEnd = (elements, appState, direction, containingFrame, elementsToBeMoved) => {
  const indicesToMove = getIndicesToMove(elements, appState, elementsToBeMoved);
  const targetElementsMap = getTargetElementsMap(elements, indicesToMove);
  const displacedElements = [];
  let leadingIndex;
  let trailingIndex;
  if (direction === "left") {
    if (containingFrame) {
      leadingIndex = findIndex(
        elements,
        (el) => isOfTargetFrame(el, containingFrame)
      );
    } else if (appState.editingGroupId) {
      const groupElements = getElementsInGroup(
        elements,
        appState.editingGroupId
      );
      if (!groupElements.length) {
        return elements;
      }
      leadingIndex = elements.indexOf(groupElements[0]);
    } else {
      leadingIndex = 0;
    }
    trailingIndex = indicesToMove[indicesToMove.length - 1];
  } else {
    if (containingFrame) {
      trailingIndex = findLastIndex(
        elements,
        (el) => isOfTargetFrame(el, containingFrame)
      );
    } else if (appState.editingGroupId) {
      const groupElements = getElementsInGroup(
        elements,
        appState.editingGroupId
      );
      if (!groupElements.length) {
        return elements;
      }
      trailingIndex = elements.indexOf(groupElements[groupElements.length - 1]);
    } else {
      trailingIndex = elements.length - 1;
    }
    leadingIndex = indicesToMove[0];
  }
  if (leadingIndex === -1) {
    leadingIndex = 0;
  }
  for (let index2 = leadingIndex; index2 < trailingIndex + 1; index2++) {
    if (!indicesToMove.includes(index2)) {
      displacedElements.push(elements[index2]);
    }
  }
  const targetElements = Array.from(targetElementsMap.values());
  const leadingElements = elements.slice(0, leadingIndex);
  const trailingElements = elements.slice(trailingIndex + 1);
  const nextElements = direction === "left" ? [
    ...leadingElements,
    ...targetElements,
    ...displacedElements,
    ...trailingElements
  ] : [
    ...leadingElements,
    ...displacedElements,
    ...targetElements,
    ...trailingElements
  ];
  syncMovedIndices(nextElements, targetElementsMap);
  return nextElements;
};
function shiftElementsAccountingForFrames(allElements, appState, direction, shiftFunction) {
  const elementsToMove = arrayToMap(
    getSelectedElements(allElements, appState, {
      includeBoundTextElement: true,
      includeElementsInFrames: true
    })
  );
  const frameAwareContiguousElementsToMove = { regularElements: [], frameChildren: /* @__PURE__ */ new Map() };
  const fullySelectedFrames = /* @__PURE__ */ new Set();
  for (const element of allElements) {
    if (elementsToMove.has(element.id) && isFrameLikeElement(element)) {
      fullySelectedFrames.add(element.id);
    }
  }
  for (const element of allElements) {
    if (elementsToMove.has(element.id)) {
      if (isFrameLikeElement(element) || element.frameId && fullySelectedFrames.has(element.frameId)) {
        frameAwareContiguousElementsToMove.regularElements.push(element);
      } else if (!element.frameId) {
        frameAwareContiguousElementsToMove.regularElements.push(element);
      } else {
        const frameChildren = frameAwareContiguousElementsToMove.frameChildren.get(
          element.frameId
        ) || [];
        frameChildren.push(element);
        frameAwareContiguousElementsToMove.frameChildren.set(
          element.frameId,
          frameChildren
        );
      }
    }
  }
  let nextElements = allElements;
  const frameChildrenSets = Array.from(
    frameAwareContiguousElementsToMove.frameChildren.entries()
  );
  for (const [frameId, children] of frameChildrenSets) {
    nextElements = shiftFunction(
      allElements,
      appState,
      direction,
      frameId,
      children
    );
  }
  return shiftFunction(
    nextElements,
    appState,
    direction,
    null,
    frameAwareContiguousElementsToMove.regularElements
  );
}
var moveOneLeft = (allElements, appState) => {
  return shiftElementsByOne(allElements, appState, "left");
};
var moveOneRight = (allElements, appState) => {
  return shiftElementsByOne(allElements, appState, "right");
};
var moveAllLeft = (allElements, appState) => {
  return shiftElementsAccountingForFrames(
    allElements,
    appState,
    "left",
    shiftElementsToEnd
  );
};
var moveAllRight = (allElements, appState) => {
  return shiftElementsAccountingForFrames(
    allElements,
    appState,
    "right",
    shiftElementsToEnd
  );
};

// actions/actionZindex.tsx
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var actionSendBackward = register({
  name: "sendBackward",
  label: "labels.sendBackward",
  keywords: ["move down", "zindex", "layer"],
  icon: SendBackwardIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState) => {
    return {
      elements: moveOneLeft(elements, appState),
      appState,
      storeAction: StoreAction.CAPTURE
    };
  },
  keyPriority: 40,
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && !event.shiftKey && event.code === CODES.BRACKET_LEFT,
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
    "button",
    {
      type: "button",
      className: "zIndexButton",
      onClick: () => updateData(null),
      title: `${t("labels.sendBackward")} \u2014 ${getShortcutKey("CtrlOrCmd+[")}`,
      children: SendBackwardIcon
    }
  )
});
var actionBringForward = register({
  name: "bringForward",
  label: "labels.bringForward",
  keywords: ["move up", "zindex", "layer"],
  icon: BringForwardIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState) => {
    return {
      elements: moveOneRight(elements, appState),
      appState,
      storeAction: StoreAction.CAPTURE
    };
  },
  keyPriority: 40,
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && !event.shiftKey && event.code === CODES.BRACKET_RIGHT,
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
    "button",
    {
      type: "button",
      className: "zIndexButton",
      onClick: () => updateData(null),
      title: `${t("labels.bringForward")} \u2014 ${getShortcutKey("CtrlOrCmd+]")}`,
      children: BringForwardIcon
    }
  )
});
var actionSendToBack = register({
  name: "sendToBack",
  label: "labels.sendToBack",
  keywords: ["move down", "zindex", "layer"],
  icon: SendToBackIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState) => {
    return {
      elements: moveAllLeft(elements, appState),
      appState,
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => isDarwin ? event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.BRACKET_LEFT : event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.code === CODES.BRACKET_LEFT,
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
    "button",
    {
      type: "button",
      className: "zIndexButton",
      onClick: () => updateData(null),
      title: `${t("labels.sendToBack")} \u2014 ${isDarwin ? getShortcutKey("CtrlOrCmd+Alt+[") : getShortcutKey("CtrlOrCmd+Shift+[")}`,
      children: SendToBackIcon
    }
  )
});
var actionBringToFront = register({
  name: "bringToFront",
  label: "labels.bringToFront",
  keywords: ["move up", "zindex", "layer"],
  icon: BringToFrontIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState) => {
    return {
      elements: moveAllRight(elements, appState),
      appState,
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => isDarwin ? event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.BRACKET_RIGHT : event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.code === CODES.BRACKET_RIGHT,
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
    "button",
    {
      type: "button",
      className: "zIndexButton",
      onClick: (event) => updateData(null),
      title: `${t("labels.bringToFront")} \u2014 ${isDarwin ? getShortcutKey("CtrlOrCmd+Alt+]") : getShortcutKey("CtrlOrCmd+Shift+]")}`,
      children: BringToFrontIcon
    }
  )
});

// actions/actionSelectAll.ts
init_define_import_meta_env();
var actionSelectAll = register({
  name: "selectAll",
  label: "labels.selectAll",
  icon: selectAllIcon,
  trackEvent: { category: "canvas" },
  viewMode: false,
  perform: (elements, appState, value, app) => {
    if (appState.editingLinearElement) {
      return false;
    }
    const selectedElementIds = excludeElementsInFramesFromSelection(
      elements.filter(
        (element) => !element.isDeleted && !(isTextElement(element) && element.containerId) && !element.locked
      )
    ).reduce((map, element) => {
      map[element.id] = true;
      return map;
    }, {});
    return {
      appState: {
        ...appState,
        ...selectGroupsForSelectedElements(
          {
            editingGroupId: null,
            selectedElementIds
          },
          getNonDeletedElements(elements),
          appState,
          app
        ),
        selectedLinearElement: (
          // single linear element selected
          Object.keys(selectedElementIds).length === 1 && isLinearElement(elements[0]) ? new LinearElementEditor(elements[0]) : null
        )
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.A
});

// actions/actionDuplicateSelection.tsx
init_define_import_meta_env();

// element/sortElements.ts
init_define_import_meta_env();
var normalizeGroupElementOrder = (elements) => {
  const origElements = elements.slice();
  const sortedElements = /* @__PURE__ */ new Set();
  const orderInnerGroups = (elements2) => {
    const firstGroupSig = elements2[0]?.groupIds?.join("");
    const aGroup = [elements2[0]];
    const bGroup = [];
    for (const element of elements2.slice(1)) {
      if (element.groupIds?.join("") === firstGroupSig) {
        aGroup.push(element);
      } else {
        bGroup.push(element);
      }
    }
    return bGroup.length ? [...aGroup, ...orderInnerGroups(bGroup)] : aGroup;
  };
  const groupHandledElements = /* @__PURE__ */ new Map();
  origElements.forEach((element, idx) => {
    if (groupHandledElements.has(element.id)) {
      return;
    }
    if (element.groupIds?.length) {
      const topGroup = element.groupIds[element.groupIds.length - 1];
      const groupElements = origElements.slice(idx).filter((element2) => {
        const ret = element2?.groupIds?.some((id) => id === topGroup);
        if (ret) {
          groupHandledElements.set(element2.id, true);
        }
        return ret;
      });
      for (const elem of orderInnerGroups(groupElements)) {
        sortedElements.add(elem);
      }
    } else {
      sortedElements.add(element);
    }
  });
  if (sortedElements.size !== elements.length) {
    console.error("normalizeGroupElementOrder: lost some elements... bailing!");
    return elements;
  }
  return [...sortedElements];
};
var normalizeBoundElementsOrder = (elements) => {
  const elementsMap = arrayToMapWithIndex(elements);
  const origElements = elements.slice();
  const sortedElements = /* @__PURE__ */ new Set();
  origElements.forEach((element, idx) => {
    if (!element) {
      return;
    }
    if (element.boundElements?.length) {
      sortedElements.add(element);
      origElements[idx] = null;
      element.boundElements.forEach((boundElement) => {
        const child = elementsMap.get(boundElement.id);
        if (child && boundElement.type === "text") {
          sortedElements.add(child[0]);
          origElements[child[1]] = null;
        }
      });
    } else if (element.type === "text" && element.containerId) {
      const parent = elementsMap.get(element.containerId);
      if (!parent?.[0].boundElements?.find((x3) => x3.id === element.id)) {
        sortedElements.add(element);
        origElements[idx] = null;
      }
    } else {
      sortedElements.add(element);
      origElements[idx] = null;
    }
  });
  if (sortedElements.size !== elements.length) {
    console.error(
      "normalizeBoundElementsOrder: lost some elements... bailing!"
    );
    return elements;
  }
  return [...sortedElements];
};
var normalizeElementOrder = (elements) => {
  const ret = normalizeBoundElementsOrder(normalizeGroupElementOrder(elements));
  return ret;
};

// actions/actionDuplicateSelection.tsx
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var actionDuplicateSelection = register({
  name: "duplicateSelection",
  label: "labels.duplicateSelection",
  icon: DuplicateIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState, formData, app) => {
    if (appState.editingLinearElement) {
      try {
        const newAppState = LinearElementEditor.duplicateSelectedPoints(
          appState,
          app.scene.getNonDeletedElementsMap()
        );
        return {
          elements,
          appState: newAppState,
          storeAction: StoreAction.CAPTURE
        };
      } catch {
        return false;
      }
    }
    return {
      ...duplicateElements2(elements, appState),
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.D,
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
    ToolButton,
    {
      type: "button",
      icon: DuplicateIcon,
      title: `${t("labels.duplicateSelection")} \u2014 ${getShortcutKey(
        "CtrlOrCmd+D"
      )}`,
      "aria-label": t("labels.duplicateSelection"),
      onClick: () => updateData(null),
      visible: isSomeElementSelected(getNonDeletedElements(elements), appState)
    }
  )
});
var duplicateElements2 = (elements, appState) => {
  const sortedElements = normalizeElementOrder(elements);
  const groupIdMap = /* @__PURE__ */ new Map();
  const newElements = [];
  const oldElements = [];
  const oldIdToDuplicatedId = /* @__PURE__ */ new Map();
  const duplicatedElementsMap = /* @__PURE__ */ new Map();
  const duplicateAndOffsetElement = (element) => {
    const newElement2 = duplicateElement(
      appState.editingGroupId,
      groupIdMap,
      element,
      {
        x: element.x + DEFAULT_GRID_SIZE / 2,
        y: element.y + DEFAULT_GRID_SIZE / 2
      }
    );
    duplicatedElementsMap.set(newElement2.id, newElement2);
    oldIdToDuplicatedId.set(element.id, newElement2.id);
    oldElements.push(element);
    newElements.push(newElement2);
    return newElement2;
  };
  const idsOfElementsToDuplicate = arrayToMap(
    getSelectedElements(sortedElements, appState, {
      includeBoundTextElement: true,
      includeElementsInFrames: true
    })
  );
  const processedIds = /* @__PURE__ */ new Map();
  const markAsProcessed = (elements2) => {
    for (const element of elements2) {
      processedIds.set(element.id, true);
    }
    return elements2;
  };
  const elementsWithClones = [];
  let index2 = -1;
  while (++index2 < sortedElements.length) {
    const element = sortedElements[index2];
    if (processedIds.get(element.id)) {
      continue;
    }
    const boundTextElement = getBoundTextElement(element, arrayToMap(elements));
    const isElementAFrameLike = isFrameLikeElement(element);
    if (idsOfElementsToDuplicate.get(element.id)) {
      if (element.groupIds.length || boundTextElement || isElementAFrameLike) {
        const groupId = getSelectedGroupForElement(appState, element);
        if (groupId) {
          const groupElements = getElementsInGroup(
            sortedElements,
            groupId
          ).flatMap(
            (element2) => isFrameLikeElement(element2) ? [...getFrameChildren(elements, element2.id), element2] : [element2]
          );
          elementsWithClones.push(
            ...markAsProcessed([
              ...groupElements,
              ...groupElements.map(
                (element2) => duplicateAndOffsetElement(element2)
              )
            ])
          );
          continue;
        }
        if (boundTextElement) {
          elementsWithClones.push(
            ...markAsProcessed([
              element,
              boundTextElement,
              duplicateAndOffsetElement(element),
              duplicateAndOffsetElement(boundTextElement)
            ])
          );
          continue;
        }
        if (isElementAFrameLike) {
          const elementsInFrame = getFrameChildren(sortedElements, element.id);
          elementsWithClones.push(
            ...markAsProcessed([
              ...elementsInFrame,
              element,
              ...elementsInFrame.map((e3) => duplicateAndOffsetElement(e3)),
              duplicateAndOffsetElement(element)
            ])
          );
          continue;
        }
      }
      if (!element.frameId || !idsOfElementsToDuplicate.has(element.frameId)) {
        elementsWithClones.push(
          ...markAsProcessed([element, duplicateAndOffsetElement(element)])
        );
      }
    } else {
      elementsWithClones.push(...markAsProcessed([element]));
    }
  }
  const finalElementsReversed = [];
  const finalElementIds = /* @__PURE__ */ new Map();
  index2 = elementsWithClones.length;
  while (--index2 >= 0) {
    const element = elementsWithClones[index2];
    if (!finalElementIds.get(element.id)) {
      finalElementIds.set(element.id, true);
      finalElementsReversed.push(element);
    }
  }
  const finalElements = syncMovedIndices(
    finalElementsReversed.reverse(),
    arrayToMap(newElements)
  );
  bindTextToShapeAfterDuplication(
    elementsWithClones,
    oldElements,
    oldIdToDuplicatedId
  );
  fixBindingsAfterDuplication(
    elementsWithClones,
    oldElements,
    oldIdToDuplicatedId
  );
  bindElementsToFramesAfterDuplication(
    finalElements,
    oldElements,
    oldIdToDuplicatedId
  );
  const nextElementsToSelect = excludeElementsInFramesFromSelection(newElements);
  return {
    elements: finalElements,
    appState: {
      ...appState,
      ...selectGroupsForSelectedElements(
        {
          editingGroupId: appState.editingGroupId,
          selectedElementIds: nextElementsToSelect.reduce(
            (acc, element) => {
              if (!isBoundToContainer(element)) {
                acc[element.id] = true;
              }
              return acc;
            },
            {}
          )
        },
        getNonDeletedElements(finalElements),
        appState,
        null
      )
    }
  };
};

// actions/actionProperties.tsx
init_define_import_meta_env();
var import_react49 = __toESM(require_react(), 1);

// analytics.ts
init_define_import_meta_env();
var ALLOWED_CATEGORIES_TO_TRACK = /* @__PURE__ */ new Set(["command_palette", "export"]);
var trackEvent = (category, action, label, value) => {
  try {
    if (typeof window === "undefined" || define_import_meta_env_default.VITE_WORKER_ID || define_import_meta_env_default.VITE_APP_ENABLE_TRACKING !== "true") {
      return;
    }
    if (!ALLOWED_CATEGORIES_TO_TRACK.has(category)) {
      return;
    }
    if (define_import_meta_env_default.DEV) {
      return;
    }
    if (!define_import_meta_env_default.PROD) {
      console.info("trackEvent", { category, action, label, value });
    }
    if (window.sa_event) {
      window.sa_event(action, {
        category,
        label,
        value
      });
    }
  } catch (error) {
    console.error("error during analytics", error);
  }
};

// components/ButtonIconSelect.tsx
init_define_import_meta_env();

// components/ButtonIcon.tsx
init_define_import_meta_env();
var import_react7 = __toESM(require_react(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var ButtonIcon = (0, import_react7.forwardRef)(
  (props, ref) => {
    const { title, className, testId, active, standalone, icon, onClick } = props;
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
      "button",
      {
        type: "button",
        ref,
        title,
        "data-testid": testId,
        className: clsx_m_default(className, { standalone, active }),
        onClick,
        children: icon
      },
      title
    );
  }
);

// components/ButtonIconSelect.tsx
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var ButtonIconSelect = (props) => /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "buttonList", children: props.options.map(
  (option) => props.type === "button" ? /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
    ButtonIcon,
    {
      icon: option.icon,
      title: option.text,
      testId: option.testId,
      active: option.active ?? props.value === option.value,
      onClick: (event) => props.onClick(option.value, event)
    },
    option.text
  ) : /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(
    "label",
    {
      className: clsx_m_default({ active: props.value === option.value }),
      title: option.text,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
          "input",
          {
            type: "radio",
            name: props.group,
            onChange: () => props.onChange(option.value),
            checked: props.value === option.value,
            "data-testid": option.testId
          }
        ),
        option.icon
      ]
    },
    option.text
  )
) });

// components/ColorPicker/ColorPicker.tsx
init_define_import_meta_env();

// components/ColorPicker/TopPicks.tsx
init_define_import_meta_env();
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var TopPicks = ({
  onChange,
  type,
  activeColor,
  topPicks
}) => {
  let colors;
  if (type === "elementStroke") {
    colors = DEFAULT_ELEMENT_STROKE_PICKS;
  }
  if (type === "elementBackground") {
    colors = DEFAULT_ELEMENT_BACKGROUND_PICKS;
  }
  if (type === "canvasBackground") {
    colors = DEFAULT_CANVAS_BACKGROUND_PICKS;
  }
  if (topPicks) {
    colors = topPicks;
  }
  if (!colors) {
    console.error("Invalid type for TopPicks");
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("div", { className: "color-picker__top-picks", children: colors.map((color) => /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
    "button",
    {
      className: clsx_m_default("color-picker__button", {
        active: color === activeColor,
        "is-transparent": color === "transparent" || !color
      }),
      style: { "--swatch-color": color },
      type: "button",
      title: color,
      onClick: () => onChange(color),
      "data-testid": `color-top-pick-${color}`,
      children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("div", { className: "color-picker__button-outline" })
    },
    color
  )) });
};

// components/ButtonSeparator.tsx
init_define_import_meta_env();
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var ButtonSeparator = () => /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
  "div",
  {
    style: {
      width: 1,
      height: "1rem",
      backgroundColor: "var(--default-border-color)",
      margin: "0 auto"
    }
  }
);

// components/ColorPicker/Picker.tsx
init_define_import_meta_env();
var import_react11 = __toESM(require_react(), 1);

// components/ColorPicker/ShadeList.tsx
init_define_import_meta_env();
var import_react8 = __toESM(require_react(), 1);

// components/ColorPicker/colorPickerUtils.ts
init_define_import_meta_env();
var getColorNameAndShadeFromColor = ({
  palette: palette2,
  color
}) => {
  for (const [colorName, colorVal] of Object.entries(palette2)) {
    if (Array.isArray(colorVal)) {
      const shade = colorVal.indexOf(color);
      if (shade > -1) {
        return { colorName, shade };
      }
    } else if (colorVal === color) {
      return { colorName, shade: null };
    }
  }
  return null;
};
var colorPickerHotkeyBindings = [
  ["q", "w", "e", "r", "t"],
  ["a", "s", "d", "f", "g"],
  ["z", "x", "c", "v", "b"]
].flat();
var isCustomColor = ({
  color,
  palette: palette2
}) => {
  const paletteValues = Object.values(palette2).flat();
  return !paletteValues.includes(color);
};
var getMostUsedCustomColors = (elements, type, palette2) => {
  const elementColorTypeMap = {
    elementBackground: "backgroundColor",
    elementStroke: "strokeColor"
  };
  const colors = elements.filter((element) => {
    if (element.isDeleted) {
      return false;
    }
    const color = element[elementColorTypeMap[type]];
    return isCustomColor({ color, palette: palette2 });
  });
  const colorCountMap = /* @__PURE__ */ new Map();
  colors.forEach((element) => {
    const color = element[elementColorTypeMap[type]];
    if (colorCountMap.has(color)) {
      colorCountMap.set(color, colorCountMap.get(color) + 1);
    } else {
      colorCountMap.set(color, 1);
    }
  });
  return [...colorCountMap.entries()].sort((a3, b3) => b3[1] - a3[1]).map((c3) => c3[0]).slice(0, MAX_CUSTOM_COLORS_USED_IN_CANVAS);
};
var activeColorPickerSectionAtom = atom2(null);
var calculateContrast = (r3, g3, b3) => {
  const yiq = (r3 * 299 + g3 * 587 + b3 * 114) / 1e3;
  return yiq >= 160 ? "black" : "white";
};
var getContrastYIQ = (bgHex, isCustomColor2) => {
  if (isCustomColor2) {
    const style = new Option().style;
    style.color = bgHex;
    if (style.color) {
      const rgb = style.color.replace(/^(rgb|rgba)\(/, "").replace(/\)$/, "").replace(/\s/g, "").split(",");
      const r4 = parseInt(rgb[0]);
      const g4 = parseInt(rgb[1]);
      const b4 = parseInt(rgb[2]);
      return calculateContrast(r4, g4, b4);
    }
  }
  if (bgHex === "transparent") {
    return "black";
  }
  const r3 = parseInt(bgHex.substring(1, 3), 16);
  const g3 = parseInt(bgHex.substring(3, 5), 16);
  const b3 = parseInt(bgHex.substring(5, 7), 16);
  return calculateContrast(r3, g3, b3);
};

// components/ColorPicker/HotkeyLabel.tsx
init_define_import_meta_env();
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var HotkeyLabel = ({
  color,
  keyLabel,
  isCustomColor: isCustomColor2 = false,
  isShade = false
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)(
    "div",
    {
      className: "color-picker__button__hotkey-label",
      style: {
        color: getContrastYIQ(color, isCustomColor2)
      },
      children: [
        isShade && "\u21E7",
        keyLabel
      ]
    }
  );
};
var HotkeyLabel_default = HotkeyLabel;

// components/ColorPicker/ShadeList.tsx
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var ShadeList = ({ hex, onChange, palette: palette2 }) => {
  const colorObj = getColorNameAndShadeFromColor({
    color: hex || "transparent",
    palette: palette2
  });
  const [activeColorPickerSection, setActiveColorPickerSection] = useAtom(
    activeColorPickerSectionAtom
  );
  const btnRef = (0, import_react8.useRef)(null);
  (0, import_react8.useEffect)(() => {
    if (btnRef.current && activeColorPickerSection === "shades") {
      btnRef.current.focus();
    }
  }, [colorObj, activeColorPickerSection]);
  if (colorObj) {
    const { colorName, shade } = colorObj;
    const shades = palette2[colorName];
    if (Array.isArray(shades)) {
      return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("div", { className: "color-picker-content--default shades", children: shades.map((color, i3) => /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)(
        "button",
        {
          ref: i3 === shade && activeColorPickerSection === "shades" ? btnRef : void 0,
          tabIndex: -1,
          type: "button",
          className: clsx_m_default(
            "color-picker__button color-picker__button--large",
            { active: i3 === shade }
          ),
          "aria-label": "Shade",
          title: `${colorName} - ${i3 + 1}`,
          style: color ? { "--swatch-color": color } : void 0,
          onClick: () => {
            onChange(color);
            setActiveColorPickerSection("shades");
          },
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("div", { className: "color-picker__button-outline" }),
            /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(HotkeyLabel_default, { color, keyLabel: i3 + 1, isShade: true })
          ]
        },
        i3
      )) });
    }
  }
  return /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)(
    "div",
    {
      className: "color-picker-content--default",
      style: { position: "relative" },
      tabIndex: -1,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
          "button",
          {
            type: "button",
            tabIndex: -1,
            className: "color-picker__button color-picker__button--large color-picker__button--no-focus-visible"
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
          "div",
          {
            tabIndex: -1,
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              textAlign: "center",
              fontSize: "0.75rem"
            },
            children: t("colorPicker.noShades")
          }
        )
      ]
    }
  );
};

// components/ColorPicker/PickerColorList.tsx
init_define_import_meta_env();
var import_react9 = __toESM(require_react(), 1);
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var PickerColorList = ({
  palette: palette2,
  color,
  onChange,
  label,
  activeShade
}) => {
  const colorObj = getColorNameAndShadeFromColor({
    color: color || "transparent",
    palette: palette2
  });
  const [activeColorPickerSection, setActiveColorPickerSection] = useAtom(
    activeColorPickerSectionAtom
  );
  const btnRef = (0, import_react9.useRef)(null);
  (0, import_react9.useEffect)(() => {
    if (btnRef.current && activeColorPickerSection === "baseColors") {
      btnRef.current.focus();
    }
  }, [colorObj?.colorName, activeColorPickerSection]);
  return /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("div", { className: "color-picker-content--default", children: Object.entries(palette2).map(([key, value], index2) => {
    const color2 = (Array.isArray(value) ? value[activeShade] : value) || "transparent";
    const keybinding = colorPickerHotkeyBindings[index2];
    const label2 = t(
      `colors.${key.replace(/\d+/, "")}`,
      null,
      ""
    );
    return /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)(
      "button",
      {
        ref: colorObj?.colorName === key ? btnRef : void 0,
        tabIndex: -1,
        type: "button",
        className: clsx_m_default(
          "color-picker__button color-picker__button--large",
          {
            active: colorObj?.colorName === key,
            "is-transparent": color2 === "transparent" || !color2
          }
        ),
        onClick: () => {
          onChange(color2);
          setActiveColorPickerSection("baseColors");
        },
        title: `${label2}${color2.startsWith("#") ? ` ${color2}` : ""} \u2014 ${keybinding}`,
        "aria-label": `${label2} \u2014 ${keybinding}`,
        style: color2 ? { "--swatch-color": color2 } : void 0,
        "data-testid": `color-${key}`,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("div", { className: "color-picker__button-outline" }),
          /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(HotkeyLabel_default, { color: color2, keyLabel: keybinding })
        ]
      },
      key
    );
  }) });
};
var PickerColorList_default = PickerColorList;

// components/ColorPicker/CustomColorList.tsx
init_define_import_meta_env();
var import_react10 = __toESM(require_react(), 1);
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var CustomColorList = ({
  colors,
  color,
  onChange,
  label
}) => {
  const [activeColorPickerSection, setActiveColorPickerSection] = useAtom(
    activeColorPickerSectionAtom
  );
  const btnRef = (0, import_react10.useRef)(null);
  (0, import_react10.useEffect)(() => {
    if (btnRef.current) {
      btnRef.current.focus();
    }
  }, [color, activeColorPickerSection]);
  return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("div", { className: "color-picker-content--default", children: colors.map((c3, i3) => {
    return /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)(
      "button",
      {
        ref: color === c3 ? btnRef : void 0,
        tabIndex: -1,
        type: "button",
        className: clsx_m_default(
          "color-picker__button color-picker__button--large",
          {
            active: color === c3,
            "is-transparent": c3 === "transparent" || !c3
          }
        ),
        onClick: () => {
          onChange(c3);
          setActiveColorPickerSection("custom");
        },
        title: c3,
        "aria-label": label,
        style: { "--swatch-color": c3 },
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("div", { className: "color-picker__button-outline" }),
          /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(HotkeyLabel_default, { color: c3, keyLabel: i3 + 1, isCustomColor: true })
        ]
      },
      i3
    );
  }) });
};

// components/ColorPicker/keyboardNavHandlers.ts
init_define_import_meta_env();
var arrowHandler = (eventKey, currentIndex, length) => {
  const rows = Math.ceil(length / COLORS_PER_ROW);
  currentIndex = currentIndex ?? -1;
  switch (eventKey) {
    case "ArrowLeft": {
      const prevIndex = currentIndex - 1;
      return prevIndex < 0 ? length - 1 : prevIndex;
    }
    case "ArrowRight": {
      return (currentIndex + 1) % length;
    }
    case "ArrowDown": {
      const nextIndex = currentIndex + COLORS_PER_ROW;
      return nextIndex >= length ? currentIndex % COLORS_PER_ROW : nextIndex;
    }
    case "ArrowUp": {
      const prevIndex = currentIndex - COLORS_PER_ROW;
      const newIndex = prevIndex < 0 ? COLORS_PER_ROW * rows + prevIndex : prevIndex;
      return newIndex >= length ? void 0 : newIndex;
    }
  }
};
var hotkeyHandler = ({
  e: e3,
  colorObj,
  onChange,
  palette: palette2,
  customColors,
  setActiveColorPickerSection,
  activeShade
}) => {
  if (colorObj?.shade != null) {
    if (["Digit1", "Digit2", "Digit3", "Digit4", "Digit5"].includes(e3.code) && e3.shiftKey) {
      const newShade = Number(e3.code.slice(-1)) - 1;
      onChange(palette2[colorObj.colorName][newShade]);
      setActiveColorPickerSection("shades");
      return true;
    }
  }
  if (["1", "2", "3", "4", "5"].includes(e3.key)) {
    const c3 = customColors[Number(e3.key) - 1];
    if (c3) {
      onChange(customColors[Number(e3.key) - 1]);
      setActiveColorPickerSection("custom");
      return true;
    }
  }
  if (colorPickerHotkeyBindings.includes(e3.key)) {
    const index2 = colorPickerHotkeyBindings.indexOf(e3.key);
    const paletteKey = Object.keys(palette2)[index2];
    const paletteValue = palette2[paletteKey];
    const r3 = Array.isArray(paletteValue) ? paletteValue[activeShade] : paletteValue;
    onChange(r3);
    setActiveColorPickerSection("baseColors");
    return true;
  }
  return false;
};
var colorPickerKeyNavHandler = ({
  event,
  activeColorPickerSection,
  palette: palette2,
  color,
  onChange,
  customColors,
  setActiveColorPickerSection,
  updateData,
  activeShade,
  onEyeDropperToggle,
  onEscape
}) => {
  if (event[KEYS.CTRL_OR_CMD]) {
    return false;
  }
  if (event.key === KEYS.ESCAPE) {
    onEscape(event);
    return true;
  }
  if (event.key === KEYS.ALT) {
    onEyeDropperToggle(true);
    return true;
  }
  if (event.key === KEYS.I) {
    onEyeDropperToggle();
    return true;
  }
  const colorObj = getColorNameAndShadeFromColor({ color, palette: palette2 });
  if (event.key === KEYS.TAB) {
    const sectionsMap = {
      custom: !!customColors.length,
      baseColors: true,
      shades: colorObj?.shade != null,
      hex: true
    };
    const sections = Object.entries(sectionsMap).reduce((acc, [key, value]) => {
      if (value) {
        acc.push(key);
      }
      return acc;
    }, []);
    const activeSectionIndex = sections.indexOf(activeColorPickerSection);
    const indexOffset = event.shiftKey ? -1 : 1;
    const nextSectionIndex = activeSectionIndex + indexOffset > sections.length - 1 ? 0 : activeSectionIndex + indexOffset < 0 ? sections.length - 1 : activeSectionIndex + indexOffset;
    const nextSection = sections[nextSectionIndex];
    if (nextSection) {
      setActiveColorPickerSection(nextSection);
    }
    if (nextSection === "custom") {
      onChange(customColors[0]);
    } else if (nextSection === "baseColors") {
      const baseColorName = Object.entries(palette2).find(([name, shades]) => {
        if (Array.isArray(shades)) {
          return shades.includes(color);
        } else if (shades === color) {
          return name;
        }
        return null;
      });
      if (!baseColorName) {
        onChange(COLOR_PALETTE.black);
      }
    }
    event.preventDefault();
    event.stopPropagation();
    return true;
  }
  if (hotkeyHandler({
    e: event,
    colorObj,
    onChange,
    palette: palette2,
    customColors,
    setActiveColorPickerSection,
    activeShade
  })) {
    return true;
  }
  if (activeColorPickerSection === "shades") {
    if (colorObj) {
      const { shade } = colorObj;
      const newShade = arrowHandler(event.key, shade, COLORS_PER_ROW);
      if (newShade !== void 0) {
        onChange(palette2[colorObj.colorName][newShade]);
        return true;
      }
    }
  }
  if (activeColorPickerSection === "baseColors") {
    if (colorObj) {
      const { colorName } = colorObj;
      const colorNames = Object.keys(palette2);
      const indexOfColorName = colorNames.indexOf(colorName);
      const newColorIndex = arrowHandler(
        event.key,
        indexOfColorName,
        colorNames.length
      );
      if (newColorIndex !== void 0) {
        const newColorName = colorNames[newColorIndex];
        const newColorNameValue = palette2[newColorName];
        onChange(
          Array.isArray(newColorNameValue) ? newColorNameValue[activeShade] : newColorNameValue
        );
        return true;
      }
    }
  }
  if (activeColorPickerSection === "custom") {
    const indexOfColor = customColors.indexOf(color);
    const newColorIndex = arrowHandler(
      event.key,
      indexOfColor,
      customColors.length
    );
    if (newColorIndex !== void 0) {
      const newColor = customColors[newColorIndex];
      onChange(newColor);
      return true;
    }
  }
  return false;
};

// components/ColorPicker/PickerHeading.tsx
init_define_import_meta_env();
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var PickerHeading = ({ children }) => /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("div", { className: "color-picker__heading", children });
var PickerHeading_default = PickerHeading;

// components/ColorPicker/Picker.tsx
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var Picker = ({
  color,
  onChange,
  label,
  type,
  elements,
  palette: palette2,
  updateData,
  children,
  onEyeDropperToggle,
  onEscape
}) => {
  const [customColors] = import_react11.default.useState(() => {
    if (type === "canvasBackground") {
      return [];
    }
    return getMostUsedCustomColors(elements, type, palette2);
  });
  const [activeColorPickerSection, setActiveColorPickerSection] = useAtom(
    activeColorPickerSectionAtom
  );
  const colorObj = getColorNameAndShadeFromColor({
    color,
    palette: palette2
  });
  (0, import_react11.useEffect)(() => {
    if (!activeColorPickerSection) {
      const isCustom = isCustomColor({ color, palette: palette2 });
      const isCustomButNotInList = isCustom && !customColors.includes(color);
      setActiveColorPickerSection(
        isCustomButNotInList ? "hex" : isCustom ? "custom" : colorObj?.shade != null ? "shades" : "baseColors"
      );
    }
  }, [
    activeColorPickerSection,
    color,
    palette2,
    setActiveColorPickerSection,
    colorObj,
    customColors
  ]);
  const [activeShade, setActiveShade] = (0, import_react11.useState)(
    colorObj?.shade ?? (type === "elementBackground" ? DEFAULT_ELEMENT_BACKGROUND_COLOR_INDEX : DEFAULT_ELEMENT_STROKE_COLOR_INDEX)
  );
  (0, import_react11.useEffect)(() => {
    if (colorObj?.shade != null) {
      setActiveShade(colorObj.shade);
    }
    const keyup = (event) => {
      if (event.key === KEYS.ALT) {
        onEyeDropperToggle(false);
      }
    };
    document.addEventListener("keyup" /* KEYUP */, keyup, { capture: true });
    return () => {
      document.removeEventListener("keyup" /* KEYUP */, keyup, { capture: true });
    };
  }, [colorObj, onEyeDropperToggle]);
  const pickerRef = import_react11.default.useRef(null);
  return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("div", { role: "dialog", "aria-modal": "true", "aria-label": t("labels.colorPicker"), children: /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)(
    "div",
    {
      ref: pickerRef,
      onKeyDown: (event) => {
        const handled = colorPickerKeyNavHandler({
          event,
          activeColorPickerSection,
          palette: palette2,
          color,
          onChange,
          onEyeDropperToggle,
          customColors,
          setActiveColorPickerSection,
          updateData,
          activeShade,
          onEscape
        });
        if (handled) {
          event.preventDefault();
          event.stopPropagation();
        }
      },
      className: "color-picker-content properties-content",
      tabIndex: -1,
      children: [
        !!customColors.length && /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("div", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(PickerHeading_default, { children: t("colorPicker.mostUsedCustomColors") }),
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
            CustomColorList,
            {
              colors: customColors,
              color,
              label: t("colorPicker.mostUsedCustomColors"),
              onChange
            }
          )
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("div", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(PickerHeading_default, { children: t("colorPicker.colors") }),
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
            PickerColorList_default,
            {
              color,
              label,
              palette: palette2,
              onChange,
              activeShade
            }
          )
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)("div", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(PickerHeading_default, { children: t("colorPicker.shades") }),
          /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(ShadeList, { hex: color, onChange, palette: palette2 })
        ] }),
        children
      ]
    }
  ) });
};

// ../../node_modules/@radix-ui/react-popover/dist/index.module.js
init_define_import_meta_env();

// ../../node_modules/@babel/runtime/helpers/esm/extends.js
init_define_import_meta_env();
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n3) {
    for (var e3 = 1; e3 < arguments.length; e3++) {
      var t3 = arguments[e3];
      for (var r3 in t3)
        ({}).hasOwnProperty.call(t3, r3) && (n3[r3] = t3[r3]);
    }
    return n3;
  }, _extends.apply(null, arguments);
}

// ../../node_modules/@radix-ui/react-popover/dist/index.module.js
var import_react30 = __toESM(require_react());

// ../../node_modules/@radix-ui/primitive/dist/index.module.js
init_define_import_meta_env();
function $e42e1063c40fb3ef$export$b9ecd428b558ff10(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented)
      return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
  };
}

// ../../node_modules/@radix-ui/react-compose-refs/dist/index.module.js
init_define_import_meta_env();
var import_react12 = __toESM(require_react());
function $6ed0406888f73fc4$var$setRef(ref, value) {
  if (typeof ref === "function")
    ref(value);
  else if (ref !== null && ref !== void 0)
    ref.current = value;
}
function $6ed0406888f73fc4$export$43e446d32b3d21af(...refs) {
  return (node) => refs.forEach(
    (ref) => $6ed0406888f73fc4$var$setRef(ref, node)
  );
}
function $6ed0406888f73fc4$export$c7b2cbe3552a0d05(...refs) {
  return (0, import_react12.useCallback)($6ed0406888f73fc4$export$43e446d32b3d21af(...refs), refs);
}

// ../../node_modules/@radix-ui/react-context/dist/index.module.js
init_define_import_meta_env();
var import_react13 = __toESM(require_react());
function $c512c27ab02ef895$export$50c7b4e9d9f19c1(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function $c512c27ab02ef895$export$fd42f52fd3ae1109(rootComponentName, defaultContext) {
    const BaseContext = /* @__PURE__ */ (0, import_react13.createContext)(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [
      ...defaultContexts,
      defaultContext
    ];
    function Provider2(props) {
      const { scope, children, ...context } = props;
      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const value = (0, import_react13.useMemo)(
        () => context,
        Object.values(context)
      );
      return /* @__PURE__ */ (0, import_react13.createElement)(Context.Provider, {
        value
      }, children);
    }
    function useContext5(consumerName, scope) {
      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const context = (0, import_react13.useContext)(Context);
      if (context)
        return context;
      if (defaultContext !== void 0)
        return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider2.displayName = rootComponentName + "Provider";
    return [
      Provider2,
      useContext5
    ];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return /* @__PURE__ */ (0, import_react13.createContext)(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope === null || scope === void 0 ? void 0 : scope[scopeName]) || scopeContexts;
      return (0, import_react13.useMemo)(
        () => ({
          [`__scope${scopeName}`]: {
            ...scope,
            [scopeName]: contexts
          }
        }),
        [
          scope,
          contexts
        ]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [
    $c512c27ab02ef895$export$fd42f52fd3ae1109,
    $c512c27ab02ef895$var$composeContextScopes(createScope, ...createContextScopeDeps)
  ];
}
function $c512c27ab02ef895$var$composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1)
    return baseScope;
  const createScope1 = () => {
    const scopeHooks = scopes.map(
      (createScope) => ({
        useScope: createScope(),
        scopeName: createScope.scopeName
      })
    );
    return function useComposedScopes(overrideScopes) {
      const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return {
          ...nextScopes,
          ...currentScope
        };
      }, {});
      return (0, import_react13.useMemo)(
        () => ({
          [`__scope${baseScope.scopeName}`]: nextScopes1
        }),
        [
          nextScopes1
        ]
      );
    };
  };
  createScope1.scopeName = baseScope.scopeName;
  return createScope1;
}

// ../../node_modules/@radix-ui/react-dismissable-layer/dist/index.module.js
init_define_import_meta_env();
var import_react18 = __toESM(require_react());

// ../../node_modules/@radix-ui/react-primitive/dist/index.module.js
init_define_import_meta_env();
var import_react15 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// ../../node_modules/@radix-ui/react-slot/dist/index.module.js
init_define_import_meta_env();
var import_react14 = __toESM(require_react());
var $5e63c961fc1ce211$export$8c6ed5c666ac1360 = /* @__PURE__ */ (0, import_react14.forwardRef)((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = import_react14.Children.toArray(children);
  const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable);
  if (slottable) {
    const newElement2 = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (import_react14.Children.count(newElement2) > 1)
          return import_react14.Children.only(null);
        return /* @__PURE__ */ (0, import_react14.isValidElement)(newElement2) ? newElement2.props.children : null;
      } else
        return child;
    });
    return /* @__PURE__ */ (0, import_react14.createElement)($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
      ref: forwardedRef
    }), /* @__PURE__ */ (0, import_react14.isValidElement)(newElement2) ? /* @__PURE__ */ (0, import_react14.cloneElement)(newElement2, void 0, newChildren) : null);
  }
  return /* @__PURE__ */ (0, import_react14.createElement)($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
    ref: forwardedRef
  }), children);
});
$5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName = "Slot";
var $5e63c961fc1ce211$var$SlotClone = /* @__PURE__ */ (0, import_react14.forwardRef)((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (/* @__PURE__ */ (0, import_react14.isValidElement)(children))
    return /* @__PURE__ */ (0, import_react14.cloneElement)(children, {
      ...$5e63c961fc1ce211$var$mergeProps(slotProps, children.props),
      ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, children.ref)
    });
  return import_react14.Children.count(children) > 1 ? import_react14.Children.only(null) : null;
});
$5e63c961fc1ce211$var$SlotClone.displayName = "SlotClone";
var $5e63c961fc1ce211$export$d9f1ccf0bdb05d45 = ({ children }) => {
  return /* @__PURE__ */ (0, import_react14.createElement)(import_react14.Fragment, null, children);
};
function $5e63c961fc1ce211$var$isSlottable(child) {
  return /* @__PURE__ */ (0, import_react14.isValidElement)(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45;
}
function $5e63c961fc1ce211$var$mergeProps(slotProps, childProps) {
  const overrideProps = {
    ...childProps
  };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue)
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      else if (slotPropValue)
        overrideProps[propName] = slotPropValue;
    } else if (propName === "style")
      overrideProps[propName] = {
        ...slotPropValue,
        ...childPropValue
      };
    else if (propName === "className")
      overrideProps[propName] = [
        slotPropValue,
        childPropValue
      ].filter(Boolean).join(" ");
  }
  return {
    ...slotProps,
    ...overrideProps
  };
}

// ../../node_modules/@radix-ui/react-primitive/dist/index.module.js
var $8927f6f2acc4f386$var$NODES = [
  "a",
  "button",
  "div",
  "h2",
  "h3",
  "img",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var $8927f6f2acc4f386$export$250ffa63cdc0d034 = $8927f6f2acc4f386$var$NODES.reduce((primitive, node) => {
  const Node = /* @__PURE__ */ (0, import_react15.forwardRef)((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac1360 : node;
    (0, import_react15.useEffect)(() => {
      window[Symbol.for("radix-ui")] = true;
    }, []);
    return /* @__PURE__ */ (0, import_react15.createElement)(Comp, _extends({}, primitiveProps, {
      ref: forwardedRef
    }));
  });
  Node.displayName = `Primitive.${node}`;
  return {
    ...primitive,
    [node]: Node
  };
}, {});
function $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event) {
  if (target)
    (0, import_react_dom.flushSync)(
      () => target.dispatchEvent(event)
    );
}

// ../../node_modules/@radix-ui/react-use-callback-ref/dist/index.module.js
init_define_import_meta_env();
var import_react16 = __toESM(require_react());
function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(callback) {
  const callbackRef = (0, import_react16.useRef)(callback);
  (0, import_react16.useEffect)(() => {
    callbackRef.current = callback;
  });
  return (0, import_react16.useMemo)(
    () => (...args) => {
      var _callbackRef$current;
      return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);
    },
    []
  );
}

// ../../node_modules/@radix-ui/react-use-escape-keydown/dist/index.module.js
init_define_import_meta_env();
var import_react17 = __toESM(require_react());
function $addc16e1bbe58fd0$export$3a72a57244d6e765(onEscapeKeyDownProp, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const onEscapeKeyDown = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEscapeKeyDownProp);
  (0, import_react17.useEffect)(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape")
        onEscapeKeyDown(event);
    };
    ownerDocument.addEventListener("keydown", handleKeyDown);
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown);
  }, [
    onEscapeKeyDown,
    ownerDocument
  ]);
}

// ../../node_modules/@radix-ui/react-dismissable-layer/dist/index.module.js
var $5cb92bef7577960e$var$CONTEXT_UPDATE = "dismissableLayer.update";
var $5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var $5cb92bef7577960e$var$FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var $5cb92bef7577960e$var$originalBodyPointerEvents;
var $5cb92bef7577960e$var$DismissableLayerContext = /* @__PURE__ */ (0, import_react18.createContext)({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var $5cb92bef7577960e$export$177fb62ff3ec1f22 = /* @__PURE__ */ (0, import_react18.forwardRef)((props, forwardedRef) => {
  var _node$ownerDocument;
  const { disableOutsidePointerEvents = false, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, ...layerProps } = props;
  const context = (0, import_react18.useContext)($5cb92bef7577960e$var$DismissableLayerContext);
  const [node1, setNode] = (0, import_react18.useState)(null);
  const ownerDocument = (_node$ownerDocument = node1 === null || node1 === void 0 ? void 0 : node1.ownerDocument) !== null && _node$ownerDocument !== void 0 ? _node$ownerDocument : globalThis === null || globalThis === void 0 ? void 0 : globalThis.document;
  const [, force] = (0, import_react18.useState)({});
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node) => setNode(node)
  );
  const layers = Array.from(context.layers);
  const [highestLayerWithOutsidePointerEventsDisabled] = [
    ...context.layersWithOutsidePointerEventsDisabled
  ].slice(-1);
  const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
  const index2 = node1 ? layers.indexOf(node1) : -1;
  const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
  const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
  const pointerDownOutside = $5cb92bef7577960e$var$usePointerDownOutside((event) => {
    const target = event.target;
    const isPointerDownOnBranch = [
      ...context.branches
    ].some(
      (branch) => branch.contains(target)
    );
    if (!isPointerEventsEnabled || isPointerDownOnBranch)
      return;
    onPointerDownOutside === null || onPointerDownOutside === void 0 || onPointerDownOutside(event);
    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
    if (!event.defaultPrevented)
      onDismiss === null || onDismiss === void 0 || onDismiss();
  }, ownerDocument);
  const focusOutside = $5cb92bef7577960e$var$useFocusOutside((event) => {
    const target = event.target;
    const isFocusInBranch = [
      ...context.branches
    ].some(
      (branch) => branch.contains(target)
    );
    if (isFocusInBranch)
      return;
    onFocusOutside === null || onFocusOutside === void 0 || onFocusOutside(event);
    onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
    if (!event.defaultPrevented)
      onDismiss === null || onDismiss === void 0 || onDismiss();
  }, ownerDocument);
  $addc16e1bbe58fd0$export$3a72a57244d6e765((event) => {
    const isHighestLayer = index2 === context.layers.size - 1;
    if (!isHighestLayer)
      return;
    onEscapeKeyDown === null || onEscapeKeyDown === void 0 || onEscapeKeyDown(event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }, ownerDocument);
  (0, import_react18.useEffect)(() => {
    if (!node1)
      return;
    if (disableOutsidePointerEvents) {
      if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
        $5cb92bef7577960e$var$originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
        ownerDocument.body.style.pointerEvents = "none";
      }
      context.layersWithOutsidePointerEventsDisabled.add(node1);
    }
    context.layers.add(node1);
    $5cb92bef7577960e$var$dispatchUpdate();
    return () => {
      if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1)
        ownerDocument.body.style.pointerEvents = $5cb92bef7577960e$var$originalBodyPointerEvents;
    };
  }, [
    node1,
    ownerDocument,
    disableOutsidePointerEvents,
    context
  ]);
  (0, import_react18.useEffect)(() => {
    return () => {
      if (!node1)
        return;
      context.layers.delete(node1);
      context.layersWithOutsidePointerEventsDisabled.delete(node1);
      $5cb92bef7577960e$var$dispatchUpdate();
    };
  }, [
    node1,
    context
  ]);
  (0, import_react18.useEffect)(() => {
    const handleUpdate = () => force({});
    document.addEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
    return () => document.removeEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
  }, []);
  return /* @__PURE__ */ (0, import_react18.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, layerProps, {
    ref: composedRefs,
    style: {
      pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
      ...props.style
    },
    onFocusCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusCapture, focusOutside.onFocusCapture),
    onBlurCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlurCapture, focusOutside.onBlurCapture),
    onPointerDownCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)
  }));
});
function $5cb92bef7577960e$var$usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const handlePointerDownOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPointerDownOutside);
  const isPointerInsideReactTreeRef = (0, import_react18.useRef)(false);
  const handleClickRef = (0, import_react18.useRef)(() => {
  });
  (0, import_react18.useEffect)(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent = function() {
          $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail, {
            discrete: true
          });
        };
        const eventDetail = {
          originalEvent: event
        };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;
          ownerDocument.addEventListener("click", handleClickRef.current, {
            once: true
          });
        } else
          handleAndDispatchPointerDownOutsideEvent();
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [
    ownerDocument,
    handlePointerDownOutside
  ]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function $5cb92bef7577960e$var$useFocusOutside(onFocusOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
  const handleFocusOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onFocusOutside);
  const isFocusInsideReactTreeRef = (0, import_react18.useRef)(false);
  (0, import_react18.useEffect)(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = {
          originalEvent: event
        };
        $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [
    ownerDocument,
    handleFocusOutside
  ]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function $5cb92bef7577960e$var$dispatchUpdate() {
  const event = new CustomEvent($5cb92bef7577960e$var$CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function $5cb92bef7577960e$var$handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, {
    bubbles: false,
    cancelable: true,
    detail
  });
  if (handler)
    target.addEventListener(name, handler, {
      once: true
    });
  if (discrete)
    $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event);
  else
    target.dispatchEvent(event);
}

// ../../node_modules/@radix-ui/react-focus-guards/dist/index.module.js
init_define_import_meta_env();
var import_react19 = __toESM(require_react());
var $3db38b7d1fb3fe6a$var$count = 0;
function $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c() {
  (0, import_react19.useEffect)(() => {
    var _edgeGuards$, _edgeGuards$2;
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", (_edgeGuards$ = edgeGuards[0]) !== null && _edgeGuards$ !== void 0 ? _edgeGuards$ : $3db38b7d1fb3fe6a$var$createFocusGuard());
    document.body.insertAdjacentElement("beforeend", (_edgeGuards$2 = edgeGuards[1]) !== null && _edgeGuards$2 !== void 0 ? _edgeGuards$2 : $3db38b7d1fb3fe6a$var$createFocusGuard());
    $3db38b7d1fb3fe6a$var$count++;
    return () => {
      if ($3db38b7d1fb3fe6a$var$count === 1)
        document.querySelectorAll("[data-radix-focus-guard]").forEach(
          (node) => node.remove()
        );
      $3db38b7d1fb3fe6a$var$count--;
    };
  }, []);
}
function $3db38b7d1fb3fe6a$var$createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
  return element;
}

// ../../node_modules/@radix-ui/react-focus-scope/dist/index.module.js
init_define_import_meta_env();
var import_react20 = __toESM(require_react());
var $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var $d3863c46a17e8a28$var$EVENT_OPTIONS = {
  bubbles: false,
  cancelable: true
};
var $d3863c46a17e8a28$export$20e40289641fbbb6 = /* @__PURE__ */ (0, import_react20.forwardRef)((props, forwardedRef) => {
  const { loop = false, trapped = false, onMountAutoFocus: onMountAutoFocusProp, onUnmountAutoFocus: onUnmountAutoFocusProp, ...scopeProps } = props;
  const [container1, setContainer] = (0, import_react20.useState)(null);
  const onMountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onMountAutoFocusProp);
  const onUnmountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onUnmountAutoFocusProp);
  const lastFocusedElementRef = (0, import_react20.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node) => setContainer(node)
  );
  const focusScope = (0, import_react20.useRef)({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  (0, import_react20.useEffect)(() => {
    if (trapped) {
      let handleFocusIn = function(event) {
        if (focusScope.paused || !container1)
          return;
        const target = event.target;
        if (container1.contains(target))
          lastFocusedElementRef.current = target;
        else
          $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
            select: true
          });
      }, handleFocusOut = function(event) {
        if (focusScope.paused || !container1)
          return;
        if (!container1.contains(event.relatedTarget))
          $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
            select: true
          });
      };
      document.addEventListener("focusin", handleFocusIn);
      document.addEventListener("focusout", handleFocusOut);
      return () => {
        document.removeEventListener("focusin", handleFocusIn);
        document.removeEventListener("focusout", handleFocusOut);
      };
    }
  }, [
    trapped,
    container1,
    focusScope.paused
  ]);
  (0, import_react20.useEffect)(() => {
    if (container1) {
      $d3863c46a17e8a28$var$focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container1.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
        container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container1.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          $d3863c46a17e8a28$var$focusFirst($d3863c46a17e8a28$var$removeLinks($d3863c46a17e8a28$var$getTabbableCandidates(container1)), {
            select: true
          });
          if (document.activeElement === previouslyFocusedElement)
            $d3863c46a17e8a28$var$focus(container1);
        }
      }
      return () => {
        container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
          container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container1.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented)
            $d3863c46a17e8a28$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {
              select: true
            });
          container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          $d3863c46a17e8a28$var$focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [
    container1,
    onMountAutoFocus,
    onUnmountAutoFocus,
    focusScope
  ]);
  const handleKeyDown = (0, import_react20.useCallback)((event) => {
    if (!loop && !trapped)
      return;
    if (focusScope.paused)
      return;
    const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
    const focusedElement = document.activeElement;
    if (isTabKey && focusedElement) {
      const container = event.currentTarget;
      const [first, last] = $d3863c46a17e8a28$var$getTabbableEdges(container);
      const hasTabbableElementsInside = first && last;
      if (!hasTabbableElementsInside) {
        if (focusedElement === container)
          event.preventDefault();
      } else {
        if (!event.shiftKey && focusedElement === last) {
          event.preventDefault();
          if (loop)
            $d3863c46a17e8a28$var$focus(first, {
              select: true
            });
        } else if (event.shiftKey && focusedElement === first) {
          event.preventDefault();
          if (loop)
            $d3863c46a17e8a28$var$focus(last, {
              select: true
            });
        }
      }
    }
  }, [
    loop,
    trapped,
    focusScope.paused
  ]);
  return /* @__PURE__ */ (0, import_react20.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    tabIndex: -1
  }, scopeProps, {
    ref: composedRefs,
    onKeyDown: handleKeyDown
  }));
});
function $d3863c46a17e8a28$var$focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    $d3863c46a17e8a28$var$focus(candidate, {
      select
    });
    if (document.activeElement !== previouslyFocusedElement)
      return;
  }
}
function $d3863c46a17e8a28$var$getTabbableEdges(container) {
  const candidates = $d3863c46a17e8a28$var$getTabbableCandidates(container);
  const first = $d3863c46a17e8a28$var$findVisible(candidates, container);
  const last = $d3863c46a17e8a28$var$findVisible(candidates.reverse(), container);
  return [
    first,
    last
  ];
}
function $d3863c46a17e8a28$var$getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}
function $d3863c46a17e8a28$var$findVisible(elements, container) {
  for (const element of elements) {
    if (!$d3863c46a17e8a28$var$isHidden(element, {
      upTo: container
    }))
      return element;
  }
}
function $d3863c46a17e8a28$var$isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden")
    return true;
  while (node) {
    if (upTo !== void 0 && node === upTo)
      return false;
    if (getComputedStyle(node).display === "none")
      return true;
    node = node.parentElement;
  }
  return false;
}
function $d3863c46a17e8a28$var$isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function $d3863c46a17e8a28$var$focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({
      preventScroll: true
    });
    if (element !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput(element) && select)
      element.select();
  }
}
var $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack();
function $d3863c46a17e8a28$var$createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope)
        activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause();
      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      var _stack$;
      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
      (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();
    }
  };
}
function $d3863c46a17e8a28$var$arrayRemove(array, item) {
  const updatedArray = [
    ...array
  ];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1)
    updatedArray.splice(index2, 1);
  return updatedArray;
}
function $d3863c46a17e8a28$var$removeLinks(items) {
  return items.filter(
    (item) => item.tagName !== "A"
  );
}

// ../../node_modules/@radix-ui/react-id/dist/index.module.js
init_define_import_meta_env();
var $2AODx$react = __toESM(require_react());

// ../../node_modules/@radix-ui/react-use-layout-effect/dist/index.module.js
init_define_import_meta_env();
var import_react21 = __toESM(require_react());
var $9f79659886946c16$export$e5c5a5f917a5871c = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? import_react21.useLayoutEffect : () => {
};

// ../../node_modules/@radix-ui/react-id/dist/index.module.js
var $1746a345f3d73bb7$var$useReactId = $2AODx$react["useId".toString()] || (() => void 0);
var $1746a345f3d73bb7$var$count = 0;
function $1746a345f3d73bb7$export$f680877a34711e37(deterministicId) {
  const [id, setId] = $2AODx$react.useState($1746a345f3d73bb7$var$useReactId());
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (!deterministicId)
      setId(
        (reactId) => reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count++)
      );
  }, [
    deterministicId
  ]);
  return deterministicId || (id ? `radix-${id}` : "");
}

// ../../node_modules/@radix-ui/react-popper/dist/index.module.js
init_define_import_meta_env();
var import_react25 = __toESM(require_react());

// ../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js
init_define_import_meta_env();

// ../../node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.min.mjs
init_define_import_meta_env();

// ../../node_modules/@floating-ui/core/dist/floating-ui.core.browser.min.mjs
init_define_import_meta_env();
function t2(t3) {
  return t3.split("-")[0];
}
function e2(t3) {
  return t3.split("-")[1];
}
function n(e3) {
  return ["top", "bottom"].includes(t2(e3)) ? "x" : "y";
}
function r(t3) {
  return "y" === t3 ? "height" : "width";
}
function i(i3, o3, a3) {
  let { reference: l3, floating: s3 } = i3;
  const c3 = l3.x + l3.width / 2 - s3.width / 2, f3 = l3.y + l3.height / 2 - s3.height / 2, u3 = n(o3), m3 = r(u3), g3 = l3[m3] / 2 - s3[m3] / 2, d3 = "x" === u3;
  let p3;
  switch (t2(o3)) {
    case "top":
      p3 = { x: c3, y: l3.y - s3.height };
      break;
    case "bottom":
      p3 = { x: c3, y: l3.y + l3.height };
      break;
    case "right":
      p3 = { x: l3.x + l3.width, y: f3 };
      break;
    case "left":
      p3 = { x: l3.x - s3.width, y: f3 };
      break;
    default:
      p3 = { x: l3.x, y: l3.y };
  }
  switch (e2(o3)) {
    case "start":
      p3[u3] -= g3 * (a3 && d3 ? -1 : 1);
      break;
    case "end":
      p3[u3] += g3 * (a3 && d3 ? -1 : 1);
  }
  return p3;
}
var o = async (t3, e3, n3) => {
  const { placement: r3 = "bottom", strategy: o3 = "absolute", middleware: a3 = [], platform: l3 } = n3, s3 = await (null == l3.isRTL ? void 0 : l3.isRTL(e3));
  let c3 = await l3.getElementRects({ reference: t3, floating: e3, strategy: o3 }), { x: f3, y: u3 } = i(c3, r3, s3), m3 = r3, g3 = {}, d3 = 0;
  for (let n4 = 0; n4 < a3.length; n4++) {
    const { name: p3, fn: h3 } = a3[n4], { x: y3, y: x3, data: w3, reset: v3 } = await h3({ x: f3, y: u3, initialPlacement: r3, placement: m3, strategy: o3, middlewareData: g3, rects: c3, platform: l3, elements: { reference: t3, floating: e3 } });
    f3 = null != y3 ? y3 : f3, u3 = null != x3 ? x3 : u3, g3 = { ...g3, [p3]: { ...g3[p3], ...w3 } }, v3 && d3 <= 50 && (d3++, "object" == typeof v3 && (v3.placement && (m3 = v3.placement), v3.rects && (c3 = true === v3.rects ? await l3.getElementRects({ reference: t3, floating: e3, strategy: o3 }) : v3.rects), { x: f3, y: u3 } = i(c3, m3, s3)), n4 = -1);
  }
  return { x: f3, y: u3, placement: m3, strategy: o3, middlewareData: g3 };
};
function a(t3) {
  return "number" != typeof t3 ? function(t4) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t4 };
  }(t3) : { top: t3, right: t3, bottom: t3, left: t3 };
}
function l(t3) {
  return { ...t3, top: t3.y, left: t3.x, right: t3.x + t3.width, bottom: t3.y + t3.height };
}
async function s(t3, e3) {
  var n3;
  void 0 === e3 && (e3 = {});
  const { x: r3, y: i3, platform: o3, rects: s3, elements: c3, strategy: f3 } = t3, { boundary: u3 = "clippingAncestors", rootBoundary: m3 = "viewport", elementContext: g3 = "floating", altBoundary: d3 = false, padding: p3 = 0 } = e3, h3 = a(p3), y3 = c3[d3 ? "floating" === g3 ? "reference" : "floating" : g3], x3 = l(await o3.getClippingRect({ element: null == (n3 = await (null == o3.isElement ? void 0 : o3.isElement(y3))) || n3 ? y3 : y3.contextElement || await (null == o3.getDocumentElement ? void 0 : o3.getDocumentElement(c3.floating)), boundary: u3, rootBoundary: m3, strategy: f3 })), w3 = l(o3.convertOffsetParentRelativeRectToViewportRelativeRect ? await o3.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: "floating" === g3 ? { ...s3.floating, x: r3, y: i3 } : s3.reference, offsetParent: await (null == o3.getOffsetParent ? void 0 : o3.getOffsetParent(c3.floating)), strategy: f3 }) : s3[g3]);
  return { top: x3.top - w3.top + h3.top, bottom: w3.bottom - x3.bottom + h3.bottom, left: x3.left - w3.left + h3.left, right: w3.right - x3.right + h3.right };
}
var c = Math.min;
var f = Math.max;
function u(t3, e3, n3) {
  return f(t3, c(e3, n3));
}
var m = (t3) => ({ name: "arrow", options: t3, async fn(i3) {
  const { element: o3, padding: l3 = 0 } = null != t3 ? t3 : {}, { x: s3, y: c3, placement: f3, rects: m3, platform: g3 } = i3;
  if (null == o3)
    return {};
  const d3 = a(l3), p3 = { x: s3, y: c3 }, h3 = n(f3), y3 = e2(f3), x3 = r(h3), w3 = await g3.getDimensions(o3), v3 = "y" === h3 ? "top" : "left", b3 = "y" === h3 ? "bottom" : "right", R3 = m3.reference[x3] + m3.reference[h3] - p3[h3] - m3.floating[x3], A2 = p3[h3] - m3.reference[h3], P2 = await (null == g3.getOffsetParent ? void 0 : g3.getOffsetParent(o3));
  let T3 = P2 ? "y" === h3 ? P2.clientHeight || 0 : P2.clientWidth || 0 : 0;
  0 === T3 && (T3 = m3.floating[x3]);
  const O2 = R3 / 2 - A2 / 2, D3 = d3[v3], L3 = T3 - w3[x3] - d3[b3], k2 = T3 / 2 - w3[x3] / 2 + O2, E3 = u(D3, k2, L3), C2 = ("start" === y3 ? d3[v3] : d3[b3]) > 0 && k2 !== E3 && m3.reference[x3] <= m3.floating[x3];
  return { [h3]: p3[h3] - (C2 ? k2 < D3 ? D3 - k2 : L3 - k2 : 0), data: { [h3]: E3, centerOffset: k2 - E3 } };
} });
var g = { left: "right", right: "left", bottom: "top", top: "bottom" };
function d(t3) {
  return t3.replace(/left|right|bottom|top/g, (t4) => g[t4]);
}
function p(t3, i3, o3) {
  void 0 === o3 && (o3 = false);
  const a3 = e2(t3), l3 = n(t3), s3 = r(l3);
  let c3 = "x" === l3 ? a3 === (o3 ? "end" : "start") ? "right" : "left" : "start" === a3 ? "bottom" : "top";
  return i3.reference[s3] > i3.floating[s3] && (c3 = d(c3)), { main: c3, cross: d(c3) };
}
var h = { start: "end", end: "start" };
function y(t3) {
  return t3.replace(/start|end/g, (t4) => h[t4]);
}
var x = ["top", "right", "bottom", "left"];
var w = x.reduce((t3, e3) => t3.concat(e3, e3 + "-start", e3 + "-end"), []);
var b = function(e3) {
  return void 0 === e3 && (e3 = {}), { name: "flip", options: e3, async fn(n3) {
    var r3;
    const { placement: i3, middlewareData: o3, rects: a3, initialPlacement: l3, platform: c3, elements: f3 } = n3, { mainAxis: u3 = true, crossAxis: m3 = true, fallbackPlacements: g3, fallbackStrategy: h3 = "bestFit", flipAlignment: x3 = true, ...w3 } = e3, v3 = t2(i3), b3 = g3 || (v3 === l3 || !x3 ? [d(l3)] : function(t3) {
      const e4 = d(t3);
      return [y(t3), e4, y(e4)];
    }(l3)), R3 = [l3, ...b3], A2 = await s(n3, w3), P2 = [];
    let T3 = (null == (r3 = o3.flip) ? void 0 : r3.overflows) || [];
    if (u3 && P2.push(A2[v3]), m3) {
      const { main: t3, cross: e4 } = p(i3, a3, await (null == c3.isRTL ? void 0 : c3.isRTL(f3.floating)));
      P2.push(A2[t3], A2[e4]);
    }
    if (T3 = [...T3, { placement: i3, overflows: P2 }], !P2.every((t3) => t3 <= 0)) {
      var O2, D3;
      const t3 = (null != (O2 = null == (D3 = o3.flip) ? void 0 : D3.index) ? O2 : 0) + 1, e4 = R3[t3];
      if (e4)
        return { data: { index: t3, overflows: T3 }, reset: { placement: e4 } };
      let n4 = "bottom";
      switch (h3) {
        case "bestFit": {
          var L3;
          const t4 = null == (L3 = T3.map((t5) => [t5, t5.overflows.filter((t6) => t6 > 0).reduce((t6, e5) => t6 + e5, 0)]).sort((t5, e5) => t5[1] - e5[1])[0]) ? void 0 : L3[0].placement;
          t4 && (n4 = t4);
          break;
        }
        case "initialPlacement":
          n4 = l3;
      }
      if (i3 !== n4)
        return { reset: { placement: n4 } };
    }
    return {};
  } };
};
function R(t3, e3) {
  return { top: t3.top - e3.height, right: t3.right - e3.width, bottom: t3.bottom - e3.height, left: t3.left - e3.width };
}
function A(t3) {
  return x.some((e3) => t3[e3] >= 0);
}
var P = function(t3) {
  let { strategy: e3 = "referenceHidden", ...n3 } = void 0 === t3 ? {} : t3;
  return { name: "hide", async fn(t4) {
    const { rects: r3 } = t4;
    switch (e3) {
      case "referenceHidden": {
        const e4 = R(await s(t4, { ...n3, elementContext: "reference" }), r3.reference);
        return { data: { referenceHiddenOffsets: e4, referenceHidden: A(e4) } };
      }
      case "escaped": {
        const e4 = R(await s(t4, { ...n3, altBoundary: true }), r3.floating);
        return { data: { escapedOffsets: e4, escaped: A(e4) } };
      }
      default:
        return {};
    }
  } };
};
var T = function(r3) {
  return void 0 === r3 && (r3 = 0), { name: "offset", options: r3, async fn(i3) {
    const { x: o3, y: a3 } = i3, l3 = await async function(r4, i4) {
      const { placement: o4, platform: a4, elements: l4 } = r4, s3 = await (null == a4.isRTL ? void 0 : a4.isRTL(l4.floating)), c3 = t2(o4), f3 = e2(o4), u3 = "x" === n(o4), m3 = ["left", "top"].includes(c3) ? -1 : 1, g3 = s3 && u3 ? -1 : 1, d3 = "function" == typeof i4 ? i4(r4) : i4;
      let { mainAxis: p3, crossAxis: h3, alignmentAxis: y3 } = "number" == typeof d3 ? { mainAxis: d3, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...d3 };
      return f3 && "number" == typeof y3 && (h3 = "end" === f3 ? -1 * y3 : y3), u3 ? { x: h3 * g3, y: p3 * m3 } : { x: p3 * m3, y: h3 * g3 };
    }(i3, r3);
    return { x: o3 + l3.x, y: a3 + l3.y, data: l3 };
  } };
};
function O(t3) {
  return "x" === t3 ? "y" : "x";
}
var D = function(e3) {
  return void 0 === e3 && (e3 = {}), { name: "shift", options: e3, async fn(r3) {
    const { x: i3, y: o3, placement: a3 } = r3, { mainAxis: l3 = true, crossAxis: c3 = false, limiter: f3 = { fn: (t3) => {
      let { x: e4, y: n3 } = t3;
      return { x: e4, y: n3 };
    } }, ...m3 } = e3, g3 = { x: i3, y: o3 }, d3 = await s(r3, m3), p3 = n(t2(a3)), h3 = O(p3);
    let y3 = g3[p3], x3 = g3[h3];
    if (l3) {
      const t3 = "y" === p3 ? "bottom" : "right";
      y3 = u(y3 + d3["y" === p3 ? "top" : "left"], y3, y3 - d3[t3]);
    }
    if (c3) {
      const t3 = "y" === h3 ? "bottom" : "right";
      x3 = u(x3 + d3["y" === h3 ? "top" : "left"], x3, x3 - d3[t3]);
    }
    const w3 = f3.fn({ ...r3, [p3]: y3, [h3]: x3 });
    return { ...w3, data: { x: w3.x - i3, y: w3.y - o3 } };
  } };
};
var L = function(e3) {
  return void 0 === e3 && (e3 = {}), { options: e3, fn(r3) {
    const { x: i3, y: o3, placement: a3, rects: l3, middlewareData: s3 } = r3, { offset: c3 = 0, mainAxis: f3 = true, crossAxis: u3 = true } = e3, m3 = { x: i3, y: o3 }, g3 = n(a3), d3 = O(g3);
    let p3 = m3[g3], h3 = m3[d3];
    const y3 = "function" == typeof c3 ? c3({ ...l3, placement: a3 }) : c3, x3 = "number" == typeof y3 ? { mainAxis: y3, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...y3 };
    if (f3) {
      const t3 = "y" === g3 ? "height" : "width", e4 = l3.reference[g3] - l3.floating[t3] + x3.mainAxis, n3 = l3.reference[g3] + l3.reference[t3] - x3.mainAxis;
      p3 < e4 ? p3 = e4 : p3 > n3 && (p3 = n3);
    }
    if (u3) {
      var w3, v3, b3, R3;
      const e4 = "y" === g3 ? "width" : "height", n3 = ["top", "left"].includes(t2(a3)), r4 = l3.reference[d3] - l3.floating[e4] + (n3 && null != (w3 = null == (v3 = s3.offset) ? void 0 : v3[d3]) ? w3 : 0) + (n3 ? 0 : x3.crossAxis), i4 = l3.reference[d3] + l3.reference[e4] + (n3 ? 0 : null != (b3 = null == (R3 = s3.offset) ? void 0 : R3[d3]) ? b3 : 0) - (n3 ? x3.crossAxis : 0);
      h3 < r4 ? h3 = r4 : h3 > i4 && (h3 = i4);
    }
    return { [g3]: p3, [d3]: h3 };
  } };
};
var k = function(n3) {
  return void 0 === n3 && (n3 = {}), { name: "size", options: n3, async fn(r3) {
    const { placement: i3, rects: o3, platform: a3, elements: l3 } = r3, { apply: c3, ...u3 } = n3, m3 = await s(r3, u3), g3 = t2(i3), d3 = e2(i3);
    let p3, h3;
    "top" === g3 || "bottom" === g3 ? (p3 = g3, h3 = d3 === (await (null == a3.isRTL ? void 0 : a3.isRTL(l3.floating)) ? "start" : "end") ? "left" : "right") : (h3 = g3, p3 = "end" === d3 ? "top" : "bottom");
    const y3 = f(m3.left, 0), x3 = f(m3.right, 0), w3 = f(m3.top, 0), v3 = f(m3.bottom, 0), b3 = { availableHeight: o3.floating.height - (["left", "right"].includes(i3) ? 2 * (0 !== w3 || 0 !== v3 ? w3 + v3 : f(m3.top, m3.bottom)) : m3[p3]), availableWidth: o3.floating.width - (["top", "bottom"].includes(i3) ? 2 * (0 !== y3 || 0 !== x3 ? y3 + x3 : f(m3.left, m3.right)) : m3[h3]) }, R3 = await a3.getDimensions(l3.floating);
    null == c3 || c3({ ...r3, ...b3 });
    const A2 = await a3.getDimensions(l3.floating);
    return R3.width !== A2.width || R3.height !== A2.height ? { reset: { rects: true } } : {};
  } };
};

// ../../node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.min.mjs
function n2(t3) {
  return t3 && t3.document && t3.location && t3.alert && t3.setInterval;
}
function o2(t3) {
  if (null == t3)
    return window;
  if (!n2(t3)) {
    const e3 = t3.ownerDocument;
    return e3 && e3.defaultView || window;
  }
  return t3;
}
function i2(t3) {
  return o2(t3).getComputedStyle(t3);
}
function r2(t3) {
  return n2(t3) ? "" : t3 ? (t3.nodeName || "").toLowerCase() : "";
}
function l2() {
  const t3 = navigator.userAgentData;
  return null != t3 && t3.brands ? t3.brands.map((t4) => t4.brand + "/" + t4.version).join(" ") : navigator.userAgent;
}
function c2(t3) {
  return t3 instanceof o2(t3).HTMLElement;
}
function f2(t3) {
  return t3 instanceof o2(t3).Element;
}
function s2(t3) {
  if ("undefined" == typeof ShadowRoot)
    return false;
  return t3 instanceof o2(t3).ShadowRoot || t3 instanceof ShadowRoot;
}
function u2(t3) {
  const { overflow: e3, overflowX: n3, overflowY: o3 } = i2(t3);
  return /auto|scroll|overlay|hidden/.test(e3 + o3 + n3);
}
function d2(t3) {
  return ["table", "td", "th"].includes(r2(t3));
}
function h2(t3) {
  const e3 = /firefox/i.test(l2()), n3 = i2(t3);
  return "none" !== n3.transform || "none" !== n3.perspective || "paint" === n3.contain || ["transform", "perspective"].includes(n3.willChange) || e3 && "filter" === n3.willChange || e3 && !!n3.filter && "none" !== n3.filter;
}
function a2() {
  return !/^((?!chrome|android).)*safari/i.test(l2());
}
var g2 = Math.min;
var p2 = Math.max;
var m2 = Math.round;
function w2(t3, e3, n3) {
  var i3, r3, l3, s3;
  void 0 === e3 && (e3 = false), void 0 === n3 && (n3 = false);
  const u3 = t3.getBoundingClientRect();
  let d3 = 1, h3 = 1;
  e3 && c2(t3) && (d3 = t3.offsetWidth > 0 && m2(u3.width) / t3.offsetWidth || 1, h3 = t3.offsetHeight > 0 && m2(u3.height) / t3.offsetHeight || 1);
  const g3 = f2(t3) ? o2(t3) : window, p3 = !a2() && n3, w3 = (u3.left + (p3 && null != (i3 = null == (r3 = g3.visualViewport) ? void 0 : r3.offsetLeft) ? i3 : 0)) / d3, v3 = (u3.top + (p3 && null != (l3 = null == (s3 = g3.visualViewport) ? void 0 : s3.offsetTop) ? l3 : 0)) / h3, y3 = u3.width / d3, x3 = u3.height / h3;
  return { width: y3, height: x3, top: v3, right: w3 + y3, bottom: v3 + x3, left: w3, x: w3, y: v3 };
}
function v2(t3) {
  return (e3 = t3, (e3 instanceof o2(e3).Node ? t3.ownerDocument : t3.document) || window.document).documentElement;
  var e3;
}
function y2(t3) {
  return f2(t3) ? { scrollLeft: t3.scrollLeft, scrollTop: t3.scrollTop } : { scrollLeft: t3.pageXOffset, scrollTop: t3.pageYOffset };
}
function x2(t3) {
  return w2(v2(t3)).left + y2(t3).scrollLeft;
}
function b2(t3, e3, n3) {
  const o3 = c2(e3), i3 = v2(e3), l3 = w2(t3, o3 && function(t4) {
    const e4 = w2(t4);
    return m2(e4.width) !== t4.offsetWidth || m2(e4.height) !== t4.offsetHeight;
  }(e3), "fixed" === n3);
  let f3 = { scrollLeft: 0, scrollTop: 0 };
  const s3 = { x: 0, y: 0 };
  if (o3 || !o3 && "fixed" !== n3)
    if (("body" !== r2(e3) || u2(i3)) && (f3 = y2(e3)), c2(e3)) {
      const t4 = w2(e3, true);
      s3.x = t4.x + e3.clientLeft, s3.y = t4.y + e3.clientTop;
    } else
      i3 && (s3.x = x2(i3));
  return { x: l3.left + f3.scrollLeft - s3.x, y: l3.top + f3.scrollTop - s3.y, width: l3.width, height: l3.height };
}
function L2(t3) {
  return "html" === r2(t3) ? t3 : t3.assignedSlot || t3.parentNode || (s2(t3) ? t3.host : null) || v2(t3);
}
function R2(t3) {
  return c2(t3) && "fixed" !== getComputedStyle(t3).position ? t3.offsetParent : null;
}
function T2(t3) {
  const e3 = o2(t3);
  let n3 = R2(t3);
  for (; n3 && d2(n3) && "static" === getComputedStyle(n3).position; )
    n3 = R2(n3);
  return n3 && ("html" === r2(n3) || "body" === r2(n3) && "static" === getComputedStyle(n3).position && !h2(n3)) ? e3 : n3 || function(t4) {
    let e4 = L2(t4);
    for (s2(e4) && (e4 = e4.host); c2(e4) && !["html", "body"].includes(r2(e4)); ) {
      if (h2(e4))
        return e4;
      e4 = e4.parentNode;
    }
    return null;
  }(t3) || e3;
}
function W(t3) {
  if (c2(t3))
    return { width: t3.offsetWidth, height: t3.offsetHeight };
  const e3 = w2(t3);
  return { width: e3.width, height: e3.height };
}
function E2(t3) {
  const e3 = L2(t3);
  return ["html", "body", "#document"].includes(r2(e3)) ? t3.ownerDocument.body : c2(e3) && u2(e3) ? e3 : E2(e3);
}
function H(t3, e3) {
  var n3;
  void 0 === e3 && (e3 = []);
  const i3 = E2(t3), r3 = i3 === (null == (n3 = t3.ownerDocument) ? void 0 : n3.body), l3 = o2(i3), c3 = r3 ? [l3].concat(l3.visualViewport || [], u2(i3) ? i3 : []) : i3, f3 = e3.concat(c3);
  return r3 ? f3 : f3.concat(H(c3));
}
function C(e3, n3, r3) {
  return "viewport" === n3 ? l(function(t3, e4) {
    const n4 = o2(t3), i3 = v2(t3), r4 = n4.visualViewport;
    let l3 = i3.clientWidth, c3 = i3.clientHeight, f3 = 0, s3 = 0;
    if (r4) {
      l3 = r4.width, c3 = r4.height;
      const t4 = a2();
      (t4 || !t4 && "fixed" === e4) && (f3 = r4.offsetLeft, s3 = r4.offsetTop);
    }
    return { width: l3, height: c3, x: f3, y: s3 };
  }(e3, r3)) : f2(n3) ? function(t3, e4) {
    const n4 = w2(t3, false, "fixed" === e4), o3 = n4.top + t3.clientTop, i3 = n4.left + t3.clientLeft;
    return { top: o3, left: i3, x: i3, y: o3, right: i3 + t3.clientWidth, bottom: o3 + t3.clientHeight, width: t3.clientWidth, height: t3.clientHeight };
  }(n3, r3) : l(function(t3) {
    var e4;
    const n4 = v2(t3), o3 = y2(t3), r4 = null == (e4 = t3.ownerDocument) ? void 0 : e4.body, l3 = p2(n4.scrollWidth, n4.clientWidth, r4 ? r4.scrollWidth : 0, r4 ? r4.clientWidth : 0), c3 = p2(n4.scrollHeight, n4.clientHeight, r4 ? r4.scrollHeight : 0, r4 ? r4.clientHeight : 0);
    let f3 = -o3.scrollLeft + x2(t3);
    const s3 = -o3.scrollTop;
    return "rtl" === i2(r4 || n4).direction && (f3 += p2(n4.clientWidth, r4 ? r4.clientWidth : 0) - l3), { width: l3, height: c3, x: f3, y: s3 };
  }(v2(e3)));
}
function S(t3) {
  const e3 = H(t3), n3 = ["absolute", "fixed"].includes(i2(t3).position) && c2(t3) ? T2(t3) : t3;
  return f2(n3) ? e3.filter((t4) => f2(t4) && function(t5, e4) {
    const n4 = null == e4.getRootNode ? void 0 : e4.getRootNode();
    if (t5.contains(e4))
      return true;
    if (n4 && s2(n4)) {
      let n5 = e4;
      do {
        if (n5 && t5 === n5)
          return true;
        n5 = n5.parentNode || n5.host;
      } while (n5);
    }
    return false;
  }(t4, n3) && "body" !== r2(t4)) : [];
}
var D2 = { getClippingRect: function(t3) {
  let { element: e3, boundary: n3, rootBoundary: o3, strategy: i3 } = t3;
  const r3 = [..."clippingAncestors" === n3 ? S(e3) : [].concat(n3), o3], l3 = r3[0], c3 = r3.reduce((t4, n4) => {
    const o4 = C(e3, n4, i3);
    return t4.top = p2(o4.top, t4.top), t4.right = g2(o4.right, t4.right), t4.bottom = g2(o4.bottom, t4.bottom), t4.left = p2(o4.left, t4.left), t4;
  }, C(e3, l3, i3));
  return { width: c3.right - c3.left, height: c3.bottom - c3.top, x: c3.left, y: c3.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(t3) {
  let { rect: e3, offsetParent: n3, strategy: o3 } = t3;
  const i3 = c2(n3), l3 = v2(n3);
  if (n3 === l3)
    return e3;
  let f3 = { scrollLeft: 0, scrollTop: 0 };
  const s3 = { x: 0, y: 0 };
  if ((i3 || !i3 && "fixed" !== o3) && (("body" !== r2(n3) || u2(l3)) && (f3 = y2(n3)), c2(n3))) {
    const t4 = w2(n3, true);
    s3.x = t4.x + n3.clientLeft, s3.y = t4.y + n3.clientTop;
  }
  return { ...e3, x: e3.x - f3.scrollLeft + s3.x, y: e3.y - f3.scrollTop + s3.y };
}, isElement: f2, getDimensions: W, getOffsetParent: T2, getDocumentElement: v2, getElementRects: (t3) => {
  let { reference: e3, floating: n3, strategy: o3 } = t3;
  return { reference: b2(e3, T2(n3), o3), floating: { ...W(n3), x: 0, y: 0 } };
}, getClientRects: (t3) => Array.from(t3.getClientRects()), isRTL: (t3) => "rtl" === i2(t3).direction };
function N(t3, e3, n3, o3) {
  void 0 === o3 && (o3 = {});
  const { ancestorScroll: i3 = true, ancestorResize: r3 = true, elementResize: l3 = true, animationFrame: c3 = false } = o3, s3 = i3 && !c3, u3 = r3 && !c3, d3 = s3 || u3 ? [...f2(t3) ? H(t3) : [], ...H(e3)] : [];
  d3.forEach((t4) => {
    s3 && t4.addEventListener("scroll", n3, { passive: true }), u3 && t4.addEventListener("resize", n3);
  });
  let h3, a3 = null;
  if (l3) {
    let o4 = true;
    a3 = new ResizeObserver(() => {
      o4 || n3(), o4 = false;
    }), f2(t3) && !c3 && a3.observe(t3), a3.observe(e3);
  }
  let g3 = c3 ? w2(t3) : null;
  return c3 && function e4() {
    const o4 = w2(t3);
    !g3 || o4.x === g3.x && o4.y === g3.y && o4.width === g3.width && o4.height === g3.height || n3();
    g3 = o4, h3 = requestAnimationFrame(e4);
  }(), n3(), () => {
    var t4;
    d3.forEach((t5) => {
      s3 && t5.removeEventListener("scroll", n3), u3 && t5.removeEventListener("resize", n3);
    }), null == (t4 = a3) || t4.disconnect(), a3 = null, c3 && cancelAnimationFrame(h3);
  };
}
var z = (t3, n3, o3) => o(t3, n3, { platform: D2, ...o3 });

// ../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js
var React5 = __toESM(require_react());
var import_react22 = __toESM(require_react());
var ReactDOM2 = __toESM(require_react_dom());
var index = typeof document !== "undefined" ? import_react22.useLayoutEffect : import_react22.useEffect;
function deepEqual(a3, b3) {
  if (a3 === b3) {
    return true;
  }
  if (typeof a3 !== typeof b3) {
    return false;
  }
  if (typeof a3 === "function" && a3.toString() === b3.toString()) {
    return true;
  }
  let length, i3, keys;
  if (a3 && b3 && typeof a3 == "object") {
    if (Array.isArray(a3)) {
      length = a3.length;
      if (length != b3.length)
        return false;
      for (i3 = length; i3-- !== 0; ) {
        if (!deepEqual(a3[i3], b3[i3])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a3);
    length = keys.length;
    if (length !== Object.keys(b3).length) {
      return false;
    }
    for (i3 = length; i3-- !== 0; ) {
      if (!Object.prototype.hasOwnProperty.call(b3, keys[i3])) {
        return false;
      }
    }
    for (i3 = length; i3-- !== 0; ) {
      const key = keys[i3];
      if (key === "_owner" && a3.$$typeof) {
        continue;
      }
      if (!deepEqual(a3[key], b3[key])) {
        return false;
      }
    }
    return true;
  }
  return a3 !== a3 && b3 !== b3;
}
function useLatestRef(value) {
  const ref = React5.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(_temp) {
  let {
    middleware,
    placement = "bottom",
    strategy = "absolute",
    whileElementsMounted
  } = _temp === void 0 ? {} : _temp;
  const reference = React5.useRef(null);
  const floating = React5.useRef(null);
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const cleanupRef = React5.useRef(null);
  const [data, setData] = React5.useState({
    // Setting these to `null` will allow the consumer to determine if
    // `computePosition()` has run yet
    x: null,
    y: null,
    strategy,
    placement,
    middlewareData: {}
  });
  const [latestMiddleware, setLatestMiddleware] = React5.useState(middleware);
  if (!deepEqual(latestMiddleware == null ? void 0 : latestMiddleware.map((_ref) => {
    let {
      options
    } = _ref;
    return options;
  }), middleware == null ? void 0 : middleware.map((_ref2) => {
    let {
      options
    } = _ref2;
    return options;
  }))) {
    setLatestMiddleware(middleware);
  }
  const update = React5.useCallback(() => {
    if (!reference.current || !floating.current) {
      return;
    }
    z(reference.current, floating.current, {
      middleware: latestMiddleware,
      placement,
      strategy
    }).then((data2) => {
      if (isMountedRef.current) {
        ReactDOM2.flushSync(() => {
          setData(data2);
        });
      }
    });
  }, [latestMiddleware, placement, strategy]);
  index(() => {
    if (isMountedRef.current) {
      update();
    }
  }, [update]);
  const isMountedRef = React5.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  const runElementMountCallback = React5.useCallback(() => {
    if (typeof cleanupRef.current === "function") {
      cleanupRef.current();
      cleanupRef.current = null;
    }
    if (reference.current && floating.current) {
      if (whileElementsMountedRef.current) {
        const cleanupFn = whileElementsMountedRef.current(reference.current, floating.current, update);
        cleanupRef.current = cleanupFn;
      } else {
        update();
      }
    }
  }, [update, whileElementsMountedRef]);
  const setReference = React5.useCallback((node) => {
    reference.current = node;
    runElementMountCallback();
  }, [runElementMountCallback]);
  const setFloating = React5.useCallback((node) => {
    floating.current = node;
    runElementMountCallback();
  }, [runElementMountCallback]);
  const refs = React5.useMemo(() => ({
    reference,
    floating
  }), []);
  return React5.useMemo(() => ({
    ...data,
    update,
    refs,
    reference: setReference,
    floating: setFloating
  }), [data, update, refs, setReference, setFloating]);
}
var arrow = (options) => {
  const {
    element,
    padding
  } = options;
  function isRef(value) {
    return Object.prototype.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(args) {
      if (isRef(element)) {
        if (element.current != null) {
          return m({
            element: element.current,
            padding
          }).fn(args);
        }
        return {};
      } else if (element) {
        return m({
          element,
          padding
        }).fn(args);
      }
      return {};
    }
  };
};

// ../../node_modules/@radix-ui/react-arrow/dist/index.module.js
init_define_import_meta_env();
var import_react23 = __toESM(require_react());
var $7e8f5cd07187803e$export$21b07c8f274aebd5 = /* @__PURE__ */ (0, import_react23.forwardRef)((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ (0, import_react23.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.svg, _extends({}, arrowProps, {
    ref: forwardedRef,
    width,
    height,
    viewBox: "0 0 30 10",
    preserveAspectRatio: "none"
  }), props.asChild ? children : /* @__PURE__ */ (0, import_react23.createElement)("polygon", {
    points: "0,0 30,0 15,10"
  }));
});
var $7e8f5cd07187803e$export$be92b6f5f03c0fe9 = $7e8f5cd07187803e$export$21b07c8f274aebd5;

// ../../node_modules/@radix-ui/react-use-size/dist/index.module.js
init_define_import_meta_env();
var import_react24 = __toESM(require_react());
function $db6c3485150b8e66$export$1ab7ae714698c4b8(element) {
  const [size, setSize] = (0, import_react24.useState)(void 0);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (element) {
      setSize({
        width: element.offsetWidth,
        height: element.offsetHeight
      });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries))
          return;
        if (!entries.length)
          return;
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({
          width,
          height
        });
      });
      resizeObserver.observe(element, {
        box: "border-box"
      });
      return () => resizeObserver.unobserve(element);
    } else
      setSize(void 0);
  }, [
    element
  ]);
  return size;
}

// ../../node_modules/@radix-ui/react-popper/dist/index.module.js
var $cf1ac5d9fe0e8206$var$POPPER_NAME = "Popper";
var [$cf1ac5d9fe0e8206$var$createPopperContext, $cf1ac5d9fe0e8206$export$722aac194ae923] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cf1ac5d9fe0e8206$var$POPPER_NAME);
var [$cf1ac5d9fe0e8206$var$PopperProvider, $cf1ac5d9fe0e8206$var$usePopperContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$POPPER_NAME);
var $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9 = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = (0, import_react25.useState)(null);
  return /* @__PURE__ */ (0, import_react25.createElement)($cf1ac5d9fe0e8206$var$PopperProvider, {
    scope: __scopePopper,
    anchor,
    onAnchorChange: setAnchor
  }, children);
};
var $cf1ac5d9fe0e8206$var$ANCHOR_NAME = "PopperAnchor";
var $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d = /* @__PURE__ */ (0, import_react25.forwardRef)((props, forwardedRef) => {
  const { __scopePopper, virtualRef, ...anchorProps } = props;
  const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$ANCHOR_NAME, __scopePopper);
  const ref = (0, import_react25.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  (0, import_react25.useEffect)(() => {
    context.onAnchorChange((virtualRef === null || virtualRef === void 0 ? void 0 : virtualRef.current) || ref.current);
  });
  return virtualRef ? null : /* @__PURE__ */ (0, import_react25.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, anchorProps, {
    ref: composedRefs
  }));
});
var $cf1ac5d9fe0e8206$var$CONTENT_NAME = "PopperContent";
var [$cf1ac5d9fe0e8206$var$PopperContentProvider, $cf1ac5d9fe0e8206$var$useContentContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME);
var [$cf1ac5d9fe0e8206$var$PositionContextProvider, $cf1ac5d9fe0e8206$var$usePositionContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, {
  hasParent: false,
  positionUpdateFns: /* @__PURE__ */ new Set()
});
var $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc = /* @__PURE__ */ (0, import_react25.forwardRef)((props, forwardedRef) => {
  var _arrowSize$width, _arrowSize$height, _middlewareData$arrow, _middlewareData$arrow2, _middlewareData$arrow3, _middlewareData$hide, _middlewareData$trans, _middlewareData$trans2;
  const { __scopePopper, side = "bottom", sideOffset = 0, align = "center", alignOffset = 0, arrowPadding = 0, collisionBoundary = [], collisionPadding: collisionPaddingProp = 0, sticky = "partial", hideWhenDetached = false, avoidCollisions = true, onPlaced, ...contentProps } = props;
  const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, __scopePopper);
  const [content, setContent] = (0, import_react25.useState)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
    forwardedRef,
    (node) => setContent(node)
  );
  const [arrow2, setArrow] = (0, import_react25.useState)(null);
  const arrowSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(arrow2);
  const arrowWidth = (_arrowSize$width = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.width) !== null && _arrowSize$width !== void 0 ? _arrowSize$width : 0;
  const arrowHeight = (_arrowSize$height = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.height) !== null && _arrowSize$height !== void 0 ? _arrowSize$height : 0;
  const desiredPlacement = side + (align !== "center" ? "-" + align : "");
  const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...collisionPaddingProp
  };
  const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [
    collisionBoundary
  ];
  const hasExplicitBoundaries = boundary.length > 0;
  const detectOverflowOptions = {
    padding: collisionPadding,
    boundary: boundary.filter($cf1ac5d9fe0e8206$var$isNotNull),
    // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
    altBoundary: hasExplicitBoundaries
  };
  const { reference, floating, strategy, x: x3, y: y3, placement, middlewareData, update } = useFloating({
    // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
    strategy: "fixed",
    placement: desiredPlacement,
    whileElementsMounted: N,
    middleware: [
      $cf1ac5d9fe0e8206$var$anchorCssProperties(),
      T({
        mainAxis: sideOffset + arrowHeight,
        alignmentAxis: alignOffset
      }),
      avoidCollisions ? D({
        mainAxis: true,
        crossAxis: false,
        limiter: sticky === "partial" ? L() : void 0,
        ...detectOverflowOptions
      }) : void 0,
      arrow2 ? arrow({
        element: arrow2,
        padding: arrowPadding
      }) : void 0,
      avoidCollisions ? b({
        ...detectOverflowOptions
      }) : void 0,
      k({
        ...detectOverflowOptions,
        apply: ({ elements, availableWidth: width, availableHeight: height }) => {
          elements.floating.style.setProperty("--radix-popper-available-width", `${width}px`);
          elements.floating.style.setProperty("--radix-popper-available-height", `${height}px`);
        }
      }),
      $cf1ac5d9fe0e8206$var$transformOrigin({
        arrowWidth,
        arrowHeight
      }),
      hideWhenDetached ? P({
        strategy: "referenceHidden"
      }) : void 0
    ].filter($cf1ac5d9fe0e8206$var$isDefined)
  });
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    reference(context.anchor);
  }, [
    reference,
    context.anchor
  ]);
  const isPlaced = x3 !== null && y3 !== null;
  const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
  const handlePlaced = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPlaced);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (isPlaced)
      handlePlaced === null || handlePlaced === void 0 || handlePlaced();
  }, [
    isPlaced,
    handlePlaced
  ]);
  const arrowX = (_middlewareData$arrow = middlewareData.arrow) === null || _middlewareData$arrow === void 0 ? void 0 : _middlewareData$arrow.x;
  const arrowY = (_middlewareData$arrow2 = middlewareData.arrow) === null || _middlewareData$arrow2 === void 0 ? void 0 : _middlewareData$arrow2.y;
  const cannotCenterArrow = ((_middlewareData$arrow3 = middlewareData.arrow) === null || _middlewareData$arrow3 === void 0 ? void 0 : _middlewareData$arrow3.centerOffset) !== 0;
  const [contentZIndex, setContentZIndex] = (0, import_react25.useState)();
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (content)
      setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [
    content
  ]);
  const { hasParent, positionUpdateFns } = $cf1ac5d9fe0e8206$var$usePositionContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, __scopePopper);
  const isRoot = !hasParent;
  (0, import_react25.useLayoutEffect)(() => {
    if (!isRoot) {
      positionUpdateFns.add(update);
      return () => {
        positionUpdateFns.delete(update);
      };
    }
  }, [
    isRoot,
    positionUpdateFns,
    update
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (isRoot && isPlaced)
      Array.from(positionUpdateFns).reverse().forEach(
        (fn) => requestAnimationFrame(fn)
      );
  }, [
    isRoot,
    isPlaced,
    positionUpdateFns
  ]);
  const commonProps = {
    "data-side": placedSide,
    "data-align": placedAlign,
    ...contentProps,
    ref: composedRefs,
    style: {
      ...contentProps.style,
      // if the PopperContent hasn't been placed yet (not all measurements done)
      // we prevent animations so that users's animation don't kick in too early referring wrong sides
      animation: !isPlaced ? "none" : void 0,
      // hide the content if using the hide middleware and should be hidden
      opacity: (_middlewareData$hide = middlewareData.hide) !== null && _middlewareData$hide !== void 0 && _middlewareData$hide.referenceHidden ? 0 : void 0
    }
  };
  return /* @__PURE__ */ (0, import_react25.createElement)("div", {
    ref: floating,
    "data-radix-popper-content-wrapper": "",
    style: {
      position: strategy,
      left: 0,
      top: 0,
      transform: isPlaced ? `translate3d(${Math.round(x3)}px, ${Math.round(y3)}px, 0)` : "translate3d(0, -200%, 0)",
      // keep off the page when measuring
      minWidth: "max-content",
      zIndex: contentZIndex,
      ["--radix-popper-transform-origin"]: [
        (_middlewareData$trans = middlewareData.transformOrigin) === null || _middlewareData$trans === void 0 ? void 0 : _middlewareData$trans.x,
        (_middlewareData$trans2 = middlewareData.transformOrigin) === null || _middlewareData$trans2 === void 0 ? void 0 : _middlewareData$trans2.y
      ].join(" ")
    },
    dir: props.dir
  }, /* @__PURE__ */ (0, import_react25.createElement)($cf1ac5d9fe0e8206$var$PopperContentProvider, {
    scope: __scopePopper,
    placedSide,
    onArrowChange: setArrow,
    arrowX,
    arrowY,
    shouldHideArrow: cannotCenterArrow
  }, isRoot ? /* @__PURE__ */ (0, import_react25.createElement)($cf1ac5d9fe0e8206$var$PositionContextProvider, {
    scope: __scopePopper,
    hasParent: true,
    positionUpdateFns
  }, /* @__PURE__ */ (0, import_react25.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, commonProps)) : /* @__PURE__ */ (0, import_react25.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, commonProps)));
});
var $cf1ac5d9fe0e8206$var$ARROW_NAME = "PopperArrow";
var $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0 = /* @__PURE__ */ (0, import_react25.forwardRef)(function $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd02(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = $cf1ac5d9fe0e8206$var$useContentContext($cf1ac5d9fe0e8206$var$ARROW_NAME, __scopePopper);
  const baseSide = $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ (0, import_react25.createElement)("span", {
      ref: contentContext.onArrowChange,
      style: {
        position: "absolute",
        left: contentContext.arrowX,
        top: contentContext.arrowY,
        [baseSide]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0"
        }[contentContext.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: `rotate(180deg)`,
          left: "translateY(50%) rotate(-90deg) translateX(50%)"
        }[contentContext.placedSide],
        visibility: contentContext.shouldHideArrow ? "hidden" : void 0
      }
    }, /* @__PURE__ */ (0, import_react25.createElement)($7e8f5cd07187803e$export$be92b6f5f03c0fe9, _extends({}, arrowProps, {
      ref: forwardedRef,
      style: {
        ...arrowProps.style,
        // ensures the element can be measured correctly (mostly for if SVG)
        display: "block"
      }
    })))
  );
});
function $cf1ac5d9fe0e8206$var$isDefined(value) {
  return value !== void 0;
}
function $cf1ac5d9fe0e8206$var$isNotNull(value) {
  return value !== null;
}
var $cf1ac5d9fe0e8206$var$anchorCssProperties = () => ({
  name: "anchorCssProperties",
  fn(data) {
    const { rects, elements } = data;
    const { width, height } = rects.reference;
    elements.floating.style.setProperty("--radix-popper-anchor-width", `${width}px`);
    elements.floating.style.setProperty("--radix-popper-anchor-height", `${height}px`);
    return {};
  }
});
var $cf1ac5d9fe0e8206$var$transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    var _middlewareData$arrow4, _middlewareData$arrow5, _middlewareData$arrow6, _middlewareData$arrow7, _middlewareData$arrow8;
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = ((_middlewareData$arrow4 = middlewareData.arrow) === null || _middlewareData$arrow4 === void 0 ? void 0 : _middlewareData$arrow4.centerOffset) !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
    const noArrowAlign = {
      start: "0%",
      center: "50%",
      end: "100%"
    }[placedAlign];
    const arrowXCenter = ((_middlewareData$arrow5 = (_middlewareData$arrow6 = middlewareData.arrow) === null || _middlewareData$arrow6 === void 0 ? void 0 : _middlewareData$arrow6.x) !== null && _middlewareData$arrow5 !== void 0 ? _middlewareData$arrow5 : 0) + arrowWidth / 2;
    const arrowYCenter = ((_middlewareData$arrow7 = (_middlewareData$arrow8 = middlewareData.arrow) === null || _middlewareData$arrow8 === void 0 ? void 0 : _middlewareData$arrow8.y) !== null && _middlewareData$arrow7 !== void 0 ? _middlewareData$arrow7 : 0) + arrowHeight / 2;
    let x3 = "";
    let y3 = "";
    if (placedSide === "bottom") {
      x3 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y3 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x3 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y3 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x3 = `${-arrowHeight}px`;
      y3 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x3 = `${rects.floating.width + arrowHeight}px`;
      y3 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return {
      data: {
        x: x3,
        y: y3
      }
    };
  }
});
function $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [
    side,
    align
  ];
}
var $cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9 = $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9;
var $cf1ac5d9fe0e8206$export$b688253958b8dfe7 = $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d;
var $cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2 = $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc;
var $cf1ac5d9fe0e8206$export$21b07c8f274aebd5 = $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0;

// ../../node_modules/@radix-ui/react-portal/dist/index.module.js
init_define_import_meta_env();
var import_react26 = __toESM(require_react());
var import_react_dom3 = __toESM(require_react_dom());
var $f1701beae083dbae$export$602eac185826482c = /* @__PURE__ */ (0, import_react26.forwardRef)((props, forwardedRef) => {
  var _globalThis$document;
  const { container = globalThis === null || globalThis === void 0 ? void 0 : (_globalThis$document = globalThis.document) === null || _globalThis$document === void 0 ? void 0 : _globalThis$document.body, ...portalProps } = props;
  return container ? /* @__PURE__ */ import_react_dom3.default.createPortal(/* @__PURE__ */ (0, import_react26.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, portalProps, {
    ref: forwardedRef
  })), container) : null;
});

// ../../node_modules/@radix-ui/react-presence/dist/index.module.js
init_define_import_meta_env();
var import_react27 = __toESM(require_react());
var import_react_dom4 = __toESM(require_react_dom());
function $fe963b355347cc68$export$3e6543de14f8614f(initialState, machine) {
  return (0, import_react27.useReducer)((state, event) => {
    const nextState = machine[state][event];
    return nextState !== null && nextState !== void 0 ? nextState : state;
  }, initialState);
}
var $921a889cee6df7e8$export$99c2b779aa4e8b8b = (props) => {
  const { present, children } = props;
  const presence = $921a889cee6df7e8$var$usePresence(present);
  const child = typeof children === "function" ? children({
    present: presence.isPresent
  }) : import_react27.Children.only(children);
  const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(presence.ref, child.ref);
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? /* @__PURE__ */ (0, import_react27.cloneElement)(child, {
    ref
  }) : null;
};
$921a889cee6df7e8$export$99c2b779aa4e8b8b.displayName = "Presence";
function $921a889cee6df7e8$var$usePresence(present) {
  const [node1, setNode] = (0, import_react27.useState)();
  const stylesRef = (0, import_react27.useRef)({});
  const prevPresentRef = (0, import_react27.useRef)(present);
  const prevAnimationNameRef = (0, import_react27.useRef)("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = $fe963b355347cc68$export$3e6543de14f8614f(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  (0, import_react27.useEffect)(() => {
    const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [
    state
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(styles);
      if (present)
        send("MOUNT");
      else if (currentAnimationName === "none" || (styles === null || styles === void 0 ? void 0 : styles.display) === "none")
        send("UNMOUNT");
      else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating)
          send("ANIMATION_OUT");
        else
          send("UNMOUNT");
      }
      prevPresentRef.current = present;
    }
  }, [
    present,
    send
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (node1) {
      const handleAnimationEnd = (event) => {
        const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node1 && isCurrentAnimation)
          (0, import_react_dom4.flushSync)(
            () => send("ANIMATION_END")
          );
      };
      const handleAnimationStart = (event) => {
        if (event.target === node1)
          prevAnimationNameRef.current = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
      };
      node1.addEventListener("animationstart", handleAnimationStart);
      node1.addEventListener("animationcancel", handleAnimationEnd);
      node1.addEventListener("animationend", handleAnimationEnd);
      return () => {
        node1.removeEventListener("animationstart", handleAnimationStart);
        node1.removeEventListener("animationcancel", handleAnimationEnd);
        node1.removeEventListener("animationend", handleAnimationEnd);
      };
    } else
      send("ANIMATION_END");
  }, [
    node1,
    send
  ]);
  return {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(state),
    ref: (0, import_react27.useCallback)((node) => {
      if (node)
        stylesRef.current = getComputedStyle(node);
      setNode(node);
    }, [])
  };
}
function $921a889cee6df7e8$var$getAnimationName(styles) {
  return (styles === null || styles === void 0 ? void 0 : styles.animationName) || "none";
}

// ../../node_modules/@radix-ui/react-use-controllable-state/dist/index.module.js
init_define_import_meta_env();
var import_react28 = __toESM(require_react());
function $71cd76cc60e0454e$export$6f32135080cb4c3({ prop, defaultProp, onChange = () => {
} }) {
  const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value1 = isControlled ? prop : uncontrolledProp;
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
  const setValue = (0, import_react28.useCallback)((nextValue) => {
    if (isControlled) {
      const setter = nextValue;
      const value = typeof nextValue === "function" ? setter(prop) : nextValue;
      if (value !== prop)
        handleChange(value);
    } else
      setUncontrolledProp(nextValue);
  }, [
    isControlled,
    prop,
    setUncontrolledProp,
    handleChange
  ]);
  return [
    value1,
    setValue
  ];
}
function $71cd76cc60e0454e$var$useUncontrolledState({ defaultProp, onChange }) {
  const uncontrolledState = (0, import_react28.useState)(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = (0, import_react28.useRef)(value);
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
  (0, import_react28.useEffect)(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [
    value,
    prevValueRef,
    handleChange
  ]);
  return uncontrolledState;
}

// ../../node_modules/aria-hidden/dist/es2015/index.js
init_define_import_meta_env();
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x3) {
    return Boolean(x3);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e3) {
          console.error("aria-hidden: cannot operate on ", node, e3);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};

// ../../node_modules/react-remove-scroll/dist/es2015/index.js
init_define_import_meta_env();

// ../../node_modules/react-remove-scroll/dist/es2015/Combination.js
init_define_import_meta_env();

// ../../node_modules/tslib/tslib.es6.mjs
init_define_import_meta_env();
var __assign = function() {
  __assign = Object.assign || function __assign2(t3) {
    for (var s3, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
      s3 = arguments[i3];
      for (var p3 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p3))
          t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign.apply(this, arguments);
};
function __rest(s3, e3) {
  var t3 = {};
  for (var p3 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p3) && e3.indexOf(p3) < 0)
      t3[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i3 = 0, p3 = Object.getOwnPropertySymbols(s3); i3 < p3.length; i3++) {
      if (e3.indexOf(p3[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i3]))
        t3[p3[i3]] = s3[p3[i3]];
    }
  return t3;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i3 = 0, l3 = from.length, ar; i3 < l3; i3++) {
      if (ar || !(i3 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i3);
        ar[i3] = from[i3];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// ../../node_modules/react-remove-scroll/dist/es2015/Combination.js
var React12 = __toESM(require_react());

// ../../node_modules/react-remove-scroll/dist/es2015/UI.js
init_define_import_meta_env();
var React8 = __toESM(require_react());

// ../../node_modules/react-remove-scroll-bar/dist/es2015/constants.js
init_define_import_meta_env();
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";

// ../../node_modules/use-callback-ref/dist/es2015/index.js
init_define_import_meta_env();

// ../../node_modules/use-callback-ref/dist/es2015/assignRef.js
init_define_import_meta_env();
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}

// ../../node_modules/use-callback-ref/dist/es2015/useRef.js
init_define_import_meta_env();
var import_react29 = __toESM(require_react());
function useCallbackRef(initialValue, callback) {
  var ref = (0, import_react29.useState)(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}

// ../../node_modules/use-callback-ref/dist/es2015/useMergeRef.js
init_define_import_meta_env();
var React6 = __toESM(require_react());
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? React6.useLayoutEffect : React6.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef(defaultValue || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}

// ../../node_modules/react-remove-scroll/dist/es2015/medium.js
init_define_import_meta_env();

// ../../node_modules/use-sidecar/dist/es2015/index.js
init_define_import_meta_env();

// ../../node_modules/use-sidecar/dist/es2015/medium.js
init_define_import_meta_env();
function ItoI(a3) {
  return a3;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x3) {
          return x3 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x3) {
          return cb(x3);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x3) {
          pendingQueue.push(x3);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}

// ../../node_modules/use-sidecar/dist/es2015/exports.js
init_define_import_meta_env();
var React7 = __toESM(require_react());
var SideCar = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React7.createElement(Target, __assign({}, rest));
};
SideCar.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar;
}

// ../../node_modules/react-remove-scroll/dist/es2015/medium.js
var effectCar = createSidecarMedium();

// ../../node_modules/react-remove-scroll/dist/es2015/UI.js
var nothing = function() {
  return;
};
var RemoveScroll = React8.forwardRef(function(props, parentRef) {
  var ref = React8.useRef(null);
  var _a = React8.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React8.createElement(
    React8.Fragment,
    null,
    enabled && React8.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }),
    forwardProps ? React8.cloneElement(React8.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React8.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};

// ../../node_modules/react-remove-scroll/dist/es2015/sidecar.js
init_define_import_meta_env();

// ../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
init_define_import_meta_env();
var React11 = __toESM(require_react());

// ../../node_modules/react-remove-scroll-bar/dist/es2015/index.js
init_define_import_meta_env();

// ../../node_modules/react-remove-scroll-bar/dist/es2015/component.js
init_define_import_meta_env();
var React10 = __toESM(require_react());

// ../../node_modules/react-style-singleton/dist/es2015/index.js
init_define_import_meta_env();

// ../../node_modules/react-style-singleton/dist/es2015/component.js
init_define_import_meta_env();

// ../../node_modules/react-style-singleton/dist/es2015/hook.js
init_define_import_meta_env();
var React9 = __toESM(require_react());

// ../../node_modules/react-style-singleton/dist/es2015/singleton.js
init_define_import_meta_env();

// ../../node_modules/get-nonce/dist/es2015/index.js
init_define_import_meta_env();
var currentNonce;
var getNonce = function() {
  if (currentNonce) {
    return currentNonce;
  }
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};

// ../../node_modules/react-style-singleton/dist/es2015/singleton.js
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};

// ../../node_modules/react-style-singleton/dist/es2015/hook.js
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React9.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};

// ../../node_modules/react-style-singleton/dist/es2015/component.js
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};

// ../../node_modules/react-remove-scroll-bar/dist/es2015/utils.js
init_define_import_meta_env();
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x3) {
  return parseInt(x3 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};

// ../../node_modules/react-remove-scroll-bar/dist/es2015/component.js
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React10.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React10.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React10.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};

// ../../node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
init_define_import_meta_env();
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var options;
var nonPassive = passiveSupported ? { passive: false } : false;

// ../../node_modules/react-remove-scroll/dist/es2015/handleScroll.js
init_define_import_meta_env();
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), s3 = _a[1], d3 = _a[2];
      if (s3 > d3) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== document.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    target = target.parentNode;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};

// ../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x3, y3) {
  return x3[0] === y3[0] && x3[1] === y3[1];
};
var generateStyle = function(id) {
  return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React11.useRef([]);
  var touchStartRef = React11.useRef([0, 0]);
  var activeAxis = React11.useRef();
  var id = React11.useState(idCounter++)[0];
  var Style2 = React11.useState(function() {
    return styleSingleton();
  })[0];
  var lastProps = React11.useRef(props);
  React11.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React11.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React11.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React11.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e3) {
      return e3.name === event.type && e3.target === event.target && deltaCompare(e3.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React11.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e3) {
        return e3 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React11.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React11.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React11.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React11.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React11.createElement(
    React11.Fragment,
    null,
    inert ? React11.createElement(Style2, { styles: generateStyle(id) }) : null,
    removeScrollBar ? React11.createElement(RemoveScrollBar, { gapMode: "margin" }) : null
  );
}

// ../../node_modules/react-remove-scroll/dist/es2015/sidecar.js
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

// ../../node_modules/react-remove-scroll/dist/es2015/Combination.js
var ReactRemoveScroll = React12.forwardRef(function(props, ref) {
  return React12.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll;

// ../../node_modules/@radix-ui/react-popover/dist/index.module.js
var $cb5cc270b50c6fcd$var$POPOVER_NAME = "Popover";
var [$cb5cc270b50c6fcd$var$createPopoverContext, $cb5cc270b50c6fcd$export$c8393c9e73286932] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cb5cc270b50c6fcd$var$POPOVER_NAME, [
  $cf1ac5d9fe0e8206$export$722aac194ae923
]);
var $cb5cc270b50c6fcd$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();
var [$cb5cc270b50c6fcd$var$PopoverProvider, $cb5cc270b50c6fcd$var$usePopoverContext] = $cb5cc270b50c6fcd$var$createPopoverContext($cb5cc270b50c6fcd$var$POPOVER_NAME);
var $cb5cc270b50c6fcd$export$5b6b19405a83ff9d = (props) => {
  const { __scopePopover, children, open: openProp, defaultOpen, onOpenChange, modal = false } = props;
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  const triggerRef = (0, import_react30.useRef)(null);
  const [hasCustomAnchor, setHasCustomAnchor] = (0, import_react30.useState)(false);
  const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ (0, import_react30.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /* @__PURE__ */ (0, import_react30.createElement)($cb5cc270b50c6fcd$var$PopoverProvider, {
    scope: __scopePopover,
    contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
    triggerRef,
    open,
    onOpenChange: setOpen,
    onOpenToggle: (0, import_react30.useCallback)(
      () => setOpen(
        (prevOpen) => !prevOpen
      ),
      [
        setOpen
      ]
    ),
    hasCustomAnchor,
    onCustomAnchorAdd: (0, import_react30.useCallback)(
      () => setHasCustomAnchor(true),
      []
    ),
    onCustomAnchorRemove: (0, import_react30.useCallback)(
      () => setHasCustomAnchor(false),
      []
    ),
    modal
  }, children));
};
var $cb5cc270b50c6fcd$var$TRIGGER_NAME = "PopoverTrigger";
var $cb5cc270b50c6fcd$export$7dacb05d26466c3 = /* @__PURE__ */ (0, import_react30.forwardRef)((props, forwardedRef) => {
  const { __scopePopover, ...triggerProps } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$TRIGGER_NAME, __scopePopover);
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  const composedTriggerRef = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.triggerRef);
  const trigger = /* @__PURE__ */ (0, import_react30.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": context.open,
    "aria-controls": context.contentId,
    "data-state": $cb5cc270b50c6fcd$var$getState(context.open)
  }, triggerProps, {
    ref: composedTriggerRef,
    onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, context.onOpenToggle)
  }));
  return context.hasCustomAnchor ? trigger : /* @__PURE__ */ (0, import_react30.createElement)($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({
    asChild: true
  }, popperScope), trigger);
});
var $cb5cc270b50c6fcd$var$PORTAL_NAME = "PopoverPortal";
var [$cb5cc270b50c6fcd$var$PortalProvider, $cb5cc270b50c6fcd$var$usePortalContext] = $cb5cc270b50c6fcd$var$createPopoverContext($cb5cc270b50c6fcd$var$PORTAL_NAME, {
  forceMount: void 0
});
var $cb5cc270b50c6fcd$export$dd679ffb4362d2d4 = (props) => {
  const { __scopePopover, forceMount, children, container } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$PORTAL_NAME, __scopePopover);
  return /* @__PURE__ */ (0, import_react30.createElement)($cb5cc270b50c6fcd$var$PortalProvider, {
    scope: __scopePopover,
    forceMount
  }, /* @__PURE__ */ (0, import_react30.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, /* @__PURE__ */ (0, import_react30.createElement)($f1701beae083dbae$export$602eac185826482c, {
    asChild: true,
    container
  }, children)));
};
var $cb5cc270b50c6fcd$var$CONTENT_NAME = "PopoverContent";
var $cb5cc270b50c6fcd$export$d7e1f420b25549ff = /* @__PURE__ */ (0, import_react30.forwardRef)((props, forwardedRef) => {
  const portalContext = $cb5cc270b50c6fcd$var$usePortalContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  const { forceMount = portalContext.forceMount, ...contentProps } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  return /* @__PURE__ */ (0, import_react30.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
    present: forceMount || context.open
  }, context.modal ? /* @__PURE__ */ (0, import_react30.createElement)($cb5cc270b50c6fcd$var$PopoverContentModal, _extends({}, contentProps, {
    ref: forwardedRef
  })) : /* @__PURE__ */ (0, import_react30.createElement)($cb5cc270b50c6fcd$var$PopoverContentNonModal, _extends({}, contentProps, {
    ref: forwardedRef
  })));
});
var $cb5cc270b50c6fcd$var$PopoverContentModal = /* @__PURE__ */ (0, import_react30.forwardRef)((props, forwardedRef) => {
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  const contentRef = (0, import_react30.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef);
  const isRightClickOutsideRef = (0, import_react30.useRef)(false);
  (0, import_react30.useEffect)(() => {
    const content = contentRef.current;
    if (content)
      return hideOthers(content);
  }, []);
  return /* @__PURE__ */ (0, import_react30.createElement)(Combination_default, {
    as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
    allowPinchZoom: true
  }, /* @__PURE__ */ (0, import_react30.createElement)($cb5cc270b50c6fcd$var$PopoverContentImpl, _extends({}, props, {
    ref: composedRefs,
    trapFocus: context.open,
    disableOutsidePointerEvents: true,
    onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {
      var _context$triggerRef$c;
      event.preventDefault();
      if (!isRightClickOutsideRef.current)
        (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();
    }),
    onPointerDownOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownOutside, (event) => {
      const originalEvent = event.detail.originalEvent;
      const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
      const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
      isRightClickOutsideRef.current = isRightClick;
    }, {
      checkForDefaultPrevented: false
    }),
    onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocusOutside,
      (event) => event.preventDefault(),
      {
        checkForDefaultPrevented: false
      }
    )
  })));
});
var $cb5cc270b50c6fcd$var$PopoverContentNonModal = /* @__PURE__ */ (0, import_react30.forwardRef)((props, forwardedRef) => {
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
  const hasInteractedOutsideRef = (0, import_react30.useRef)(false);
  return /* @__PURE__ */ (0, import_react30.createElement)($cb5cc270b50c6fcd$var$PopoverContentImpl, _extends({}, props, {
    ref: forwardedRef,
    trapFocus: false,
    disableOutsidePointerEvents: false,
    onCloseAutoFocus: (event) => {
      var _props$onCloseAutoFoc;
      (_props$onCloseAutoFoc = props.onCloseAutoFocus) === null || _props$onCloseAutoFoc === void 0 || _props$onCloseAutoFoc.call(props, event);
      if (!event.defaultPrevented) {
        var _context$triggerRef$c2;
        if (!hasInteractedOutsideRef.current)
          (_context$triggerRef$c2 = context.triggerRef.current) === null || _context$triggerRef$c2 === void 0 || _context$triggerRef$c2.focus();
        event.preventDefault();
      }
      hasInteractedOutsideRef.current = false;
    },
    onInteractOutside: (event) => {
      var _props$onInteractOuts, _context$triggerRef$c3;
      (_props$onInteractOuts = props.onInteractOutside) === null || _props$onInteractOuts === void 0 || _props$onInteractOuts.call(props, event);
      if (!event.defaultPrevented)
        hasInteractedOutsideRef.current = true;
      const target = event.target;
      const targetIsTrigger = (_context$triggerRef$c3 = context.triggerRef.current) === null || _context$triggerRef$c3 === void 0 ? void 0 : _context$triggerRef$c3.contains(target);
      if (targetIsTrigger)
        event.preventDefault();
    }
  }));
});
var $cb5cc270b50c6fcd$var$PopoverContentImpl = /* @__PURE__ */ (0, import_react30.forwardRef)((props, forwardedRef) => {
  const { __scopePopover, trapFocus, onOpenAutoFocus, onCloseAutoFocus, disableOutsidePointerEvents, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, ...contentProps } = props;
  const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, __scopePopover);
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();
  return /* @__PURE__ */ (0, import_react30.createElement)($d3863c46a17e8a28$export$20e40289641fbbb6, {
    asChild: true,
    loop: true,
    trapped: trapFocus,
    onMountAutoFocus: onOpenAutoFocus,
    onUnmountAutoFocus: onCloseAutoFocus
  }, /* @__PURE__ */ (0, import_react30.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f22, {
    asChild: true,
    disableOutsidePointerEvents,
    onInteractOutside,
    onEscapeKeyDown,
    onPointerDownOutside,
    onFocusOutside,
    onDismiss: () => context.onOpenChange(false)
  }, /* @__PURE__ */ (0, import_react30.createElement)($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends({
    "data-state": $cb5cc270b50c6fcd$var$getState(context.open),
    role: "dialog",
    id: context.contentId
  }, popperScope, contentProps, {
    ref: forwardedRef,
    style: {
      ...contentProps.style,
      // re-namespace exposed content custom property
      ["--radix-popover-content-transform-origin"]: "var(--radix-popper-transform-origin)"
    }
  }))));
});
var $cb5cc270b50c6fcd$export$3152841115e061b2 = /* @__PURE__ */ (0, import_react30.forwardRef)((props, forwardedRef) => {
  const { __scopePopover, ...arrowProps } = props;
  const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
  return /* @__PURE__ */ (0, import_react30.createElement)($cf1ac5d9fe0e8206$export$21b07c8f274aebd5, _extends({}, popperScope, arrowProps, {
    ref: forwardedRef
  }));
});
function $cb5cc270b50c6fcd$var$getState(open) {
  return open ? "open" : "closed";
}
var $cb5cc270b50c6fcd$export$be92b6f5f03c0fe9 = $cb5cc270b50c6fcd$export$5b6b19405a83ff9d;
var $cb5cc270b50c6fcd$export$41fb9f06171c75f4 = $cb5cc270b50c6fcd$export$7dacb05d26466c3;
var $cb5cc270b50c6fcd$export$602eac185826482c = $cb5cc270b50c6fcd$export$dd679ffb4362d2d4;
var $cb5cc270b50c6fcd$export$7c6e2c02157bb7d2 = $cb5cc270b50c6fcd$export$d7e1f420b25549ff;
var $cb5cc270b50c6fcd$export$21b07c8f274aebd5 = $cb5cc270b50c6fcd$export$3152841115e061b2;

// components/ColorPicker/ColorPicker.tsx
var import_react39 = __toESM(require_react(), 1);

// components/ColorPicker/ColorInput.tsx
init_define_import_meta_env();
var import_react36 = __toESM(require_react(), 1);

// components/EyeDropper.tsx
init_define_import_meta_env();
var import_react35 = __toESM(require_react(), 1);
var import_react_dom5 = __toESM(require_react_dom(), 1);

// context/ui-appState.ts
init_define_import_meta_env();
var import_react31 = __toESM(require_react(), 1);
var UIAppStateContext = import_react31.default.createContext(null);
var useUIAppState = () => import_react31.default.useContext(UIAppStateContext);

// hooks/useCreatePortalContainer.ts
init_define_import_meta_env();
var import_react32 = __toESM(require_react(), 1);
var useCreatePortalContainer = (opts) => {
  const [div, setDiv] = (0, import_react32.useState)(null);
  const device = useDevice();
  const { theme } = useUIAppState();
  const { container: excalidrawContainer } = useExcalidrawContainer();
  (0, import_react32.useLayoutEffect)(() => {
    if (div) {
      div.className = "";
      div.classList.add("excalidraw", ...opts?.className?.split(/\s+/) || []);
      div.classList.toggle("excalidraw--mobile", device.editor.isMobile);
      div.classList.toggle("theme--dark", theme === THEME.DARK);
    }
  }, [div, theme, device.editor.isMobile, opts?.className]);
  (0, import_react32.useLayoutEffect)(() => {
    const container = opts?.parentSelector ? excalidrawContainer?.querySelector(opts.parentSelector) : document.body;
    if (!container) {
      return;
    }
    const div2 = document.createElement("div");
    container.appendChild(div2);
    setDiv(div2);
    return () => {
      container.removeChild(div2);
    };
  }, [excalidrawContainer, opts?.parentSelector]);
  return div;
};

// hooks/useOutsideClick.ts
init_define_import_meta_env();
var import_react33 = __toESM(require_react(), 1);
function useOutsideClick(ref, callback, isInside) {
  (0, import_react33.useEffect)(() => {
    function onOutsideClick(event) {
      const _event = event;
      if (!ref.current) {
        return;
      }
      const isInsideOverride = isInside?.(_event, ref.current);
      if (isInsideOverride === true) {
        return;
      } else if (isInsideOverride === false) {
        return callback(_event);
      }
      if (ref.current.contains(_event.target) || // target is detached from DOM (happens when the element is removed
      // on a pointerup event fired *before* this handler's pointerup is
      // dispatched)
      !document.documentElement.contains(_event.target)) {
        return;
      }
      const isClickOnRadixPortal = _event.target.closest("[data-radix-portal]") || // when radix popup is in "modal" mode, it disables pointer events on
      // the `body` element, so the target element is going to be the `html`
      // (note: this won't work if we selectively re-enable pointer events on
      // specific elements as we do with navbar or excalidraw UI elements)
      _event.target === document.documentElement && document.body.style.pointerEvents === "none";
      if (isClickOnRadixPortal) {
        return;
      }
      if (_event.target.closest("[data-prevent-outside-click]")) {
        return;
      }
      callback(_event);
    }
    document.addEventListener("pointerdown" /* POINTER_DOWN */, onOutsideClick);
    document.addEventListener("touchstart" /* TOUCH_START */, onOutsideClick);
    return () => {
      document.removeEventListener("pointerdown" /* POINTER_DOWN */, onOutsideClick);
      document.removeEventListener("touchstart" /* TOUCH_START */, onOutsideClick);
    };
  }, [ref, callback, isInside]);
}

// hooks/useStable.ts
init_define_import_meta_env();
var import_react34 = __toESM(require_react(), 1);
var useStable = (value) => {
  const ref = (0, import_react34.useRef)(value);
  Object.assign(ref.current, value);
  return ref.current;
};

// components/EyeDropper.tsx
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var activeEyeDropperAtom = atom2(null);
var EyeDropper = ({ onCancel, onChange, onSelect, colorPickerType }) => {
  const eyeDropperContainer = useCreatePortalContainer({
    className: "excalidraw-eye-dropper-backdrop",
    parentSelector: ".excalidraw-eye-dropper-container"
  });
  const appState = useUIAppState();
  const elements = useExcalidrawElements();
  const app = useApp();
  const selectedElements = getSelectedElements(elements, appState);
  const stableProps = useStable({
    app,
    onCancel,
    onChange,
    onSelect,
    selectedElements
  });
  const { container: excalidrawContainer } = useExcalidrawContainer();
  (0, import_react35.useEffect)(() => {
    const colorPreviewDiv = ref.current;
    if (!colorPreviewDiv || !app.canvas || !eyeDropperContainer) {
      return;
    }
    let isHoldingPointerDown = false;
    const ctx = app.canvas.getContext("2d");
    const getCurrentColor = ({
      clientX,
      clientY
    }) => {
      const pixel = ctx.getImageData(
        (clientX - appState.offsetLeft) * window.devicePixelRatio,
        (clientY - appState.offsetTop) * window.devicePixelRatio,
        1,
        1
      ).data;
      return rgbToHex(pixel[0], pixel[1], pixel[2]);
    };
    const mouseMoveListener = ({
      clientX,
      clientY,
      altKey
    }) => {
      colorPreviewDiv.style.top = `${clientY + 20}px`;
      colorPreviewDiv.style.left = `${clientX + 20}px`;
      const currentColor = getCurrentColor({ clientX, clientY });
      if (isHoldingPointerDown) {
        stableProps.onChange(
          colorPickerType,
          currentColor,
          stableProps.selectedElements,
          { altKey }
        );
      }
      colorPreviewDiv.style.background = currentColor;
    };
    const onCancel2 = () => {
      stableProps.onCancel();
    };
    const onSelect2 = (color, event) => {
      stableProps.onSelect(color, event);
    };
    const pointerDownListener = (event) => {
      isHoldingPointerDown = true;
      event.stopImmediatePropagation();
    };
    const pointerUpListener = (event) => {
      isHoldingPointerDown = false;
      excalidrawContainer?.focus();
      event.stopImmediatePropagation();
      event.preventDefault();
      onSelect2(getCurrentColor(event), event);
    };
    const keyDownListener = (event) => {
      if (event.key === KEYS.ESCAPE) {
        event.preventDefault();
        event.stopImmediatePropagation();
        onCancel2();
      }
    };
    eyeDropperContainer.tabIndex = -1;
    eyeDropperContainer.focus();
    mouseMoveListener({
      clientX: stableProps.app.lastViewportPosition.x,
      clientY: stableProps.app.lastViewportPosition.y,
      altKey: false
    });
    eyeDropperContainer.addEventListener("keydown" /* KEYDOWN */, keyDownListener);
    eyeDropperContainer.addEventListener(
      "pointerdown" /* POINTER_DOWN */,
      pointerDownListener
    );
    eyeDropperContainer.addEventListener("pointerup" /* POINTER_UP */, pointerUpListener);
    window.addEventListener("pointermove", mouseMoveListener, {
      passive: true
    });
    window.addEventListener("blur" /* BLUR */, onCancel2);
    return () => {
      isHoldingPointerDown = false;
      eyeDropperContainer.removeEventListener("keydown" /* KEYDOWN */, keyDownListener);
      eyeDropperContainer.removeEventListener(
        "pointerdown" /* POINTER_DOWN */,
        pointerDownListener
      );
      eyeDropperContainer.removeEventListener(
        "pointerup" /* POINTER_UP */,
        pointerUpListener
      );
      window.removeEventListener("pointermove", mouseMoveListener);
      window.removeEventListener("blur" /* BLUR */, onCancel2);
    };
  }, [
    stableProps,
    app.canvas,
    eyeDropperContainer,
    colorPickerType,
    excalidrawContainer,
    appState.offsetLeft,
    appState.offsetTop
  ]);
  const ref = (0, import_react35.useRef)(null);
  useOutsideClick(
    ref,
    () => {
      onCancel();
    },
    (event) => {
      if (event.target.closest(
        ".excalidraw-eye-dropper-trigger, .excalidraw-eye-dropper-backdrop"
      )) {
        return true;
      }
      return false;
    }
  );
  if (!eyeDropperContainer) {
    return null;
  }
  return (0, import_react_dom5.createPortal)(
    /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("div", { ref, className: "excalidraw-eye-dropper-preview" }),
    eyeDropperContainer
  );
};

// components/ColorPicker/ColorInput.tsx
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var ColorInput = ({
  color,
  onChange,
  label,
  colorPickerType
}) => {
  const device = useDevice();
  const [innerValue, setInnerValue] = (0, import_react36.useState)(color);
  const [activeSection, setActiveColorPickerSection] = useAtom(
    activeColorPickerSectionAtom
  );
  (0, import_react36.useEffect)(() => {
    setInnerValue(color);
  }, [color]);
  const changeColor = (0, import_react36.useCallback)(
    (inputValue) => {
      const value = inputValue.toLowerCase();
      const color2 = getColor(value);
      if (color2) {
        onChange(color2);
      }
      setInnerValue(value);
    },
    [onChange]
  );
  const inputRef = (0, import_react36.useRef)(null);
  const eyeDropperTriggerRef = (0, import_react36.useRef)(null);
  (0, import_react36.useEffect)(() => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  }, [activeSection]);
  const [eyeDropperState, setEyeDropperState] = useAtom(
    activeEyeDropperAtom,
    jotaiScope
  );
  (0, import_react36.useEffect)(() => {
    return () => {
      setEyeDropperState(null);
    };
  }, [setEyeDropperState]);
  return /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("div", { className: "color-picker__input-label", children: [
    /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("div", { className: "color-picker__input-hash", children: "#" }),
    /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
      "input",
      {
        ref: activeSection === "hex" ? inputRef : void 0,
        style: { border: 0, padding: 0 },
        spellCheck: false,
        className: "color-picker-input",
        "aria-label": label,
        onChange: (event) => {
          changeColor(event.target.value);
        },
        value: (innerValue || "").replace(/^#/, ""),
        onBlur: () => {
          setInnerValue(color);
        },
        tabIndex: -1,
        onFocus: () => setActiveColorPickerSection("hex"),
        onKeyDown: (event) => {
          if (event.key === KEYS.TAB) {
            return;
          } else if (event.key === KEYS.ESCAPE) {
            eyeDropperTriggerRef.current?.focus();
          }
          event.stopPropagation();
        }
      }
    ),
    !device.editor.isMobile && /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)(import_jsx_runtime19.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        "div",
        {
          style: {
            width: "1px",
            height: "1.25rem",
            backgroundColor: "var(--default-border-color)"
          }
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        "div",
        {
          ref: eyeDropperTriggerRef,
          className: clsx_m_default("excalidraw-eye-dropper-trigger", {
            selected: eyeDropperState
          }),
          onClick: () => setEyeDropperState(
            (s3) => s3 ? null : {
              keepOpenOnAlt: false,
              onSelect: (color2) => onChange(color2),
              colorPickerType
            }
          ),
          title: `${t(
            "labels.eyeDropper"
          )} \u2014 ${KEYS.I.toLocaleUpperCase()} or ${getShortcutKey("Alt")} `,
          children: eyeDropperIcon
        }
      )
    ] })
  ] });
};

// components/PropertiesPopover.tsx
init_define_import_meta_env();
var import_react38 = __toESM(require_react(), 1);

// components/Island.tsx
init_define_import_meta_env();
var import_react37 = __toESM(require_react(), 1);
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var Island = import_react37.default.forwardRef(
  ({ children, padding, className, style }, ref) => /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
    "div",
    {
      className: clsx_m_default("Island", className),
      style: { "--padding": padding, ...style },
      ref,
      children
    }
  )
);

// components/PropertiesPopover.tsx
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var PropertiesPopover = import_react38.default.forwardRef(
  ({
    className,
    container,
    children,
    style,
    onClose,
    onKeyDown,
    onFocusOutside,
    onPointerLeave,
    onPointerDownOutside
  }, ref) => {
    const device = useDevice();
    return /* @__PURE__ */ (0, import_jsx_runtime21.jsx)($cb5cc270b50c6fcd$export$602eac185826482c, { container, children: /* @__PURE__ */ (0, import_jsx_runtime21.jsxs)(
      $cb5cc270b50c6fcd$export$7c6e2c02157bb7d2,
      {
        ref,
        className: clsx_m_default("focus-visible-none", className),
        "data-prevent-outside-click": true,
        side: device.editor.isMobile && !device.viewport.isLandscape ? "bottom" : "right",
        align: device.editor.isMobile && !device.viewport.isLandscape ? "center" : "start",
        alignOffset: -16,
        sideOffset: 20,
        style: {
          zIndex: "var(--zIndex-popup)"
        },
        onPointerLeave,
        onKeyDown,
        onFocusOutside,
        onPointerDownOutside,
        onCloseAutoFocus: (e3) => {
          e3.stopPropagation();
          e3.preventDefault();
          if (container && !isInteractive(document.activeElement)) {
            container.focus();
          }
          onClose();
        },
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(Island, { padding: 3, style, children }),
          /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
            $cb5cc270b50c6fcd$export$21b07c8f274aebd5,
            {
              width: 20,
              height: 10,
              style: {
                fill: "var(--popup-bg-color)",
                filter: "drop-shadow(rgba(0, 0, 0, 0.05) 0px 3px 2px)"
              }
            }
          )
        ]
      }
    ) });
  }
);

// components/ColorPicker/ColorPicker.tsx
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var isValidColor = (color) => {
  const style = new Option().style;
  style.color = color;
  return !!style.color;
};
var getColor = (color) => {
  if (isTransparent(color)) {
    return color;
  }
  return isValidColor(`#${color}`) ? `#${color}` : isValidColor(color) ? color : null;
};
var ColorPickerPopupContent = ({
  type,
  color,
  onChange,
  label,
  elements,
  palette: palette2 = COLOR_PALETTE,
  updateData
}) => {
  const { container } = useExcalidrawContainer();
  const [, setActiveColorPickerSection] = useAtom(activeColorPickerSectionAtom);
  const [eyeDropperState, setEyeDropperState] = useAtom(
    activeEyeDropperAtom,
    jotaiScope
  );
  const colorInputJSX = /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("div", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(PickerHeading_default, { children: t("colorPicker.hexCode") }),
    /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
      ColorInput,
      {
        color,
        label,
        onChange: (color2) => {
          onChange(color2);
        },
        colorPickerType: type
      }
    )
  ] });
  const popoverRef = (0, import_react39.useRef)(null);
  const focusPickerContent = () => {
    popoverRef.current?.querySelector(".color-picker-content")?.focus();
  };
  return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
    PropertiesPopover,
    {
      container,
      style: { maxWidth: "13rem" },
      onFocusOutside: (event) => {
        focusPickerContent();
        event.preventDefault();
      },
      onPointerDownOutside: (event) => {
        if (eyeDropperState) {
          event.preventDefault();
        }
      },
      onClose: () => {
        updateData({ openPopup: null });
        setActiveColorPickerSection(null);
      },
      children: palette2 ? /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
        Picker,
        {
          palette: palette2,
          color,
          onChange: (changedColor) => {
            onChange(changedColor);
          },
          onEyeDropperToggle: (force) => {
            setEyeDropperState((state) => {
              if (force) {
                state = state || {
                  keepOpenOnAlt: true,
                  onSelect: onChange,
                  colorPickerType: type
                };
                state.keepOpenOnAlt = true;
                return state;
              }
              return force === false || state ? null : {
                keepOpenOnAlt: false,
                onSelect: onChange,
                colorPickerType: type
              };
            });
          },
          onEscape: (event) => {
            if (eyeDropperState) {
              setEyeDropperState(null);
            } else {
              updateData({ openPopup: null });
            }
          },
          label,
          type,
          elements,
          updateData,
          children: colorInputJSX
        }
      ) : colorInputJSX
    }
  );
};
var ColorPickerTrigger = ({
  label,
  color,
  type
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
    $cb5cc270b50c6fcd$export$41fb9f06171c75f4,
    {
      type: "button",
      className: clsx_m_default("color-picker__button active-color properties-trigger", {
        "is-transparent": color === "transparent" || !color
      }),
      "aria-label": label,
      style: color ? { "--swatch-color": color } : void 0,
      title: type === "elementStroke" ? t("labels.showStroke") : t("labels.showBackground"),
      children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("div", { className: "color-picker__button-outline" })
    }
  );
};
var ColorPicker = ({
  type,
  color,
  onChange,
  label,
  elements,
  palette: palette2 = COLOR_PALETTE,
  topPicks,
  updateData,
  appState
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("div", { role: "dialog", "aria-modal": "true", className: "color-picker-container", children: [
    /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
      TopPicks,
      {
        activeColor: color,
        onChange,
        type,
        topPicks
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(ButtonSeparator, {}),
    /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)(
      $cb5cc270b50c6fcd$export$be92b6f5f03c0fe9,
      {
        open: appState.openPopup === type,
        onOpenChange: (open) => {
          updateData({ openPopup: open ? type : null });
        },
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(ColorPickerTrigger, { color, label, type }),
          appState.openPopup === type && /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
            ColorPickerPopupContent,
            {
              type,
              color,
              onChange,
              label,
              elements,
              palette: palette2,
              updateData
            }
          )
        ]
      }
    )
  ] }) });
};

// components/IconPicker.tsx
init_define_import_meta_env();
var import_react41 = __toESM(require_react(), 1);

// components/Popover.tsx
init_define_import_meta_env();
var import_react40 = __toESM(require_react(), 1);
var import_react_dom6 = __toESM(require_react_dom(), 1);
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var Popover = ({
  children,
  left,
  top,
  onCloseRequest,
  fitInViewport = false,
  offsetLeft = 0,
  offsetTop = 0,
  viewportWidth = window.innerWidth,
  viewportHeight = window.innerHeight
}) => {
  const popoverRef = (0, import_react40.useRef)(null);
  (0, import_react40.useEffect)(() => {
    const container = popoverRef.current;
    if (!container) {
      return;
    }
    if (!container.contains(document.activeElement)) {
      container.focus();
    }
    const handleKeyDown = (event) => {
      if (event.key === KEYS.TAB) {
        const focusableElements = queryFocusableElements(container);
        const { activeElement } = document;
        const currentIndex = focusableElements.findIndex(
          (element) => element === activeElement
        );
        if (activeElement === container) {
          if (event.shiftKey) {
            focusableElements[focusableElements.length - 1]?.focus();
          } else {
            focusableElements[0].focus();
          }
          event.preventDefault();
          event.stopImmediatePropagation();
        } else if (currentIndex === 0 && event.shiftKey) {
          focusableElements[focusableElements.length - 1]?.focus();
          event.preventDefault();
          event.stopImmediatePropagation();
        } else if (currentIndex === focusableElements.length - 1 && !event.shiftKey) {
          focusableElements[0]?.focus();
          event.preventDefault();
          event.stopImmediatePropagation();
        }
      }
    };
    container.addEventListener("keydown", handleKeyDown);
    return () => container.removeEventListener("keydown", handleKeyDown);
  }, []);
  const lastInitializedPosRef = (0, import_react40.useRef)(
    null
  );
  (0, import_react40.useLayoutEffect)(() => {
    if (fitInViewport && popoverRef.current && top != null && left != null) {
      const container = popoverRef.current;
      const { width, height } = container.getBoundingClientRect();
      if (lastInitializedPosRef.current?.top === top && lastInitializedPosRef.current?.left === left) {
        return;
      }
      lastInitializedPosRef.current = { top, left };
      if (width >= viewportWidth) {
        container.style.width = `${viewportWidth}px`;
        container.style.left = "0px";
        container.style.overflowX = "scroll";
      } else if (left + width - offsetLeft > viewportWidth) {
        container.style.left = `${viewportWidth - width - 10}px`;
      } else {
        container.style.left = `${left}px`;
      }
      if (height >= viewportHeight) {
        container.style.height = `${viewportHeight - 20}px`;
        container.style.top = "10px";
        container.style.overflowY = "scroll";
      } else if (top + height - offsetTop > viewportHeight) {
        container.style.top = `${viewportHeight - height}px`;
      } else {
        container.style.top = `${top}px`;
      }
    }
  }, [
    top,
    left,
    fitInViewport,
    viewportWidth,
    viewportHeight,
    offsetLeft,
    offsetTop
  ]);
  (0, import_react40.useEffect)(() => {
    if (onCloseRequest) {
      const handler = (event) => {
        if (!popoverRef.current?.contains(event.target)) {
          (0, import_react_dom6.unstable_batchedUpdates)(() => onCloseRequest(event));
        }
      };
      document.addEventListener("pointerdown", handler, false);
      return () => document.removeEventListener("pointerdown", handler, false);
    }
  }, [onCloseRequest]);
  return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { className: "popover", ref: popoverRef, tabIndex: -1, children });
};

// components/IconPicker.tsx
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
function Picker2({
  options,
  value,
  label,
  onChange,
  onClose
}) {
  const rFirstItem = import_react41.default.useRef();
  const rActiveItem = import_react41.default.useRef();
  const rGallery = import_react41.default.useRef(null);
  import_react41.default.useEffect(() => {
    if (rActiveItem.current) {
      rActiveItem.current.focus();
    } else if (rGallery.current) {
      rGallery.current.focus();
    }
  }, []);
  const handleKeyDown = (event) => {
    const pressedOption = options.find(
      (option) => option.keyBinding === event.key.toLowerCase()
    );
    if (!(event.metaKey || event.altKey || event.ctrlKey) && pressedOption) {
      const index2 = options.indexOf(pressedOption);
      rGallery.current.children[index2].focus();
      event.preventDefault();
    } else if (event.key === KEYS.TAB) {
      setTimeout(() => {
        const active = rActiveItem.current;
        const docActive = document.activeElement;
        if (active !== docActive) {
          onClose();
        }
      }, 0);
    } else if (isArrowKey(event.key)) {
      const { activeElement } = document;
      const isRTL = getLanguage().rtl;
      const index2 = Array.prototype.indexOf.call(
        rGallery.current.children,
        activeElement
      );
      if (index2 !== -1) {
        const length = options.length;
        let nextIndex = index2;
        switch (event.key) {
          case (isRTL ? KEYS.ARROW_LEFT : KEYS.ARROW_RIGHT):
          case KEYS.ARROW_DOWN: {
            nextIndex = (index2 + 1) % length;
            break;
          }
          case (isRTL ? KEYS.ARROW_RIGHT : KEYS.ARROW_LEFT):
          case KEYS.ARROW_UP: {
            nextIndex = (length + index2 - 1) % length;
            break;
          }
        }
        rGallery.current.children[nextIndex].focus();
      }
      event.preventDefault();
    } else if (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) {
      event.preventDefault();
      onClose();
    }
    event.nativeEvent.stopImmediatePropagation();
    event.stopPropagation();
  };
  return /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
    "div",
    {
      className: `picker`,
      role: "dialog",
      "aria-modal": "true",
      "aria-label": label,
      onKeyDown: handleKeyDown,
      children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("div", { className: "picker-content", ref: rGallery, children: options.map((option, i3) => /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)(
        "button",
        {
          type: "button",
          className: clsx_m_default("picker-option", {
            active: value === option.value
          }),
          onClick: (event) => {
            event.currentTarget.focus();
            onChange(option.value);
          },
          title: `${option.text} ${option.keyBinding && `\u2014 ${option.keyBinding.toUpperCase()}`}`,
          "aria-label": option.text || "none",
          "aria-keyshortcuts": option.keyBinding || void 0,
          ref: (el) => {
            if (el && i3 === 0) {
              rFirstItem.current = el;
            }
            if (el && option.value === value) {
              rActiveItem.current = el;
            }
          },
          onFocus: () => {
            onChange(option.value);
          },
          children: [
            option.icon,
            option.keyBinding && /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("span", { className: "picker-keybinding", children: option.keyBinding })
          ]
        },
        option.text
      )) })
    }
  );
}
function IconPicker({
  value,
  label,
  options,
  onChange,
  group = ""
}) {
  const [isActive, setActive] = import_react41.default.useState(false);
  const rPickerButton = import_react41.default.useRef(null);
  const isRTL = getLanguage().rtl;
  return /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)("div", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
      "button",
      {
        name: group,
        type: "button",
        className: isActive ? "active" : "",
        "aria-label": label,
        onClick: () => setActive(!isActive),
        ref: rPickerButton,
        children: options.find((option) => option.value === value)?.icon
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(import_react41.default.Suspense, { fallback: "", children: isActive ? /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
        Popover,
        {
          onCloseRequest: (event) => event.target !== rPickerButton.current && setActive(false),
          ...isRTL ? { right: 5.5 } : { left: -5.5 },
          children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
            Picker2,
            {
              options: options.filter((opt) => opt.showInPicker !== false),
              value,
              label,
              onChange,
              onClose: () => {
                setActive(false);
                rPickerButton.current?.focus();
              }
            }
          )
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("div", { className: "picker-triangle" })
    ] }) : null })
  ] });
}

// components/FontPicker/FontPicker.tsx
init_define_import_meta_env();
var import_react48 = __toESM(require_react(), 1);

// components/FontPicker/FontPickerList.tsx
init_define_import_meta_env();
var import_react46 = __toESM(require_react(), 1);

// components/QuickSearch.tsx
init_define_import_meta_env();
var import_react42 = __toESM(require_react(), 1);
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var QuickSearch = import_react42.default.forwardRef(
  ({ className, placeholder, onChange }, ref) => {
    return /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)("div", { className: clsx_m_default("QuickSearch__wrapper", className), children: [
      searchIcon,
      /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
        "input",
        {
          ref,
          className: "QuickSearch__input",
          type: "text",
          placeholder,
          onChange: (e3) => onChange(e3.target.value.trim().toLowerCase())
        }
      )
    ] });
  }
);

// components/ScrollableList.tsx
init_define_import_meta_env();
var import_react43 = __toESM(require_react(), 1);
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var ScrollableList = ({
  className,
  placeholder,
  children
}) => {
  const isEmpty = !import_react43.Children.count(children);
  return /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("div", { className: clsx_m_default("ScrollableList__wrapper", className), role: "menu", children: isEmpty ? /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("div", { className: "empty", children: placeholder }) : children });
};

// components/dropdownMenu/DropdownMenuGroup.tsx
init_define_import_meta_env();
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var MenuGroup = ({
  children,
  className = "",
  style,
  title
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)("div", { className: `dropdown-menu-group ${className}`, style, children: [
    title && /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("p", { className: "dropdown-menu-group-title", children: title }),
    children
  ] });
};
var DropdownMenuGroup_default = MenuGroup;
MenuGroup.displayName = "DropdownMenuGroup";

// components/dropdownMenu/DropdownMenuItem.tsx
init_define_import_meta_env();
var import_react45 = __toESM(require_react(), 1);

// components/dropdownMenu/common.ts
init_define_import_meta_env();
var import_react44 = __toESM(require_react(), 1);
var DropdownMenuContentPropsContext = import_react44.default.createContext({});
var getDropdownMenuItemClassName = (className = "", selected = false, hovered = false) => {
  return `dropdown-menu-item dropdown-menu-item-base ${className}
  ${selected ? "dropdown-menu-item--selected" : ""} ${hovered ? "dropdown-menu-item--hovered" : ""}`.trim();
};
var useHandleDropdownMenuItemClick = (origOnClick, onSelect) => {
  const DropdownMenuContentProps = (0, import_react44.useContext)(DropdownMenuContentPropsContext);
  return composeEventHandlers(origOnClick, (event) => {
    const itemSelectEvent = new CustomEvent("menu.itemSelect" /* MENU_ITEM_SELECT */, {
      bubbles: true,
      cancelable: true
    });
    onSelect?.(itemSelectEvent);
    if (!itemSelectEvent.defaultPrevented) {
      DropdownMenuContentProps.onSelect?.(itemSelectEvent);
    }
  });
};

// components/dropdownMenu/DropdownMenuItemContent.tsx
init_define_import_meta_env();
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var MenuItemContent = ({
  textStyle,
  icon,
  shortcut,
  children
}) => {
  const device = useDevice();
  return /* @__PURE__ */ (0, import_jsx_runtime28.jsxs)(import_jsx_runtime28.Fragment, { children: [
    icon && /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("div", { className: "dropdown-menu-item__icon", children: icon }),
    /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("div", { style: textStyle, className: "dropdown-menu-item__text", children }),
    shortcut && !device.editor.isMobile && /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("div", { className: "dropdown-menu-item__shortcut", children: shortcut })
  ] });
};
var DropdownMenuItemContent_default = MenuItemContent;

// components/dropdownMenu/DropdownMenuItem.tsx
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var DropdownMenuItem = ({
  icon,
  value,
  order,
  children,
  shortcut,
  className,
  hovered,
  selected,
  textStyle,
  onSelect,
  onClick,
  ...rest
}) => {
  const handleClick = useHandleDropdownMenuItemClick(onClick, onSelect);
  const ref = (0, import_react45.useRef)(null);
  (0, import_react45.useEffect)(() => {
    if (hovered) {
      if (order === 0) {
        ref.current?.scrollIntoView({ block: "end" });
      } else {
        ref.current?.scrollIntoView({ block: "nearest" });
      }
    }
  }, [hovered, order]);
  return /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
    "button",
    {
      ...rest,
      ref,
      value,
      onClick: handleClick,
      className: getDropdownMenuItemClassName(className, selected, hovered),
      title: rest.title ?? rest["aria-label"],
      children: /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(DropdownMenuItemContent_default, { textStyle, icon, shortcut, children })
    }
  );
};
DropdownMenuItem.displayName = "DropdownMenuItem";
var DropDownMenuItemBadgeType = {
  GREEN: "green",
  RED: "red",
  BLUE: "blue"
};
var DropDownMenuItemBadge = ({
  type = DropDownMenuItemBadgeType.BLUE,
  children
}) => {
  const { theme } = useExcalidrawAppState();
  const style = {
    display: "inline-flex",
    marginLeft: "auto",
    padding: "2px 4px",
    borderRadius: 6,
    fontSize: 9,
    fontFamily: "Cascadia, monospace",
    border: theme === THEME.LIGHT ? "1.5px solid white" : "none"
  };
  switch (type) {
    case DropDownMenuItemBadgeType.GREEN:
      Object.assign(style, {
        backgroundColor: "var(--background-color-badge)",
        color: "var(--color-badge)"
      });
      break;
    case DropDownMenuItemBadgeType.RED:
      Object.assign(style, {
        backgroundColor: "pink",
        color: "darkred"
      });
      break;
    case DropDownMenuItemBadgeType.BLUE:
    default:
      Object.assign(style, {
        background: "var(--color-promo)",
        color: "var(--color-surface-lowest)"
      });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("div", { className: "DropDownMenuItemBadge", style, children });
};
DropDownMenuItemBadge.displayName = "DropdownMenuItemBadge";
DropdownMenuItem.Badge = DropDownMenuItemBadge;
var DropdownMenuItem_default = DropdownMenuItem;

// components/FontPicker/keyboardNavHandlers.ts
init_define_import_meta_env();
var fontPickerKeyHandler = ({
  event,
  inputRef,
  hoveredFont,
  filteredFonts,
  onClose,
  onSelect,
  onHover
}) => {
  if (!event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key.toLowerCase() === KEYS.F) {
    inputRef.current?.focus();
    return true;
  }
  if (event.key === KEYS.ESCAPE) {
    onClose();
    return true;
  }
  if (event.key === KEYS.ENTER) {
    if (hoveredFont?.value) {
      onSelect(hoveredFont.value);
    }
    return true;
  }
  if (event.key === KEYS.ARROW_DOWN) {
    if (hoveredFont?.next) {
      onHover(hoveredFont.next.value);
    } else if (filteredFonts[0]?.value) {
      onHover(filteredFonts[0].value);
    }
    return true;
  }
  if (event.key === KEYS.ARROW_UP) {
    if (hoveredFont?.prev) {
      onHover(hoveredFont.prev.value);
    } else if (filteredFonts[filteredFonts.length - 1]?.value) {
      onHover(filteredFonts[filteredFonts.length - 1].value);
    }
    return true;
  }
};

// components/FontPicker/FontPickerList.tsx
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
var FontPickerList = import_react46.default.memo(
  ({
    selectedFontFamily,
    hoveredFontFamily,
    onSelect,
    onHover,
    onLeave,
    onOpen,
    onClose
  }) => {
    const { container } = useExcalidrawContainer();
    const { fonts } = useApp();
    const { showDeprecatedFonts } = useAppProps();
    const [searchTerm, setSearchTerm] = (0, import_react46.useState)("");
    const inputRef = (0, import_react46.useRef)(null);
    const allFonts = (0, import_react46.useMemo)(
      () => Array.from(Fonts.registered.entries()).filter(([_, { metadata }]) => !metadata.serverSide).map(([familyId, { metadata, fonts: fonts2 }]) => {
        const fontDescriptor = {
          value: familyId,
          icon: metadata.icon,
          text: fonts2[0].fontFace.family
        };
        if (metadata.deprecated) {
          Object.assign(fontDescriptor, {
            deprecated: metadata.deprecated,
            badge: {
              type: DropDownMenuItemBadgeType.RED,
              placeholder: t("fontList.badge.old")
            }
          });
        }
        return fontDescriptor;
      }).sort(
        (a3, b3) => a3.text.toLowerCase() > b3.text.toLowerCase() ? 1 : -1
      ),
      []
    );
    const sceneFamilies = (0, import_react46.useMemo)(
      () => new Set(fonts.getSceneFontFamilies()),
      // cache per selected font family, so hover re-render won't mess it up
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [selectedFontFamily]
    );
    const sceneFonts = (0, import_react46.useMemo)(
      () => allFonts.filter((font) => sceneFamilies.has(font.value)),
      // always show all the fonts in the scene, even those that were deprecated
      [allFonts, sceneFamilies]
    );
    const availableFonts = (0, import_react46.useMemo)(
      () => allFonts.filter(
        (font) => !sceneFamilies.has(font.value) && (showDeprecatedFonts || !font.deprecated)
        // skip deprecated fonts
      ),
      [allFonts, sceneFamilies, showDeprecatedFonts]
    );
    const filteredFonts = (0, import_react46.useMemo)(
      () => arrayToList(
        [...sceneFonts, ...availableFonts].filter(
          (font) => font.text?.toLowerCase().includes(searchTerm)
        )
      ),
      [sceneFonts, availableFonts, searchTerm]
    );
    const hoveredFont = (0, import_react46.useMemo)(() => {
      let font;
      if (hoveredFontFamily) {
        font = filteredFonts.find((font2) => font2.value === hoveredFontFamily);
      } else if (selectedFontFamily) {
        font = filteredFonts.find((font2) => font2.value === selectedFontFamily);
      }
      if (!font && searchTerm) {
        if (filteredFonts[0]?.value) {
          onHover(filteredFonts[0].value);
        } else {
          onLeave();
        }
      }
      return font;
    }, [
      hoveredFontFamily,
      selectedFontFamily,
      searchTerm,
      filteredFonts,
      onHover,
      onLeave
    ]);
    const onKeyDown = (0, import_react46.useCallback)(
      (event) => {
        const handled = fontPickerKeyHandler({
          event,
          inputRef,
          hoveredFont,
          filteredFonts,
          onSelect,
          onHover,
          onClose
        });
        if (handled) {
          event.preventDefault();
          event.stopPropagation();
        }
      },
      [hoveredFont, filteredFonts, onSelect, onHover, onClose]
    );
    (0, import_react46.useEffect)(() => {
      onOpen();
      return () => {
        onClose();
      };
    }, []);
    const sceneFilteredFonts = (0, import_react46.useMemo)(
      () => filteredFonts.filter((font) => sceneFamilies.has(font.value)),
      [filteredFonts, sceneFamilies]
    );
    const availableFilteredFonts = (0, import_react46.useMemo)(
      () => filteredFonts.filter((font) => !sceneFamilies.has(font.value)),
      [filteredFonts, sceneFamilies]
    );
    const renderFont = (font, index2) => /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)(
      DropdownMenuItem_default,
      {
        icon: font.icon,
        value: font.value,
        order: index2,
        textStyle: {
          fontFamily: getFontFamilyString({ fontFamily: font.value })
        },
        hovered: font.value === hoveredFont?.value,
        selected: font.value === selectedFontFamily,
        tabIndex: font.value === selectedFontFamily ? 0 : -1,
        onClick: (e3) => {
          onSelect(Number(e3.currentTarget.value));
        },
        onMouseMove: () => {
          if (hoveredFont?.value !== font.value) {
            onHover(font.value);
          }
        },
        children: [
          font.text,
          font.badge && /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(DropDownMenuItemBadge, { type: font.badge.type, children: font.badge.placeholder })
        ]
      },
      font.value
    );
    const groups = [];
    if (sceneFilteredFonts.length) {
      groups.push(
        /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(DropdownMenuGroup_default, { title: t("fontList.sceneFonts"), children: sceneFilteredFonts.map(renderFont) }, "group_1")
      );
    }
    if (availableFilteredFonts.length) {
      groups.push(
        /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(DropdownMenuGroup_default, { title: t("fontList.availableFonts"), children: availableFilteredFonts.map(
          (font, index2) => renderFont(font, index2 + sceneFilteredFonts.length)
        ) }, "group_2")
      );
    }
    return /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)(
      PropertiesPopover,
      {
        className: "properties-content",
        container,
        style: { width: "15rem" },
        onClose,
        onPointerLeave: onLeave,
        onKeyDown,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
            QuickSearch,
            {
              ref: inputRef,
              placeholder: t("quickSearch.placeholder"),
              onChange: debounce(setSearchTerm, 20)
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
            ScrollableList,
            {
              className: "dropdown-menu fonts manual-hover",
              placeholder: t("fontList.empty"),
              children: groups.length ? groups : null
            }
          )
        ]
      }
    );
  },
  (prev, next) => prev.selectedFontFamily === next.selectedFontFamily && prev.hoveredFontFamily === next.hoveredFontFamily
);

// components/FontPicker/FontPickerTrigger.tsx
init_define_import_meta_env();
var import_react47 = __toESM(require_react(), 1);
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var FontPickerTrigger = ({
  selectedFontFamily
}) => {
  const isTriggerActive = (0, import_react47.useMemo)(
    () => Boolean(selectedFontFamily && !isDefaultFont(selectedFontFamily)),
    [selectedFontFamily]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)($cb5cc270b50c6fcd$export$41fb9f06171c75f4, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
    ButtonIcon,
    {
      standalone: true,
      icon: TextIcon,
      title: t("labels.showFonts"),
      className: "properties-trigger",
      testId: "font-family-show-fonts",
      active: isTriggerActive,
      onClick: () => {
      }
    }
  ) }) });
};

// components/FontPicker/FontPicker.tsx
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var DEFAULT_FONTS = [
  {
    value: FONT_FAMILY.Excalifont,
    icon: FreedrawIcon,
    text: t("labels.handDrawn"),
    testId: "font-family-handrawn"
  },
  {
    value: FONT_FAMILY.Nunito,
    icon: FontFamilyNormalIcon,
    text: t("labels.normal"),
    testId: "font-family-normal"
  },
  {
    value: FONT_FAMILY["Comic Shanns"],
    icon: FontFamilyCodeIcon,
    text: t("labels.code"),
    testId: "font-family-code"
  }
];
var defaultFontFamilies = new Set(DEFAULT_FONTS.map((x3) => x3.value));
var isDefaultFont = (fontFamily) => {
  if (!fontFamily) {
    return false;
  }
  return defaultFontFamilies.has(fontFamily);
};
var FontPicker = import_react48.default.memo(
  ({
    isOpened,
    selectedFontFamily,
    hoveredFontFamily,
    onSelect,
    onHover,
    onLeave,
    onPopupChange
  }) => {
    const defaultFonts = (0, import_react48.useMemo)(() => DEFAULT_FONTS, []);
    const onSelectCallback = (0, import_react48.useCallback)(
      (value) => {
        if (value) {
          onSelect(value);
        }
      },
      [onSelect]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)("div", { role: "dialog", "aria-modal": "true", className: "FontPicker__container", children: [
      /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
        ButtonIconSelect,
        {
          type: "button",
          options: defaultFonts,
          value: selectedFontFamily,
          onClick: onSelectCallback
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(ButtonSeparator, {}),
      /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)($cb5cc270b50c6fcd$export$be92b6f5f03c0fe9, { open: isOpened, onOpenChange: onPopupChange, children: [
        /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(FontPickerTrigger, { selectedFontFamily }),
        isOpened && /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
          FontPickerList,
          {
            selectedFontFamily,
            hoveredFontFamily,
            onSelect: onSelectCallback,
            onHover,
            onLeave,
            onOpen: () => onPopupChange(true),
            onClose: () => onPopupChange(false)
          }
        )
      ] })
    ] });
  },
  (prev, next) => prev.isOpened === next.isOpened && prev.selectedFontFamily === next.selectedFontFamily && prev.hoveredFontFamily === next.hoveredFontFamily
);

// actions/actionProperties.tsx
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
var FONT_SIZE_RELATIVE_INCREASE_STEP = 0.1;
var changeProperty = (elements, appState, callback, includeBoundText = false) => {
  const selectedElementIds = arrayToMap(
    getSelectedElements(elements, appState, {
      includeBoundTextElement: includeBoundText
    })
  );
  return elements.map((element) => {
    if (selectedElementIds.get(element.id) || element.id === appState.editingTextElement?.id) {
      return callback(element);
    }
    return element;
  });
};
var getFormValue = function(elements, appState, getAttribute, isRelevantElement, defaultValue) {
  const editingTextElement = appState.editingTextElement;
  const nonDeletedElements = getNonDeletedElements(elements);
  let ret = null;
  if (editingTextElement) {
    ret = getAttribute(editingTextElement);
  }
  if (!ret) {
    const hasSelection = isSomeElementSelected(nonDeletedElements, appState);
    if (hasSelection) {
      ret = getCommonAttributeOfSelectedElements(
        isRelevantElement === true ? nonDeletedElements : nonDeletedElements.filter((el) => isRelevantElement(el)),
        appState,
        getAttribute
      ) ?? (typeof defaultValue === "function" ? defaultValue(true) : defaultValue);
    } else {
      ret = typeof defaultValue === "function" ? defaultValue(false) : defaultValue;
    }
  }
  return ret;
};
var offsetElementAfterFontResize = (prevElement, nextElement) => {
  if (isBoundToContainer(nextElement) || !nextElement.autoResize) {
    return nextElement;
  }
  return mutateElement(
    nextElement,
    {
      x: prevElement.textAlign === "left" ? prevElement.x : prevElement.x + (prevElement.width - nextElement.width) / (prevElement.textAlign === "center" ? 2 : 1),
      // centering vertically is non-standard, but for Excalidraw I think
      // it makes sense
      y: prevElement.y + (prevElement.height - nextElement.height) / 2
    },
    false
  );
};
var changeFontSize = (elements, appState, app, getNewFontSize, fallbackValue) => {
  const newFontSizes = /* @__PURE__ */ new Set();
  return {
    elements: changeProperty(
      elements,
      appState,
      (oldElement) => {
        if (isTextElement(oldElement)) {
          const newFontSize = getNewFontSize(oldElement);
          newFontSizes.add(newFontSize);
          let newElement2 = newElementWith(oldElement, {
            fontSize: newFontSize
          });
          redrawTextBoundingBox(
            newElement2,
            app.scene.getContainerElement(oldElement),
            app.scene.getNonDeletedElementsMap()
          );
          newElement2 = offsetElementAfterFontResize(oldElement, newElement2);
          return newElement2;
        }
        return oldElement;
      },
      true
    ),
    appState: {
      ...appState,
      // update state only if we've set all select text elements to
      // the same font size
      currentItemFontSize: newFontSizes.size === 1 ? [...newFontSizes][0] : fallbackValue ?? appState.currentItemFontSize
    },
    storeAction: StoreAction.CAPTURE
  };
};
var actionChangeStrokeColor = register({
  name: "changeStrokeColor",
  label: "labels.stroke",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      ...value.currentItemStrokeColor && {
        elements: changeProperty(
          elements,
          appState,
          (el) => {
            return hasStrokeColor(el.type) ? newElementWith(el, {
              strokeColor: value.currentItemStrokeColor
            }) : el;
          },
          true
        )
      },
      appState: {
        ...appState,
        ...value
      },
      storeAction: !!value.currentItemStrokeColor ? StoreAction.CAPTURE : StoreAction.NONE
    };
  },
  PanelComponent: ({ elements, appState, updateData, appProps }) => /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)(import_jsx_runtime33.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("h3", { "aria-hidden": "true", children: t("labels.stroke") }),
    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
      ColorPicker,
      {
        topPicks: DEFAULT_ELEMENT_STROKE_PICKS,
        palette: DEFAULT_ELEMENT_STROKE_COLOR_PALETTE,
        type: "elementStroke",
        label: t("labels.stroke"),
        color: getFormValue(
          elements,
          appState,
          (element) => element.strokeColor,
          true,
          appState.currentItemStrokeColor
        ),
        onChange: (color) => updateData({ currentItemStrokeColor: color }),
        elements,
        appState,
        updateData
      }
    )
  ] })
});
var actionChangeBackgroundColor = register({
  name: "changeBackgroundColor",
  label: "labels.changeBackground",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      ...value.currentItemBackgroundColor && {
        elements: changeProperty(
          elements,
          appState,
          (el) => newElementWith(el, {
            backgroundColor: value.currentItemBackgroundColor
          })
        )
      },
      appState: {
        ...appState,
        ...value
      },
      storeAction: !!value.currentItemBackgroundColor ? StoreAction.CAPTURE : StoreAction.NONE
    };
  },
  PanelComponent: ({ elements, appState, updateData, appProps }) => /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)(import_jsx_runtime33.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("h3", { "aria-hidden": "true", children: t("labels.background") }),
    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
      ColorPicker,
      {
        topPicks: DEFAULT_ELEMENT_BACKGROUND_PICKS,
        palette: DEFAULT_ELEMENT_BACKGROUND_COLOR_PALETTE,
        type: "elementBackground",
        label: t("labels.background"),
        color: getFormValue(
          elements,
          appState,
          (element) => element.backgroundColor,
          true,
          appState.currentItemBackgroundColor
        ),
        onChange: (color) => updateData({ currentItemBackgroundColor: color }),
        elements,
        appState,
        updateData
      }
    )
  ] })
});
var actionChangeFillStyle = register({
  name: "changeFillStyle",
  label: "labels.fill",
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    trackEvent(
      "element",
      "changeFillStyle",
      `${value} (${app.device.editor.isMobile ? "mobile" : "desktop"})`
    );
    return {
      elements: changeProperty(
        elements,
        appState,
        (el) => newElementWith(el, {
          fillStyle: value
        })
      ),
      appState: { ...appState, currentItemFillStyle: value },
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData }) => {
    const selectedElements = getSelectedElements(elements, appState);
    const allElementsZigZag = selectedElements.length > 0 && selectedElements.every((el) => el.fillStyle === "zigzag");
    return /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)("fieldset", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("legend", { children: t("labels.fill") }),
      /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
        ButtonIconSelect,
        {
          type: "button",
          options: [
            {
              value: "hachure",
              text: `${allElementsZigZag ? t("labels.zigzag") : t("labels.hachure")} (${getShortcutKey("Alt-Click")})`,
              icon: allElementsZigZag ? FillZigZagIcon : FillHachureIcon,
              active: allElementsZigZag ? true : void 0,
              testId: `fill-hachure`
            },
            {
              value: "cross-hatch",
              text: t("labels.crossHatch"),
              icon: FillCrossHatchIcon,
              testId: `fill-cross-hatch`
            },
            {
              value: "solid",
              text: t("labels.solid"),
              icon: FillSolidIcon,
              testId: `fill-solid`
            }
          ],
          value: getFormValue(
            elements,
            appState,
            (element) => element.fillStyle,
            (element) => element.hasOwnProperty("fillStyle"),
            (hasSelection) => hasSelection ? null : appState.currentItemFillStyle
          ),
          onClick: (value, event) => {
            const nextValue = event.altKey && value === "hachure" && selectedElements.every((el) => el.fillStyle === "hachure") ? "zigzag" : value;
            updateData(nextValue);
          }
        }
      )
    ] });
  }
});
var actionChangeStrokeWidth = register({
  name: "changeStrokeWidth",
  label: "labels.strokeWidth",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      elements: changeProperty(
        elements,
        appState,
        (el) => newElementWith(el, {
          strokeWidth: value
        })
      ),
      appState: { ...appState, currentItemStrokeWidth: value },
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)("fieldset", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("legend", { children: t("labels.strokeWidth") }),
    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
      ButtonIconSelect,
      {
        group: "stroke-width",
        options: [
          {
            value: STROKE_WIDTH.thin,
            text: t("labels.thin"),
            icon: StrokeWidthBaseIcon,
            testId: "strokeWidth-thin"
          },
          {
            value: STROKE_WIDTH.bold,
            text: t("labels.bold"),
            icon: StrokeWidthBoldIcon,
            testId: "strokeWidth-bold"
          },
          {
            value: STROKE_WIDTH.extraBold,
            text: t("labels.extraBold"),
            icon: StrokeWidthExtraBoldIcon,
            testId: "strokeWidth-extraBold"
          }
        ],
        value: getFormValue(
          elements,
          appState,
          (element) => element.strokeWidth,
          (element) => element.hasOwnProperty("strokeWidth"),
          (hasSelection) => hasSelection ? null : appState.currentItemStrokeWidth
        ),
        onChange: (value) => updateData(value)
      }
    )
  ] })
});
var actionChangeSloppiness = register({
  name: "changeSloppiness",
  label: "labels.sloppiness",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      elements: changeProperty(
        elements,
        appState,
        (el) => newElementWith(el, {
          seed: randomInteger(),
          roughness: value
        })
      ),
      appState: { ...appState, currentItemRoughness: value },
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)("fieldset", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("legend", { children: t("labels.sloppiness") }),
    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
      ButtonIconSelect,
      {
        group: "sloppiness",
        options: [
          {
            value: 0,
            text: t("labels.architect"),
            icon: SloppinessArchitectIcon
          },
          {
            value: 1,
            text: t("labels.artist"),
            icon: SloppinessArtistIcon
          },
          {
            value: 2,
            text: t("labels.cartoonist"),
            icon: SloppinessCartoonistIcon
          }
        ],
        value: getFormValue(
          elements,
          appState,
          (element) => element.roughness,
          (element) => element.hasOwnProperty("roughness"),
          (hasSelection) => hasSelection ? null : appState.currentItemRoughness
        ),
        onChange: (value) => updateData(value)
      }
    )
  ] })
});
var actionChangeStrokeStyle = register({
  name: "changeStrokeStyle",
  label: "labels.strokeStyle",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      elements: changeProperty(
        elements,
        appState,
        (el) => newElementWith(el, {
          strokeStyle: value
        })
      ),
      appState: { ...appState, currentItemStrokeStyle: value },
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)("fieldset", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("legend", { children: t("labels.strokeStyle") }),
    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
      ButtonIconSelect,
      {
        group: "strokeStyle",
        options: [
          {
            value: "solid",
            text: t("labels.strokeStyle_solid"),
            icon: StrokeWidthBaseIcon
          },
          {
            value: "dashed",
            text: t("labels.strokeStyle_dashed"),
            icon: StrokeStyleDashedIcon
          },
          {
            value: "dotted",
            text: t("labels.strokeStyle_dotted"),
            icon: StrokeStyleDottedIcon
          }
        ],
        value: getFormValue(
          elements,
          appState,
          (element) => element.strokeStyle,
          (element) => element.hasOwnProperty("strokeStyle"),
          (hasSelection) => hasSelection ? null : appState.currentItemStrokeStyle
        ),
        onChange: (value) => updateData(value)
      }
    )
  ] })
});
var actionChangeOpacity = register({
  name: "changeOpacity",
  label: "labels.opacity",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      elements: changeProperty(
        elements,
        appState,
        (el) => newElementWith(el, {
          opacity: value
        }),
        true
      ),
      appState: { ...appState, currentItemOpacity: value },
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)("label", { className: "control-label", children: [
    t("labels.opacity"),
    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
      "input",
      {
        type: "range",
        min: "0",
        max: "100",
        step: "10",
        onChange: (event) => updateData(+event.target.value),
        value: getFormValue(
          elements,
          appState,
          (element) => element.opacity,
          true,
          appState.currentItemOpacity
        ) ?? void 0
      }
    )
  ] })
});
var actionChangeFontSize = register({
  name: "changeFontSize",
  label: "labels.fontSize",
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    return changeFontSize(elements, appState, app, () => value, value);
  },
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)("fieldset", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("legend", { children: t("labels.fontSize") }),
    /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
      ButtonIconSelect,
      {
        group: "font-size",
        options: [
          {
            value: 16,
            text: t("labels.small"),
            icon: FontSizeSmallIcon,
            testId: "fontSize-small"
          },
          {
            value: 20,
            text: t("labels.medium"),
            icon: FontSizeMediumIcon,
            testId: "fontSize-medium"
          },
          {
            value: 28,
            text: t("labels.large"),
            icon: FontSizeLargeIcon,
            testId: "fontSize-large"
          },
          {
            value: 36,
            text: t("labels.veryLarge"),
            icon: FontSizeExtraLargeIcon,
            testId: "fontSize-veryLarge"
          }
        ],
        value: getFormValue(
          elements,
          appState,
          (element) => {
            if (isTextElement(element)) {
              return element.fontSize;
            }
            const boundTextElement = getBoundTextElement(
              element,
              app.scene.getNonDeletedElementsMap()
            );
            if (boundTextElement) {
              return boundTextElement.fontSize;
            }
            return null;
          },
          (element) => isTextElement(element) || getBoundTextElement(
            element,
            app.scene.getNonDeletedElementsMap()
          ) !== null,
          (hasSelection) => hasSelection ? null : appState.currentItemFontSize || DEFAULT_FONT_SIZE
        ),
        onChange: (value) => updateData(value)
      }
    )
  ] })
});
var actionDecreaseFontSize = register({
  name: "decreaseFontSize",
  label: "labels.decreaseFontSize",
  icon: fontSizeIcon,
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    return changeFontSize(
      elements,
      appState,
      app,
      (element) => Math.round(
        // get previous value before relative increase (doesn't work fully
        // due to rounding and float precision issues)
        1 / (1 + FONT_SIZE_RELATIVE_INCREASE_STEP) * element.fontSize
      )
    );
  },
  keyTest: (event) => {
    return event[KEYS.CTRL_OR_CMD] && event.shiftKey && // KEYS.COMMA needed for MacOS
    (event.key === KEYS.CHEVRON_LEFT || event.key === KEYS.COMMA);
  }
});
var actionIncreaseFontSize = register({
  name: "increaseFontSize",
  label: "labels.increaseFontSize",
  icon: fontSizeIcon,
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    return changeFontSize(
      elements,
      appState,
      app,
      (element) => Math.round(element.fontSize * (1 + FONT_SIZE_RELATIVE_INCREASE_STEP))
    );
  },
  keyTest: (event) => {
    return event[KEYS.CTRL_OR_CMD] && event.shiftKey && // KEYS.PERIOD needed for MacOS
    (event.key === KEYS.CHEVRON_RIGHT || event.key === KEYS.PERIOD);
  }
});
var actionChangeFontFamily = register({
  name: "changeFontFamily",
  label: "labels.fontFamily",
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    const { cachedElements, resetAll, resetContainers, ...nextAppState } = value;
    if (resetAll) {
      const nextElements = changeProperty(
        elements,
        appState,
        (element) => {
          const cachedElement = cachedElements?.get(element.id);
          if (cachedElement) {
            const newElement2 = newElementWith(element, {
              ...cachedElement
            });
            return newElement2;
          }
          return element;
        },
        true
      );
      return {
        elements: nextElements,
        appState: {
          ...appState,
          ...nextAppState
        },
        storeAction: StoreAction.UPDATE
      };
    }
    const { currentItemFontFamily, currentHoveredFontFamily } = value;
    let nexStoreAction = StoreAction.NONE;
    let nextFontFamily;
    let skipOnHoverRender = false;
    if (currentItemFontFamily) {
      nextFontFamily = currentItemFontFamily;
      nexStoreAction = StoreAction.CAPTURE;
    } else if (currentHoveredFontFamily) {
      nextFontFamily = currentHoveredFontFamily;
      nexStoreAction = StoreAction.NONE;
      const selectedTextElements = getSelectedElements(elements, appState, {
        includeBoundTextElement: true
      }).filter((element) => isTextElement(element));
      if (selectedTextElements.length > 200) {
        skipOnHoverRender = true;
      } else {
        let i3 = 0;
        let textLengthAccumulator = 0;
        while (i3 < selectedTextElements.length && textLengthAccumulator < 5e3) {
          const textElement = selectedTextElements[i3];
          textLengthAccumulator += textElement?.originalText.length || 0;
          i3++;
        }
        if (textLengthAccumulator > 5e3) {
          skipOnHoverRender = true;
        }
      }
    }
    const result = {
      appState: {
        ...appState,
        ...nextAppState
      },
      storeAction: nexStoreAction
    };
    if (nextFontFamily && !skipOnHoverRender) {
      const elementContainerMapping = /* @__PURE__ */ new Map();
      let uniqueChars = /* @__PURE__ */ new Set();
      let skipFontFaceCheck = false;
      const fontsCache = Array.from(Fonts.loadedFontsCache.values());
      const fontFamily = Object.entries(FONT_FAMILY).find(
        ([_, value2]) => value2 === nextFontFamily
      )?.[0];
      if (currentHoveredFontFamily && fontFamily && fontsCache.some((sig) => sig.startsWith(fontFamily))) {
        skipFontFaceCheck = true;
      }
      Object.assign(result, {
        elements: changeProperty(
          elements,
          appState,
          (oldElement) => {
            if (isTextElement(oldElement) && (oldElement.fontFamily !== nextFontFamily || currentItemFontFamily)) {
              const newElement2 = newElementWith(
                oldElement,
                {
                  fontFamily: nextFontFamily,
                  lineHeight: getLineHeight(nextFontFamily)
                }
              );
              const cachedContainer = cachedElements?.get(oldElement.containerId || "") || {};
              const container = app.scene.getContainerElement(oldElement);
              if (resetContainers && container && cachedContainer) {
                mutateElement(container, { ...cachedContainer }, false);
              }
              if (!skipFontFaceCheck) {
                uniqueChars = /* @__PURE__ */ new Set([
                  ...uniqueChars,
                  ...Array.from(newElement2.originalText)
                ]);
              }
              elementContainerMapping.set(newElement2, container);
              return newElement2;
            }
            return oldElement;
          },
          true
        )
      });
      const fontString = `10px ${getFontFamilyString({
        fontFamily: nextFontFamily
      })}`;
      const chars = Array.from(uniqueChars.values()).join();
      if (skipFontFaceCheck || window.document.fonts.check(fontString, chars)) {
        for (const [element, container] of elementContainerMapping) {
          redrawTextBoundingBox(
            element,
            container,
            app.scene.getNonDeletedElementsMap(),
            false
          );
        }
      } else {
        window.document.fonts.load(fontString, chars).then((fontFaces) => {
          for (const [element, container] of elementContainerMapping) {
            const latestElement = app.scene.getElement(element.id);
            const latestContainer = container ? app.scene.getElement(container.id) : null;
            if (latestElement) {
              redrawTextBoundingBox(
                latestElement,
                latestContainer,
                app.scene.getNonDeletedElementsMap(),
                false
              );
            }
          }
          app.fonts.onLoaded(fontFaces);
        });
      }
    }
    return result;
  },
  PanelComponent: ({ elements, appState, app, updateData }) => {
    const cachedElementsRef = (0, import_react49.useRef)(/* @__PURE__ */ new Map());
    const prevSelectedFontFamilyRef = (0, import_react49.useRef)(null);
    const [batchedData, setBatchedData] = (0, import_react49.useState)({});
    const isUnmounted = (0, import_react49.useRef)(true);
    const selectedFontFamily = (0, import_react49.useMemo)(() => {
      const getFontFamily = (elementsArray, elementsMap) => getFormValue(
        elementsArray,
        appState,
        (element) => {
          if (isTextElement(element)) {
            return element.fontFamily;
          }
          const boundTextElement = getBoundTextElement(element, elementsMap);
          if (boundTextElement) {
            return boundTextElement.fontFamily;
          }
          return null;
        },
        (element) => isTextElement(element) || getBoundTextElement(element, elementsMap) !== null,
        (hasSelection) => hasSelection ? null : appState.currentItemFontFamily || DEFAULT_FONT_FAMILY
      );
      if (batchedData.openPopup === "fontFamily" && appState.openPopup === "fontFamily") {
        return getFontFamily(
          Array.from(cachedElementsRef.current?.values() ?? []),
          cachedElementsRef.current
        );
      }
      if (!batchedData.openPopup && appState.openPopup !== "fontFamily") {
        return getFontFamily(elements, app.scene.getNonDeletedElementsMap());
      }
      return prevSelectedFontFamilyRef.current;
    }, [batchedData.openPopup, appState, elements, app.scene]);
    (0, import_react49.useEffect)(() => {
      prevSelectedFontFamilyRef.current = selectedFontFamily;
    }, [selectedFontFamily]);
    (0, import_react49.useEffect)(() => {
      if (Object.keys(batchedData).length) {
        updateData(batchedData);
        setBatchedData({});
      }
    }, [batchedData]);
    (0, import_react49.useEffect)(() => {
      isUnmounted.current = false;
      return () => {
        isUnmounted.current = true;
      };
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)("fieldset", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("legend", { children: t("labels.fontFamily") }),
      /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
        FontPicker,
        {
          isOpened: appState.openPopup === "fontFamily",
          selectedFontFamily,
          hoveredFontFamily: appState.currentHoveredFontFamily,
          onSelect: (fontFamily) => {
            setBatchedData({
              openPopup: null,
              currentHoveredFontFamily: null,
              currentItemFontFamily: fontFamily
            });
            cachedElementsRef.current.clear();
          },
          onHover: (fontFamily) => {
            setBatchedData({
              currentHoveredFontFamily: fontFamily,
              cachedElements: new Map(cachedElementsRef.current),
              resetContainers: true
            });
          },
          onLeave: () => {
            setBatchedData({
              currentHoveredFontFamily: null,
              cachedElements: new Map(cachedElementsRef.current),
              resetAll: true
            });
          },
          onPopupChange: (open) => {
            if (open) {
              cachedElementsRef.current.clear();
              const { editingTextElement } = appState;
              if (editingTextElement?.type === "text") {
                const latesteditingTextElement = app.scene.getElement(
                  editingTextElement.id
                );
                cachedElementsRef.current.set(
                  editingTextElement.id,
                  newElementWith(
                    latesteditingTextElement || editingTextElement,
                    {},
                    true
                  )
                );
              } else {
                const selectedElements = getSelectedElements(
                  elements,
                  appState,
                  {
                    includeBoundTextElement: true
                  }
                );
                for (const element of selectedElements) {
                  cachedElementsRef.current.set(
                    element.id,
                    newElementWith(element, {}, true)
                  );
                }
              }
              setBatchedData({
                openPopup: "fontFamily"
              });
            } else {
              const data = {
                openPopup: null,
                currentHoveredFontFamily: null,
                cachedElements: new Map(cachedElementsRef.current),
                resetAll: true
              };
              if (isUnmounted.current) {
                updateData({ ...batchedData, ...data });
              } else {
                setBatchedData(data);
              }
              cachedElementsRef.current.clear();
            }
          }
        }
      )
    ] });
  }
});
var actionChangeTextAlign = register({
  name: "changeTextAlign",
  label: "Change text alignment",
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    return {
      elements: changeProperty(
        elements,
        appState,
        (oldElement) => {
          if (isTextElement(oldElement)) {
            const newElement2 = newElementWith(
              oldElement,
              { textAlign: value }
            );
            redrawTextBoundingBox(
              newElement2,
              app.scene.getContainerElement(oldElement),
              app.scene.getNonDeletedElementsMap()
            );
            return newElement2;
          }
          return oldElement;
        },
        true
      ),
      appState: {
        ...appState,
        currentItemTextAlign: value
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData, app }) => {
    const elementsMap = app.scene.getNonDeletedElementsMap();
    return /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)("fieldset", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("legend", { children: t("labels.textAlign") }),
      /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
        ButtonIconSelect,
        {
          group: "text-align",
          options: [
            {
              value: "left",
              text: t("labels.left"),
              icon: TextAlignLeftIcon,
              testId: "align-left"
            },
            {
              value: "center",
              text: t("labels.center"),
              icon: TextAlignCenterIcon,
              testId: "align-horizontal-center"
            },
            {
              value: "right",
              text: t("labels.right"),
              icon: TextAlignRightIcon,
              testId: "align-right"
            }
          ],
          value: getFormValue(
            elements,
            appState,
            (element) => {
              if (isTextElement(element)) {
                return element.textAlign;
              }
              const boundTextElement = getBoundTextElement(
                element,
                elementsMap
              );
              if (boundTextElement) {
                return boundTextElement.textAlign;
              }
              return null;
            },
            (element) => isTextElement(element) || getBoundTextElement(element, elementsMap) !== null,
            (hasSelection) => hasSelection ? null : appState.currentItemTextAlign
          ),
          onChange: (value) => updateData(value)
        }
      )
    ] });
  }
});
var actionChangeVerticalAlign = register({
  name: "changeVerticalAlign",
  label: "Change vertical alignment",
  trackEvent: { category: "element" },
  perform: (elements, appState, value, app) => {
    return {
      elements: changeProperty(
        elements,
        appState,
        (oldElement) => {
          if (isTextElement(oldElement)) {
            const newElement2 = newElementWith(
              oldElement,
              { verticalAlign: value }
            );
            redrawTextBoundingBox(
              newElement2,
              app.scene.getContainerElement(oldElement),
              app.scene.getNonDeletedElementsMap()
            );
            return newElement2;
          }
          return oldElement;
        },
        true
      ),
      appState: {
        ...appState
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData, app }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("fieldset", { children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
      ButtonIconSelect,
      {
        group: "text-align",
        options: [
          {
            value: VERTICAL_ALIGN.TOP,
            text: t("labels.alignTop"),
            icon: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(TextAlignTopIcon, { theme: appState.theme }),
            testId: "align-top"
          },
          {
            value: VERTICAL_ALIGN.MIDDLE,
            text: t("labels.centerVertically"),
            icon: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(TextAlignMiddleIcon, { theme: appState.theme }),
            testId: "align-middle"
          },
          {
            value: VERTICAL_ALIGN.BOTTOM,
            text: t("labels.alignBottom"),
            icon: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(TextAlignBottomIcon, { theme: appState.theme }),
            testId: "align-bottom"
          }
        ],
        value: getFormValue(
          elements,
          appState,
          (element) => {
            if (isTextElement(element) && element.containerId) {
              return element.verticalAlign;
            }
            const boundTextElement = getBoundTextElement(
              element,
              app.scene.getNonDeletedElementsMap()
            );
            if (boundTextElement) {
              return boundTextElement.verticalAlign;
            }
            return null;
          },
          (element) => isTextElement(element) || getBoundTextElement(
            element,
            app.scene.getNonDeletedElementsMap()
          ) !== null,
          (hasSelection) => hasSelection ? null : VERTICAL_ALIGN.MIDDLE
        ),
        onChange: (value) => updateData(value)
      }
    ) });
  }
});
var actionChangeRoundness = register({
  name: "changeRoundness",
  label: "Change edge roundness",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      elements: changeProperty(elements, appState, (el) => {
        if (isElbowArrow(el)) {
          return el;
        }
        return newElementWith(el, {
          roundness: value === "round" ? {
            type: isUsingAdaptiveRadius(el.type) ? ROUNDNESS.ADAPTIVE_RADIUS : ROUNDNESS.PROPORTIONAL_RADIUS
          } : null
        });
      }),
      appState: {
        ...appState,
        currentItemRoundness: value
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData }) => {
    const targetElements = getTargetElements(
      getNonDeletedElements(elements),
      appState
    );
    const hasLegacyRoundness = targetElements.some(
      (el) => el.roundness?.type === ROUNDNESS.LEGACY
    );
    return /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)("fieldset", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("legend", { children: t("labels.edges") }),
      /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
        ButtonIconSelect,
        {
          group: "edges",
          options: [
            {
              value: "sharp",
              text: t("labels.sharp"),
              icon: EdgeSharpIcon
            },
            {
              value: "round",
              text: t("labels.round"),
              icon: EdgeRoundIcon
            }
          ],
          value: getFormValue(
            elements,
            appState,
            (element) => hasLegacyRoundness ? null : element.roundness ? "round" : "sharp",
            (element) => !isArrowElement(element) && element.hasOwnProperty("roundness"),
            (hasSelection) => hasSelection ? null : appState.currentItemRoundness
          ),
          onChange: (value) => updateData(value)
        }
      )
    ] });
  }
});
var getArrowheadOptions = (flip) => {
  return [
    {
      value: null,
      text: t("labels.arrowhead_none"),
      keyBinding: "q",
      icon: ArrowheadNoneIcon
    },
    {
      value: "arrow",
      text: t("labels.arrowhead_arrow"),
      keyBinding: "w",
      icon: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(ArrowheadArrowIcon, { flip })
    },
    {
      value: "bar",
      text: t("labels.arrowhead_bar"),
      keyBinding: "e",
      icon: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(ArrowheadBarIcon, { flip })
    },
    {
      value: "dot",
      text: t("labels.arrowhead_circle"),
      keyBinding: null,
      icon: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(ArrowheadCircleIcon, { flip }),
      showInPicker: false
    },
    {
      value: "circle",
      text: t("labels.arrowhead_circle"),
      keyBinding: "r",
      icon: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(ArrowheadCircleIcon, { flip }),
      showInPicker: false
    },
    {
      value: "circle_outline",
      text: t("labels.arrowhead_circle_outline"),
      keyBinding: null,
      icon: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(ArrowheadCircleOutlineIcon, { flip }),
      showInPicker: false
    },
    {
      value: "triangle",
      text: t("labels.arrowhead_triangle"),
      icon: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(ArrowheadTriangleIcon, { flip }),
      keyBinding: "t"
    },
    {
      value: "triangle_outline",
      text: t("labels.arrowhead_triangle_outline"),
      icon: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(ArrowheadTriangleOutlineIcon, { flip }),
      keyBinding: null,
      showInPicker: false
    },
    {
      value: "diamond",
      text: t("labels.arrowhead_diamond"),
      icon: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(ArrowheadDiamondIcon, { flip }),
      keyBinding: null,
      showInPicker: false
    },
    {
      value: "diamond_outline",
      text: t("labels.arrowhead_diamond_outline"),
      icon: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(ArrowheadDiamondOutlineIcon, { flip }),
      keyBinding: null,
      showInPicker: false
    }
  ];
};
var actionChangeArrowhead = register({
  name: "changeArrowhead",
  label: "Change arrowheads",
  trackEvent: false,
  perform: (elements, appState, value) => {
    return {
      elements: changeProperty(elements, appState, (el) => {
        if (isLinearElement(el)) {
          const { position, type } = value;
          if (position === "start") {
            const element = newElementWith(el, {
              startArrowhead: type
            });
            return element;
          } else if (position === "end") {
            const element = newElementWith(el, {
              endArrowhead: type
            });
            return element;
          }
        }
        return el;
      }),
      appState: {
        ...appState,
        [value.position === "start" ? "currentItemStartArrowhead" : "currentItemEndArrowhead"]: value.type
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData }) => {
    const isRTL = getLanguage().rtl;
    return /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)("fieldset", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("legend", { children: t("labels.arrowheads") }),
      /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)("div", { className: "iconSelectList buttonList", children: [
        /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
          IconPicker,
          {
            label: "arrowhead_start",
            options: getArrowheadOptions(!isRTL),
            value: getFormValue(
              elements,
              appState,
              (element) => isLinearElement(element) && canHaveArrowheads(element.type) ? element.startArrowhead : appState.currentItemStartArrowhead,
              true,
              appState.currentItemStartArrowhead
            ),
            onChange: (value) => updateData({ position: "start", type: value })
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
          IconPicker,
          {
            label: "arrowhead_end",
            group: "arrowheads",
            options: getArrowheadOptions(!!isRTL),
            value: getFormValue(
              elements,
              appState,
              (element) => isLinearElement(element) && canHaveArrowheads(element.type) ? element.endArrowhead : appState.currentItemEndArrowhead,
              true,
              appState.currentItemEndArrowhead
            ),
            onChange: (value) => updateData({ position: "end", type: value })
          }
        )
      ] })
    ] });
  }
});
var actionChangeArrowType = register({
  name: "changeArrowType",
  label: "Change arrow types",
  trackEvent: false,
  perform: (elements, appState, value, app) => {
    return {
      elements: changeProperty(elements, appState, (el) => {
        if (!isArrowElement(el)) {
          return el;
        }
        const newElement2 = newElementWith(el, {
          roundness: value === ARROW_TYPE.round ? {
            type: ROUNDNESS.PROPORTIONAL_RADIUS
          } : null,
          elbowed: value === ARROW_TYPE.elbow,
          points: value === ARROW_TYPE.elbow || el.elbowed ? [el.points[0], el.points[el.points.length - 1]] : el.points
        });
        if (isElbowArrow(newElement2)) {
          const elementsMap = app.scene.getNonDeletedElementsMap();
          app.dismissLinearEditor();
          const startGlobalPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(
            newElement2,
            0,
            elementsMap
          );
          const endGlobalPoint = LinearElementEditor.getPointAtIndexGlobalCoordinates(
            newElement2,
            -1,
            elementsMap
          );
          const startHoveredElement = !newElement2.startBinding && getHoveredElementForBinding(
            tupleToCoors(startGlobalPoint),
            elements,
            elementsMap,
            true
          );
          const endHoveredElement = !newElement2.endBinding && getHoveredElementForBinding(
            tupleToCoors(endGlobalPoint),
            elements,
            elementsMap,
            true
          );
          const startElement = startHoveredElement ? startHoveredElement : newElement2.startBinding && elementsMap.get(
            newElement2.startBinding.elementId
          );
          const endElement = endHoveredElement ? endHoveredElement : newElement2.endBinding && elementsMap.get(
            newElement2.endBinding.elementId
          );
          const finalStartPoint = startHoveredElement ? bindPointToSnapToElementOutline(
            startGlobalPoint,
            endGlobalPoint,
            startHoveredElement,
            elementsMap
          ) : startGlobalPoint;
          const finalEndPoint = endHoveredElement ? bindPointToSnapToElementOutline(
            endGlobalPoint,
            startGlobalPoint,
            endHoveredElement,
            elementsMap
          ) : endGlobalPoint;
          startHoveredElement && bindLinearElement(
            newElement2,
            startHoveredElement,
            "start",
            elementsMap
          );
          endHoveredElement && bindLinearElement(
            newElement2,
            endHoveredElement,
            "end",
            elementsMap
          );
          mutateElbowArrow(
            newElement2,
            elementsMap,
            [finalStartPoint, finalEndPoint].map(
              (p3) => pointFrom(p3[0] - newElement2.x, p3[1] - newElement2.y)
            ),
            vector(0, 0),
            {
              ...startElement && newElement2.startBinding ? {
                startBinding: {
                  // @ts-ignore TS cannot discern check above
                  ...newElement2.startBinding,
                  ...calculateFixedPointForElbowArrowBinding(
                    newElement2,
                    startElement,
                    "start",
                    elementsMap
                  )
                }
              } : {},
              ...endElement && newElement2.endBinding ? {
                endBinding: {
                  // @ts-ignore TS cannot discern check above
                  ...newElement2.endBinding,
                  ...calculateFixedPointForElbowArrowBinding(
                    newElement2,
                    endElement,
                    "end",
                    elementsMap
                  )
                }
              } : {}
            }
          );
        }
        return newElement2;
      }),
      appState: {
        ...appState,
        currentItemArrowType: value
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)("fieldset", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("legend", { children: t("labels.arrowtypes") }),
      /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
        ButtonIconSelect,
        {
          group: "arrowtypes",
          options: [
            {
              value: ARROW_TYPE.sharp,
              text: t("labels.arrowtype_sharp"),
              icon: sharpArrowIcon,
              testId: "sharp-arrow"
            },
            {
              value: ARROW_TYPE.round,
              text: t("labels.arrowtype_round"),
              icon: roundArrowIcon,
              testId: "round-arrow"
            },
            {
              value: ARROW_TYPE.elbow,
              text: t("labels.arrowtype_elbowed"),
              icon: elbowArrowIcon,
              testId: "elbow-arrow"
            }
          ],
          value: getFormValue(
            elements,
            appState,
            (element) => {
              if (isArrowElement(element)) {
                return element.elbowed ? ARROW_TYPE.elbow : element.roundness ? ARROW_TYPE.round : ARROW_TYPE.sharp;
              }
              return null;
            },
            (element) => isArrowElement(element),
            (hasSelection) => hasSelection ? null : appState.currentItemArrowType
          ),
          onChange: (value) => updateData(value)
        }
      )
    ] });
  }
});

// actions/actionCanvas.tsx
init_define_import_meta_env();

// scene/zoom.ts
init_define_import_meta_env();
var getStateForZoom = ({
  viewportX,
  viewportY,
  nextZoom
}, appState) => {
  const appLayerX = viewportX - appState.offsetLeft;
  const appLayerY = viewportY - appState.offsetTop;
  const currentZoom = appState.zoom.value;
  const baseScrollX = appState.scrollX + (appLayerX - appLayerX / currentZoom);
  const baseScrollY = appState.scrollY + (appLayerY - appLayerY / currentZoom);
  const zoomOffsetScrollX = -(appLayerX - appLayerX / nextZoom);
  const zoomOffsetScrollY = -(appLayerY - appLayerY / nextZoom);
  return {
    scrollX: baseScrollX + zoomOffsetScrollX,
    scrollY: baseScrollY + zoomOffsetScrollY,
    zoom: {
      value: nextZoom
    }
  };
};

// components/Tooltip.tsx
init_define_import_meta_env();
var import_react50 = __toESM(require_react(), 1);
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var getTooltipDiv = () => {
  const existingDiv = document.querySelector(
    ".excalidraw-tooltip"
  );
  if (existingDiv) {
    return existingDiv;
  }
  const div = document.createElement("div");
  document.body.appendChild(div);
  div.classList.add("excalidraw-tooltip");
  return div;
};
var updateTooltipPosition = (tooltip, item, position = "bottom") => {
  const tooltipRect = tooltip.getBoundingClientRect();
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;
  const margin = 5;
  let left = item.left + item.width / 2 - tooltipRect.width / 2;
  if (left < 0) {
    left = margin;
  } else if (left + tooltipRect.width >= viewportWidth) {
    left = viewportWidth - tooltipRect.width - margin;
  }
  let top;
  if (position === "bottom") {
    top = item.top + item.height + margin;
    if (top + tooltipRect.height >= viewportHeight) {
      top = item.top - tooltipRect.height - margin;
    }
  } else {
    top = item.top - tooltipRect.height - margin;
    if (top < 0) {
      top = item.top + item.height + margin;
    }
  }
  Object.assign(tooltip.style, {
    top: `${top}px`,
    left: `${left}px`
  });
};
var updateTooltip = (item, tooltip, label, long) => {
  tooltip.classList.add("excalidraw-tooltip--visible");
  tooltip.style.minWidth = long ? "50ch" : "10ch";
  tooltip.style.maxWidth = long ? "50ch" : "15ch";
  tooltip.textContent = label;
  const itemRect = item.getBoundingClientRect();
  updateTooltipPosition(tooltip, itemRect);
};
var Tooltip = ({
  children,
  label,
  long = false,
  style,
  disabled
}) => {
  (0, import_react50.useEffect)(() => {
    return () => getTooltipDiv().classList.remove("excalidraw-tooltip--visible");
  }, []);
  if (disabled) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
    "div",
    {
      className: "excalidraw-tooltip-wrapper",
      onPointerEnter: (event) => updateTooltip(
        event.currentTarget,
        getTooltipDiv(),
        label,
        long
      ),
      onPointerLeave: () => getTooltipDiv().classList.remove("excalidraw-tooltip--visible"),
      style,
      children
    }
  );
};

// actions/actionCanvas.tsx
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var actionChangeViewBackgroundColor = register({
  name: "changeViewBackgroundColor",
  label: "labels.canvasBackground",
  paletteName: "Change canvas background color",
  trackEvent: false,
  predicate: (elements, appState, props, app) => {
    return !!app.props.UIOptions.canvasActions.changeViewBackgroundColor && !appState.viewModeEnabled;
  },
  perform: (_, appState, value) => {
    return {
      appState: { ...appState, ...value },
      storeAction: !!value.viewBackgroundColor ? StoreAction.CAPTURE : StoreAction.NONE
    };
  },
  PanelComponent: ({ elements, appState, updateData, appProps }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(
      ColorPicker,
      {
        palette: null,
        topPicks: DEFAULT_CANVAS_BACKGROUND_PICKS,
        label: t("labels.canvasBackground"),
        type: "canvasBackground",
        color: appState.viewBackgroundColor,
        onChange: (color) => updateData({ viewBackgroundColor: color }),
        "data-testid": "canvas-background-picker",
        elements,
        appState,
        updateData
      }
    );
  }
});
var actionClearCanvas = register({
  name: "clearCanvas",
  label: "labels.clearCanvas",
  paletteName: "Clear canvas",
  icon: TrashIcon,
  trackEvent: { category: "canvas" },
  predicate: (elements, appState, props, app) => {
    return !!app.props.UIOptions.canvasActions.clearCanvas && !appState.viewModeEnabled;
  },
  perform: (elements, appState, _, app) => {
    app.imageCache.clear();
    return {
      elements: elements.map(
        (element) => newElementWith(element, { isDeleted: true })
      ),
      appState: {
        ...getDefaultAppState(),
        files: {},
        theme: appState.theme,
        penMode: appState.penMode,
        penDetected: appState.penDetected,
        exportBackground: appState.exportBackground,
        exportEmbedScene: appState.exportEmbedScene,
        gridSize: appState.gridSize,
        gridStep: appState.gridStep,
        gridModeEnabled: appState.gridModeEnabled,
        stats: appState.stats,
        pasteDialog: appState.pasteDialog,
        activeTool: appState.activeTool.type === "image" ? { ...appState.activeTool, type: "selection" } : appState.activeTool
      },
      storeAction: StoreAction.CAPTURE
    };
  }
});
var actionZoomIn = register({
  name: "zoomIn",
  label: "buttons.zoomIn",
  viewMode: true,
  icon: ZoomInIcon,
  trackEvent: { category: "canvas" },
  perform: (_elements, appState, _, app) => {
    return {
      appState: {
        ...appState,
        ...getStateForZoom(
          {
            viewportX: appState.width / 2 + appState.offsetLeft,
            viewportY: appState.height / 2 + appState.offsetTop,
            nextZoom: getNormalizedZoom(appState.zoom.value + ZOOM_STEP)
          },
          appState
        ),
        userToFollow: null
      },
      storeAction: StoreAction.NONE
    };
  },
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(
    ToolButton,
    {
      type: "button",
      className: "zoom-in-button zoom-button",
      icon: ZoomInIcon,
      title: `${t("buttons.zoomIn")} \u2014 ${getShortcutKey("CtrlOrCmd++")}`,
      "aria-label": t("buttons.zoomIn"),
      disabled: appState.zoom.value >= MAX_ZOOM,
      onClick: () => {
        updateData(null);
      }
    }
  ),
  keyTest: (event) => (event.code === CODES.EQUAL || event.code === CODES.NUM_ADD) && (event[KEYS.CTRL_OR_CMD] || event.shiftKey)
});
var actionZoomOut = register({
  name: "zoomOut",
  label: "buttons.zoomOut",
  icon: ZoomOutIcon,
  viewMode: true,
  trackEvent: { category: "canvas" },
  perform: (_elements, appState, _, app) => {
    return {
      appState: {
        ...appState,
        ...getStateForZoom(
          {
            viewportX: appState.width / 2 + appState.offsetLeft,
            viewportY: appState.height / 2 + appState.offsetTop,
            nextZoom: getNormalizedZoom(appState.zoom.value - ZOOM_STEP)
          },
          appState
        ),
        userToFollow: null
      },
      storeAction: StoreAction.NONE
    };
  },
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(
    ToolButton,
    {
      type: "button",
      className: "zoom-out-button zoom-button",
      icon: ZoomOutIcon,
      title: `${t("buttons.zoomOut")} \u2014 ${getShortcutKey("CtrlOrCmd+-")}`,
      "aria-label": t("buttons.zoomOut"),
      disabled: appState.zoom.value <= MIN_ZOOM,
      onClick: () => {
        updateData(null);
      }
    }
  ),
  keyTest: (event) => (event.code === CODES.MINUS || event.code === CODES.NUM_SUBTRACT) && (event[KEYS.CTRL_OR_CMD] || event.shiftKey)
});
var actionResetZoom = register({
  name: "resetZoom",
  label: "buttons.resetZoom",
  icon: ZoomResetIcon,
  viewMode: true,
  trackEvent: { category: "canvas" },
  perform: (_elements, appState, _, app) => {
    return {
      appState: {
        ...appState,
        ...getStateForZoom(
          {
            viewportX: appState.width / 2 + appState.offsetLeft,
            viewportY: appState.height / 2 + appState.offsetTop,
            nextZoom: getNormalizedZoom(1)
          },
          appState
        ),
        userToFollow: null
      },
      storeAction: StoreAction.NONE
    };
  },
  PanelComponent: ({ updateData, appState }) => /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(Tooltip, { label: t("buttons.resetZoom"), style: { height: "100%" }, children: /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)(
    ToolButton,
    {
      type: "button",
      className: "reset-zoom-button zoom-button",
      title: t("buttons.resetZoom"),
      "aria-label": t("buttons.resetZoom"),
      onClick: () => {
        updateData(null);
      },
      children: [
        (appState.zoom.value * 100).toFixed(0),
        "%"
      ]
    }
  ) }),
  keyTest: (event) => (event.code === CODES.ZERO || event.code === CODES.NUM_ZERO) && (event[KEYS.CTRL_OR_CMD] || event.shiftKey)
});
var zoomValueToFitBoundsOnViewport = (bounds, viewportDimensions, viewportZoomFactor = 1) => {
  const [x1, y1, x22, y22] = bounds;
  const commonBoundsWidth = x22 - x1;
  const zoomValueForWidth = viewportDimensions.width / commonBoundsWidth;
  const commonBoundsHeight = y22 - y1;
  const zoomValueForHeight = viewportDimensions.height / commonBoundsHeight;
  const smallestZoomValue = Math.min(zoomValueForWidth, zoomValueForHeight);
  const adjustedZoomValue = smallestZoomValue * clamp(viewportZoomFactor, 0.1, 1);
  return Math.min(adjustedZoomValue, 1);
};
var zoomToFitBounds = ({
  bounds,
  appState,
  canvasOffsets,
  fitToViewport = false,
  viewportZoomFactor = 1,
  minZoom = -Infinity,
  maxZoom = Infinity
}) => {
  viewportZoomFactor = clamp(viewportZoomFactor, MIN_ZOOM, MAX_ZOOM);
  const [x1, y1, x22, y22] = bounds;
  const centerX = (x1 + x22) / 2;
  const centerY = (y1 + y22) / 2;
  const canvasOffsetLeft = canvasOffsets?.left ?? 0;
  const canvasOffsetTop = canvasOffsets?.top ?? 0;
  const canvasOffsetRight = canvasOffsets?.right ?? 0;
  const canvasOffsetBottom = canvasOffsets?.bottom ?? 0;
  const effectiveCanvasWidth = appState.width - canvasOffsetLeft - canvasOffsetRight;
  const effectiveCanvasHeight = appState.height - canvasOffsetTop - canvasOffsetBottom;
  let adjustedZoomValue;
  if (fitToViewport) {
    const commonBoundsWidth = x22 - x1;
    const commonBoundsHeight = y22 - y1;
    adjustedZoomValue = Math.min(
      effectiveCanvasWidth / commonBoundsWidth,
      effectiveCanvasHeight / commonBoundsHeight
    ) * viewportZoomFactor;
  } else {
    adjustedZoomValue = zoomValueToFitBoundsOnViewport(
      bounds,
      {
        width: effectiveCanvasWidth,
        height: effectiveCanvasHeight
      },
      viewportZoomFactor
    );
  }
  const newZoomValue = getNormalizedZoom(
    clamp(roundToStep(adjustedZoomValue, ZOOM_STEP, "floor"), minZoom, maxZoom)
  );
  const centerScroll = centerScrollOn({
    scenePoint: { x: centerX, y: centerY },
    viewportDimensions: {
      width: appState.width,
      height: appState.height
    },
    offsets: canvasOffsets,
    zoom: { value: newZoomValue }
  });
  return {
    appState: {
      ...appState,
      scrollX: centerScroll.scrollX,
      scrollY: centerScroll.scrollY,
      zoom: { value: newZoomValue }
    },
    storeAction: StoreAction.NONE
  };
};
var zoomToFit = ({
  canvasOffsets,
  targetElements,
  appState,
  fitToViewport,
  viewportZoomFactor,
  minZoom,
  maxZoom
}) => {
  const commonBounds = getCommonBounds(getNonDeletedElements(targetElements));
  return zoomToFitBounds({
    canvasOffsets,
    bounds: commonBounds,
    appState,
    fitToViewport,
    viewportZoomFactor,
    minZoom,
    maxZoom
  });
};
var actionZoomToFitSelectionInViewport = register({
  name: "zoomToFitSelectionInViewport",
  label: "labels.zoomToFitViewport",
  icon: zoomAreaIcon,
  trackEvent: { category: "canvas" },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    return zoomToFit({
      targetElements: selectedElements.length ? selectedElements : elements,
      appState: {
        ...appState,
        userToFollow: null
      },
      fitToViewport: false,
      canvasOffsets: app.getEditorUIOffsets()
    });
  },
  // NOTE shift-2 should have been assigned actionZoomToFitSelection.
  // TBD on how proceed
  keyTest: (event) => event.code === CODES.TWO && event.shiftKey && !event.altKey && !event[KEYS.CTRL_OR_CMD]
});
var actionZoomToFitSelection = register({
  name: "zoomToFitSelection",
  label: "helpDialog.zoomToSelection",
  icon: zoomAreaIcon,
  trackEvent: { category: "canvas" },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    return zoomToFit({
      targetElements: selectedElements.length ? selectedElements : elements,
      appState: {
        ...appState,
        userToFollow: null
      },
      fitToViewport: true,
      canvasOffsets: app.getEditorUIOffsets()
    });
  },
  // NOTE this action should use shift-2 per figma, alas
  keyTest: (event) => event.code === CODES.THREE && event.shiftKey && !event.altKey && !event[KEYS.CTRL_OR_CMD]
});
var actionZoomToFit = register({
  name: "zoomToFit",
  label: "helpDialog.zoomToFit",
  icon: zoomAreaIcon,
  viewMode: true,
  trackEvent: { category: "canvas" },
  perform: (elements, appState, _, app) => zoomToFit({
    targetElements: elements,
    appState: {
      ...appState,
      userToFollow: null
    },
    fitToViewport: false,
    canvasOffsets: app.getEditorUIOffsets()
  }),
  keyTest: (event) => event.code === CODES.ONE && event.shiftKey && !event.altKey && !event[KEYS.CTRL_OR_CMD]
});
var actionToggleTheme = register({
  name: "toggleTheme",
  label: (_, appState) => {
    return appState.theme === THEME.DARK ? "buttons.lightMode" : "buttons.darkMode";
  },
  keywords: ["toggle", "dark", "light", "mode", "theme"],
  icon: (appState) => appState.theme === THEME.LIGHT ? MoonIcon : SunIcon,
  viewMode: true,
  trackEvent: { category: "canvas" },
  perform: (_, appState, value) => {
    return {
      appState: {
        ...appState,
        theme: value || (appState.theme === THEME.LIGHT ? THEME.DARK : THEME.LIGHT)
      },
      storeAction: StoreAction.NONE
    };
  },
  keyTest: (event) => event.altKey && event.shiftKey && event.code === CODES.D,
  predicate: (elements, appState, props, app) => {
    return !!app.props.UIOptions.canvasActions.toggleTheme;
  }
});
var actionToggleEraserTool = register({
  name: "toggleEraserTool",
  label: "toolBar.eraser",
  trackEvent: { category: "toolbar" },
  perform: (elements, appState) => {
    let activeTool;
    if (isEraserActive(appState)) {
      activeTool = updateActiveTool(appState, {
        ...appState.activeTool.lastActiveTool || {
          type: "selection"
        },
        lastActiveToolBeforeEraser: null
      });
    } else {
      activeTool = updateActiveTool(appState, {
        type: "eraser",
        lastActiveToolBeforeEraser: appState.activeTool
      });
    }
    return {
      appState: {
        ...appState,
        selectedElementIds: {},
        selectedGroupIds: {},
        activeEmbeddable: null,
        activeTool
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => event.key === KEYS.E
});
var actionToggleHandTool = register({
  name: "toggleHandTool",
  label: "toolBar.hand",
  paletteName: "Toggle hand tool",
  trackEvent: { category: "toolbar" },
  icon: handIcon,
  viewMode: false,
  perform: (elements, appState, _, app) => {
    let activeTool;
    if (isHandToolActive(appState)) {
      activeTool = updateActiveTool(appState, {
        ...appState.activeTool.lastActiveTool || {
          type: "selection"
        },
        lastActiveToolBeforeEraser: null
      });
    } else {
      activeTool = updateActiveTool(appState, {
        type: "hand",
        lastActiveToolBeforeEraser: appState.activeTool
      });
      setCursor(app.interactiveCanvas, CURSOR_TYPE.GRAB);
    }
    return {
      appState: {
        ...appState,
        selectedElementIds: {},
        selectedGroupIds: {},
        activeEmbeddable: null,
        activeTool
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => !event.altKey && !event[KEYS.CTRL_OR_CMD] && event.key === KEYS.H
});

// actions/actionFinalize.tsx
init_define_import_meta_env();
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
var actionFinalize = register({
  name: "finalize",
  label: "",
  trackEvent: false,
  perform: (elements, appState, _, app) => {
    const { interactiveCanvas, focusContainer, scene } = app;
    const elementsMap = scene.getNonDeletedElementsMap();
    if (appState.editingLinearElement) {
      const { elementId, startBindingElement, endBindingElement } = appState.editingLinearElement;
      const element = LinearElementEditor.getElement(elementId, elementsMap);
      if (element) {
        if (isBindingElement(element)) {
          bindOrUnbindLinearElement(
            element,
            startBindingElement,
            endBindingElement,
            elementsMap,
            scene
          );
        }
        return {
          elements: element.points.length < 2 || isInvisiblySmallElement(element) ? elements.filter((el) => el.id !== element.id) : void 0,
          appState: {
            ...appState,
            cursorButton: "up",
            editingLinearElement: null
          },
          storeAction: StoreAction.CAPTURE
        };
      }
    }
    let newElements = elements;
    const pendingImageElement = appState.pendingImageElementId && scene.getElement(appState.pendingImageElementId);
    if (pendingImageElement) {
      mutateElement(pendingImageElement, { isDeleted: true }, false);
    }
    if (window.document.activeElement instanceof HTMLElement) {
      focusContainer();
    }
    const multiPointElement = appState.multiElement ? appState.multiElement : appState.newElement?.type === "freedraw" ? appState.newElement : null;
    if (multiPointElement) {
      if (multiPointElement.type !== "freedraw" && appState.lastPointerDownWith !== "touch") {
        const { points, lastCommittedPoint } = multiPointElement;
        if (!lastCommittedPoint || points[points.length - 1] !== lastCommittedPoint) {
          mutateElement(multiPointElement, {
            points: multiPointElement.points.slice(0, -1)
          });
        }
      }
      if (isInvisiblySmallElement(multiPointElement)) {
        newElements = newElements.filter(
          (el) => el.id !== multiPointElement.id
        );
      }
      const isLoop = isPathALoop(multiPointElement.points, appState.zoom.value);
      if (multiPointElement.type === "line" || multiPointElement.type === "freedraw") {
        if (isLoop) {
          const linePoints = multiPointElement.points;
          const firstPoint = linePoints[0];
          mutateElement(multiPointElement, {
            points: linePoints.map(
              (p3, index2) => index2 === linePoints.length - 1 ? pointFrom(firstPoint[0], firstPoint[1]) : p3
            )
          });
        }
      }
      if (isBindingElement(multiPointElement) && !isLoop && multiPointElement.points.length > 1) {
        const [x3, y3] = LinearElementEditor.getPointAtIndexGlobalCoordinates(
          multiPointElement,
          -1,
          arrayToMap(elements)
        );
        maybeBindLinearElement(
          multiPointElement,
          appState,
          { x: x3, y: y3 },
          elementsMap,
          elements
        );
      }
    }
    if (!appState.activeTool.locked && appState.activeTool.type !== "freedraw" || !multiPointElement) {
      resetCursor(interactiveCanvas);
    }
    let activeTool;
    if (appState.activeTool.type === "eraser") {
      activeTool = updateActiveTool(appState, {
        ...appState.activeTool.lastActiveTool || {
          type: "selection"
        },
        lastActiveToolBeforeEraser: null
      });
    } else {
      activeTool = updateActiveTool(appState, {
        type: "selection"
      });
    }
    return {
      elements: newElements,
      appState: {
        ...appState,
        cursorButton: "up",
        activeTool: (appState.activeTool.locked || appState.activeTool.type === "freedraw") && multiPointElement ? appState.activeTool : activeTool,
        activeEmbeddable: null,
        newElement: null,
        selectionElement: null,
        multiElement: null,
        editingTextElement: null,
        startBoundElement: null,
        suggestedBindings: [],
        selectedElementIds: multiPointElement && !appState.activeTool.locked && appState.activeTool.type !== "freedraw" ? {
          ...appState.selectedElementIds,
          [multiPointElement.id]: true
        } : appState.selectedElementIds,
        // To select the linear element when user has finished mutipoint editing
        selectedLinearElement: multiPointElement && isLinearElement(multiPointElement) ? new LinearElementEditor(multiPointElement) : appState.selectedLinearElement,
        pendingImageElementId: null
      },
      // TODO: #7348 we should not capture everything, but if we don't, it leads to incosistencies -> revisit
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event, appState) => event.key === KEYS.ESCAPE && (appState.editingLinearElement !== null || !appState.newElement && appState.multiElement === null) || (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) && appState.multiElement !== null,
  PanelComponent: ({ appState, updateData, data }) => /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
    ToolButton,
    {
      type: "button",
      icon: done,
      title: t("buttons.done"),
      "aria-label": t("buttons.done"),
      onClick: updateData,
      visible: appState.multiElement != null,
      size: data?.size || "medium",
      style: { pointerEvents: "all" }
    }
  )
});

// actions/actionExport.tsx
init_define_import_meta_env();

// components/ProjectName.tsx
init_define_import_meta_env();
var import_react51 = __toESM(require_react(), 1);
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
var ProjectName = (props) => {
  const { id } = useExcalidrawContainer();
  const [fileName, setFileName] = (0, import_react51.useState)(props.value);
  const handleBlur = (event) => {
    if (!props.ignoreFocus) {
      focusNearestParent(event.target);
    }
    const value = event.target.value;
    if (value !== props.value) {
      props.onChange(value);
    }
  };
  const handleKeyDown = (event) => {
    if (event.key === KEYS.ENTER) {
      event.preventDefault();
      if (event.nativeEvent.isComposing || event.keyCode === 229) {
        return;
      }
      event.currentTarget.blur();
    }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: "ProjectName", children: [
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("label", { className: "ProjectName-label", htmlFor: "filename", children: `${props.label}:` }),
    /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
      "input",
      {
        type: "text",
        className: "TextInput",
        onBlur: handleBlur,
        onKeyDown: handleKeyDown,
        id: `${id}-filename`,
        value: fileName,
        onChange: (event) => setFileName(event.target.value)
      }
    )
  ] });
};

// components/DarkModeToggle.tsx
init_define_import_meta_env();
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var DarkModeToggle = (props) => {
  const title = props.title || (props.value === THEME.DARK ? t("buttons.lightMode") : t("buttons.darkMode"));
  return /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
    ToolButton,
    {
      type: "icon",
      icon: props.value === THEME.LIGHT ? ICONS.MOON : ICONS.SUN,
      title,
      "aria-label": title,
      onClick: () => props.onChange(props.value === THEME.DARK ? THEME.LIGHT : THEME.DARK),
      "data-testid": "toggle-dark-mode"
    }
  );
};
var ICONS = {
  SUN: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)("svg", { width: "512", height: "512", className: "rtl-mirror", viewBox: "0 0 512 512", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
    "path",
    {
      fill: "currentColor",
      d: "M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z"
    }
  ) }),
  MOON: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)("svg", { width: "512", height: "512", className: "rtl-mirror", viewBox: "0 0 512 512", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
    "path",
    {
      fill: "currentColor",
      d: "M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 0 0 283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z"
    }
  ) })
};

// data/index.ts
init_define_import_meta_env();
var prepareElementsForExport = (elements, { selectedElementIds }, exportSelectionOnly) => {
  elements = getNonDeletedElements(elements);
  const isExportingSelection = exportSelectionOnly && isSomeElementSelected(elements, { selectedElementIds });
  let exportingFrame = null;
  let exportedElements = isExportingSelection ? getSelectedElements(
    elements,
    { selectedElementIds },
    {
      includeBoundTextElement: true
    }
  ) : elements;
  if (isExportingSelection) {
    if (exportedElements.length === 1 && isFrameLikeElement(exportedElements[0])) {
      exportingFrame = exportedElements[0];
      exportedElements = getElementsOverlappingFrame(elements, exportingFrame);
    } else if (exportedElements.length > 1) {
      exportedElements = getSelectedElements(
        elements,
        { selectedElementIds },
        {
          includeBoundTextElement: true,
          includeElementsInFrames: true
        }
      );
    }
  }
  return {
    exportingFrame,
    exportedElements: cloneJSON(exportedElements)
  };
};
var exportCanvas = async (type, elements, appState, files, {
  exportBackground,
  exportPadding = DEFAULT_EXPORT_PADDING,
  viewBackgroundColor,
  name = appState.name || DEFAULT_FILENAME,
  fileHandle = null,
  exportingFrame = null
}) => {
  if (elements.length === 0) {
    throw new Error(t("alerts.cannotExportEmptyCanvas"));
  }
  if (type === "svg" || type === "clipboard-svg") {
    const svgPromise = exportToSvg(
      elements,
      {
        exportBackground,
        exportWithDarkMode: appState.exportWithDarkMode,
        viewBackgroundColor,
        exportPadding,
        exportScale: appState.exportScale,
        exportEmbedScene: appState.exportEmbedScene && type === "svg"
      },
      files,
      { exportingFrame }
    );
    if (type === "svg") {
      return fileSave(
        svgPromise.then((svg) => {
          return new Blob([svg.outerHTML], { type: MIME_TYPES.svg });
        }),
        {
          description: "Export to SVG",
          name,
          extension: appState.exportEmbedScene ? "excalidraw.svg" : "svg",
          fileHandle
        }
      );
    } else if (type === "clipboard-svg") {
      const svg = await svgPromise.then((svg2) => svg2.outerHTML);
      try {
        await copyTextToSystemClipboard(svg);
      } catch (e3) {
        throw new Error(t("errors.copyToSystemClipboardFailed"));
      }
      return;
    }
  }
  const tempCanvas = exportToCanvas(elements, appState, files, {
    exportBackground,
    viewBackgroundColor,
    exportPadding,
    exportingFrame
  });
  if (type === "png") {
    let blob = canvasToBlob(tempCanvas);
    if (appState.exportEmbedScene) {
      blob = blob.then(
        (blob2) => import("./excalidraw-assets-dev/image-VQG6JJBF.js").then(
          ({ encodePngMetadata }) => encodePngMetadata({
            blob: blob2,
            metadata: serializeAsJSON(elements, appState, files, "local")
          })
        )
      );
    }
    return fileSave(blob, {
      description: "Export to PNG",
      name,
      // FIXME reintroduce `excalidraw.png` when most people upgrade away
      // from 111.0.5563.64 (arm64), see #6349
      extension: (
        /* appState.exportEmbedScene ? "excalidraw.png" : */
        "png"
      ),
      fileHandle
    });
  } else if (type === "clipboard") {
    try {
      const blob = canvasToBlob(tempCanvas);
      await copyBlobToClipboardAsPng(blob);
    } catch (error) {
      console.warn(error);
      if (error.name === "CANVAS_POSSIBLY_TOO_BIG") {
        throw new Error(t("canvasError.canvasTooBig"));
      }
      if (isFirefox && error.name === "TypeError") {
        throw new Error(
          `${t("alerts.couldNotCopyToClipboard")}

${t(
            "hints.firefox_clipboard_write"
          )}`
        );
      } else {
        throw new Error(t("alerts.couldNotCopyToClipboard"));
      }
    }
  } else {
    throw new Error("Unsupported export type");
  }
};

// data/resave.ts
init_define_import_meta_env();
var resaveAsImageWithScene = async (elements, appState, files, name) => {
  const { exportBackground, viewBackgroundColor, fileHandle } = appState;
  const fileHandleType = getFileHandleType(fileHandle);
  if (!fileHandle || !isImageFileHandleType(fileHandleType)) {
    throw new Error(
      "fileHandle should exist and should be of type svg or png when resaving"
    );
  }
  appState = {
    ...appState,
    exportEmbedScene: true
  };
  const { exportedElements, exportingFrame } = prepareElementsForExport(
    elements,
    appState,
    false
  );
  await exportCanvas(fileHandleType, exportedElements, appState, files, {
    exportBackground,
    viewBackgroundColor,
    name,
    fileHandle,
    exportingFrame
  });
  return { fileHandle };
};

// components/CheckboxItem.tsx
init_define_import_meta_env();
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var CheckboxItem = ({ children, checked, onChange, className }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime39.jsxs)(
    "div",
    {
      className: clsx_m_default("Checkbox", className, { "is-checked": checked }),
      onClick: (event) => {
        onChange(!checked, event);
        event.currentTarget.querySelector(
          ".Checkbox-box"
        ).focus();
      },
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(
          "button",
          {
            type: "button",
            className: "Checkbox-box",
            role: "checkbox",
            "aria-checked": checked,
            children: checkIcon
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime39.jsx)("div", { className: "Checkbox-label", children })
      ]
    }
  );
};

// actions/actionExport.tsx
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var actionChangeProjectName = register({
  name: "changeProjectName",
  label: "labels.fileTitle",
  trackEvent: false,
  perform: (_elements, appState, value) => {
    return {
      appState: { ...appState, name: value },
      storeAction: StoreAction.NONE
    };
  },
  PanelComponent: ({ appState, updateData, appProps, data, app }) => /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
    ProjectName,
    {
      label: t("labels.fileTitle"),
      value: app.getName(),
      onChange: (name) => updateData(name),
      ignoreFocus: data?.ignoreFocus ?? false
    }
  )
});
var actionChangeExportScale = register({
  name: "changeExportScale",
  label: "imageExportDialog.scale",
  trackEvent: { category: "export", action: "scale" },
  perform: (_elements, appState, value) => {
    return {
      appState: { ...appState, exportScale: value },
      storeAction: StoreAction.NONE
    };
  },
  PanelComponent: ({ elements: allElements, appState, updateData }) => {
    const elements = getNonDeletedElements(allElements);
    const exportSelected = isSomeElementSelected(elements, appState);
    const exportedElements = exportSelected ? getSelectedElements(elements, appState) : elements;
    return /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(import_jsx_runtime40.Fragment, { children: EXPORT_SCALES.map((s3) => {
      const [width, height] = getExportSize(
        exportedElements,
        DEFAULT_EXPORT_PADDING,
        s3
      );
      const scaleButtonTitle = `${t(
        "imageExportDialog.label.scale"
      )} ${s3}x (${width}x${height})`;
      return /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
        ToolButton,
        {
          size: "small",
          type: "radio",
          icon: `${s3}x`,
          name: "export-canvas-scale",
          title: scaleButtonTitle,
          "aria-label": scaleButtonTitle,
          id: "export-canvas-scale",
          checked: s3 === appState.exportScale,
          onChange: () => updateData(s3)
        },
        s3
      );
    }) });
  }
});
var actionChangeExportBackground = register({
  name: "changeExportBackground",
  label: "imageExportDialog.label.withBackground",
  trackEvent: { category: "export", action: "toggleBackground" },
  perform: (_elements, appState, value) => {
    return {
      appState: { ...appState, exportBackground: value },
      storeAction: StoreAction.NONE
    };
  },
  PanelComponent: ({ appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
    CheckboxItem,
    {
      checked: appState.exportBackground,
      onChange: (checked) => updateData(checked),
      children: t("imageExportDialog.label.withBackground")
    }
  )
});
var actionChangeExportEmbedScene = register({
  name: "changeExportEmbedScene",
  label: "imageExportDialog.tooltip.embedScene",
  trackEvent: { category: "export", action: "embedScene" },
  perform: (_elements, appState, value) => {
    return {
      appState: { ...appState, exportEmbedScene: value },
      storeAction: StoreAction.NONE
    };
  },
  PanelComponent: ({ appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)(
    CheckboxItem,
    {
      checked: appState.exportEmbedScene,
      onChange: (checked) => updateData(checked),
      children: [
        t("imageExportDialog.label.embedScene"),
        /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(Tooltip, { label: t("imageExportDialog.tooltip.embedScene"), long: true, children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)("div", { className: "excalidraw-tooltip-icon", children: questionCircle }) })
      ]
    }
  )
});
var actionSaveToActiveFile = register({
  name: "saveToActiveFile",
  label: "buttons.save",
  icon: ExportIcon,
  trackEvent: { category: "export" },
  predicate: (elements, appState, props, app) => {
    return !!app.props.UIOptions.canvasActions.saveToActiveFile && !!appState.fileHandle && !appState.viewModeEnabled;
  },
  perform: async (elements, appState, value, app) => {
    const fileHandleExists = !!appState.fileHandle;
    try {
      const { fileHandle } = isImageFileHandle(appState.fileHandle) ? await resaveAsImageWithScene(
        elements,
        appState,
        app.files,
        app.getName()
      ) : await saveAsJSON(elements, appState, app.files, app.getName());
      return {
        storeAction: StoreAction.NONE,
        appState: {
          ...appState,
          fileHandle,
          toast: fileHandleExists ? {
            message: fileHandle?.name ? t("toast.fileSavedToFilename").replace(
              "{filename}",
              `"${fileHandle.name}"`
            ) : t("toast.fileSaved")
          } : null
        }
      };
    } catch (error) {
      if (error?.name !== "AbortError") {
        console.error(error);
      } else {
        console.warn(error);
      }
      return { storeAction: StoreAction.NONE };
    }
  },
  keyTest: (event) => event.key === KEYS.S && event[KEYS.CTRL_OR_CMD] && !event.shiftKey
});
var actionSaveFileToDisk = register({
  name: "saveFileToDisk",
  label: "exportDialog.disk_title",
  icon: ExportIcon,
  viewMode: true,
  trackEvent: { category: "export" },
  perform: async (elements, appState, value, app) => {
    try {
      const { fileHandle } = await saveAsJSON(
        elements,
        {
          ...appState,
          fileHandle: null
        },
        app.files,
        app.getName()
      );
      return {
        storeAction: StoreAction.NONE,
        appState: {
          ...appState,
          openDialog: null,
          fileHandle,
          toast: { message: t("toast.fileSaved") }
        }
      };
    } catch (error) {
      if (error?.name !== "AbortError") {
        console.error(error);
      } else {
        console.warn(error);
      }
      return { storeAction: StoreAction.NONE };
    }
  },
  keyTest: (event) => event.key === KEYS.S && event.shiftKey && event[KEYS.CTRL_OR_CMD],
  PanelComponent: ({ updateData }) => /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
    ToolButton,
    {
      type: "button",
      icon: saveAs,
      title: t("buttons.saveAs"),
      "aria-label": t("buttons.saveAs"),
      showAriaLabel: useDevice().editor.isMobile,
      hidden: !e,
      onClick: () => updateData(null),
      "data-testid": "save-as-button"
    }
  )
});
var actionLoadScene = register({
  name: "loadScene",
  label: "buttons.load",
  trackEvent: { category: "export" },
  predicate: (elements, appState, props, app) => {
    return !!app.props.UIOptions.canvasActions.loadScene && !appState.viewModeEnabled;
  },
  perform: async (elements, appState, _, app) => {
    try {
      const {
        elements: loadedElements,
        appState: loadedAppState,
        files
      } = await loadFromJSON(appState, elements);
      return {
        elements: loadedElements,
        appState: loadedAppState,
        files,
        storeAction: StoreAction.CAPTURE
      };
    } catch (error) {
      if (error?.name === "AbortError") {
        console.warn(error);
        return false;
      }
      return {
        elements,
        appState: { ...appState, errorMessage: error.message },
        files: app.files,
        storeAction: StoreAction.NONE
      };
    }
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.O
});
var actionExportWithDarkMode = register({
  name: "exportWithDarkMode",
  label: "imageExportDialog.label.darkMode",
  trackEvent: { category: "export", action: "toggleTheme" },
  perform: (_elements, appState, value) => {
    return {
      appState: { ...appState, exportWithDarkMode: value },
      storeAction: StoreAction.NONE
    };
  },
  PanelComponent: ({ appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
    "div",
    {
      style: {
        display: "flex",
        justifyContent: "flex-end",
        marginTop: "-45px",
        marginBottom: "10px"
      },
      children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
        DarkModeToggle,
        {
          value: appState.exportWithDarkMode ? THEME.DARK : THEME.LIGHT,
          onChange: (theme) => {
            updateData(theme === THEME.DARK);
          },
          title: t("imageExportDialog.label.darkMode")
        }
      )
    }
  )
});

// actions/actionStyles.ts
init_define_import_meta_env();
var copiedStyles = "{}";
var actionCopyStyles = register({
  name: "copyStyles",
  label: "labels.copyStyles",
  icon: paintIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState, formData, app) => {
    const elementsCopied = [];
    const element = elements.find((el) => appState.selectedElementIds[el.id]);
    elementsCopied.push(element);
    if (element && hasBoundTextElement(element)) {
      const boundTextElement = getBoundTextElement(
        element,
        app.scene.getNonDeletedElementsMap()
      );
      elementsCopied.push(boundTextElement);
    }
    if (element) {
      copiedStyles = JSON.stringify(elementsCopied);
    }
    return {
      appState: {
        ...appState,
        toast: { message: t("toast.copyStyles") }
      },
      storeAction: StoreAction.NONE
    };
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.C
});
var actionPasteStyles = register({
  name: "pasteStyles",
  label: "labels.pasteStyles",
  icon: paintIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState, formData, app) => {
    const elementsCopied = JSON.parse(copiedStyles);
    const pastedElement = elementsCopied[0];
    const boundTextElement = elementsCopied[1];
    if (!isExcalidrawElement(pastedElement)) {
      return { elements, storeAction: StoreAction.NONE };
    }
    const selectedElements = getSelectedElements(elements, appState, {
      includeBoundTextElement: true
    });
    const selectedElementIds = selectedElements.map((element) => element.id);
    return {
      elements: elements.map((element) => {
        if (selectedElementIds.includes(element.id)) {
          let elementStylesToCopyFrom = pastedElement;
          if (isTextElement(element) && element.containerId) {
            elementStylesToCopyFrom = boundTextElement;
          }
          if (!elementStylesToCopyFrom) {
            return element;
          }
          let newElement2 = newElementWith(element, {
            backgroundColor: elementStylesToCopyFrom?.backgroundColor,
            strokeWidth: elementStylesToCopyFrom?.strokeWidth,
            strokeColor: elementStylesToCopyFrom?.strokeColor,
            strokeStyle: elementStylesToCopyFrom?.strokeStyle,
            fillStyle: elementStylesToCopyFrom?.fillStyle,
            opacity: elementStylesToCopyFrom?.opacity,
            roughness: elementStylesToCopyFrom?.roughness,
            roundness: elementStylesToCopyFrom.roundness ? canApplyRoundnessTypeToElement(
              elementStylesToCopyFrom.roundness.type,
              element
            ) ? elementStylesToCopyFrom.roundness : getDefaultRoundnessTypeForElement(element) : null
          });
          if (isTextElement(newElement2)) {
            const fontSize = elementStylesToCopyFrom.fontSize || DEFAULT_FONT_SIZE;
            const fontFamily = elementStylesToCopyFrom.fontFamily || DEFAULT_FONT_FAMILY;
            newElement2 = newElementWith(newElement2, {
              fontSize,
              fontFamily,
              textAlign: elementStylesToCopyFrom.textAlign || DEFAULT_TEXT_ALIGN,
              lineHeight: elementStylesToCopyFrom.lineHeight || getLineHeight(fontFamily)
            });
            let container = null;
            if (newElement2.containerId) {
              container = selectedElements.find(
                (element2) => isTextElement(newElement2) && element2.id === newElement2.containerId
              ) || null;
            }
            redrawTextBoundingBox(
              newElement2,
              container,
              app.scene.getNonDeletedElementsMap()
            );
          }
          if (newElement2.type === "arrow" && isArrowElement(elementStylesToCopyFrom)) {
            newElement2 = newElementWith(newElement2, {
              startArrowhead: elementStylesToCopyFrom.startArrowhead,
              endArrowhead: elementStylesToCopyFrom.endArrowhead
            });
          }
          if (isFrameLikeElement(element)) {
            newElement2 = newElementWith(newElement2, {
              roundness: null,
              backgroundColor: "transparent"
            });
          }
          return newElement2;
        }
        return element;
      }),
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.V
});

// actions/actionMenu.tsx
init_define_import_meta_env();
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var actionToggleCanvasMenu = register({
  name: "toggleCanvasMenu",
  label: "buttons.menu",
  trackEvent: { category: "menu" },
  perform: (_, appState) => ({
    appState: {
      ...appState,
      openMenu: appState.openMenu === "canvas" ? null : "canvas"
    },
    storeAction: StoreAction.NONE
  }),
  PanelComponent: ({ appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
    ToolButton,
    {
      type: "button",
      icon: HamburgerMenuIcon,
      "aria-label": t("buttons.menu"),
      onClick: updateData,
      selected: appState.openMenu === "canvas"
    }
  )
});
var actionToggleEditMenu = register({
  name: "toggleEditMenu",
  label: "buttons.edit",
  trackEvent: { category: "menu" },
  perform: (_elements, appState) => ({
    appState: {
      ...appState,
      openMenu: appState.openMenu === "shape" ? null : "shape"
    },
    storeAction: StoreAction.NONE
  }),
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
    ToolButton,
    {
      visible: showSelectedShapeActions(
        appState,
        getNonDeletedElements(elements)
      ),
      type: "button",
      icon: palette,
      "aria-label": t("buttons.edit"),
      onClick: updateData,
      selected: appState.openMenu === "shape"
    }
  )
});
var actionShortcuts = register({
  name: "toggleShortcuts",
  label: "welcomeScreen.defaults.helpHint",
  icon: HelpIconThin,
  viewMode: true,
  trackEvent: { category: "menu", action: "toggleHelpDialog" },
  perform: (_elements, appState, _, { focusContainer }) => {
    if (appState.openDialog?.name === "help") {
      focusContainer();
    }
    return {
      appState: {
        ...appState,
        openDialog: appState.openDialog?.name === "help" ? null : {
          name: "help"
        }
      },
      storeAction: StoreAction.NONE
    };
  },
  keyTest: (event) => event.key === KEYS.QUESTION_MARK
});

// actions/actionGroup.tsx
init_define_import_meta_env();
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
var allElementsInSameGroup = (elements) => {
  if (elements.length >= 2) {
    const groupIds = elements[0].groupIds;
    for (const groupId of groupIds) {
      if (elements.reduce(
        (acc, element) => acc && isElementInGroup(element, groupId),
        true
      )) {
        return true;
      }
    }
  }
  return false;
};
var enableActionGroup = (elements, appState, app) => {
  const selectedElements = app.scene.getSelectedElements({
    selectedElementIds: appState.selectedElementIds,
    includeBoundTextElement: true
  });
  return selectedElements.length >= 2 && !allElementsInSameGroup(selectedElements);
};
var actionGroup = register({
  name: "group",
  label: "labels.group",
  icon: (appState) => /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(GroupIcon, { theme: appState.theme }),
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true
    });
    if (selectedElements.length < 2) {
      return { appState, elements, storeAction: StoreAction.NONE };
    }
    const selectedGroupIds = getSelectedGroupIds(appState);
    if (selectedGroupIds.length === 1) {
      const selectedGroupId = selectedGroupIds[0];
      const elementIdsInGroup = new Set(
        getElementsInGroup(elements, selectedGroupId).map(
          (element) => element.id
        )
      );
      const selectedElementIds = new Set(
        selectedElements.map((element) => element.id)
      );
      const combinedSet = /* @__PURE__ */ new Set([
        ...Array.from(elementIdsInGroup),
        ...Array.from(selectedElementIds)
      ]);
      if (combinedSet.size === elementIdsInGroup.size) {
        return { appState, elements, storeAction: StoreAction.NONE };
      }
    }
    let nextElements = [...elements];
    const groupingElementsFromDifferentFrames = new Set(selectedElements.map((element) => element.frameId)).size > 1;
    if (groupingElementsFromDifferentFrames) {
      const frameElementsMap = groupByFrameLikes(selectedElements);
      frameElementsMap.forEach((elementsInFrame, frameId) => {
        removeElementsFromFrame(
          elementsInFrame,
          app.scene.getNonDeletedElementsMap()
        );
      });
    }
    const newGroupId = randomId();
    const selectElementIds = arrayToMap(selectedElements);
    nextElements = nextElements.map((element) => {
      if (!selectElementIds.get(element.id)) {
        return element;
      }
      return newElementWith(element, {
        groupIds: addToGroup(
          element.groupIds,
          newGroupId,
          appState.editingGroupId
        )
      });
    });
    const elementsInGroup = getElementsInGroup(nextElements, newGroupId);
    const lastElementInGroup = elementsInGroup[elementsInGroup.length - 1];
    const lastGroupElementIndex = nextElements.lastIndexOf(
      lastElementInGroup
    );
    const elementsAfterGroup = nextElements.slice(lastGroupElementIndex + 1);
    const elementsBeforeGroup = nextElements.slice(0, lastGroupElementIndex).filter(
      (updatedElement) => !isElementInGroup(updatedElement, newGroupId)
    );
    const reorderedElements = syncMovedIndices(
      [...elementsBeforeGroup, ...elementsInGroup, ...elementsAfterGroup],
      arrayToMap(elementsInGroup)
    );
    return {
      appState: {
        ...appState,
        ...selectGroup(
          newGroupId,
          { ...appState, selectedGroupIds: {} },
          getNonDeletedElements(nextElements)
        )
      },
      elements: reorderedElements,
      storeAction: StoreAction.CAPTURE
    };
  },
  predicate: (elements, appState, _, app) => enableActionGroup(elements, appState, app),
  keyTest: (event) => !event.shiftKey && event[KEYS.CTRL_OR_CMD] && event.key === KEYS.G,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
    ToolButton,
    {
      hidden: !enableActionGroup(elements, appState, app),
      type: "button",
      icon: /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(GroupIcon, { theme: appState.theme }),
      onClick: () => updateData(null),
      title: `${t("labels.group")} \u2014 ${getShortcutKey("CtrlOrCmd+G")}`,
      "aria-label": t("labels.group"),
      visible: isSomeElementSelected(getNonDeletedElements(elements), appState)
    }
  )
});
var actionUngroup = register({
  name: "ungroup",
  label: "labels.ungroup",
  icon: (appState) => /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(UngroupIcon, { theme: appState.theme }),
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    const groupIds = getSelectedGroupIds(appState);
    const elementsMap = arrayToMap(elements);
    if (groupIds.length === 0) {
      return { appState, elements, storeAction: StoreAction.NONE };
    }
    let nextElements = [...elements];
    const boundTextElementIds = [];
    nextElements = nextElements.map((element) => {
      if (isBoundToContainer(element)) {
        boundTextElementIds.push(element.id);
      }
      const nextGroupIds = removeFromSelectedGroups(
        element.groupIds,
        appState.selectedGroupIds
      );
      if (nextGroupIds.length === element.groupIds.length) {
        return element;
      }
      return newElementWith(element, {
        groupIds: nextGroupIds
      });
    });
    const updateAppState = selectGroupsForSelectedElements(
      appState,
      getNonDeletedElements(nextElements),
      appState,
      null
    );
    const selectedElements = app.scene.getSelectedElements(appState);
    const selectedElementFrameIds = new Set(
      selectedElements.filter((element) => element.frameId).map((element) => element.frameId)
    );
    const targetFrames = getFrameLikeElements(elements).filter(
      (frame) => selectedElementFrameIds.has(frame.id)
    );
    targetFrames.forEach((frame) => {
      if (frame) {
        nextElements = replaceAllElementsInFrame(
          nextElements,
          getElementsInResizingFrame(
            nextElements,
            frame,
            appState,
            elementsMap
          ),
          frame,
          app
        );
      }
    });
    updateAppState.selectedElementIds = Object.entries(
      updateAppState.selectedElementIds
    ).reduce(
      (acc, [id, selected]) => {
        if (selected && !boundTextElementIds.includes(id)) {
          acc[id] = true;
        }
        return acc;
      },
      {}
    );
    return {
      appState: { ...appState, ...updateAppState },
      elements: nextElements,
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => event.shiftKey && event[KEYS.CTRL_OR_CMD] && event.key === KEYS.G.toUpperCase(),
  predicate: (elements, appState) => getSelectedGroupIds(appState).length > 0,
  PanelComponent: ({ elements, appState, updateData }) => /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
    ToolButton,
    {
      type: "button",
      hidden: getSelectedGroupIds(appState).length === 0,
      icon: /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(UngroupIcon, { theme: appState.theme }),
      onClick: () => updateData(null),
      title: `${t("labels.ungroup")} \u2014 ${getShortcutKey("CtrlOrCmd+Shift+G")}`,
      "aria-label": t("labels.ungroup"),
      visible: isSomeElementSelected(getNonDeletedElements(elements), appState)
    }
  )
});

// actions/actionNavigate.tsx
init_define_import_meta_env();

// clients.ts
init_define_import_meta_env();

// renderer/roundRect.ts
init_define_import_meta_env();
var roundRect = (context, x3, y3, width, height, radius, strokeColor) => {
  context.beginPath();
  context.moveTo(x3 + radius, y3);
  context.lineTo(x3 + width - radius, y3);
  context.quadraticCurveTo(x3 + width, y3, x3 + width, y3 + radius);
  context.lineTo(x3 + width, y3 + height - radius);
  context.quadraticCurveTo(
    x3 + width,
    y3 + height,
    x3 + width - radius,
    y3 + height
  );
  context.lineTo(x3 + radius, y3 + height);
  context.quadraticCurveTo(x3, y3 + height, x3, y3 + height - radius);
  context.lineTo(x3, y3 + radius);
  context.quadraticCurveTo(x3, y3, x3 + radius, y3);
  context.closePath();
  context.fill();
  if (strokeColor) {
    context.strokeStyle = strokeColor;
  }
  context.stroke();
};

// types.ts
init_define_import_meta_env();

// clients.ts
function hashToInteger(id) {
  let hash = 0;
  if (id.length === 0) {
    return hash;
  }
  for (let i3 = 0; i3 < id.length; i3++) {
    const char = id.charCodeAt(i3);
    hash = (hash << 5) - hash + char;
  }
  return hash;
}
var getClientColor = (socketId, collaborator) => {
  const hash = Math.abs(hashToInteger(collaborator?.id || socketId));
  const hue = hash % 37 * 10;
  const saturation = 100;
  const lightness = 83;
  return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
};
var getNameInitial = (name) => {
  const firstCodePoint = name?.trim()?.codePointAt(0);
  return (firstCodePoint ? String.fromCodePoint(firstCodePoint) : "?").toUpperCase();
};
var renderRemoteCursors = ({
  context,
  renderConfig,
  appState,
  normalizedWidth,
  normalizedHeight
}) => {
  for (const [socketId, pointer] of renderConfig.remotePointerViewportCoords) {
    let { x: x3, y: y3 } = pointer;
    const collaborator = appState.collaborators.get(socketId);
    x3 -= appState.offsetLeft;
    y3 -= appState.offsetTop;
    const width = 11;
    const height = 14;
    const isOutOfBounds = x3 < 0 || x3 > normalizedWidth - width || y3 < 0 || y3 > normalizedHeight - height;
    x3 = Math.max(x3, 0);
    x3 = Math.min(x3, normalizedWidth - width);
    y3 = Math.max(y3, 0);
    y3 = Math.min(y3, normalizedHeight - height);
    const background = getClientColor(socketId, collaborator);
    context.save();
    context.strokeStyle = background;
    context.fillStyle = background;
    const userState = renderConfig.remotePointerUserStates.get(socketId);
    const isInactive = isOutOfBounds || userState === "idle" /* IDLE */ || userState === "away" /* AWAY */;
    if (isInactive) {
      context.globalAlpha = 0.3;
    }
    if (renderConfig.remotePointerButton.get(socketId) === "down") {
      context.beginPath();
      context.arc(x3, y3, 15, 0, 2 * Math.PI, false);
      context.lineWidth = 3;
      context.strokeStyle = "#ffffff88";
      context.stroke();
      context.closePath();
      context.beginPath();
      context.arc(x3, y3, 15, 0, 2 * Math.PI, false);
      context.lineWidth = 1;
      context.strokeStyle = background;
      context.stroke();
      context.closePath();
    }
    const IS_SPEAKING_COLOR = appState.theme === THEME.DARK ? "#2f6330" : COLOR_VOICE_CALL;
    const isSpeaking = collaborator?.isSpeaking;
    if (isSpeaking) {
      context.fillStyle = IS_SPEAKING_COLOR;
      context.strokeStyle = IS_SPEAKING_COLOR;
      context.lineWidth = 10;
      context.lineJoin = "round";
      context.beginPath();
      context.moveTo(x3, y3);
      context.lineTo(x3 + 0, y3 + 14);
      context.lineTo(x3 + 4, y3 + 9);
      context.lineTo(x3 + 11, y3 + 8);
      context.closePath();
      context.stroke();
      context.fill();
    }
    context.fillStyle = COLOR_WHITE;
    context.strokeStyle = COLOR_WHITE;
    context.lineWidth = 6;
    context.lineJoin = "round";
    context.beginPath();
    context.moveTo(x3, y3);
    context.lineTo(x3 + 0, y3 + 14);
    context.lineTo(x3 + 4, y3 + 9);
    context.lineTo(x3 + 11, y3 + 8);
    context.closePath();
    context.stroke();
    context.fill();
    context.fillStyle = background;
    context.strokeStyle = background;
    context.lineWidth = 2;
    context.lineJoin = "round";
    context.beginPath();
    if (isInactive) {
      context.moveTo(x3 - 1, y3 - 1);
      context.lineTo(x3 - 1, y3 + 15);
      context.lineTo(x3 + 5, y3 + 10);
      context.lineTo(x3 + 12, y3 + 9);
      context.closePath();
      context.fill();
    } else {
      context.moveTo(x3, y3);
      context.lineTo(x3 + 0, y3 + 14);
      context.lineTo(x3 + 4, y3 + 9);
      context.lineTo(x3 + 11, y3 + 8);
      context.closePath();
      context.fill();
      context.stroke();
    }
    const username = renderConfig.remotePointerUsernames.get(socketId) || "";
    if (!isOutOfBounds && username) {
      context.font = "600 12px sans-serif";
      const offsetX = (isSpeaking ? x3 + 0 : x3) + width / 2;
      const offsetY = (isSpeaking ? y3 + 0 : y3) + height + 2;
      const paddingHorizontal = 5;
      const paddingVertical = 3;
      const measure = context.measureText(username);
      const measureHeight = measure.actualBoundingBoxDescent + measure.actualBoundingBoxAscent;
      const finalHeight = Math.max(measureHeight, 12);
      const boxX = offsetX - 1;
      const boxY = offsetY - 1;
      const boxWidth = measure.width + 2 + paddingHorizontal * 2 + 2;
      const boxHeight = finalHeight + 2 + paddingVertical * 2 + 2;
      if (context.roundRect) {
        context.beginPath();
        context.roundRect(boxX, boxY, boxWidth, boxHeight, 8);
        context.fillStyle = background;
        context.fill();
        context.strokeStyle = COLOR_WHITE;
        context.stroke();
        if (isSpeaking) {
          context.beginPath();
          context.roundRect(boxX - 2, boxY - 2, boxWidth + 4, boxHeight + 4, 8);
          context.strokeStyle = IS_SPEAKING_COLOR;
          context.stroke();
        }
      } else {
        roundRect(context, boxX, boxY, boxWidth, boxHeight, 8, COLOR_WHITE);
      }
      context.fillStyle = COLOR_CHARCOAL_BLACK;
      context.fillText(
        username,
        offsetX + paddingHorizontal + 1,
        offsetY + paddingVertical + measure.actualBoundingBoxAscent + Math.floor((finalHeight - measureHeight) / 2) + 2
      );
      if (isSpeaking) {
        context.fillStyle = IS_SPEAKING_COLOR;
        const barheight = 8;
        const margin = 8;
        const gap = 5;
        context.fillRect(
          boxX + boxWidth + margin,
          boxY + (boxHeight / 2 - barheight / 2),
          2,
          barheight
        );
        context.fillRect(
          boxX + boxWidth + margin + gap,
          boxY + (boxHeight / 2 - barheight * 2 / 2),
          2,
          barheight * 2
        );
        context.fillRect(
          boxX + boxWidth + margin + gap * 2,
          boxY + (boxHeight / 2 - barheight / 2),
          2,
          barheight
        );
      }
    }
    context.restore();
    context.closePath();
  }
};

// components/Avatar.tsx
init_define_import_meta_env();
var import_react52 = __toESM(require_react(), 1);
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var Avatar = ({
  color,
  onClick,
  name,
  src,
  className
}) => {
  const shortName = getNameInitial(name);
  const [error, setError] = (0, import_react52.useState)(false);
  const loadImg = !error && src;
  const style = loadImg ? void 0 : { background: color };
  return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("div", { className: clsx_m_default("Avatar", className), style, onClick, children: loadImg ? /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
    "img",
    {
      className: "Avatar-img",
      src,
      alt: shortName,
      referrerPolicy: "no-referrer",
      onError: () => setError(true)
    }
  ) : shortName });
};

// actions/actionNavigate.tsx
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
var actionGoToCollaborator = register({
  name: "goToCollaborator",
  label: "Go to a collaborator",
  viewMode: true,
  trackEvent: { category: "collab" },
  perform: (_elements, appState, collaborator) => {
    if (!collaborator.socketId || appState.userToFollow?.socketId === collaborator.socketId || collaborator.isCurrentUser) {
      return {
        appState: {
          ...appState,
          userToFollow: null
        },
        storeAction: StoreAction.NONE
      };
    }
    return {
      appState: {
        ...appState,
        userToFollow: {
          socketId: collaborator.socketId,
          username: collaborator.username || ""
        },
        // Close mobile menu
        openMenu: appState.openMenu === "canvas" ? null : appState.openMenu
      },
      storeAction: StoreAction.NONE
    };
  },
  PanelComponent: ({ updateData, data, appState }) => {
    const { socketId, collaborator, withName, isBeingFollowed } = data;
    const background = getClientColor(socketId, collaborator);
    const statusClassNames = clsx_m_default({
      "is-followed": isBeingFollowed,
      "is-current-user": collaborator.isCurrentUser === true,
      "is-speaking": collaborator.isSpeaking,
      "is-in-call": collaborator.isInCall,
      "is-muted": collaborator.isMuted
    });
    const statusIconJSX = collaborator.isInCall ? collaborator.isSpeaking ? /* @__PURE__ */ (0, import_jsx_runtime44.jsxs)(
      "div",
      {
        className: "UserList__collaborator-status-icon-speaking-indicator",
        title: t("userList.hint.isSpeaking"),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime44.jsx)("div", {}),
          /* @__PURE__ */ (0, import_jsx_runtime44.jsx)("div", {}),
          /* @__PURE__ */ (0, import_jsx_runtime44.jsx)("div", {})
        ]
      }
    ) : collaborator.isMuted ? /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(
      "div",
      {
        className: "UserList__collaborator-status-icon-microphone-muted",
        title: t("userList.hint.micMuted"),
        children: microphoneMutedIcon
      }
    ) : /* @__PURE__ */ (0, import_jsx_runtime44.jsx)("div", { title: t("userList.hint.inCall"), children: microphoneIcon }) : null;
    return withName ? /* @__PURE__ */ (0, import_jsx_runtime44.jsxs)(
      "div",
      {
        className: `dropdown-menu-item dropdown-menu-item-base UserList__collaborator ${statusClassNames}`,
        style: { [`--avatar-size`]: "1.5rem" },
        onClick: () => updateData(collaborator),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(
            Avatar,
            {
              color: background,
              onClick: () => {
              },
              name: collaborator.username || "",
              src: collaborator.avatarUrl,
              className: statusClassNames
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime44.jsx)("div", { className: "UserList__collaborator-name", children: collaborator.username }),
          /* @__PURE__ */ (0, import_jsx_runtime44.jsxs)("div", { className: "UserList__collaborator-status-icons", "aria-hidden": true, children: [
            isBeingFollowed && /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(
              "div",
              {
                className: "UserList__collaborator-status-icon-is-followed",
                title: t("userList.hint.followStatus"),
                children: eyeIcon
              }
            ),
            statusIconJSX
          ] })
        ]
      }
    ) : /* @__PURE__ */ (0, import_jsx_runtime44.jsxs)(
      "div",
      {
        className: `UserList__collaborator UserList__collaborator--avatar-only ${statusClassNames}`,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(
            Avatar,
            {
              color: background,
              onClick: () => {
                updateData(collaborator);
              },
              name: collaborator.username || "",
              src: collaborator.avatarUrl,
              className: statusClassNames
            }
          ),
          statusIconJSX && /* @__PURE__ */ (0, import_jsx_runtime44.jsx)("div", { className: "UserList__collaborator-status-icon", children: statusIconJSX })
        ]
      }
    );
  }
});

// actions/actionAddToLibrary.ts
init_define_import_meta_env();
var actionAddToLibrary = register({
  name: "addToLibrary",
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true,
      includeElementsInFrames: true
    });
    for (const type of LIBRARY_DISABLED_TYPES) {
      if (selectedElements.some((element) => element.type === type)) {
        return {
          storeAction: StoreAction.NONE,
          appState: {
            ...appState,
            errorMessage: t(`errors.libraryElementTypeError.${type}`)
          }
        };
      }
    }
    return app.library.getLatestLibrary().then((items) => {
      return app.library.setLibrary([
        {
          id: randomId(),
          status: "unpublished",
          elements: selectedElements.map(deepCopyElement),
          created: Date.now()
        },
        ...items
      ]);
    }).then(() => {
      return {
        storeAction: StoreAction.NONE,
        appState: {
          ...appState,
          toast: { message: t("toast.addedToLibrary") }
        }
      };
    }).catch((error) => {
      return {
        storeAction: StoreAction.NONE,
        appState: {
          ...appState,
          errorMessage: error.message
        }
      };
    });
  },
  label: "labels.addToLibrary"
});

// actions/actionAlign.tsx
init_define_import_meta_env();

// align.ts
init_define_import_meta_env();
var alignElements = (selectedElements, elementsMap, alignment) => {
  const groups = getMaximumGroups(
    selectedElements,
    elementsMap
  );
  const selectionBoundingBox = getCommonBoundingBox(selectedElements);
  return groups.flatMap((group) => {
    const translation = calculateTranslation(
      group,
      selectionBoundingBox,
      alignment
    );
    return group.map(
      (element) => newElementWith(element, {
        x: element.x + translation.x,
        y: element.y + translation.y
      })
    );
  });
};
var calculateTranslation = (group, selectionBoundingBox, { axis, position }) => {
  const groupBoundingBox = getCommonBoundingBox(group);
  const [min, max] = axis === "x" ? ["minX", "maxX"] : ["minY", "maxY"];
  const noTranslation = { x: 0, y: 0 };
  if (position === "start") {
    return {
      ...noTranslation,
      [axis]: selectionBoundingBox[min] - groupBoundingBox[min]
    };
  } else if (position === "end") {
    return {
      ...noTranslation,
      [axis]: selectionBoundingBox[max] - groupBoundingBox[max]
    };
  }
  return {
    ...noTranslation,
    [axis]: (selectionBoundingBox[min] + selectionBoundingBox[max]) / 2 - (groupBoundingBox[min] + groupBoundingBox[max]) / 2
  };
};

// actions/actionAlign.tsx
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
var alignActionsPredicate = (elements, appState, _, app) => {
  const selectedElements = app.scene.getSelectedElements(appState);
  return selectedElements.length > 1 && // TODO enable aligning frames when implemented properly
  !selectedElements.some((el) => isFrameLikeElement(el));
};
var alignSelectedElements = (elements, appState, app, alignment) => {
  const selectedElements = app.scene.getSelectedElements(appState);
  const elementsMap = arrayToMap(elements);
  const updatedElements = alignElements(
    selectedElements,
    elementsMap,
    alignment
  );
  const updatedElementsMap = arrayToMap(updatedElements);
  return updateFrameMembershipOfSelectedElements(
    elements.map((element) => updatedElementsMap.get(element.id) || element),
    appState,
    app
  );
};
var actionAlignTop = register({
  name: "alignTop",
  label: "labels.alignTop",
  icon: AlignTopIcon,
  trackEvent: { category: "element" },
  predicate: alignActionsPredicate,
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "start",
        axis: "y"
      }),
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_UP,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(
    ToolButton,
    {
      hidden: !alignActionsPredicate(elements, appState, null, app),
      type: "button",
      icon: AlignTopIcon,
      onClick: () => updateData(null),
      title: `${t("labels.alignTop")} \u2014 ${getShortcutKey(
        "CtrlOrCmd+Shift+Up"
      )}`,
      "aria-label": t("labels.alignTop"),
      visible: isSomeElementSelected(getNonDeletedElements(elements), appState)
    }
  )
});
var actionAlignBottom = register({
  name: "alignBottom",
  label: "labels.alignBottom",
  icon: AlignBottomIcon,
  trackEvent: { category: "element" },
  predicate: alignActionsPredicate,
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "end",
        axis: "y"
      }),
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_DOWN,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(
    ToolButton,
    {
      hidden: !alignActionsPredicate(elements, appState, null, app),
      type: "button",
      icon: AlignBottomIcon,
      onClick: () => updateData(null),
      title: `${t("labels.alignBottom")} \u2014 ${getShortcutKey(
        "CtrlOrCmd+Shift+Down"
      )}`,
      "aria-label": t("labels.alignBottom"),
      visible: isSomeElementSelected(getNonDeletedElements(elements), appState)
    }
  )
});
var actionAlignLeft = register({
  name: "alignLeft",
  label: "labels.alignLeft",
  icon: AlignLeftIcon,
  trackEvent: { category: "element" },
  predicate: alignActionsPredicate,
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "start",
        axis: "x"
      }),
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_LEFT,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(
    ToolButton,
    {
      hidden: !alignActionsPredicate(elements, appState, null, app),
      type: "button",
      icon: AlignLeftIcon,
      onClick: () => updateData(null),
      title: `${t("labels.alignLeft")} \u2014 ${getShortcutKey(
        "CtrlOrCmd+Shift+Left"
      )}`,
      "aria-label": t("labels.alignLeft"),
      visible: isSomeElementSelected(getNonDeletedElements(elements), appState)
    }
  )
});
var actionAlignRight = register({
  name: "alignRight",
  label: "labels.alignRight",
  icon: AlignRightIcon,
  trackEvent: { category: "element" },
  predicate: alignActionsPredicate,
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "end",
        axis: "x"
      }),
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key === KEYS.ARROW_RIGHT,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(
    ToolButton,
    {
      hidden: !alignActionsPredicate(elements, appState, null, app),
      type: "button",
      icon: AlignRightIcon,
      onClick: () => updateData(null),
      title: `${t("labels.alignRight")} \u2014 ${getShortcutKey(
        "CtrlOrCmd+Shift+Right"
      )}`,
      "aria-label": t("labels.alignRight"),
      visible: isSomeElementSelected(getNonDeletedElements(elements), appState)
    }
  )
});
var actionAlignVerticallyCentered = register({
  name: "alignVerticallyCentered",
  label: "labels.centerVertically",
  icon: CenterVerticallyIcon,
  trackEvent: { category: "element" },
  predicate: alignActionsPredicate,
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "center",
        axis: "y"
      }),
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(
    ToolButton,
    {
      hidden: !alignActionsPredicate(elements, appState, null, app),
      type: "button",
      icon: CenterVerticallyIcon,
      onClick: () => updateData(null),
      title: t("labels.centerVertically"),
      "aria-label": t("labels.centerVertically"),
      visible: isSomeElementSelected(getNonDeletedElements(elements), appState)
    }
  )
});
var actionAlignHorizontallyCentered = register({
  name: "alignHorizontallyCentered",
  label: "labels.centerHorizontally",
  icon: CenterHorizontallyIcon,
  trackEvent: { category: "element" },
  predicate: alignActionsPredicate,
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: alignSelectedElements(elements, appState, app, {
        position: "center",
        axis: "x"
      }),
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(
    ToolButton,
    {
      hidden: !alignActionsPredicate(elements, appState, null, app),
      type: "button",
      icon: CenterHorizontallyIcon,
      onClick: () => updateData(null),
      title: t("labels.centerHorizontally"),
      "aria-label": t("labels.centerHorizontally"),
      visible: isSomeElementSelected(getNonDeletedElements(elements), appState)
    }
  )
});

// actions/actionDistribute.tsx
init_define_import_meta_env();

// distribute.ts
init_define_import_meta_env();
var distributeElements = (selectedElements, elementsMap, distribution) => {
  const [start, mid, end, extent] = distribution.axis === "x" ? ["minX", "midX", "maxX", "width"] : ["minY", "midY", "maxY", "height"];
  const bounds = getCommonBoundingBox(selectedElements);
  const groups = getMaximumGroups(selectedElements, elementsMap).map((group) => [group, getCommonBoundingBox(group)]).sort((a3, b3) => a3[1][mid] - b3[1][mid]);
  let span = 0;
  for (const group of groups) {
    span += group[1][extent];
  }
  const step = (bounds[extent] - span) / (groups.length - 1);
  if (step < 0) {
    const index0 = groups.findIndex((g3) => g3[1][start] === bounds[start]);
    const index1 = groups.findIndex((g3) => g3[1][end] === bounds[end]);
    const step2 = (groups[index1][1][mid] - groups[index0][1][mid]) / (groups.length - 1);
    let pos2 = groups[index0][1][mid];
    return groups.flatMap(([group, box], index2) => {
      const translation = {
        x: 0,
        y: 0
      };
      if (index2 !== index0 && index2 !== index1) {
        pos2 += step2;
        translation[distribution.axis] = pos2 - box[mid];
      }
      return group.map(
        (element) => newElementWith(element, {
          x: element.x + translation.x,
          y: element.y + translation.y
        })
      );
    });
  }
  let pos = bounds[start];
  return groups.flatMap(([group, box]) => {
    const translation = {
      x: 0,
      y: 0
    };
    translation[distribution.axis] = pos - box[start];
    pos += step;
    pos += box[extent];
    return group.map(
      (element) => newElementWith(element, {
        x: element.x + translation.x,
        y: element.y + translation.y
      })
    );
  });
};

// actions/actionDistribute.tsx
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
var enableActionGroup2 = (appState, app) => {
  const selectedElements = app.scene.getSelectedElements(appState);
  return selectedElements.length > 1 && // TODO enable distributing frames when implemented properly
  !selectedElements.some((el) => isFrameLikeElement(el));
};
var distributeSelectedElements = (elements, appState, app, distribution) => {
  const selectedElements = app.scene.getSelectedElements(appState);
  const updatedElements = distributeElements(
    selectedElements,
    app.scene.getNonDeletedElementsMap(),
    distribution
  );
  const updatedElementsMap = arrayToMap(updatedElements);
  return updateFrameMembershipOfSelectedElements(
    elements.map((element) => updatedElementsMap.get(element.id) || element),
    appState,
    app
  );
};
var distributeHorizontally = register({
  name: "distributeHorizontally",
  label: "labels.distributeHorizontally",
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: distributeSelectedElements(elements, appState, app, {
        space: "between",
        axis: "x"
      }),
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.H,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
    ToolButton,
    {
      hidden: !enableActionGroup2(appState, app),
      type: "button",
      icon: DistributeHorizontallyIcon,
      onClick: () => updateData(null),
      title: `${t("labels.distributeHorizontally")} \u2014 ${getShortcutKey(
        "Alt+H"
      )}`,
      "aria-label": t("labels.distributeHorizontally"),
      visible: isSomeElementSelected(getNonDeletedElements(elements), appState)
    }
  )
});
var distributeVertically = register({
  name: "distributeVertically",
  label: "labels.distributeVertically",
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    return {
      appState,
      elements: distributeSelectedElements(elements, appState, app, {
        space: "between",
        axis: "y"
      }),
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.V,
  PanelComponent: ({ elements, appState, updateData, app }) => /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
    ToolButton,
    {
      hidden: !enableActionGroup2(appState, app),
      type: "button",
      icon: DistributeVerticallyIcon,
      onClick: () => updateData(null),
      title: `${t("labels.distributeVertically")} \u2014 ${getShortcutKey("Alt+V")}`,
      "aria-label": t("labels.distributeVertically"),
      visible: isSomeElementSelected(getNonDeletedElements(elements), appState)
    }
  )
});

// actions/actionFlip.ts
init_define_import_meta_env();
var actionFlipHorizontal = register({
  name: "flipHorizontal",
  label: "labels.flipHorizontal",
  icon: flipHorizontal,
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    return {
      elements: updateFrameMembershipOfSelectedElements(
        flipSelectedElements(
          elements,
          app.scene.getNonDeletedElementsMap(),
          appState,
          "horizontal",
          app
        ),
        appState,
        app
      ),
      appState,
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => event.shiftKey && event.code === CODES.H
});
var actionFlipVertical = register({
  name: "flipVertical",
  label: "labels.flipVertical",
  icon: flipVertical,
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    return {
      elements: updateFrameMembershipOfSelectedElements(
        flipSelectedElements(
          elements,
          app.scene.getNonDeletedElementsMap(),
          appState,
          "vertical",
          app
        ),
        appState,
        app
      ),
      appState,
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event) => event.shiftKey && event.code === CODES.V && !event[KEYS.CTRL_OR_CMD]
});
var flipSelectedElements = (elements, elementsMap, appState, flipDirection, app) => {
  const selectedElements = getSelectedElements(
    getNonDeletedElements(elements),
    appState,
    {
      includeBoundTextElement: true,
      includeElementsInFrames: true
    }
  );
  const updatedElements = flipElements(
    selectedElements,
    elementsMap,
    appState,
    flipDirection,
    app
  );
  const updatedElementsMap = arrayToMap(updatedElements);
  return elements.map(
    (element) => updatedElementsMap.get(element.id) || element
  );
};
var flipElements = (selectedElements, elementsMap, appState, flipDirection, app) => {
  if (selectedElements.every(
    (element) => isArrowElement(element) && (element.startBinding || element.endBinding)
  )) {
    return selectedElements.map((element) => {
      const _element = element;
      return newElementWith(_element, {
        startArrowhead: _element.endArrowhead,
        endArrowhead: _element.startArrowhead
      });
    });
  }
  const { minX, minY, maxX, maxY, midX, midY } = getCommonBoundingBox(selectedElements);
  resizeMultipleElements(
    elementsMap,
    selectedElements,
    elementsMap,
    "nw",
    true,
    true,
    flipDirection === "horizontal" ? maxX : minX,
    flipDirection === "horizontal" ? minY : maxY
  );
  bindOrUnbindLinearElements(
    selectedElements.filter(isLinearElement),
    elementsMap,
    app.scene.getNonDeletedElements(),
    app.scene,
    isBindingEnabled(appState),
    []
  );
  const { elbowArrows, otherElements } = selectedElements.reduce(
    (acc, element) => isElbowArrow(element) ? { ...acc, elbowArrows: acc.elbowArrows.concat(element) } : { ...acc, otherElements: acc.otherElements.concat(element) },
    { elbowArrows: [], otherElements: [] }
  );
  const { midX: newMidX, midY: newMidY } = getCommonBoundingBox(selectedElements);
  const [diffX, diffY] = [midX - newMidX, midY - newMidY];
  otherElements.forEach(
    (element) => mutateElement(element, {
      x: element.x + diffX,
      y: element.y + diffY
    })
  );
  elbowArrows.forEach(
    (element) => mutateElbowArrow(
      element,
      elementsMap,
      element.points,
      void 0,
      void 0,
      {
        informMutation: false
      }
    )
  );
  return selectedElements;
};

// actions/actionClipboard.tsx
init_define_import_meta_env();
var actionCopy = register({
  name: "copy",
  label: "labels.copy",
  icon: DuplicateIcon,
  trackEvent: { category: "element" },
  perform: async (elements, appState, event, app) => {
    const elementsToCopy = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true,
      includeElementsInFrames: true
    });
    try {
      await copyToClipboard(elementsToCopy, app.files, event);
    } catch (error) {
      return {
        storeAction: StoreAction.NONE,
        appState: {
          ...appState,
          errorMessage: error.message
        }
      };
    }
    return {
      storeAction: StoreAction.NONE
    };
  },
  // don't supply a shortcut since we handle this conditionally via onCopy event
  keyTest: void 0
});
var actionPaste = register({
  name: "paste",
  label: "labels.paste",
  trackEvent: { category: "element" },
  perform: async (elements, appState, data, app) => {
    let types;
    try {
      types = await readSystemClipboard();
    } catch (error) {
      if (error.name === "AbortError" || error.name === "NotAllowedError") {
        return false;
      }
      console.error(`actionPaste ${error.name}: ${error.message}`);
      if (isFirefox) {
        return {
          storeAction: StoreAction.NONE,
          appState: {
            ...appState,
            errorMessage: t("hints.firefox_clipboard_write")
          }
        };
      }
      return {
        storeAction: StoreAction.NONE,
        appState: {
          ...appState,
          errorMessage: t("errors.asyncPasteFailedOnRead")
        }
      };
    }
    try {
      app.pasteFromClipboard(createPasteEvent({ types }));
    } catch (error) {
      console.error(error);
      return {
        storeAction: StoreAction.NONE,
        appState: {
          ...appState,
          errorMessage: t("errors.asyncPasteFailedOnParse")
        }
      };
    }
    return {
      storeAction: StoreAction.NONE
    };
  },
  // don't supply a shortcut since we handle this conditionally via onCopy event
  keyTest: void 0
});
var actionCut = register({
  name: "cut",
  label: "labels.cut",
  icon: cutIcon,
  trackEvent: { category: "element" },
  perform: (elements, appState, event, app) => {
    actionCopy.perform(elements, appState, event, app);
    return actionDeleteSelected.perform(elements, appState, null, app);
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.X
});
var actionCopyAsSvg = register({
  name: "copyAsSvg",
  label: "labels.copyAsSvg",
  icon: svgIcon,
  trackEvent: { category: "element" },
  perform: async (elements, appState, _data, app) => {
    if (!app.canvas) {
      return {
        storeAction: StoreAction.NONE
      };
    }
    const { exportedElements, exportingFrame } = prepareElementsForExport(
      elements,
      appState,
      true
    );
    try {
      await exportCanvas(
        "clipboard-svg",
        exportedElements,
        appState,
        app.files,
        {
          ...appState,
          exportingFrame,
          name: app.getName()
        }
      );
      return {
        storeAction: StoreAction.NONE
      };
    } catch (error) {
      console.error(error);
      return {
        appState: {
          ...appState,
          errorMessage: error.message
        },
        storeAction: StoreAction.NONE
      };
    }
  },
  predicate: (elements) => {
    return probablySupportsClipboardWriteText && elements.length > 0;
  },
  keywords: ["svg", "clipboard", "copy"]
});
var actionCopyAsPng = register({
  name: "copyAsPng",
  label: "labels.copyAsPng",
  icon: pngIcon,
  trackEvent: { category: "element" },
  perform: async (elements, appState, _data, app) => {
    if (!app.canvas) {
      return {
        storeAction: StoreAction.NONE
      };
    }
    const selectedElements = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true,
      includeElementsInFrames: true
    });
    const { exportedElements, exportingFrame } = prepareElementsForExport(
      elements,
      appState,
      true
    );
    try {
      await exportCanvas("clipboard", exportedElements, appState, app.files, {
        ...appState,
        exportingFrame,
        name: app.getName()
      });
      return {
        appState: {
          ...appState,
          toast: {
            message: t("toast.copyToClipboardAsPng", {
              exportSelection: selectedElements.length ? t("toast.selection") : t("toast.canvas"),
              exportColorScheme: appState.exportWithDarkMode ? t("buttons.darkMode") : t("buttons.lightMode")
            })
          }
        },
        storeAction: StoreAction.NONE
      };
    } catch (error) {
      console.error(error);
      return {
        appState: {
          ...appState,
          errorMessage: error.message
        },
        storeAction: StoreAction.NONE
      };
    }
  },
  predicate: (elements) => {
    return probablySupportsClipboardBlob && elements.length > 0;
  },
  keyTest: (event) => event.code === CODES.C && event.altKey && event.shiftKey,
  keywords: ["png", "clipboard", "copy"]
});
var copyText = register({
  name: "copyText",
  label: "labels.copyText",
  trackEvent: { category: "element" },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true
    });
    try {
      copyTextToSystemClipboard(getTextFromElements(selectedElements));
    } catch (e3) {
      throw new Error(t("errors.copyToSystemClipboardFailed"));
    }
    return {
      storeAction: StoreAction.NONE
    };
  },
  predicate: (elements, appState, _, app) => {
    return probablySupportsClipboardWriteText && app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true
    }).some(isTextElement);
  },
  keywords: ["text", "clipboard", "copy"]
});

// actions/actionToggleGridMode.tsx
init_define_import_meta_env();
var actionToggleGridMode = register({
  name: "gridMode",
  icon: gridIcon,
  keywords: ["snap"],
  label: "labels.toggleGrid",
  viewMode: true,
  trackEvent: {
    category: "canvas",
    predicate: (appState) => appState.gridModeEnabled
  },
  perform(elements, appState) {
    return {
      appState: {
        ...appState,
        gridModeEnabled: !this.checked(appState),
        objectsSnapModeEnabled: false
      },
      storeAction: StoreAction.NONE
    };
  },
  checked: (appState) => appState.gridModeEnabled,
  predicate: (element, appState, props) => {
    return props.gridModeEnabled === void 0;
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.code === CODES.QUOTE
});

// actions/actionToggleZenMode.tsx
init_define_import_meta_env();
var actionToggleZenMode = register({
  name: "zenMode",
  label: "buttons.zenMode",
  icon: coffeeIcon,
  paletteName: "Toggle zen mode",
  viewMode: true,
  trackEvent: {
    category: "canvas",
    predicate: (appState) => !appState.zenModeEnabled
  },
  perform(elements, appState) {
    return {
      appState: {
        ...appState,
        zenModeEnabled: !this.checked(appState)
      },
      storeAction: StoreAction.NONE
    };
  },
  checked: (appState) => appState.zenModeEnabled,
  predicate: (elements, appState, appProps) => {
    return typeof appProps.zenModeEnabled === "undefined";
  },
  keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.Z
});

// actions/actionToggleObjectsSnapMode.tsx
init_define_import_meta_env();
var actionToggleObjectsSnapMode = register({
  name: "objectsSnapMode",
  label: "buttons.objectsSnapMode",
  icon: magnetIcon,
  viewMode: false,
  trackEvent: {
    category: "canvas",
    predicate: (appState) => !appState.objectsSnapModeEnabled
  },
  perform(elements, appState) {
    return {
      appState: {
        ...appState,
        objectsSnapModeEnabled: !this.checked(appState),
        gridModeEnabled: false
      },
      storeAction: StoreAction.NONE
    };
  },
  checked: (appState) => appState.objectsSnapModeEnabled,
  predicate: (elements, appState, appProps) => {
    return typeof appProps.objectsSnapModeEnabled === "undefined";
  },
  keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.S
});

// actions/actionToggleStats.tsx
init_define_import_meta_env();
var actionToggleStats = register({
  name: "stats",
  label: "stats.fullTitle",
  icon: abacusIcon,
  paletteName: "Toggle stats",
  viewMode: true,
  trackEvent: { category: "menu" },
  keywords: ["edit", "attributes", "customize"],
  perform(elements, appState) {
    return {
      appState: {
        ...appState,
        stats: { ...appState.stats, open: !this.checked(appState) }
      },
      storeAction: StoreAction.NONE
    };
  },
  checked: (appState) => appState.stats.open,
  keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.SLASH
});

// actions/actionBoundText.tsx
init_define_import_meta_env();
var actionUnbindText = register({
  name: "unbindText",
  label: "labels.unbindText",
  trackEvent: { category: "element" },
  predicate: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    return selectedElements.some((element) => hasBoundTextElement(element));
  },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    const elementsMap = app.scene.getNonDeletedElementsMap();
    selectedElements.forEach((element) => {
      const boundTextElement = getBoundTextElement(element, elementsMap);
      if (boundTextElement) {
        const { width, height } = measureText(
          boundTextElement.originalText,
          getFontString(boundTextElement),
          boundTextElement.lineHeight
        );
        const originalContainerHeight = getOriginalContainerHeightFromCache(
          element.id
        );
        resetOriginalContainerCache(element.id);
        const { x: x3, y: y3 } = computeBoundTextPosition(
          element,
          boundTextElement,
          elementsMap
        );
        mutateElement(boundTextElement, {
          containerId: null,
          width,
          height,
          text: boundTextElement.originalText,
          x: x3,
          y: y3
        });
        mutateElement(element, {
          boundElements: element.boundElements?.filter(
            (ele) => ele.id !== boundTextElement.id
          ),
          height: originalContainerHeight ? originalContainerHeight : element.height
        });
      }
    });
    return {
      elements,
      appState,
      storeAction: StoreAction.CAPTURE
    };
  }
});
var actionBindText = register({
  name: "bindText",
  label: "labels.bindText",
  trackEvent: { category: "element" },
  predicate: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    if (selectedElements.length === 2) {
      const textElement = isTextElement(selectedElements[0]) || isTextElement(selectedElements[1]);
      let bindingContainer;
      if (isTextBindableContainer(selectedElements[0])) {
        bindingContainer = selectedElements[0];
      } else if (isTextBindableContainer(selectedElements[1])) {
        bindingContainer = selectedElements[1];
      }
      if (textElement && bindingContainer && getBoundTextElement(
        bindingContainer,
        app.scene.getNonDeletedElementsMap()
      ) === null) {
        return true;
      }
    }
    return false;
  },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    let textElement;
    let container;
    if (isTextElement(selectedElements[0]) && isTextBindableContainer(selectedElements[1])) {
      textElement = selectedElements[0];
      container = selectedElements[1];
    } else {
      textElement = selectedElements[1];
      container = selectedElements[0];
    }
    mutateElement(textElement, {
      containerId: container.id,
      verticalAlign: VERTICAL_ALIGN.MIDDLE,
      textAlign: TEXT_ALIGN.CENTER,
      autoResize: true
    });
    mutateElement(container, {
      boundElements: (container.boundElements || []).concat({
        type: "text",
        id: textElement.id
      })
    });
    const originalContainerHeight = container.height;
    redrawTextBoundingBox(
      textElement,
      container,
      app.scene.getNonDeletedElementsMap()
    );
    updateOriginalContainerCache(container.id, originalContainerHeight);
    return {
      elements: pushTextAboveContainer(elements, container, textElement),
      appState: { ...appState, selectedElementIds: { [container.id]: true } },
      storeAction: StoreAction.CAPTURE
    };
  }
});
var pushTextAboveContainer = (elements, container, textElement) => {
  const updatedElements = elements.slice();
  const textElementIndex = updatedElements.findIndex(
    (ele) => ele.id === textElement.id
  );
  updatedElements.splice(textElementIndex, 1);
  const containerIndex = updatedElements.findIndex(
    (ele) => ele.id === container.id
  );
  updatedElements.splice(containerIndex + 1, 0, textElement);
  syncMovedIndices(updatedElements, arrayToMap([container, textElement]));
  return updatedElements;
};
var pushContainerBelowText = (elements, container, textElement) => {
  const updatedElements = elements.slice();
  const containerIndex = updatedElements.findIndex(
    (ele) => ele.id === container.id
  );
  updatedElements.splice(containerIndex, 1);
  const textElementIndex = updatedElements.findIndex(
    (ele) => ele.id === textElement.id
  );
  updatedElements.splice(textElementIndex, 0, container);
  syncMovedIndices(updatedElements, arrayToMap([container, textElement]));
  return updatedElements;
};
var actionWrapTextInContainer = register({
  name: "wrapTextInContainer",
  label: "labels.createContainerFromText",
  trackEvent: { category: "element" },
  predicate: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    const areTextElements = selectedElements.every((el) => isTextElement(el));
    return selectedElements.length > 0 && areTextElements;
  },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    let updatedElements = elements.slice();
    const containerIds = {};
    for (const textElement of selectedElements) {
      if (isTextElement(textElement)) {
        const container = newElement({
          type: "rectangle",
          backgroundColor: appState.currentItemBackgroundColor,
          boundElements: [
            ...textElement.boundElements || [],
            { id: textElement.id, type: "text" }
          ],
          angle: textElement.angle,
          fillStyle: appState.currentItemFillStyle,
          strokeColor: appState.currentItemStrokeColor,
          roughness: appState.currentItemRoughness,
          strokeWidth: appState.currentItemStrokeWidth,
          strokeStyle: appState.currentItemStrokeStyle,
          roundness: appState.currentItemRoundness === "round" ? {
            type: isUsingAdaptiveRadius("rectangle") ? ROUNDNESS.ADAPTIVE_RADIUS : ROUNDNESS.PROPORTIONAL_RADIUS
          } : null,
          opacity: 100,
          locked: false,
          x: textElement.x - BOUND_TEXT_PADDING,
          y: textElement.y - BOUND_TEXT_PADDING,
          width: computeContainerDimensionForBoundText(
            textElement.width,
            "rectangle"
          ),
          height: computeContainerDimensionForBoundText(
            textElement.height,
            "rectangle"
          ),
          groupIds: textElement.groupIds,
          frameId: textElement.frameId
        });
        if (textElement.boundElements?.length) {
          const linearElementIds = textElement.boundElements.filter((ele) => ele.type === "arrow").map((el) => el.id);
          const linearElements = updatedElements.filter(
            (ele) => linearElementIds.includes(ele.id)
          );
          linearElements.forEach((ele) => {
            let startBinding = ele.startBinding;
            let endBinding = ele.endBinding;
            if (startBinding?.elementId === textElement.id) {
              startBinding = {
                ...startBinding,
                elementId: container.id
              };
            }
            if (endBinding?.elementId === textElement.id) {
              endBinding = { ...endBinding, elementId: container.id };
            }
            if (startBinding || endBinding) {
              mutateElement(ele, { startBinding, endBinding }, false);
            }
          });
        }
        mutateElement(
          textElement,
          {
            containerId: container.id,
            verticalAlign: VERTICAL_ALIGN.MIDDLE,
            boundElements: null,
            textAlign: TEXT_ALIGN.CENTER,
            autoResize: true
          },
          false
        );
        redrawTextBoundingBox(
          textElement,
          container,
          app.scene.getNonDeletedElementsMap()
        );
        updatedElements = pushContainerBelowText(
          [...updatedElements, container],
          container,
          textElement
        );
        containerIds[container.id] = true;
      }
    }
    return {
      elements: updatedElements,
      appState: {
        ...appState,
        selectedElementIds: containerIds
      },
      storeAction: StoreAction.CAPTURE
    };
  }
});

// actions/actionLink.tsx
init_define_import_meta_env();

// components/hyperlink/Hyperlink.tsx
init_define_import_meta_env();
var import_react53 = __toESM(require_react(), 1);
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
var CONTAINER_WIDTH = 320;
var SPACE_BOTTOM = 85;
var CONTAINER_PADDING = 5;
var CONTAINER_HEIGHT = 42;
var AUTO_HIDE_TIMEOUT = 500;
var IS_HYPERLINK_TOOLTIP_VISIBLE = false;
var embeddableLinkCache = /* @__PURE__ */ new Map();
var Hyperlink = ({
  element,
  elementsMap,
  setAppState,
  onLinkOpen,
  setToast,
  updateEmbedValidationStatus
}) => {
  const appState = useExcalidrawAppState();
  const appProps = useAppProps();
  const linkVal = element.link || "";
  const [inputVal, setInputVal] = (0, import_react53.useState)(linkVal);
  const inputRef = (0, import_react53.useRef)(null);
  const isEditing = appState.showHyperlinkPopup === "editor";
  const handleSubmit = (0, import_react53.useCallback)(() => {
    if (!inputRef.current) {
      return;
    }
    const link = normalizeLink(inputRef.current.value) || null;
    if (!element.link && link) {
      trackEvent("hyperlink", "create");
    }
    if (isEmbeddableElement(element)) {
      if (appState.activeEmbeddable?.element === element) {
        setAppState({ activeEmbeddable: null });
      }
      if (!link) {
        mutateElement(element, {
          link: null
        });
        updateEmbedValidationStatus(element, false);
        return;
      }
      if (!embeddableURLValidator(link, appProps.validateEmbeddable)) {
        if (link) {
          setToast({ message: t("toast.unableToEmbed"), closable: true });
        }
        element.link && embeddableLinkCache.set(element.id, element.link);
        mutateElement(element, {
          link
        });
        updateEmbedValidationStatus(element, false);
      } else {
        const { width, height } = element;
        const embedLink = getEmbedLink(link);
        if (embedLink?.error instanceof URIError) {
          setToast({
            message: t("toast.unrecognizedLinkFormat"),
            closable: true
          });
        }
        const ar = embedLink ? embedLink.intrinsicSize.w / embedLink.intrinsicSize.h : 1;
        const hasLinkChanged = embeddableLinkCache.get(element.id) !== element.link;
        mutateElement(element, {
          ...hasLinkChanged ? {
            width: embedLink?.type === "video" ? width > height ? width : height * ar : width,
            height: embedLink?.type === "video" ? width > height ? width / ar : height : height
          } : {},
          link
        });
        updateEmbedValidationStatus(element, true);
        if (embeddableLinkCache.has(element.id)) {
          embeddableLinkCache.delete(element.id);
        }
      }
    } else {
      mutateElement(element, { link });
    }
  }, [
    element,
    setToast,
    appProps.validateEmbeddable,
    appState.activeEmbeddable,
    setAppState,
    updateEmbedValidationStatus
  ]);
  (0, import_react53.useLayoutEffect)(() => {
    return () => {
      handleSubmit();
    };
  }, [handleSubmit]);
  (0, import_react53.useEffect)(() => {
    let timeoutId = null;
    const handlePointerMove = (event) => {
      if (isEditing) {
        return;
      }
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      const shouldHide = shouldHideLinkPopup(
        element,
        elementsMap,
        appState,
        pointFrom(event.clientX, event.clientY)
      );
      if (shouldHide) {
        timeoutId = window.setTimeout(() => {
          setAppState({ showHyperlinkPopup: false });
        }, AUTO_HIDE_TIMEOUT);
      }
    };
    window.addEventListener("pointermove" /* POINTER_MOVE */, handlePointerMove, false);
    return () => {
      window.removeEventListener("pointermove" /* POINTER_MOVE */, handlePointerMove, false);
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  }, [appState, element, isEditing, setAppState, elementsMap]);
  const handleRemove = (0, import_react53.useCallback)(() => {
    trackEvent("hyperlink", "delete");
    mutateElement(element, { link: null });
    if (isEditing) {
      inputRef.current.value = "";
    }
    setAppState({ showHyperlinkPopup: false });
  }, [setAppState, element, isEditing]);
  const onEdit = () => {
    trackEvent("hyperlink", "edit", "popup-ui");
    setAppState({ showHyperlinkPopup: "editor" });
  };
  const { x: x3, y: y3 } = getCoordsForPopover(element, appState, elementsMap);
  if (appState.contextMenu || appState.selectedElementsAreBeingDragged || appState.resizingElement || appState.isRotating || appState.openMenu || appState.viewModeEnabled) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime47.jsxs)(
    "div",
    {
      className: "excalidraw-hyperlinkContainer",
      style: {
        top: `${y3}px`,
        left: `${x3}px`,
        width: CONTAINER_WIDTH,
        padding: CONTAINER_PADDING
      },
      onClick: () => {
        if (!element.link && !isEditing) {
          setAppState({ showHyperlinkPopup: "editor" });
        }
      },
      children: [
        isEditing ? /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(
          "input",
          {
            className: clsx_m_default("excalidraw-hyperlinkContainer-input"),
            placeholder: "Type or paste your link here",
            ref: inputRef,
            value: inputVal,
            onChange: (event) => setInputVal(event.target.value),
            autoFocus: true,
            onKeyDown: (event) => {
              event.stopPropagation();
              if (event[KEYS.CTRL_OR_CMD] && event.key === KEYS.K) {
                event.preventDefault();
              }
              if (event.key === KEYS.ENTER || event.key === KEYS.ESCAPE) {
                handleSubmit();
                setAppState({ showHyperlinkPopup: "info" });
              }
            }
          }
        ) : element.link ? /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(
          "a",
          {
            href: normalizeLink(element.link || ""),
            className: "excalidraw-hyperlinkContainer-link",
            target: isLocalLink(element.link) ? "_self" : "_blank",
            onClick: (event) => {
              if (element.link && onLinkOpen) {
                const customEvent = wrapEvent(
                  "excalidraw-link" /* EXCALIDRAW_LINK */,
                  event.nativeEvent
                );
                onLinkOpen(
                  {
                    ...element,
                    link: normalizeLink(element.link)
                  },
                  customEvent
                );
                if (customEvent.defaultPrevented) {
                  event.preventDefault();
                }
              }
            },
            rel: "noopener noreferrer",
            children: element.link
          }
        ) : /* @__PURE__ */ (0, import_jsx_runtime47.jsx)("div", { className: "excalidraw-hyperlinkContainer-link", children: t("labels.link.empty") }),
        /* @__PURE__ */ (0, import_jsx_runtime47.jsxs)("div", { className: "excalidraw-hyperlinkContainer__buttons", children: [
          !isEditing && /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(
            ToolButton,
            {
              type: "button",
              title: t("buttons.edit"),
              "aria-label": t("buttons.edit"),
              label: t("buttons.edit"),
              onClick: onEdit,
              className: "excalidraw-hyperlinkContainer--edit",
              icon: FreedrawIcon
            }
          ),
          linkVal && !isEmbeddableElement(element) && /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(
            ToolButton,
            {
              type: "button",
              title: t("buttons.remove"),
              "aria-label": t("buttons.remove"),
              label: t("buttons.remove"),
              onClick: handleRemove,
              className: "excalidraw-hyperlinkContainer--remove",
              icon: TrashIcon
            }
          )
        ] })
      ]
    }
  );
};
var getCoordsForPopover = (element, appState, elementsMap) => {
  const [x1, y1] = getElementAbsoluteCoords(element, elementsMap);
  const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(
    { sceneX: x1 + element.width / 2, sceneY: y1 },
    appState
  );
  const x3 = viewportX - appState.offsetLeft - CONTAINER_WIDTH / 2;
  const y3 = viewportY - appState.offsetTop - SPACE_BOTTOM;
  return { x: x3, y: y3 };
};
var getContextMenuLabel = (elements, appState) => {
  const selectedElements = getSelectedElements(elements, appState);
  const label = selectedElements[0]?.link ? isEmbeddableElement(selectedElements[0]) ? "labels.link.editEmbed" : "labels.link.edit" : isEmbeddableElement(selectedElements[0]) ? "labels.link.createEmbed" : "labels.link.create";
  return label;
};
var HYPERLINK_TOOLTIP_TIMEOUT_ID = null;
var showHyperlinkTooltip = (element, appState, elementsMap) => {
  if (HYPERLINK_TOOLTIP_TIMEOUT_ID) {
    clearTimeout(HYPERLINK_TOOLTIP_TIMEOUT_ID);
  }
  HYPERLINK_TOOLTIP_TIMEOUT_ID = window.setTimeout(
    () => renderTooltip(element, appState, elementsMap),
    HYPERLINK_TOOLTIP_DELAY
  );
};
var renderTooltip = (element, appState, elementsMap) => {
  if (!element.link) {
    return;
  }
  const tooltipDiv = getTooltipDiv();
  tooltipDiv.classList.add("excalidraw-tooltip--visible");
  tooltipDiv.style.maxWidth = "20rem";
  tooltipDiv.textContent = element.link;
  const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
  const [linkX, linkY, linkWidth, linkHeight] = getLinkHandleFromCoords(
    [x1, y1, x22, y22],
    element.angle,
    appState
  );
  const linkViewportCoords = sceneCoordsToViewportCoords(
    { sceneX: linkX, sceneY: linkY },
    appState
  );
  updateTooltipPosition(
    tooltipDiv,
    {
      left: linkViewportCoords.x,
      top: linkViewportCoords.y,
      width: linkWidth,
      height: linkHeight
    },
    "top"
  );
  trackEvent("hyperlink", "tooltip", "link-icon");
  IS_HYPERLINK_TOOLTIP_VISIBLE = true;
};
var hideHyperlinkToolip = () => {
  if (HYPERLINK_TOOLTIP_TIMEOUT_ID) {
    clearTimeout(HYPERLINK_TOOLTIP_TIMEOUT_ID);
  }
  if (IS_HYPERLINK_TOOLTIP_VISIBLE) {
    IS_HYPERLINK_TOOLTIP_VISIBLE = false;
    getTooltipDiv().classList.remove("excalidraw-tooltip--visible");
  }
};
var shouldHideLinkPopup = (element, elementsMap, appState, [clientX, clientY]) => {
  const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(
    { clientX, clientY },
    appState
  );
  const threshold = 15 / appState.zoom.value;
  if (hitElementBoundingBox(sceneX, sceneY, element, elementsMap)) {
    return false;
  }
  const [x1, y1, x22] = getElementAbsoluteCoords(element, elementsMap);
  if (sceneX >= x1 && sceneX <= x22 && sceneY >= y1 - SPACE_BOTTOM && sceneY <= y1) {
    return false;
  }
  const { x: popoverX, y: popoverY } = getCoordsForPopover(
    element,
    appState,
    elementsMap
  );
  if (clientX >= popoverX - threshold && clientX <= popoverX + CONTAINER_WIDTH + CONTAINER_PADDING * 2 + threshold && clientY >= popoverY - threshold && clientY <= popoverY + threshold + CONTAINER_PADDING * 2 + CONTAINER_HEIGHT) {
    return false;
  }
  return true;
};

// actions/actionLink.tsx
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
var actionLink = register({
  name: "hyperlink",
  label: (elements, appState) => getContextMenuLabel(elements, appState),
  icon: LinkIcon,
  perform: (elements, appState) => {
    if (appState.showHyperlinkPopup === "editor") {
      return false;
    }
    return {
      elements,
      appState: {
        ...appState,
        showHyperlinkPopup: "editor",
        openMenu: null
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  trackEvent: { category: "hyperlink", action: "click" },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.K,
  predicate: (elements, appState) => {
    const selectedElements = getSelectedElements(elements, appState);
    return selectedElements.length === 1;
  },
  PanelComponent: ({ elements, appState, updateData }) => {
    const selectedElements = getSelectedElements(elements, appState);
    return /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(
      ToolButton,
      {
        type: "button",
        icon: LinkIcon,
        "aria-label": t(getContextMenuLabel(elements, appState)),
        title: `${isEmbeddableElement(elements[0]) ? t("labels.link.labelEmbed") : t("labels.link.label")} - ${getShortcutKey("CtrlOrCmd+K")}`,
        onClick: () => updateData(null),
        selected: selectedElements.length === 1 && !!selectedElements[0].link
      }
    );
  }
});

// actions/actionElementLock.ts
init_define_import_meta_env();
var shouldLock = (elements) => elements.every((el) => !el.locked);
var actionToggleElementLock = register({
  name: "toggleElementLock",
  label: (elements, appState, app) => {
    const selected = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: false
    });
    if (selected.length === 1 && !isFrameLikeElement(selected[0])) {
      return selected[0].locked ? "labels.elementLock.unlock" : "labels.elementLock.lock";
    }
    return shouldLock(selected) ? "labels.elementLock.lockAll" : "labels.elementLock.unlockAll";
  },
  icon: (appState, elements) => {
    const selectedElements = getSelectedElements(elements, appState);
    return shouldLock(selectedElements) ? LockedIcon : UnlockedIcon;
  },
  trackEvent: { category: "element" },
  predicate: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    return selectedElements.length > 0 && !selectedElements.some((element) => element.locked && element.frameId);
  },
  perform: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true,
      includeElementsInFrames: true
    });
    if (!selectedElements.length) {
      return false;
    }
    const nextLockState = shouldLock(selectedElements);
    const selectedElementsMap = arrayToMap(selectedElements);
    return {
      elements: elements.map((element) => {
        if (!selectedElementsMap.has(element.id)) {
          return element;
        }
        return newElementWith(element, { locked: nextLockState });
      }),
      appState: {
        ...appState,
        selectedLinearElement: nextLockState ? null : appState.selectedLinearElement
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  keyTest: (event, appState, elements, app) => {
    return event.key.toLocaleLowerCase() === KEYS.L && event[KEYS.CTRL_OR_CMD] && event.shiftKey && app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: false
    }).length > 0;
  }
});
var actionUnlockAllElements = register({
  name: "unlockAllElements",
  paletteName: "Unlock all elements",
  trackEvent: { category: "canvas" },
  viewMode: false,
  icon: UnlockedIcon,
  predicate: (elements, appState) => {
    const selectedElements = getSelectedElements(elements, appState);
    return selectedElements.length === 0 && elements.some((element) => element.locked);
  },
  perform: (elements, appState) => {
    const lockedElements = elements.filter((el) => el.locked);
    return {
      elements: elements.map((element) => {
        if (element.locked) {
          return newElementWith(element, { locked: false });
        }
        return element;
      }),
      appState: {
        ...appState,
        selectedElementIds: Object.fromEntries(
          lockedElements.map((el) => [el.id, true])
        )
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  label: "labels.elementLock.unlockAll"
});

// actions/actionLinearEditor.tsx
init_define_import_meta_env();

// components/CommandPalette/CommandPalette.tsx
init_define_import_meta_env();
var import_react77 = __toESM(require_react(), 1);

// components/Dialog.tsx
init_define_import_meta_env();
var import_react70 = __toESM(require_react(), 1);

// hooks/useCallbackRefState.ts
init_define_import_meta_env();
var import_react54 = __toESM(require_react(), 1);
var useCallbackRefState = () => {
  const [refValue, setRefValue] = (0, import_react54.useState)(null);
  const refCallback = (0, import_react54.useCallback)((value) => setRefValue(value), []);
  return [refValue, refCallback];
};

// components/Modal.tsx
init_define_import_meta_env();
var import_react_dom7 = __toESM(require_react_dom(), 1);
var import_react55 = __toESM(require_react(), 1);
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
var Modal = (props) => {
  const { closeOnClickOutside = true } = props;
  const modalRoot = useCreatePortalContainer({
    className: "excalidraw-modal-container"
  });
  const animationsDisabledRef = (0, import_react55.useRef)(
    document.body.classList.contains("excalidraw-animations-disabled")
  );
  if (!modalRoot) {
    return null;
  }
  const handleKeydown = (event) => {
    if (event.key === KEYS.ESCAPE) {
      event.nativeEvent.stopImmediatePropagation();
      event.stopPropagation();
      props.onCloseRequest();
    }
  };
  return (0, import_react_dom7.createPortal)(
    /* @__PURE__ */ (0, import_jsx_runtime49.jsxs)(
      "div",
      {
        className: clsx_m_default("Modal", props.className, {
          "animations-disabled": animationsDisabledRef.current
        }),
        role: "dialog",
        "aria-modal": "true",
        onKeyDown: handleKeydown,
        "aria-labelledby": props.labelledBy,
        "data-prevent-outside-click": true,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(
            "div",
            {
              className: "Modal__background",
              onClick: closeOnClickOutside ? props.onCloseRequest : void 0
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(
            "div",
            {
              className: "Modal__content",
              style: { "--max-width": `${props.maxWidth}px` },
              tabIndex: 0,
              children: props.children
            }
          )
        ]
      }
    ),
    modalRoot
  );
};

// components/LibraryMenu.tsx
init_define_import_meta_env();
var import_react69 = __toESM(require_react(), 1);

// data/library.ts
init_define_import_meta_env();
var import_react57 = __toESM(require_react(), 1);

// hooks/useLibraryItemSvg.ts
init_define_import_meta_env();
var import_react56 = __toESM(require_react(), 1);
var libraryItemSvgsCache = atom2(/* @__PURE__ */ new Map());
var exportLibraryItemToSvg = async (elements) => {
  return await exportToSvg2({
    elements,
    appState: {
      exportBackground: false,
      viewBackgroundColor: COLOR_PALETTE.white
    },
    files: null,
    renderEmbeddables: false,
    skipInliningFonts: true
  });
};
var useLibraryItemSvg = (id, elements, svgCache) => {
  const [svg, setSvg] = (0, import_react56.useState)();
  (0, import_react56.useEffect)(() => {
    if (elements) {
      if (id) {
        const cachedSvg = svgCache.get(id);
        if (cachedSvg) {
          setSvg(cachedSvg);
        } else {
          (async () => {
            const exportedSvg = await exportLibraryItemToSvg(elements);
            exportedSvg.querySelector(".style-fonts")?.remove();
            if (exportedSvg) {
              svgCache.set(id, exportedSvg);
              setSvg(exportedSvg);
            }
          })();
        }
      } else {
        (async () => {
          const exportedSvg = await exportLibraryItemToSvg(elements);
          setSvg(exportedSvg);
        })();
      }
    }
  }, [id, elements, svgCache, setSvg]);
  return svg;
};
var useLibraryCache = () => {
  const [svgCache] = useAtom(libraryItemSvgsCache, jotaiScope);
  const clearLibraryCache = () => svgCache.clear();
  const deleteItemsFromLibraryCache = (items) => {
    items.forEach((item) => svgCache.delete(item));
  };
  return {
    clearLibraryCache,
    deleteItemsFromLibraryCache,
    svgCache
  };
};

// queue.ts
init_define_import_meta_env();
var Queue = class {
  jobs = [];
  running = false;
  tick() {
    if (this.running) {
      return;
    }
    const job = this.jobs.shift();
    if (job) {
      this.running = true;
      job.promise.resolve(
        promiseTry(job.jobFactory, ...job.args).finally(() => {
          this.running = false;
          this.tick();
        })
      );
    } else {
      this.running = false;
    }
  }
  push(jobFactory, ...args) {
    const promise = resolvablePromise();
    this.jobs.push({ jobFactory, promise, args });
    this.tick();
    return promise;
  }
};

// data/library.ts
var onLibraryUpdateEmitter = new Emitter();
var libraryItemsAtom = atom2({ status: "loaded", isInitialized: false, libraryItems: [] });
var cloneLibraryItems = (libraryItems) => cloneJSON(libraryItems);
var isUniqueItem = (existingLibraryItems, targetLibraryItem) => {
  return !existingLibraryItems.find((libraryItem) => {
    if (libraryItem.elements.length !== targetLibraryItem.elements.length) {
      return false;
    }
    return libraryItem.elements.every((libItemExcalidrawItem, idx) => {
      return libItemExcalidrawItem.id === targetLibraryItem.elements[idx].id && libItemExcalidrawItem.versionNonce === targetLibraryItem.elements[idx].versionNonce;
    });
  });
};
var mergeLibraryItems = (localItems, otherItems) => {
  const newItems = [];
  for (const item of otherItems) {
    if (isUniqueItem(localItems, item)) {
      newItems.push(item);
    }
  }
  return [...newItems, ...localItems];
};
var createLibraryUpdate = (prevLibraryItems, nextLibraryItems) => {
  const nextItemsMap = arrayToMap(nextLibraryItems);
  const update = {
    deletedItems: /* @__PURE__ */ new Map(),
    addedItems: /* @__PURE__ */ new Map()
  };
  for (const item of prevLibraryItems) {
    if (!nextItemsMap.has(item.id)) {
      update.deletedItems.set(item.id, item);
    }
  }
  const prevItemsMap = arrayToMap(prevLibraryItems);
  for (const item of nextLibraryItems) {
    if (!prevItemsMap.has(item.id)) {
      update.addedItems.set(item.id, item);
    }
  }
  return update;
};
var Library = class {
  /** latest libraryItems */
  currLibraryItems = [];
  /** snapshot of library items since last onLibraryChange call */
  prevLibraryItems = cloneLibraryItems(this.currLibraryItems);
  app;
  constructor(app) {
    this.app = app;
  }
  updateQueue = [];
  getLastUpdateTask = () => {
    return this.updateQueue[this.updateQueue.length - 1];
  };
  notifyListeners = () => {
    if (this.updateQueue.length > 0) {
      jotaiStore.set(libraryItemsAtom, (s3) => ({
        status: "loading",
        libraryItems: this.currLibraryItems,
        isInitialized: s3.isInitialized
      }));
    } else {
      jotaiStore.set(libraryItemsAtom, {
        status: "loaded",
        libraryItems: this.currLibraryItems,
        isInitialized: true
      });
      try {
        const prevLibraryItems = this.prevLibraryItems;
        this.prevLibraryItems = cloneLibraryItems(this.currLibraryItems);
        const nextLibraryItems = cloneLibraryItems(this.currLibraryItems);
        this.app.props.onLibraryChange?.(nextLibraryItems);
        onLibraryUpdateEmitter.trigger(
          createLibraryUpdate(prevLibraryItems, nextLibraryItems),
          nextLibraryItems
        );
      } catch (error) {
        console.error(error);
      }
    }
  };
  /** call on excalidraw instance unmount */
  destroy = () => {
    this.updateQueue = [];
    this.currLibraryItems = [];
    jotaiStore.set(libraryItemSvgsCache, /* @__PURE__ */ new Map());
  };
  resetLibrary = () => {
    return this.setLibrary([]);
  };
  /**
   * @returns latest cloned libraryItems. Awaits all in-progress updates first.
   */
  getLatestLibrary = () => {
    return new Promise(async (resolve) => {
      try {
        const libraryItems = await (this.getLastUpdateTask() || this.currLibraryItems);
        if (this.updateQueue.length > 0) {
          resolve(this.getLatestLibrary());
        } else {
          resolve(cloneLibraryItems(libraryItems));
        }
      } catch (error) {
        return resolve(this.currLibraryItems);
      }
    });
  };
  // NOTE this is a high-level public API (exposed on ExcalidrawAPI) with
  // a slight overhead (always restoring library items). For internal use
  // where merging isn't needed, use `library.setLibrary()` directly.
  updateLibrary = async ({
    libraryItems,
    prompt = false,
    merge = false,
    openLibraryMenu = false,
    defaultStatus = "unpublished"
  }) => {
    if (openLibraryMenu) {
      this.app.setState({
        openSidebar: { name: DEFAULT_SIDEBAR.name, tab: LIBRARY_SIDEBAR_TAB }
      });
    }
    return this.setLibrary(() => {
      return new Promise(async (resolve, reject) => {
        try {
          const source = await (typeof libraryItems === "function" && !(libraryItems instanceof Blob) ? libraryItems(this.currLibraryItems) : libraryItems);
          let nextItems;
          if (source instanceof Blob) {
            nextItems = await loadLibraryFromBlob(source, defaultStatus);
          } else {
            nextItems = restoreLibraryItems(source, defaultStatus);
          }
          if (!prompt || window.confirm(
            t("alerts.confirmAddLibrary", {
              numShapes: nextItems.length
            })
          )) {
            if (prompt) {
              this.app.focusContainer();
            }
            if (merge) {
              resolve(mergeLibraryItems(this.currLibraryItems, nextItems));
            } else {
              resolve(nextItems);
            }
          } else {
            reject(new AbortError());
          }
        } catch (error) {
          reject(error);
        }
      });
    });
  };
  setLibrary = (libraryItems) => {
    const task = new Promise(async (resolve, reject) => {
      try {
        await this.getLastUpdateTask();
        if (typeof libraryItems === "function") {
          libraryItems = libraryItems(this.currLibraryItems);
        }
        this.currLibraryItems = cloneLibraryItems(await libraryItems);
        resolve(this.currLibraryItems);
      } catch (error) {
        reject(error);
      }
    }).catch((error) => {
      if (error.name === "AbortError") {
        console.warn("Library update aborted by user");
        return this.currLibraryItems;
      }
      throw error;
    }).finally(() => {
      this.updateQueue = this.updateQueue.filter((_task) => _task !== task);
      this.notifyListeners();
    });
    this.updateQueue.push(task);
    this.notifyListeners();
    return task;
  };
};
var library_default = Library;
var distributeLibraryItemsOnSquareGrid = (libraryItems) => {
  const PADDING = 50;
  const ITEMS_PER_ROW = Math.ceil(Math.sqrt(libraryItems.length));
  const resElements = [];
  const getMaxHeightPerRow = (row2) => {
    const maxHeight = libraryItems.slice(row2 * ITEMS_PER_ROW, row2 * ITEMS_PER_ROW + ITEMS_PER_ROW).reduce((acc, item) => {
      const { height } = getCommonBoundingBox(item.elements);
      return Math.max(acc, height);
    }, 0);
    return maxHeight;
  };
  const getMaxWidthPerCol = (targetCol) => {
    let index3 = 0;
    let currCol = 0;
    let maxWidth = 0;
    for (const item of libraryItems) {
      if (index3 % ITEMS_PER_ROW === 0) {
        currCol = 0;
      }
      if (currCol === targetCol) {
        const { width } = getCommonBoundingBox(item.elements);
        maxWidth = Math.max(maxWidth, width);
      }
      index3++;
      currCol++;
    }
    return maxWidth;
  };
  let colOffsetX = 0;
  let rowOffsetY = 0;
  let maxHeightCurrRow = 0;
  let maxWidthCurrCol = 0;
  let index2 = 0;
  let col = 0;
  let row = 0;
  for (const item of libraryItems) {
    if (index2 && index2 % ITEMS_PER_ROW === 0) {
      rowOffsetY += maxHeightCurrRow + PADDING;
      colOffsetX = 0;
      col = 0;
      row++;
    }
    if (col === 0) {
      maxHeightCurrRow = getMaxHeightPerRow(row);
    }
    maxWidthCurrCol = getMaxWidthPerCol(col);
    const { minX, minY, width, height } = getCommonBoundingBox(item.elements);
    const offsetCenterX = (maxWidthCurrCol - width) / 2;
    const offsetCenterY = (maxHeightCurrRow - height) / 2;
    resElements.push(
      ...item.elements.map((element) => ({
        ...element,
        x: element.x + // offset for column
        colOffsetX + // offset to center in given square grid
        offsetCenterX - // subtract minX so that given item starts at 0 coord
        minX,
        y: element.y + // offset for row
        rowOffsetY + // offset to center in given square grid
        offsetCenterY - // subtract minY so that given item starts at 0 coord
        minY
      }))
    );
    colOffsetX += maxWidthCurrCol + PADDING;
    index2++;
    col++;
  }
  return resElements;
};
var parseLibraryTokensFromUrl = () => {
  const libraryUrl = (
    // current
    new URLSearchParams(window.location.hash.slice(1)).get(
      URL_HASH_KEYS.addLibrary
    ) || // legacy, kept for compat reasons
    new URLSearchParams(window.location.search).get(URL_QUERY_KEYS.addLibrary)
  );
  const idToken = libraryUrl ? new URLSearchParams(window.location.hash.slice(1)).get("token") : null;
  return libraryUrl ? { libraryUrl, idToken } : null;
};
var AdapterTransaction = class _AdapterTransaction {
  static queue = new Queue();
  static async getLibraryItems(adapter, source, _queue = true) {
    const task = () => new Promise(async (resolve, reject) => {
      try {
        const data = await adapter.load({ source });
        resolve(restoreLibraryItems(data?.libraryItems || [], "published"));
      } catch (error) {
        reject(error);
      }
    });
    if (_queue) {
      return _AdapterTransaction.queue.push(task);
    }
    return task();
  }
  static run = async (adapter, fn) => {
    const transaction = new _AdapterTransaction(adapter);
    return _AdapterTransaction.queue.push(() => fn(transaction));
  };
  // ------------------
  adapter;
  constructor(adapter) {
    this.adapter = adapter;
  }
  getLibraryItems(source) {
    return _AdapterTransaction.getLibraryItems(this.adapter, source, false);
  }
};
var lastSavedLibraryItemsHash = 0;
var librarySaveCounter = 0;
var getLibraryItemsHash = (items) => {
  return hashString(
    items.map((item) => {
      return `${item.id}:${hashElementsVersion(item.elements)}`;
    }).sort().join()
  );
};
var persistLibraryUpdate = async (adapter, update) => {
  try {
    librarySaveCounter++;
    return await AdapterTransaction.run(adapter, async (transaction) => {
      const nextLibraryItemsMap = arrayToMap(
        await transaction.getLibraryItems("save")
      );
      for (const [id] of update.deletedItems) {
        nextLibraryItemsMap.delete(id);
      }
      const addedItems = [];
      for (const [id, item] of update.addedItems) {
        if (nextLibraryItemsMap.has(id)) {
          nextLibraryItemsMap.set(id, item);
        } else {
          addedItems.push(item);
        }
      }
      const nextLibraryItems = addedItems.concat(
        Array.from(nextLibraryItemsMap.values())
      );
      const version = getLibraryItemsHash(nextLibraryItems);
      if (version !== lastSavedLibraryItemsHash) {
        await adapter.save({ libraryItems: nextLibraryItems });
      }
      lastSavedLibraryItemsHash = version;
      return nextLibraryItems;
    });
  } finally {
    librarySaveCounter--;
  }
};
var useHandleLibrary = (opts) => {
  const { excalidrawAPI } = opts;
  const optsRef = (0, import_react57.useRef)(opts);
  optsRef.current = opts;
  const isLibraryLoadedRef = (0, import_react57.useRef)(false);
  (0, import_react57.useEffect)(() => {
    if (!excalidrawAPI) {
      return;
    }
    isLibraryLoadedRef.current = false;
    const importLibraryFromURL = async ({
      libraryUrl,
      idToken
    }) => {
      const libraryPromise = new Promise(async (resolve, reject) => {
        try {
          const request = await fetch(decodeURIComponent(libraryUrl));
          const blob = await request.blob();
          resolve(blob);
        } catch (error) {
          reject(error);
        }
      });
      const shouldPrompt = idToken !== excalidrawAPI.id;
      await (shouldPrompt && document.hidden ? new Promise((resolve) => {
        window.addEventListener("focus", () => resolve(), {
          once: true
        });
      }) : null);
      try {
        await excalidrawAPI.updateLibrary({
          libraryItems: libraryPromise,
          prompt: shouldPrompt,
          merge: true,
          defaultStatus: "published",
          openLibraryMenu: true
        });
      } catch (error) {
        throw error;
      } finally {
        if (window.location.hash.includes(URL_HASH_KEYS.addLibrary)) {
          const hash = new URLSearchParams(window.location.hash.slice(1));
          hash.delete(URL_HASH_KEYS.addLibrary);
          window.history.replaceState({}, APP_NAME, `#${hash.toString()}`);
        } else if (window.location.search.includes(URL_QUERY_KEYS.addLibrary)) {
          const query = new URLSearchParams(window.location.search);
          query.delete(URL_QUERY_KEYS.addLibrary);
          window.history.replaceState({}, APP_NAME, `?${query.toString()}`);
        }
      }
    };
    const onHashChange = (event) => {
      event.preventDefault();
      const libraryUrlTokens2 = parseLibraryTokensFromUrl();
      if (libraryUrlTokens2) {
        event.stopImmediatePropagation();
        window.history.replaceState({}, "", event.oldURL);
        importLibraryFromURL(libraryUrlTokens2);
      }
    };
    const libraryUrlTokens = parseLibraryTokensFromUrl();
    if (libraryUrlTokens) {
      importLibraryFromURL(libraryUrlTokens);
    }
    if ("getInitialLibraryItems" in optsRef.current && optsRef.current.getInitialLibraryItems) {
      console.warn(
        "useHandleLibrar `opts.getInitialLibraryItems` is deprecated. Use `opts.adapter` instead."
      );
      Promise.resolve(optsRef.current.getInitialLibraryItems()).then((libraryItems) => {
        excalidrawAPI.updateLibrary({
          libraryItems,
          // merge with current library items because we may have already
          // populated it (e.g. by installing 3rd party library which can
          // happen before the DB data is loaded)
          merge: true
        });
      }).catch((error) => {
        console.error(
          `UseHandeLibrary getInitialLibraryItems failed: ${error?.message}`
        );
      });
    }
    if ("adapter" in optsRef.current && optsRef.current.adapter) {
      const adapter = optsRef.current.adapter;
      const migrationAdapter = optsRef.current.migrationAdapter;
      const initDataPromise = resolvablePromise();
      if (migrationAdapter) {
        initDataPromise.resolve(
          promiseTry(migrationAdapter.load).then(async (libraryData) => {
            let restoredData = null;
            try {
              if (!libraryData) {
                return AdapterTransaction.getLibraryItems(adapter, "load");
              }
              restoredData = restoreLibraryItems(
                libraryData.libraryItems || [],
                "published"
              );
              const nextItems = await persistLibraryUpdate(
                adapter,
                createLibraryUpdate([], restoredData)
              );
              try {
                await migrationAdapter.clear();
              } catch (error) {
                console.error(
                  `couldn't delete legacy library data: ${error.message}`
                );
              }
              return nextItems;
            } catch (error) {
              console.error(
                `couldn't migrate legacy library data: ${error.message}`
              );
              return restoredData;
            }
          }).catch((error) => {
            console.error(`error during library migration: ${error.message}`);
            return AdapterTransaction.getLibraryItems(adapter, "load");
          })
        );
      } else {
        initDataPromise.resolve(
          promiseTry(AdapterTransaction.getLibraryItems, adapter, "load")
        );
      }
      excalidrawAPI.updateLibrary({
        libraryItems: initDataPromise.then((libraryItems) => {
          const _libraryItems = libraryItems || [];
          lastSavedLibraryItemsHash = getLibraryItemsHash(_libraryItems);
          return _libraryItems;
        }),
        // merge with current library items because we may have already
        // populated it (e.g. by installing 3rd party library which can
        // happen before the DB data is loaded)
        merge: true
      }).finally(() => {
        isLibraryLoadedRef.current = true;
      });
    }
    window.addEventListener("hashchange" /* HASHCHANGE */, onHashChange);
    return () => {
      window.removeEventListener("hashchange" /* HASHCHANGE */, onHashChange);
    };
  }, [
    // important this useEffect only depends on excalidrawAPI so it only reruns
    // on editor remounts (the excalidrawAPI changes)
    excalidrawAPI
  ]);
  (0, import_react57.useEffect)(
    () => {
      const unsubOnLibraryUpdate = onLibraryUpdateEmitter.on(
        async (update, nextLibraryItems) => {
          const isLoaded = isLibraryLoadedRef.current;
          const adapter = "adapter" in optsRef.current && optsRef.current.adapter || null;
          try {
            if (adapter) {
              if (
                // if nextLibraryItems hash identical to previously saved hash,
                // exit early, even if actual upstream state ends up being
                // different (e.g. has more data than we have locally), as it'd
                // be low-impact scenario.
                lastSavedLibraryItemsHash !== getLibraryItemsHash(nextLibraryItems)
              ) {
                await persistLibraryUpdate(adapter, update);
              }
            }
          } catch (error) {
            console.error(
              `couldn't persist library update: ${error.message}`,
              update
            );
            if (isLoaded && optsRef.current.excalidrawAPI) {
              optsRef.current.excalidrawAPI.updateScene({
                appState: {
                  errorMessage: t("errors.saveLibraryError")
                }
              });
            }
          }
        }
      );
      const onUnload = (event) => {
        if (librarySaveCounter) {
          preventUnload(event);
        }
      };
      window.addEventListener("beforeunload" /* BEFORE_UNLOAD */, onUnload);
      return () => {
        window.removeEventListener("beforeunload" /* BEFORE_UNLOAD */, onUnload);
        unsubOnLibraryUpdate();
        lastSavedLibraryItemsHash = 0;
        librarySaveCounter = 0;
      };
    },
    [
      // this effect must not have any deps so it doesn't rerun
    ]
  );
};

// components/LibraryMenuItems.tsx
init_define_import_meta_env();
var import_react68 = __toESM(require_react(), 1);

// components/Stack.tsx
init_define_import_meta_env();
var import_react58 = __toESM(require_react(), 1);
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
var RowStack = (0, import_react58.forwardRef)(
  ({ children, gap, align, justifyContent, className, style }, ref) => {
    return /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(
      "div",
      {
        className: clsx_m_default("Stack Stack_horizontal", className),
        style: {
          "--gap": gap,
          alignItems: align,
          justifyContent,
          ...style
        },
        ref,
        children
      }
    );
  }
);
var ColStack = (0, import_react58.forwardRef)(
  ({ children, gap, align, justifyContent, className, style }, ref) => {
    return /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(
      "div",
      {
        className: clsx_m_default("", className),
        style: {
          "--gap": gap,
          justifyItems: align,
          justifyContent,
          ...style
        },
        ref,
        children
      }
    );
  }
);
var Stack_default = {
  Row: RowStack,
  Col: ColStack
};

// components/LibraryMenuControlButtons.tsx
init_define_import_meta_env();

// components/LibraryMenuBrowseButton.tsx
init_define_import_meta_env();
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);
var LibraryMenuBrowseButton = ({
  theme,
  id,
  libraryReturnUrl
}) => {
  const referrer = libraryReturnUrl || window.location.origin + window.location.pathname;
  return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(
    "a",
    {
      className: "library-menu-browse-button",
      href: `${define_import_meta_env_default.VITE_APP_LIBRARY_URL}?target=${window.name || "_blank"}&referrer=${referrer}&useHash=true&token=${id}&theme=${theme}&version=${VERSIONS.excalidrawLibrary}`,
      target: "_excalidraw_libraries",
      children: t("labels.libraries")
    }
  );
};
var LibraryMenuBrowseButton_default = LibraryMenuBrowseButton;

// components/LibraryMenuControlButtons.tsx
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
var LibraryMenuControlButtons = ({
  libraryReturnUrl,
  theme,
  id,
  style,
  children,
  className
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime52.jsxs)(
    "div",
    {
      className: clsx_m_default("library-menu-control-buttons", className),
      style,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(
          LibraryMenuBrowseButton_default,
          {
            id,
            libraryReturnUrl,
            theme
          }
        ),
        children
      ]
    }
  );
};

// components/LibraryMenuHeaderContent.tsx
init_define_import_meta_env();
var import_react63 = __toESM(require_react(), 1);

// components/Trans.tsx
init_define_import_meta_env();
var import_react59 = __toESM(require_react(), 1);
var SPLIT_REGEX = /({{[\w-]+}})|(<[\w-]+>)|(<\/[\w-]+>)/g;
var KEY_REGEXP = /{{([\w-]+)}}/;
var TAG_START_REGEXP = /<([\w-]+)>/;
var TAG_END_REGEXP = /<\/([\w-]+)>/;
var getTransChildren = (format, props) => {
  const stack = [
    {
      name: "",
      children: []
    }
  ];
  format.split(SPLIT_REGEX).filter(Boolean).forEach((match) => {
    const tagStartMatch = match.match(TAG_START_REGEXP);
    const tagEndMatch = match.match(TAG_END_REGEXP);
    const keyMatch = match.match(KEY_REGEXP);
    if (tagStartMatch !== null) {
      const name = tagStartMatch[1];
      if (props.hasOwnProperty(name)) {
        stack.push({
          name,
          children: []
        });
      } else {
        console.warn(
          `Trans: missed to pass in prop ${name} for interpolating ${format}`
        );
      }
    } else if (tagEndMatch !== null) {
      const name = tagEndMatch[1];
      if (name === stack[stack.length - 1].name) {
        const item = stack.pop();
        const itemChildren = import_react59.default.createElement(
          import_react59.default.Fragment,
          {},
          ...item.children
        );
        const fn = props[item.name];
        if (typeof fn === "function") {
          stack[stack.length - 1].children.push(fn(itemChildren));
        }
      } else {
        console.warn(
          `Trans: unexpected end tag ${match} for interpolating ${format}`
        );
      }
    } else if (keyMatch !== null) {
      const name = keyMatch[1];
      if (props.hasOwnProperty(name)) {
        stack[stack.length - 1].children.push(props[name]);
      } else {
        console.warn(
          `Trans: key ${name} not in props for interpolating ${format}`
        );
      }
    } else {
      stack[stack.length - 1].children.push(match);
    }
  });
  if (stack.length !== 1) {
    console.warn(`Trans: stack not empty for interpolating ${format}`);
  }
  return stack[0].children;
};
var Trans = ({
  i18nKey,
  children,
  ...props
}) => {
  const { t: t3 } = useI18n();
  return import_react59.default.createElement(
    import_react59.default.Fragment,
    {},
    ...getTransChildren(t3(i18nKey), props)
  );
};
var Trans_default = Trans;

// components/ConfirmDialog.tsx
init_define_import_meta_env();

// components/DialogActionButton.tsx
init_define_import_meta_env();
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
var DialogActionButton = ({
  label,
  onClick,
  className,
  children,
  actionType,
  type = "button",
  isLoading,
  ...rest
}) => {
  const cs = actionType ? `Dialog__action-button--${actionType}` : "";
  return /* @__PURE__ */ (0, import_jsx_runtime53.jsxs)(
    "button",
    {
      className: clsx_m_default("Dialog__action-button", cs, className),
      type,
      "aria-label": label,
      onClick,
      ...rest,
      children: [
        children && /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("div", { style: isLoading ? { visibility: "hidden" } : {}, children }),
        /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("div", { style: isLoading ? { visibility: "hidden" } : {}, children: label }),
        isLoading && /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("div", { style: { position: "absolute", inset: 0 }, children: /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(Spinner_default, {}) })
      ]
    }
  );
};
var DialogActionButton_default = DialogActionButton;

// components/ConfirmDialog.tsx
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);
var ConfirmDialog = (props) => {
  const {
    onConfirm,
    onCancel,
    children,
    confirmText = t("buttons.confirm"),
    cancelText = t("buttons.cancel"),
    className = "",
    ...rest
  } = props;
  const setAppState = useExcalidrawSetAppState();
  const setIsLibraryMenuOpen = useSetAtom(isLibraryMenuOpenAtom, jotaiScope);
  const { container } = useExcalidrawContainer();
  return /* @__PURE__ */ (0, import_jsx_runtime54.jsxs)(
    Dialog,
    {
      onCloseRequest: onCancel,
      size: "small",
      ...rest,
      className: `confirm-dialog ${className}`,
      children: [
        children,
        /* @__PURE__ */ (0, import_jsx_runtime54.jsxs)("div", { className: "confirm-dialog-buttons", children: [
          /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
            DialogActionButton_default,
            {
              label: cancelText,
              onClick: () => {
                setAppState({ openMenu: null });
                setIsLibraryMenuOpen(false);
                onCancel();
                container?.focus();
              }
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
            DialogActionButton_default,
            {
              label: confirmText,
              onClick: () => {
                setAppState({ openMenu: null });
                setIsLibraryMenuOpen(false);
                onConfirm();
                container?.focus();
              },
              actionType: "danger"
            }
          )
        ] })
      ]
    }
  );
};
var ConfirmDialog_default = ConfirmDialog;

// components/PublishLibrary.tsx
init_define_import_meta_env();
var import_react60 = __toESM(require_react(), 1);

// data/EditorLocalStorage.ts
init_define_import_meta_env();
var EditorLocalStorage = class {
  static has(key) {
    try {
      return !!window.localStorage.getItem(key);
    } catch (error) {
      console.warn(`localStorage.getItem error: ${error.message}`);
      return false;
    }
  }
  static get(key) {
    try {
      const value = window.localStorage.getItem(key);
      if (value) {
        return JSON.parse(value);
      }
      return null;
    } catch (error) {
      console.warn(`localStorage.getItem error: ${error.message}`);
      return null;
    }
  }
  static set = (key, value) => {
    try {
      window.localStorage.setItem(key, JSON.stringify(value));
      return true;
    } catch (error) {
      console.warn(`localStorage.setItem error: ${error.message}`);
      return false;
    }
  };
  static delete = (name) => {
    try {
      window.localStorage.removeItem(name);
    } catch (error) {
      console.warn(`localStorage.removeItem error: ${error.message}`);
    }
  };
};

// components/PublishLibrary.tsx
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);
var generatePreviewImage = async (libraryItems) => {
  const MAX_ITEMS_PER_ROW = 6;
  const BOX_SIZE = 128;
  const BOX_PADDING = Math.round(BOX_SIZE / 16);
  const BORDER_WIDTH = Math.max(Math.round(BOX_SIZE / 64), 2);
  const rows = chunk(libraryItems, MAX_ITEMS_PER_ROW);
  const canvas = document.createElement("canvas");
  canvas.width = rows[0].length * BOX_SIZE + (rows[0].length + 1) * (BOX_PADDING * 2) - BOX_PADDING * 2;
  canvas.height = rows.length * BOX_SIZE + (rows.length + 1) * (BOX_PADDING * 2) - BOX_PADDING * 2;
  const ctx = canvas.getContext("2d");
  ctx.fillStyle = open_color_default.white;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  for (const [index2, item] of libraryItems.entries()) {
    const itemCanvas = await exportToCanvas2({
      elements: item.elements,
      files: null,
      maxWidthOrHeight: BOX_SIZE
    });
    const { width, height } = itemCanvas;
    const rowOffset = Math.floor(index2 / MAX_ITEMS_PER_ROW) * (BOX_SIZE + BOX_PADDING * 2);
    const colOffset = index2 % MAX_ITEMS_PER_ROW * (BOX_SIZE + BOX_PADDING * 2);
    ctx.drawImage(
      itemCanvas,
      colOffset + (BOX_SIZE - width) / 2 + BOX_PADDING,
      rowOffset + (BOX_SIZE - height) / 2 + BOX_PADDING
    );
    ctx.lineWidth = BORDER_WIDTH;
    ctx.strokeStyle = open_color_default.gray[4];
    ctx.strokeRect(
      colOffset + BOX_PADDING / 2,
      rowOffset + BOX_PADDING / 2,
      BOX_SIZE + BOX_PADDING,
      BOX_SIZE + BOX_PADDING
    );
  }
  return await resizeImageFile(
    new File([await canvasToBlob(canvas)], "preview", { type: MIME_TYPES.png }),
    {
      outputType: MIME_TYPES.jpg,
      maxWidthOrHeight: 5e3
    }
  );
};
var SingleLibraryItem = ({
  libItem,
  appState,
  index: index2,
  onChange,
  onRemove
}) => {
  const svgRef = (0, import_react60.useRef)(null);
  const inputRef = (0, import_react60.useRef)(null);
  (0, import_react60.useEffect)(() => {
    const node = svgRef.current;
    if (!node) {
      return;
    }
    (async () => {
      const svg = await exportToSvg2({
        elements: libItem.elements,
        appState: {
          ...appState,
          viewBackgroundColor: open_color_default.white,
          exportBackground: true
        },
        files: null,
        skipInliningFonts: true
      });
      node.innerHTML = svg.outerHTML;
    })();
  }, [libItem.elements, appState]);
  return /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)("div", { className: "single-library-item", children: [
    libItem.status === "published" && /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("span", { className: "single-library-item-status", children: t("labels.statusPublished") }),
    /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("div", { ref: svgRef, className: "single-library-item__svg" }),
    /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
      ToolButton,
      {
        "aria-label": t("buttons.remove"),
        type: "button",
        icon: CloseIcon,
        className: "single-library-item--remove",
        onClick: onRemove.bind(null, libItem.id),
        title: t("buttons.remove")
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)(
      "div",
      {
        style: {
          display: "flex",
          margin: "0.8rem 0",
          width: "100%",
          fontSize: "14px",
          fontWeight: 500,
          flexDirection: "column"
        },
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)(
            "label",
            {
              style: {
                display: "flex",
                justifyContent: "space-between",
                flexDirection: "column"
              },
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)("div", { style: { padding: "0.5em 0" }, children: [
                  /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("span", { style: { fontWeight: 500, color: open_color_default.gray[6] }, children: t("publishDialog.itemName") }),
                  /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("span", { "aria-hidden": "true", className: "required", children: "*" })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
                  "input",
                  {
                    type: "text",
                    ref: inputRef,
                    style: { width: "80%", padding: "0.2rem" },
                    defaultValue: libItem.name,
                    placeholder: "Item name",
                    onChange: (event) => {
                      onChange(event.target.value, index2);
                    }
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("span", { className: "error", children: libItem.error })
        ]
      }
    )
  ] });
};
var PublishLibrary = ({
  onClose,
  libraryItems,
  appState,
  onSuccess,
  onError,
  updateItemsInStorage,
  onRemove
}) => {
  const [libraryData, setLibraryData] = (0, import_react60.useState)({
    authorName: "",
    githubHandle: "",
    name: "",
    description: "",
    twitterHandle: "",
    website: ""
  });
  const [isSubmitting, setIsSubmitting] = (0, import_react60.useState)(false);
  (0, import_react60.useEffect)(() => {
    const data = EditorLocalStorage.get(
      EDITOR_LS_KEYS.PUBLISH_LIBRARY
    );
    if (data) {
      setLibraryData(data);
    }
  }, []);
  const [clonedLibItems, setClonedLibItems] = (0, import_react60.useState)(
    libraryItems.slice()
  );
  (0, import_react60.useEffect)(() => {
    setClonedLibItems(libraryItems.slice());
  }, [libraryItems]);
  const onInputChange = (event) => {
    setLibraryData({
      ...libraryData,
      [event.target.name]: event.target.value
    });
  };
  const onSubmit = async (event) => {
    event.preventDefault();
    setIsSubmitting(true);
    const erroredLibItems = [];
    let isError = false;
    clonedLibItems.forEach((libItem) => {
      let error = "";
      if (!libItem.name) {
        error = t("publishDialog.errors.required");
        isError = true;
      }
      erroredLibItems.push({ ...libItem, error });
    });
    if (isError) {
      setClonedLibItems(erroredLibItems);
      setIsSubmitting(false);
      return;
    }
    const previewImage = await generatePreviewImage(clonedLibItems);
    const libContent = {
      type: EXPORT_DATA_TYPES.excalidrawLibrary,
      version: VERSIONS.excalidrawLibrary,
      source: EXPORT_SOURCE,
      libraryItems: clonedLibItems
    };
    const content = JSON.stringify(libContent, null, 2);
    const lib = new Blob([content], { type: "application/json" });
    const formData = new FormData();
    formData.append("excalidrawLib", lib);
    formData.append("previewImage", previewImage);
    formData.append("previewImageType", previewImage.type);
    formData.append("title", libraryData.name);
    formData.append("authorName", libraryData.authorName);
    formData.append("githubHandle", libraryData.githubHandle);
    formData.append("name", libraryData.name);
    formData.append("description", libraryData.description);
    formData.append("twitterHandle", libraryData.twitterHandle);
    formData.append("website", libraryData.website);
    fetch(`${define_import_meta_env_default.VITE_APP_LIBRARY_BACKEND}/submit`, {
      method: "post",
      body: formData
    }).then(
      (response) => {
        if (response.ok) {
          return response.json().then(({ url }) => {
            EditorLocalStorage.delete(EDITOR_LS_KEYS.PUBLISH_LIBRARY);
            onSuccess({
              url,
              authorName: libraryData.authorName,
              items: clonedLibItems
            });
          });
        }
        return response.json().catch(() => {
          throw new Error(response.statusText || "something went wrong");
        }).then((error) => {
          throw new Error(
            error.message || response.statusText || "something went wrong"
          );
        });
      },
      (err) => {
        console.error(err);
        onError(err);
        setIsSubmitting(false);
      }
    ).catch((err) => {
      console.error(err);
      onError(err);
      setIsSubmitting(false);
    });
  };
  const renderLibraryItems = () => {
    const items = [];
    clonedLibItems.forEach((libItem, index2) => {
      items.push(
        /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("div", { className: "single-library-item-wrapper", children: /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
          SingleLibraryItem,
          {
            libItem,
            appState,
            index: index2,
            onChange: (val, index3) => {
              const items2 = clonedLibItems.slice();
              items2[index3].name = val;
              setClonedLibItems(items2);
            },
            onRemove
          }
        ) }, index2)
      );
    });
    return /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("div", { className: "selected-library-items", children: items });
  };
  const onDialogClose = (0, import_react60.useCallback)(() => {
    updateItemsInStorage(clonedLibItems);
    EditorLocalStorage.set(EDITOR_LS_KEYS.PUBLISH_LIBRARY, libraryData);
    onClose();
  }, [clonedLibItems, onClose, updateItemsInStorage, libraryData]);
  const shouldRenderForm = !!libraryItems.length;
  const containsPublishedItems = libraryItems.some(
    (item) => item.status === "published"
  );
  return /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
    Dialog,
    {
      onCloseRequest: onDialogClose,
      title: t("publishDialog.title"),
      className: "publish-library",
      children: shouldRenderForm ? /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)("form", { onSubmit, children: [
        /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("div", { className: "publish-library-note", children: /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
          Trans_default,
          {
            i18nKey: "publishDialog.noteDescription",
            link: (el) => /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
              "a",
              {
                href: "https://libraries.excalidraw.com",
                target: "_blank",
                rel: "noopener noreferrer",
                children: el
              }
            )
          }
        ) }),
        /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("span", { className: "publish-library-note", children: /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
          Trans_default,
          {
            i18nKey: "publishDialog.noteGuidelines",
            link: (el) => /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
              "a",
              {
                href: "https://github.com/excalidraw/excalidraw-libraries#guidelines",
                target: "_blank",
                rel: "noopener noreferrer",
                children: el
              }
            )
          }
        ) }),
        /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("div", { className: "publish-library-note", children: t("publishDialog.noteItems") }),
        containsPublishedItems && /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("span", { className: "publish-library-note publish-library-warning", children: t("publishDialog.republishWarning") }),
        renderLibraryItems(),
        /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)("div", { className: "publish-library__fields", children: [
          /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)("label", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)("div", { children: [
              /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("span", { children: t("publishDialog.libraryName") }),
              /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("span", { "aria-hidden": "true", className: "required", children: "*" })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
              "input",
              {
                type: "text",
                name: "name",
                required: true,
                value: libraryData.name,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.libraryName")
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)("label", { style: { alignItems: "flex-start" }, children: [
            /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)("div", { children: [
              /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("span", { children: t("publishDialog.libraryDesc") }),
              /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("span", { "aria-hidden": "true", className: "required", children: "*" })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
              "textarea",
              {
                name: "description",
                rows: 4,
                required: true,
                value: libraryData.description,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.libraryDesc")
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)("label", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)("div", { children: [
              /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("span", { children: t("publishDialog.authorName") }),
              /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("span", { "aria-hidden": "true", className: "required", children: "*" })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
              "input",
              {
                type: "text",
                name: "authorName",
                required: true,
                value: libraryData.authorName,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.authorName")
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)("label", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("span", { children: t("publishDialog.githubUsername") }),
            /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
              "input",
              {
                type: "text",
                name: "githubHandle",
                value: libraryData.githubHandle,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.githubHandle")
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)("label", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("span", { children: t("publishDialog.twitterUsername") }),
            /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
              "input",
              {
                type: "text",
                name: "twitterHandle",
                value: libraryData.twitterHandle,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.twitterHandle")
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)("label", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("span", { children: t("publishDialog.website") }),
            /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
              "input",
              {
                type: "text",
                name: "website",
                pattern: "https?://.+",
                title: t("publishDialog.errors.website"),
                value: libraryData.website,
                onChange: onInputChange,
                placeholder: t("publishDialog.placeholder.website")
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("span", { className: "publish-library-note", children: /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
            Trans_default,
            {
              i18nKey: "publishDialog.noteLicense",
              link: (el) => /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
                "a",
                {
                  href: "https://github.com/excalidraw/excalidraw-libraries/blob/main/LICENSE",
                  target: "_blank",
                  rel: "noopener noreferrer",
                  children: el
                }
              )
            }
          ) })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime55.jsxs)("div", { className: "publish-library__buttons", children: [
          /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
            DialogActionButton_default,
            {
              label: t("buttons.cancel"),
              onClick: onDialogClose,
              "data-testid": "cancel-clear-canvas-button"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(
            DialogActionButton_default,
            {
              type: "submit",
              label: t("buttons.submit"),
              actionType: "primary",
              isLoading: isSubmitting
            }
          )
        ] })
      ] }) : /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("p", { style: { padding: "1em", textAlign: "center", fontWeight: 500 }, children: t("publishDialog.atleastOneLibItem") })
    }
  );
};
var PublishLibrary_default = PublishLibrary;

// components/dropdownMenu/DropdownMenu.tsx
init_define_import_meta_env();

// components/dropdownMenu/DropdownMenuTrigger.tsx
init_define_import_meta_env();
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
var MenuTrigger = ({
  className = "",
  children,
  onToggle,
  title,
  ...rest
}) => {
  const device = useDevice();
  const classNames = clsx_m_default(
    `dropdown-menu-button ${className}`,
    "zen-mode-transition",
    {
      "dropdown-menu-button--mobile": device.editor.isMobile
    }
  ).trim();
  return /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(
    "button",
    {
      "data-prevent-outside-click": true,
      className: classNames,
      onClick: onToggle,
      type: "button",
      "data-testid": "dropdown-menu-button",
      title,
      ...rest,
      children
    }
  );
};
var DropdownMenuTrigger_default = MenuTrigger;
MenuTrigger.displayName = "DropdownMenuTrigger";

// components/dropdownMenu/DropdownMenuSeparator.tsx
init_define_import_meta_env();
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
var MenuSeparator = () => /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(
  "div",
  {
    style: {
      height: "1px",
      backgroundColor: "var(--default-border-color)",
      margin: ".5rem 0"
    }
  }
);
var DropdownMenuSeparator_default = MenuSeparator;
MenuSeparator.displayName = "DropdownMenuSeparator";

// components/dropdownMenu/DropdownMenuContent.tsx
init_define_import_meta_env();
var import_react61 = __toESM(require_react(), 1);
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);
var MenuContent = ({
  children,
  onClickOutside,
  className = "",
  onSelect,
  style
}) => {
  const device = useDevice();
  const menuRef = (0, import_react61.useRef)(null);
  const callbacksRef = useStable({ onClickOutside });
  useOutsideClick(menuRef, () => {
    callbacksRef.onClickOutside?.();
  });
  (0, import_react61.useEffect)(() => {
    const onKeyDown = (event) => {
      if (event.key === KEYS.ESCAPE) {
        event.stopImmediatePropagation();
        callbacksRef.onClickOutside?.();
      }
    };
    const option = {
      // so that we can stop propagation of the event before it reaches
      // event handlers that were bound before this one
      capture: true
    };
    document.addEventListener("keydown" /* KEYDOWN */, onKeyDown, option);
    return () => {
      document.removeEventListener("keydown" /* KEYDOWN */, onKeyDown, option);
    };
  }, [callbacksRef]);
  const classNames = clsx_m_default(`dropdown-menu ${className}`, {
    "dropdown-menu--mobile": device.editor.isMobile
  }).trim();
  return /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(DropdownMenuContentPropsContext.Provider, { value: { onSelect }, children: /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(
    "div",
    {
      ref: menuRef,
      className: classNames,
      style,
      "data-testid": "dropdown-menu",
      children: device.editor.isMobile ? /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(Stack_default.Col, { className: "dropdown-menu-container", children }) : /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(
        Island,
        {
          className: "dropdown-menu-container",
          padding: 2,
          style: { zIndex: 2 },
          children
        }
      )
    }
  ) });
};
MenuContent.displayName = "DropdownMenuContent";
var DropdownMenuContent_default = MenuContent;

// components/dropdownMenu/DropdownMenuItemLink.tsx
init_define_import_meta_env();
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);
var DropdownMenuItemLink = ({
  icon,
  shortcut,
  href,
  children,
  onSelect,
  className = "",
  selected,
  rel = "noreferrer",
  ...rest
}) => {
  const handleClick = useHandleDropdownMenuItemClick(rest.onClick, onSelect);
  return /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(
    "a",
    {
      ...rest,
      href,
      target: "_blank",
      rel: "noreferrer",
      className: getDropdownMenuItemClassName(className, selected),
      title: rest.title ?? rest["aria-label"],
      onClick: handleClick,
      children: /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(DropdownMenuItemContent_default, { icon, shortcut, children })
    }
  );
};
var DropdownMenuItemLink_default = DropdownMenuItemLink;
DropdownMenuItemLink.displayName = "DropdownMenuItemLink";

// components/dropdownMenu/DropdownMenuItemCustom.tsx
init_define_import_meta_env();
var import_jsx_runtime60 = __toESM(require_jsx_runtime(), 1);
var DropdownMenuItemCustom = ({
  children,
  className = "",
  selected,
  ...rest
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(
    "div",
    {
      ...rest,
      className: `dropdown-menu-item-base dropdown-menu-item-custom ${className} ${selected ? `dropdown-menu-item--selected` : ``}`.trim(),
      children
    }
  );
};
var DropdownMenuItemCustom_default = DropdownMenuItemCustom;

// components/dropdownMenu/dropdownMenuUtils.ts
init_define_import_meta_env();
var import_react62 = __toESM(require_react(), 1);
var getMenuTriggerComponent = (children) => {
  const comp = import_react62.default.Children.toArray(children).find(
    (child) => import_react62.default.isValidElement(child) && typeof child.type !== "string" && //@ts-ignore
    child?.type.displayName && //@ts-ignore
    child.type.displayName === "DropdownMenuTrigger"
  );
  if (!comp) {
    return null;
  }
  return comp;
};
var getMenuContentComponent = (children) => {
  const comp = import_react62.default.Children.toArray(children).find(
    (child) => import_react62.default.isValidElement(child) && typeof child.type !== "string" && //@ts-ignore
    child?.type.displayName && //@ts-ignore
    child.type.displayName === "DropdownMenuContent"
  );
  if (!comp) {
    return null;
  }
  return comp;
};

// components/dropdownMenu/DropdownMenu.tsx
var import_jsx_runtime61 = __toESM(require_jsx_runtime(), 1);
var DropdownMenu = ({
  children,
  open
}) => {
  const MenuTriggerComp = getMenuTriggerComponent(children);
  const MenuContentComp = getMenuContentComponent(children);
  return /* @__PURE__ */ (0, import_jsx_runtime61.jsxs)(import_jsx_runtime61.Fragment, { children: [
    MenuTriggerComp,
    open && MenuContentComp
  ] });
};
DropdownMenu.Trigger = DropdownMenuTrigger_default;
DropdownMenu.Content = DropdownMenuContent_default;
DropdownMenu.Item = DropdownMenuItem_default;
DropdownMenu.ItemLink = DropdownMenuItemLink_default;
DropdownMenu.ItemCustom = DropdownMenuItemCustom_default;
DropdownMenu.Group = DropdownMenuGroup_default;
DropdownMenu.Separator = DropdownMenuSeparator_default;
var DropdownMenu_default = DropdownMenu;
DropdownMenu.displayName = "DropdownMenu";

// components/LibraryMenuHeaderContent.tsx
var import_jsx_runtime62 = __toESM(require_jsx_runtime(), 1);
var getSelectedItems = (libraryItems, selectedItems) => libraryItems.filter((item) => selectedItems.includes(item.id));
var LibraryDropdownMenuButton = ({
  setAppState,
  selectedItems,
  library,
  onRemoveFromLibrary,
  resetLibrary,
  onSelectItems,
  appState,
  className
}) => {
  const [libraryItemsData] = useAtom(libraryItemsAtom, jotaiScope);
  const [isLibraryMenuOpen, setIsLibraryMenuOpen] = useAtom(
    isLibraryMenuOpenAtom,
    jotaiScope
  );
  const renderRemoveLibAlert = () => {
    const content = selectedItems.length ? t("alerts.removeItemsFromsLibrary", { count: selectedItems.length }) : t("alerts.resetLibrary");
    const title = selectedItems.length ? t("confirmDialog.removeItemsFromLib") : t("confirmDialog.resetLibrary");
    return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
      ConfirmDialog_default,
      {
        onConfirm: () => {
          if (selectedItems.length) {
            onRemoveFromLibrary();
          } else {
            resetLibrary();
          }
          setShowRemoveLibAlert(false);
        },
        onCancel: () => {
          setShowRemoveLibAlert(false);
        },
        title,
        children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)("p", { children: content })
      }
    );
  };
  const [showRemoveLibAlert, setShowRemoveLibAlert] = (0, import_react63.useState)(false);
  const itemsSelected = !!selectedItems.length;
  const items = itemsSelected ? libraryItemsData.libraryItems.filter(
    (item) => selectedItems.includes(item.id)
  ) : libraryItemsData.libraryItems;
  const resetLabel = itemsSelected ? t("buttons.remove") : t("buttons.resetLibrary");
  const [showPublishLibraryDialog, setShowPublishLibraryDialog] = (0, import_react63.useState)(false);
  const [publishLibSuccess, setPublishLibSuccess] = (0, import_react63.useState)(null);
  const renderPublishSuccess = (0, import_react63.useCallback)(() => {
    return /* @__PURE__ */ (0, import_jsx_runtime62.jsxs)(
      Dialog,
      {
        onCloseRequest: () => setPublishLibSuccess(null),
        title: t("publishSuccessDialog.title"),
        className: "publish-library-success",
        size: "small",
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime62.jsx)("p", { children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
            Trans_default,
            {
              i18nKey: "publishSuccessDialog.content",
              authorName: publishLibSuccess.authorName,
              link: (el) => /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
                "a",
                {
                  href: publishLibSuccess?.url,
                  target: "_blank",
                  rel: "noopener noreferrer",
                  children: el
                }
              )
            }
          ) }),
          /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
            ToolButton,
            {
              type: "button",
              title: t("buttons.close"),
              "aria-label": t("buttons.close"),
              label: t("buttons.close"),
              onClick: () => setPublishLibSuccess(null),
              "data-testid": "publish-library-success-close",
              className: "publish-library-success-close"
            }
          )
        ]
      }
    );
  }, [setPublishLibSuccess, publishLibSuccess]);
  const onPublishLibSuccess = (data, libraryItems) => {
    setShowPublishLibraryDialog(false);
    setPublishLibSuccess({ url: data.url, authorName: data.authorName });
    const nextLibItems = libraryItems.slice();
    nextLibItems.forEach((libItem) => {
      if (selectedItems.includes(libItem.id)) {
        libItem.status = "published";
      }
    });
    library.setLibrary(nextLibItems);
  };
  const onLibraryImport = async () => {
    try {
      await library.updateLibrary({
        libraryItems: fileOpen({
          description: "Excalidraw library files"
          // ToDo: Be over-permissive until https://bugs.webkit.org/show_bug.cgi?id=34442
          // gets resolved. Else, iOS users cannot open `.excalidraw` files.
          /*
            extensions: [".json", ".excalidrawlib"],
            */
        }),
        merge: true,
        openLibraryMenu: true
      });
    } catch (error) {
      if (error?.name === "AbortError") {
        console.warn(error);
        return;
      }
      setAppState({ errorMessage: t("errors.importLibraryError") });
    }
  };
  const onLibraryExport = async () => {
    const libraryItems = itemsSelected ? items : await library.getLatestLibrary();
    saveLibraryAsJSON(libraryItems).catch(muteFSAbortError).catch((error) => {
      setAppState({ errorMessage: error.message });
    });
  };
  const renderLibraryMenu = () => {
    return /* @__PURE__ */ (0, import_jsx_runtime62.jsxs)(DropdownMenu_default, { open: isLibraryMenuOpen, children: [
      /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
        DropdownMenu_default.Trigger,
        {
          onToggle: () => setIsLibraryMenuOpen(!isLibraryMenuOpen),
          children: DotsIcon
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime62.jsxs)(
        DropdownMenu_default.Content,
        {
          onClickOutside: () => setIsLibraryMenuOpen(false),
          onSelect: () => setIsLibraryMenuOpen(false),
          className: "library-menu",
          children: [
            !itemsSelected && /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
              DropdownMenu_default.Item,
              {
                onSelect: onLibraryImport,
                icon: LoadIcon,
                "data-testid": "lib-dropdown--load",
                children: t("buttons.load")
              }
            ),
            !!items.length && /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
              DropdownMenu_default.Item,
              {
                onSelect: onLibraryExport,
                icon: ExportIcon,
                "data-testid": "lib-dropdown--export",
                children: t("buttons.export")
              }
            ),
            !!items.length && /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
              DropdownMenu_default.Item,
              {
                onSelect: () => setShowRemoveLibAlert(true),
                icon: TrashIcon,
                children: resetLabel
              }
            ),
            itemsSelected && /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
              DropdownMenu_default.Item,
              {
                icon: publishIcon,
                onSelect: () => setShowPublishLibraryDialog(true),
                "data-testid": "lib-dropdown--remove",
                children: t("buttons.publishLibrary")
              }
            )
          ]
        }
      )
    ] });
  };
  return /* @__PURE__ */ (0, import_jsx_runtime62.jsxs)("div", { className: clsx_m_default("library-menu-dropdown-container", className), children: [
    renderLibraryMenu(),
    selectedItems.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime62.jsx)("div", { className: "library-actions-counter", children: selectedItems.length }),
    showRemoveLibAlert && renderRemoveLibAlert(),
    showPublishLibraryDialog && /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
      PublishLibrary_default,
      {
        onClose: () => setShowPublishLibraryDialog(false),
        libraryItems: getSelectedItems(
          libraryItemsData.libraryItems,
          selectedItems
        ),
        appState,
        onSuccess: (data) => onPublishLibSuccess(data, libraryItemsData.libraryItems),
        onError: (error) => window.alert(error),
        updateItemsInStorage: () => library.setLibrary(libraryItemsData.libraryItems),
        onRemove: (id) => onSelectItems(selectedItems.filter((_id) => _id !== id))
      }
    ),
    publishLibSuccess && renderPublishSuccess()
  ] });
};
var LibraryDropdownMenu = ({
  selectedItems,
  onSelectItems,
  className
}) => {
  const { library } = useApp();
  const { clearLibraryCache, deleteItemsFromLibraryCache } = useLibraryCache();
  const appState = useUIAppState();
  const setAppState = useExcalidrawSetAppState();
  const [libraryItemsData] = useAtom(libraryItemsAtom, jotaiScope);
  const removeFromLibrary = async (libraryItems) => {
    const nextItems = libraryItems.filter(
      (item) => !selectedItems.includes(item.id)
    );
    library.setLibrary(nextItems).catch(() => {
      setAppState({ errorMessage: t("alerts.errorRemovingFromLibrary") });
    });
    deleteItemsFromLibraryCache(selectedItems);
    onSelectItems([]);
  };
  const resetLibrary = () => {
    library.resetLibrary();
    clearLibraryCache();
  };
  return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(
    LibraryDropdownMenuButton,
    {
      appState,
      setAppState,
      selectedItems,
      onSelectItems,
      library,
      onRemoveFromLibrary: () => removeFromLibrary(libraryItemsData.libraryItems),
      resetLibrary,
      className
    }
  );
};

// components/LibraryMenuSection.tsx
init_define_import_meta_env();
var import_react66 = __toESM(require_react(), 1);

// components/LibraryUnit.tsx
init_define_import_meta_env();
var import_react64 = __toESM(require_react(), 1);
var import_jsx_runtime63 = __toESM(require_jsx_runtime(), 1);
var LibraryUnit = (0, import_react64.memo)(
  ({
    id,
    elements,
    isPending,
    onClick,
    selected,
    onToggle,
    onDrag,
    svgCache
  }) => {
    const ref = (0, import_react64.useRef)(null);
    const svg = useLibraryItemSvg(id, elements, svgCache);
    (0, import_react64.useEffect)(() => {
      const node = ref.current;
      if (!node) {
        return;
      }
      if (svg) {
        node.innerHTML = svg.outerHTML;
      }
      return () => {
        node.innerHTML = "";
      };
    }, [svg]);
    const [isHovered, setIsHovered] = (0, import_react64.useState)(false);
    const isMobile = useDevice().editor.isMobile;
    const adder = isPending && /* @__PURE__ */ (0, import_jsx_runtime63.jsx)("div", { className: "library-unit__adder", children: PlusIcon });
    return /* @__PURE__ */ (0, import_jsx_runtime63.jsxs)(
      "div",
      {
        className: clsx_m_default("library-unit", {
          "library-unit__active": elements,
          "library-unit--hover": elements && isHovered,
          "library-unit--selected": selected,
          "library-unit--skeleton": !svg
        }),
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => setIsHovered(false),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(
            "div",
            {
              className: clsx_m_default("library-unit__dragger", {
                "library-unit__pulse": !!isPending
              }),
              ref,
              draggable: !!elements,
              onClick: !!elements || !!isPending ? (event) => {
                if (id && event.shiftKey) {
                  onToggle(id, event);
                } else {
                  onClick(id);
                }
              } : void 0,
              onDragStart: (event) => {
                if (!id) {
                  event.preventDefault();
                  return;
                }
                setIsHovered(false);
                onDrag(id, event);
              }
            }
          ),
          adder,
          id && elements && (isHovered || isMobile || selected) && /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(
            CheckboxItem,
            {
              checked: selected,
              onChange: (checked, event) => onToggle(id, event),
              className: "library-unit__checkbox"
            }
          )
        ]
      }
    );
  }
);
var EmptyLibraryUnit = () => /* @__PURE__ */ (0, import_jsx_runtime63.jsx)("div", { className: "library-unit library-unit--skeleton" });

// hooks/useTransition.ts
init_define_import_meta_env();
var import_react65 = __toESM(require_react(), 1);
function useTransitionPolyfill() {
  const startTransition = (0, import_react65.useCallback)((callback) => callback(), []);
  return [false, startTransition];
}
var useTransition = import_react65.default.useTransition || useTransitionPolyfill;

// components/LibraryMenuSection.tsx
var import_jsx_runtime64 = __toESM(require_jsx_runtime(), 1);
var LibraryMenuSectionGrid = ({
  children
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime64.jsx)("div", { className: "library-menu-items-container__grid", children });
};
var LibraryMenuSection = (0, import_react66.memo)(
  ({
    items,
    onItemSelectToggle,
    onItemDrag,
    isItemSelected,
    onClick,
    svgCache,
    itemsRenderedPerBatch
  }) => {
    const [, startTransition] = useTransition();
    const [index2, setIndex] = (0, import_react66.useState)(0);
    (0, import_react66.useEffect)(() => {
      if (index2 < items.length) {
        startTransition(() => {
          setIndex(index2 + itemsRenderedPerBatch);
        });
      }
    }, [index2, items.length, startTransition, itemsRenderedPerBatch]);
    return /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(import_jsx_runtime64.Fragment, { children: items.map((item, i3) => {
      return i3 < index2 ? /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
        LibraryUnit,
        {
          elements: item?.elements,
          isPending: !item?.id && !!item?.elements,
          onClick,
          svgCache,
          id: item?.id,
          selected: isItemSelected(item.id),
          onToggle: onItemSelectToggle,
          onDrag: onItemDrag
        },
        item?.id ?? i3
      ) : /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(EmptyLibraryUnit, {}, i3);
    }) });
  }
);

// hooks/useScrollPosition.ts
init_define_import_meta_env();
var import_react67 = __toESM(require_react(), 1);
var import_lodash = __toESM(require_lodash(), 1);
var scrollPositionAtom = atom2(0);
var useScrollPosition = (elementRef) => {
  const [scrollPosition, setScrollPosition] = useAtom(scrollPositionAtom);
  (0, import_react67.useEffect)(() => {
    const { current: element } = elementRef;
    if (!element) {
      return;
    }
    const handleScroll2 = (0, import_lodash.default)(() => {
      const { scrollTop } = element;
      setScrollPosition(scrollTop);
    }, 200);
    element.addEventListener("scroll", handleScroll2);
    return () => {
      handleScroll2.cancel();
      element.removeEventListener("scroll", handleScroll2);
    };
  }, [elementRef, setScrollPosition]);
  return scrollPosition;
};

// components/LibraryMenuItems.tsx
var import_jsx_runtime65 = __toESM(require_jsx_runtime(), 1);
var ITEMS_RENDERED_PER_BATCH = 17;
var CACHED_ITEMS_RENDERED_PER_BATCH = 64;
function LibraryMenuItems({
  isLoading,
  libraryItems,
  onAddToLibrary,
  onInsertLibraryItems,
  pendingElements,
  theme,
  id,
  libraryReturnUrl,
  onSelectItems,
  selectedItems
}) {
  const libraryContainerRef = (0, import_react68.useRef)(null);
  const scrollPosition = useScrollPosition(libraryContainerRef);
  (0, import_react68.useEffect)(() => {
    if (scrollPosition > 0) {
      libraryContainerRef.current?.scrollTo(0, scrollPosition);
    }
  }, []);
  const { svgCache } = useLibraryCache();
  const unpublishedItems = (0, import_react68.useMemo)(
    () => libraryItems.filter((item) => item.status !== "published"),
    [libraryItems]
  );
  const publishedItems = (0, import_react68.useMemo)(
    () => libraryItems.filter((item) => item.status === "published"),
    [libraryItems]
  );
  const showBtn = !libraryItems.length && !pendingElements.length;
  const isLibraryEmpty = !pendingElements.length && !unpublishedItems.length && !publishedItems.length;
  const [lastSelectedItem, setLastSelectedItem] = (0, import_react68.useState)(null);
  const onItemSelectToggle = (0, import_react68.useCallback)(
    (id2, event) => {
      const shouldSelect = !selectedItems.includes(id2);
      const orderedItems = [...unpublishedItems, ...publishedItems];
      if (shouldSelect) {
        if (event.shiftKey && lastSelectedItem) {
          const rangeStart = orderedItems.findIndex(
            (item) => item.id === lastSelectedItem
          );
          const rangeEnd = orderedItems.findIndex((item) => item.id === id2);
          if (rangeStart === -1 || rangeEnd === -1) {
            onSelectItems([...selectedItems, id2]);
            return;
          }
          const selectedItemsMap = arrayToMap(selectedItems);
          const nextSelectedIds = orderedItems.reduce(
            (acc, item, idx) => {
              if (idx >= rangeStart && idx <= rangeEnd || selectedItemsMap.has(item.id)) {
                acc.push(item.id);
              }
              return acc;
            },
            []
          );
          onSelectItems(nextSelectedIds);
        } else {
          onSelectItems([...selectedItems, id2]);
        }
        setLastSelectedItem(id2);
      } else {
        setLastSelectedItem(null);
        onSelectItems(selectedItems.filter((_id) => _id !== id2));
      }
    },
    [
      lastSelectedItem,
      onSelectItems,
      publishedItems,
      selectedItems,
      unpublishedItems
    ]
  );
  const getInsertedElements = (0, import_react68.useCallback)(
    (id2) => {
      let targetElements;
      if (selectedItems.includes(id2)) {
        targetElements = libraryItems.filter(
          (item) => selectedItems.includes(item.id)
        );
      } else {
        targetElements = libraryItems.filter((item) => item.id === id2);
      }
      return targetElements.map((item) => {
        return {
          ...item,
          // duplicate each library item before inserting on canvas to confine
          // ids and bindings to each library item. See #6465
          elements: duplicateElements(item.elements, { randomizeSeed: true })
        };
      });
    },
    [libraryItems, selectedItems]
  );
  const onItemDrag = (0, import_react68.useCallback)(
    (id2, event) => {
      event.dataTransfer.setData(
        MIME_TYPES.excalidrawlib,
        serializeLibraryAsJSON(getInsertedElements(id2))
      );
    },
    [getInsertedElements]
  );
  const isItemSelected = (0, import_react68.useCallback)(
    (id2) => {
      if (!id2) {
        return false;
      }
      return selectedItems.includes(id2);
    },
    [selectedItems]
  );
  const onAddToLibraryClick = (0, import_react68.useCallback)(() => {
    onAddToLibrary(pendingElements);
  }, [pendingElements, onAddToLibrary]);
  const onItemClick = (0, import_react68.useCallback)(
    (id2) => {
      if (id2) {
        onInsertLibraryItems(getInsertedElements(id2));
      }
    },
    [getInsertedElements, onInsertLibraryItems]
  );
  const itemsRenderedPerBatch = svgCache.size >= libraryItems.length ? CACHED_ITEMS_RENDERED_PER_BATCH : ITEMS_RENDERED_PER_BATCH;
  return /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(
    "div",
    {
      className: "library-menu-items-container",
      style: pendingElements.length || unpublishedItems.length || publishedItems.length ? { justifyContent: "flex-start" } : { borderBottom: 0 },
      children: [
        !isLibraryEmpty && /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(
          LibraryDropdownMenu,
          {
            selectedItems,
            onSelectItems,
            className: "library-menu-dropdown-container--in-heading"
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(
          Stack_default.Col,
          {
            className: "library-menu-items-container__items",
            align: "start",
            gap: 1,
            style: {
              flex: publishedItems.length > 0 ? 1 : "0 1 auto",
              marginBottom: 0
            },
            ref: libraryContainerRef,
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(import_jsx_runtime65.Fragment, { children: [
                !isLibraryEmpty && /* @__PURE__ */ (0, import_jsx_runtime65.jsx)("div", { className: "library-menu-items-container__header", children: t("labels.personalLib") }),
                isLoading && /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(
                  "div",
                  {
                    style: {
                      position: "absolute",
                      top: "var(--container-padding-y)",
                      right: "var(--container-padding-x)",
                      transform: "translateY(50%)"
                    },
                    children: /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(Spinner_default, {})
                  }
                ),
                !pendingElements.length && !unpublishedItems.length ? /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)("div", { className: "library-menu-items__no-items", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime65.jsx)("div", { className: "library-menu-items__no-items__label", children: t("library.noItems") }),
                  /* @__PURE__ */ (0, import_jsx_runtime65.jsx)("div", { className: "library-menu-items__no-items__hint", children: publishedItems.length > 0 ? t("library.hint_emptyPrivateLibrary") : t("library.hint_emptyLibrary") })
                ] }) : /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(LibraryMenuSectionGrid, { children: [
                  pendingElements.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(
                    LibraryMenuSection,
                    {
                      itemsRenderedPerBatch,
                      items: [{ id: null, elements: pendingElements }],
                      onItemSelectToggle,
                      onItemDrag,
                      onClick: onAddToLibraryClick,
                      isItemSelected,
                      svgCache
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(
                    LibraryMenuSection,
                    {
                      itemsRenderedPerBatch,
                      items: unpublishedItems,
                      onItemSelectToggle,
                      onItemDrag,
                      onClick: onItemClick,
                      isItemSelected,
                      svgCache
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(import_jsx_runtime65.Fragment, { children: [
                (publishedItems.length > 0 || pendingElements.length > 0 || unpublishedItems.length > 0) && /* @__PURE__ */ (0, import_jsx_runtime65.jsx)("div", { className: "library-menu-items-container__header library-menu-items-container__header--excal", children: t("labels.excalidrawLib") }),
                publishedItems.length > 0 ? /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(LibraryMenuSectionGrid, { children: /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(
                  LibraryMenuSection,
                  {
                    itemsRenderedPerBatch,
                    items: publishedItems,
                    onItemSelectToggle,
                    onItemDrag,
                    onClick: onItemClick,
                    isItemSelected,
                    svgCache
                  }
                ) }) : unpublishedItems.length > 0 ? /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(
                  "div",
                  {
                    style: {
                      margin: "1rem 0",
                      display: "flex",
                      flexDirection: "column",
                      alignItems: "center",
                      justifyContent: "center",
                      width: "100%",
                      fontSize: ".9rem"
                    },
                    children: t("library.noItems")
                  }
                ) : null
              ] }),
              showBtn && /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(
                LibraryMenuControlButtons,
                {
                  style: { padding: "16px 0", width: "100%" },
                  id,
                  libraryReturnUrl,
                  theme,
                  children: /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(
                    LibraryDropdownMenu,
                    {
                      selectedItems,
                      onSelectItems
                    }
                  )
                }
              )
            ]
          }
        )
      ]
    }
  );
}

// components/LibraryMenu.tsx
var import_jsx_runtime66 = __toESM(require_jsx_runtime(), 1);
var isLibraryMenuOpenAtom = atom2(false);
var LibraryMenuWrapper = ({ children }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime66.jsx)("div", { className: "layer-ui__library", children });
};
var LibraryMenuContent = ({
  onInsertLibraryItems,
  pendingElements,
  onAddToLibrary,
  setAppState,
  libraryReturnUrl,
  library,
  id,
  theme,
  selectedItems,
  onSelectItems
}) => {
  const [libraryItemsData] = useAtom(libraryItemsAtom, jotaiScope);
  const _onAddToLibrary = (0, import_react69.useCallback)(
    (elements) => {
      const addToLibrary = async (processedElements, libraryItems2) => {
        trackEvent("element", "addToLibrary", "ui");
        for (const type of LIBRARY_DISABLED_TYPES) {
          if (processedElements.some((element) => element.type === type)) {
            return setAppState({
              errorMessage: t(`errors.libraryElementTypeError.${type}`)
            });
          }
        }
        const nextItems = [
          {
            status: "unpublished",
            elements: processedElements,
            id: randomId(),
            created: Date.now()
          },
          ...libraryItems2
        ];
        onAddToLibrary();
        library.setLibrary(nextItems).catch(() => {
          setAppState({ errorMessage: t("alerts.errorAddingToLibrary") });
        });
      };
      addToLibrary(elements, libraryItemsData.libraryItems);
    },
    [onAddToLibrary, library, setAppState, libraryItemsData.libraryItems]
  );
  const libraryItems = (0, import_react69.useMemo)(
    () => libraryItemsData.libraryItems,
    [libraryItemsData]
  );
  if (libraryItemsData.status === "loading" && !libraryItemsData.isInitialized) {
    return /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(LibraryMenuWrapper, { children: /* @__PURE__ */ (0, import_jsx_runtime66.jsx)("div", { className: "layer-ui__library-message", children: /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)("div", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(Spinner_default, { size: "2em" }),
      /* @__PURE__ */ (0, import_jsx_runtime66.jsx)("span", { children: t("labels.libraryLoadingMessage") })
    ] }) }) });
  }
  const showBtn = libraryItemsData.libraryItems.length > 0 || pendingElements.length > 0;
  return /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)(LibraryMenuWrapper, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(
      LibraryMenuItems,
      {
        isLoading: libraryItemsData.status === "loading",
        libraryItems,
        onAddToLibrary: _onAddToLibrary,
        onInsertLibraryItems,
        pendingElements,
        id,
        libraryReturnUrl,
        theme,
        onSelectItems,
        selectedItems
      }
    ),
    showBtn && /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(
      LibraryMenuControlButtons,
      {
        className: "library-menu-control-buttons--at-bottom",
        style: { padding: "16px 12px 0 12px" },
        id,
        libraryReturnUrl,
        theme
      }
    )
  ] });
};
var usePendingElementsMemo = (appState, elements) => {
  const create2 = () => getSelectedElements(elements, appState, {
    includeBoundTextElement: true,
    includeElementsInFrames: true
  });
  const val = (0, import_react69.useRef)(create2());
  const prevAppState = (0, import_react69.useRef)(appState);
  const prevElements = (0, import_react69.useRef)(elements);
  if (!isShallowEqual(
    appState.selectedElementIds,
    prevAppState.current.selectedElementIds
  ) || !isShallowEqual(elements, prevElements.current)) {
    val.current = create2();
    prevAppState.current = appState;
    prevElements.current = elements;
  }
  return val.current;
};
var LibraryMenu = () => {
  const { library, id, onInsertElements } = useApp();
  const appProps = useAppProps();
  const appState = useUIAppState();
  const setAppState = useExcalidrawSetAppState();
  const elements = useExcalidrawElements();
  const [selectedItems, setSelectedItems] = (0, import_react69.useState)([]);
  const memoizedLibrary = (0, import_react69.useMemo)(() => library, [library]);
  const pendingElements = usePendingElementsMemo(appState, elements);
  const onInsertLibraryItems = (0, import_react69.useCallback)(
    (libraryItems) => {
      onInsertElements(distributeLibraryItemsOnSquareGrid(libraryItems));
    },
    [onInsertElements]
  );
  const deselectItems = (0, import_react69.useCallback)(() => {
    setAppState({
      selectedElementIds: {},
      selectedGroupIds: {},
      activeEmbeddable: null
    });
  }, [setAppState]);
  return /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(
    LibraryMenuContent,
    {
      pendingElements,
      onInsertLibraryItems,
      onAddToLibrary: deselectItems,
      setAppState,
      libraryReturnUrl: appProps.libraryReturnUrl,
      library: memoizedLibrary,
      id,
      theme: appState.theme,
      selectedItems,
      onSelectItems: setSelectedItems
    }
  );
};

// components/Dialog.tsx
var import_jsx_runtime67 = __toESM(require_jsx_runtime(), 1);
function getDialogSize(size) {
  if (size && typeof size === "number") {
    return size;
  }
  switch (size) {
    case "small":
      return 550;
    case "wide":
      return 1024;
    case "regular":
    default:
      return 800;
  }
}
var Dialog = (props) => {
  const [islandNode, setIslandNode] = useCallbackRefState();
  const [lastActiveElement] = (0, import_react70.useState)(document.activeElement);
  const { id } = useExcalidrawContainer();
  const isFullscreen = useDevice().viewport.isMobile;
  (0, import_react70.useEffect)(() => {
    if (!islandNode) {
      return;
    }
    const focusableElements = queryFocusableElements(islandNode);
    setTimeout(() => {
      if (focusableElements.length > 0 && props.autofocus !== false) {
        (focusableElements[1] || focusableElements[0]).focus();
      }
    });
    const handleKeyDown = (event) => {
      if (event.key === KEYS.TAB) {
        const focusableElements2 = queryFocusableElements(islandNode);
        const { activeElement } = document;
        const currentIndex = focusableElements2.findIndex(
          (element) => element === activeElement
        );
        if (currentIndex === 0 && event.shiftKey) {
          focusableElements2[focusableElements2.length - 1].focus();
          event.preventDefault();
        } else if (currentIndex === focusableElements2.length - 1 && !event.shiftKey) {
          focusableElements2[0].focus();
          event.preventDefault();
        }
      }
    };
    islandNode.addEventListener("keydown", handleKeyDown);
    return () => islandNode.removeEventListener("keydown", handleKeyDown);
  }, [islandNode, props.autofocus]);
  const setAppState = useExcalidrawSetAppState();
  const setIsLibraryMenuOpen = useSetAtom(isLibraryMenuOpenAtom, jotaiScope);
  const onClose = () => {
    setAppState({ openMenu: null });
    setIsLibraryMenuOpen(false);
    lastActiveElement.focus();
    props.onCloseRequest();
  };
  return /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(
    Modal,
    {
      className: clsx_m_default("Dialog", props.className, {
        "Dialog--fullscreen": isFullscreen
      }),
      labelledBy: "dialog-title",
      maxWidth: getDialogSize(props.size),
      onCloseRequest: onClose,
      closeOnClickOutside: props.closeOnClickOutside,
      children: /* @__PURE__ */ (0, import_jsx_runtime67.jsxs)(Island, { ref: setIslandNode, children: [
        props.title && /* @__PURE__ */ (0, import_jsx_runtime67.jsx)("h2", { id: `${id}-dialog-title`, className: "Dialog__title", children: /* @__PURE__ */ (0, import_jsx_runtime67.jsx)("span", { className: "Dialog__titleContent", children: props.title }) }),
        isFullscreen && /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(
          "button",
          {
            className: "Dialog__close",
            onClick: onClose,
            title: t("buttons.close"),
            "aria-label": t("buttons.close"),
            type: "button",
            children: CloseIcon
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime67.jsx)("div", { className: "Dialog__content", children: props.children })
      ] })
    }
  );
};

// components/TextField.tsx
init_define_import_meta_env();
var import_react71 = __toESM(require_react(), 1);

// components/Button.tsx
init_define_import_meta_env();
var import_jsx_runtime68 = __toESM(require_jsx_runtime(), 1);
var Button = ({
  type = "button",
  onSelect,
  selected,
  children,
  className = "",
  ...rest
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime68.jsx)(
    "button",
    {
      onClick: composeEventHandlers(rest.onClick, (event) => {
        onSelect();
      }),
      type,
      className: clsx_m_default("excalidraw-button", className, { selected }),
      ...rest,
      children
    }
  );
};

// components/TextField.tsx
var import_jsx_runtime69 = __toESM(require_jsx_runtime(), 1);
var TextField = (0, import_react71.forwardRef)(
  ({
    onChange,
    label,
    fullWidth,
    placeholder,
    readonly,
    selectOnRender,
    onKeyDown,
    isRedacted = false,
    icon,
    className,
    ...rest
  }, ref) => {
    const innerRef = (0, import_react71.useRef)(null);
    (0, import_react71.useImperativeHandle)(ref, () => innerRef.current);
    (0, import_react71.useLayoutEffect)(() => {
      if (selectOnRender) {
        innerRef.current?.focus();
        innerRef.current?.select();
      }
    }, [selectOnRender]);
    const [isTemporarilyUnredacted, setIsTemporarilyUnredacted] = (0, import_react71.useState)(false);
    return /* @__PURE__ */ (0, import_jsx_runtime69.jsxs)(
      "div",
      {
        className: clsx_m_default("ExcTextField", className, {
          "ExcTextField--fullWidth": fullWidth,
          "ExcTextField--hasIcon": !!icon
        }),
        onClick: () => {
          innerRef.current?.focus();
        },
        children: [
          icon,
          label && /* @__PURE__ */ (0, import_jsx_runtime69.jsx)("div", { className: "ExcTextField__label", children: label }),
          /* @__PURE__ */ (0, import_jsx_runtime69.jsxs)(
            "div",
            {
              className: clsx_m_default("ExcTextField__input", {
                "ExcTextField__input--readonly": readonly
              }),
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime69.jsx)(
                  "input",
                  {
                    className: clsx_m_default({
                      "is-redacted": "value" in rest && rest.value && isRedacted && !isTemporarilyUnredacted
                    }),
                    readOnly: readonly,
                    value: "value" in rest ? rest.value : void 0,
                    defaultValue: "defaultValue" in rest ? rest.defaultValue : void 0,
                    placeholder,
                    ref: innerRef,
                    onChange: (event) => onChange?.(event.target.value),
                    onKeyDown
                  }
                ),
                isRedacted && /* @__PURE__ */ (0, import_jsx_runtime69.jsx)(
                  Button,
                  {
                    onSelect: () => setIsTemporarilyUnredacted(!isTemporarilyUnredacted),
                    style: { border: 0, userSelect: "none" },
                    children: isTemporarilyUnredacted ? eyeClosedIcon : eyeIcon
                  }
                )
              ]
            }
          )
        ]
      }
    );
  }
);

// actions/shortcuts.ts
init_define_import_meta_env();
var shortcutMap = {
  toggleTheme: [getShortcutKey("Shift+Alt+D")],
  saveScene: [getShortcutKey("CtrlOrCmd+S")],
  loadScene: [getShortcutKey("CtrlOrCmd+O")],
  clearCanvas: [getShortcutKey("CtrlOrCmd+Delete")],
  imageExport: [getShortcutKey("CtrlOrCmd+Shift+E")],
  commandPalette: [
    getShortcutKey("CtrlOrCmd+/"),
    getShortcutKey("CtrlOrCmd+Shift+P")
  ],
  cut: [getShortcutKey("CtrlOrCmd+X")],
  copy: [getShortcutKey("CtrlOrCmd+C")],
  paste: [getShortcutKey("CtrlOrCmd+V")],
  copyStyles: [getShortcutKey("CtrlOrCmd+Alt+C")],
  pasteStyles: [getShortcutKey("CtrlOrCmd+Alt+V")],
  selectAll: [getShortcutKey("CtrlOrCmd+A")],
  deleteSelectedElements: [getShortcutKey("Delete")],
  duplicateSelection: [
    getShortcutKey("CtrlOrCmd+D"),
    getShortcutKey(`Alt+${t("helpDialog.drag")}`)
  ],
  sendBackward: [getShortcutKey("CtrlOrCmd+[")],
  bringForward: [getShortcutKey("CtrlOrCmd+]")],
  sendToBack: [
    isDarwin ? getShortcutKey("CtrlOrCmd+Alt+[") : getShortcutKey("CtrlOrCmd+Shift+[")
  ],
  bringToFront: [
    isDarwin ? getShortcutKey("CtrlOrCmd+Alt+]") : getShortcutKey("CtrlOrCmd+Shift+]")
  ],
  copyAsPng: [getShortcutKey("Shift+Alt+C")],
  copyAsSvg: [],
  group: [getShortcutKey("CtrlOrCmd+G")],
  ungroup: [getShortcutKey("CtrlOrCmd+Shift+G")],
  gridMode: [getShortcutKey("CtrlOrCmd+'")],
  zenMode: [getShortcutKey("Alt+Z")],
  objectsSnapMode: [getShortcutKey("Alt+S")],
  stats: [getShortcutKey("Alt+/")],
  addToLibrary: [],
  flipHorizontal: [getShortcutKey("Shift+H")],
  flipVertical: [getShortcutKey("Shift+V")],
  viewMode: [getShortcutKey("Alt+R")],
  hyperlink: [getShortcutKey("CtrlOrCmd+K")],
  toggleElementLock: [getShortcutKey("CtrlOrCmd+Shift+L")],
  resetZoom: [getShortcutKey("CtrlOrCmd+0")],
  zoomOut: [getShortcutKey("CtrlOrCmd+-")],
  zoomIn: [getShortcutKey("CtrlOrCmd++")],
  zoomToFitSelection: [getShortcutKey("Shift+3")],
  zoomToFit: [getShortcutKey("Shift+1")],
  zoomToFitSelectionInViewport: [getShortcutKey("Shift+2")],
  toggleEraserTool: [getShortcutKey("E")],
  toggleHandTool: [getShortcutKey("H")],
  setFrameAsActiveTool: [getShortcutKey("F")],
  saveFileToDisk: [getShortcutKey("CtrlOrCmd+S")],
  saveToActiveFile: [getShortcutKey("CtrlOrCmd+S")],
  toggleShortcuts: [getShortcutKey("?")],
  searchMenu: [getShortcutKey("CtrlOrCmd+F")]
};
var getShortcutFromShortcutName = (name, idx = 0) => {
  const shortcuts = shortcutMap[name];
  return shortcuts && shortcuts.length > 0 ? shortcuts[idx] || shortcuts[0] : "";
};

// components/CommandPalette/CommandPalette.tsx
var import_fuzzy = __toESM(require_fuzzy(), 1);

// deburr.ts
init_define_import_meta_env();
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsCombo = `[${rsComboRange}]`;
var reComboMark = RegExp(rsCombo, "g");
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var deburredLetters = {
  "\xC0": "A",
  "\xC1": "A",
  "\xC2": "A",
  "\xC3": "A",
  "\xC4": "A",
  "\xC5": "A",
  "\xE0": "a",
  "\xE1": "a",
  "\xE2": "a",
  "\xE3": "a",
  "\xE4": "a",
  "\xE5": "a",
  "\xC7": "C",
  "\xE7": "c",
  "\xD0": "D",
  "\xF0": "d",
  "\xC8": "E",
  "\xC9": "E",
  "\xCA": "E",
  "\xCB": "E",
  "\xE8": "e",
  "\xE9": "e",
  "\xEA": "e",
  "\xEB": "e",
  "\xCC": "I",
  "\xCD": "I",
  "\xCE": "I",
  "\xCF": "I",
  "\xEC": "i",
  "\xED": "i",
  "\xEE": "i",
  "\xEF": "i",
  "\xD1": "N",
  "\xF1": "n",
  "\xD2": "O",
  "\xD3": "O",
  "\xD4": "O",
  "\xD5": "O",
  "\xD6": "O",
  "\xD8": "O",
  "\xF2": "o",
  "\xF3": "o",
  "\xF4": "o",
  "\xF5": "o",
  "\xF6": "o",
  "\xF8": "o",
  "\xD9": "U",
  "\xDA": "U",
  "\xDB": "U",
  "\xDC": "U",
  "\xF9": "u",
  "\xFA": "u",
  "\xFB": "u",
  "\xFC": "u",
  "\xDD": "Y",
  "\xFD": "y",
  "\xFF": "y",
  // normaly Ae/ae
  "\xC6": "E",
  "\xE6": "e",
  // normally Th/th
  "\xDE": "T",
  "\xFE": "t",
  // normally ss
  "\xDF": "s",
  "\u0100": "A",
  "\u0102": "A",
  "\u0104": "A",
  "\u0101": "a",
  "\u0103": "a",
  "\u0105": "a",
  "\u0106": "C",
  "\u0108": "C",
  "\u010A": "C",
  "\u010C": "C",
  "\u0107": "c",
  "\u0109": "c",
  "\u010B": "c",
  "\u010D": "c",
  "\u010E": "D",
  "\u0110": "D",
  "\u010F": "d",
  "\u0111": "d",
  "\u0112": "E",
  "\u0114": "E",
  "\u0116": "E",
  "\u0118": "E",
  "\u011A": "E",
  "\u0113": "e",
  "\u0115": "e",
  "\u0117": "e",
  "\u0119": "e",
  "\u011B": "e",
  "\u011C": "G",
  "\u011E": "G",
  "\u0120": "G",
  "\u0122": "G",
  "\u011D": "g",
  "\u011F": "g",
  "\u0121": "g",
  "\u0123": "g",
  "\u0124": "H",
  "\u0126": "H",
  "\u0125": "h",
  "\u0127": "h",
  "\u0128": "I",
  "\u012A": "I",
  "\u012C": "I",
  "\u012E": "I",
  "\u0130": "I",
  "\u0129": "i",
  "\u012B": "i",
  "\u012D": "i",
  "\u012F": "i",
  "\u0131": "i",
  "\u0134": "J",
  "\u0135": "j",
  "\u0136": "K",
  "\u0137": "k",
  "\u0138": "k",
  "\u0139": "L",
  "\u013B": "L",
  "\u013D": "L",
  "\u013F": "L",
  "\u0141": "L",
  "\u013A": "l",
  "\u013C": "l",
  "\u013E": "l",
  "\u0140": "l",
  "\u0142": "l",
  "\u0143": "N",
  "\u0145": "N",
  "\u0147": "N",
  "\u014A": "N",
  "\u0144": "n",
  "\u0146": "n",
  "\u0148": "n",
  "\u014B": "n",
  "\u014C": "O",
  "\u014E": "O",
  "\u0150": "O",
  "\u014D": "o",
  "\u014F": "o",
  "\u0151": "o",
  "\u0154": "R",
  "\u0156": "R",
  "\u0158": "R",
  "\u0155": "r",
  "\u0157": "r",
  "\u0159": "r",
  "\u015A": "S",
  "\u015C": "S",
  "\u015E": "S",
  "\u0160": "S",
  "\u015B": "s",
  "\u015D": "s",
  "\u015F": "s",
  "\u0161": "s",
  "\u0162": "T",
  "\u0164": "T",
  "\u0166": "T",
  "\u0163": "t",
  "\u0165": "t",
  "\u0167": "t",
  "\u0168": "U",
  "\u016A": "U",
  "\u016C": "U",
  "\u016E": "U",
  "\u0170": "U",
  "\u0172": "U",
  "\u0169": "u",
  "\u016B": "u",
  "\u016D": "u",
  "\u016F": "u",
  "\u0171": "u",
  "\u0173": "u",
  "\u0174": "W",
  "\u0175": "w",
  "\u0176": "Y",
  "\u0177": "y",
  "\u0178": "Y",
  "\u0179": "Z",
  "\u017B": "Z",
  "\u017D": "Z",
  "\u017A": "z",
  "\u017C": "z",
  "\u017E": "z",
  // normally IJ/ij
  "\u0132": "I",
  "\u0133": "i",
  // normally OE/oe
  "\u0152": "E",
  "\u0153": "e",
  // normally "'n"
  "\u0149": "n",
  "\u017F": "s"
};
var deburr = (str) => {
  return str.replace(reLatin, (key) => {
    return deburredLetters[key] || key;
  }).replace(reComboMark, "");
};

// components/InlineIcon.tsx
init_define_import_meta_env();
var import_jsx_runtime70 = __toESM(require_jsx_runtime(), 1);
var InlineIcon = ({ icon }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime70.jsx)(
    "span",
    {
      style: {
        width: "1em",
        margin: "0 0.5ex 0 0.5ex",
        display: "inline-block",
        lineHeight: 0,
        verticalAlign: "middle"
      },
      children: icon
    }
  );
};

// components/Actions.tsx
init_define_import_meta_env();
var import_react75 = __toESM(require_react(), 1);

// context/tunnels.ts
init_define_import_meta_env();
var import_react74 = __toESM(require_react(), 1);

// ../../node_modules/tunnel-rat/dist/index.js
init_define_import_meta_env();
var import_react73 = __toESM(require_react());

// ../../node_modules/zustand/esm/index.mjs
init_define_import_meta_env();

// ../../node_modules/zustand/esm/vanilla.mjs
init_define_import_meta_env();
var createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if ((define_import_meta_env_default ? define_import_meta_env_default.MODE : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState, getInitialState, subscribe, destroy };
  const initialState = state = createState(setState, getState, api);
  return api;
};
var createStore2 = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

// ../../node_modules/zustand/esm/index.mjs
var import_react72 = __toESM(require_react(), 1);
var import_with_selector = __toESM(require_with_selector(), 1);
var { useDebugValue: useDebugValue2 } = import_react72.default;
var { useSyncExternalStoreWithSelector } = import_with_selector.default;
var didWarnAboutEqualityFn = false;
var identity = (arg) => arg;
function useStore(api, selector = identity, equalityFn) {
  if ((define_import_meta_env_default ? define_import_meta_env_default.MODE : void 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
    console.warn(
      "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
    );
    didWarnAboutEqualityFn = true;
  }
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getInitialState,
    selector,
    equalityFn
  );
  useDebugValue2(slice);
  return slice;
}
var createImpl = (createState) => {
  if ((define_import_meta_env_default ? define_import_meta_env_default.MODE : void 0) !== "production" && typeof createState !== "function") {
    console.warn(
      "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
    );
  }
  const api = typeof createState === "function" ? createStore2(createState) : createState;
  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
var create = (createState) => createState ? createImpl(createState) : createImpl;

// ../../node_modules/tunnel-rat/dist/index.js
var _window$document;
var _window$navigator;
var useIsomorphicLayoutEffect2 = typeof window !== "undefined" && ((_window$document = window.document) != null && _window$document.createElement || ((_window$navigator = window.navigator) == null ? void 0 : _window$navigator.product) === "ReactNative") ? import_react73.default.useLayoutEffect : import_react73.default.useEffect;
function tunnel() {
  const useStore2 = create((set) => ({
    current: new Array(),
    version: 0,
    set
  }));
  return {
    In: ({
      children
    }) => {
      const set = useStore2((state) => state.set);
      const version = useStore2((state) => state.version);
      useIsomorphicLayoutEffect2(() => {
        set((state) => ({
          version: state.version + 1
        }));
      }, []);
      useIsomorphicLayoutEffect2(() => {
        set(({
          current
        }) => ({
          current: [...current, children]
        }));
        return () => set(({
          current
        }) => ({
          current: current.filter((c3) => c3 !== children)
        }));
      }, [children, version]);
      return null;
    },
    Out: () => {
      const current = useStore2((state) => state.current);
      return /* @__PURE__ */ import_react73.default.createElement(import_react73.default.Fragment, null, current);
    }
  };
}

// context/tunnels.ts
var TunnelsContext = import_react74.default.createContext(null);
var useTunnels = () => import_react74.default.useContext(TunnelsContext);
var useInitializeTunnels = () => {
  return import_react74.default.useMemo(() => {
    return {
      MainMenuTunnel: tunnel(),
      WelcomeScreenMenuHintTunnel: tunnel(),
      WelcomeScreenToolbarHintTunnel: tunnel(),
      WelcomeScreenHelpHintTunnel: tunnel(),
      WelcomeScreenCenterTunnel: tunnel(),
      FooterCenterTunnel: tunnel(),
      DefaultSidebarTriggerTunnel: tunnel(),
      DefaultSidebarTabTriggersTunnel: tunnel(),
      OverwriteConfirmDialogTunnel: tunnel(),
      TTDDialogTriggerTunnel: tunnel(),
      jotaiScope: Symbol()
    };
  }, []);
};

// components/Actions.tsx
var import_jsx_runtime71 = __toESM(require_jsx_runtime(), 1);
var canChangeStrokeColor = (appState, targetElements) => {
  let commonSelectedType = targetElements[0]?.type || null;
  for (const element of targetElements) {
    if (element.type !== commonSelectedType) {
      commonSelectedType = null;
      break;
    }
  }
  return hasStrokeColor(appState.activeTool.type) && appState.activeTool.type !== "image" && commonSelectedType !== "image" && commonSelectedType !== "frame" && commonSelectedType !== "magicframe" || targetElements.some((element) => hasStrokeColor(element.type));
};
var canChangeBackgroundColor = (appState, targetElements) => {
  return hasBackground(appState.activeTool.type) || targetElements.some((element) => hasBackground(element.type));
};
var SelectedShapeActions = ({
  appState,
  elementsMap,
  renderAction
}) => {
  const targetElements = getTargetElements(elementsMap, appState);
  let isSingleElementBoundContainer = false;
  if (targetElements.length === 2 && (hasBoundTextElement(targetElements[0]) || hasBoundTextElement(targetElements[1]))) {
    isSingleElementBoundContainer = true;
  }
  const isEditingTextOrNewElement = Boolean(
    appState.editingTextElement || appState.newElement
  );
  const device = useDevice();
  const isRTL = document.documentElement.getAttribute("dir") === "rtl";
  const showFillIcons = hasBackground(appState.activeTool.type) && !isTransparent(appState.currentItemBackgroundColor) || targetElements.some(
    (element) => hasBackground(element.type) && !isTransparent(element.backgroundColor)
  );
  const showLinkIcon = targetElements.length === 1 || isSingleElementBoundContainer;
  const showLineEditorAction = !appState.editingLinearElement && targetElements.length === 1 && isLinearElement(targetElements[0]) && !isElbowArrow(targetElements[0]);
  return /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)("div", { className: "panelColumn", children: [
    /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("div", { children: canChangeStrokeColor(appState, targetElements) && renderAction("changeStrokeColor") }),
    canChangeBackgroundColor(appState, targetElements) && /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("div", { children: renderAction("changeBackgroundColor") }),
    showFillIcons && renderAction("changeFillStyle"),
    (hasStrokeWidth(appState.activeTool.type) || targetElements.some((element) => hasStrokeWidth(element.type))) && renderAction("changeStrokeWidth"),
    (appState.activeTool.type === "freedraw" || targetElements.some((element) => element.type === "freedraw")) && renderAction("changeStrokeShape"),
    (hasStrokeStyle(appState.activeTool.type) || targetElements.some((element) => hasStrokeStyle(element.type))) && /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)(import_jsx_runtime71.Fragment, { children: [
      renderAction("changeStrokeStyle"),
      renderAction("changeSloppiness")
    ] }),
    (canChangeRoundness(appState.activeTool.type) || targetElements.some((element) => canChangeRoundness(element.type))) && /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(import_jsx_runtime71.Fragment, { children: renderAction("changeRoundness") }),
    (toolIsArrow(appState.activeTool.type) || targetElements.some((element) => toolIsArrow(element.type))) && /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(import_jsx_runtime71.Fragment, { children: renderAction("changeArrowType") }),
    (appState.activeTool.type === "text" || targetElements.some(isTextElement)) && /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)(import_jsx_runtime71.Fragment, { children: [
      renderAction("changeFontFamily"),
      renderAction("changeFontSize"),
      (appState.activeTool.type === "text" || suppportsHorizontalAlign(targetElements, elementsMap)) && renderAction("changeTextAlign")
    ] }),
    shouldAllowVerticalAlign(targetElements, elementsMap) && renderAction("changeVerticalAlign"),
    (canHaveArrowheads(appState.activeTool.type) || targetElements.some((element) => canHaveArrowheads(element.type))) && /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(import_jsx_runtime71.Fragment, { children: renderAction("changeArrowhead") }),
    renderAction("changeOpacity"),
    /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)("fieldset", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("legend", { children: t("labels.layers") }),
      /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)("div", { className: "buttonList", children: [
        renderAction("sendToBack"),
        renderAction("sendBackward"),
        renderAction("bringForward"),
        renderAction("bringToFront")
      ] })
    ] }),
    targetElements.length > 1 && !isSingleElementBoundContainer && /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)("fieldset", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("legend", { children: t("labels.align") }),
      /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)("div", { className: "buttonList", children: [
        isRTL ? /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)(import_jsx_runtime71.Fragment, { children: [
          renderAction("alignRight"),
          renderAction("alignHorizontallyCentered"),
          renderAction("alignLeft")
        ] }) : /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)(import_jsx_runtime71.Fragment, { children: [
          renderAction("alignLeft"),
          renderAction("alignHorizontallyCentered"),
          renderAction("alignRight")
        ] }),
        targetElements.length > 2 && renderAction("distributeHorizontally"),
        /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("div", { style: { flexBasis: "100%", height: 0 } }),
        /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)(
          "div",
          {
            style: {
              display: "flex",
              flexWrap: "wrap",
              gap: ".5rem",
              marginTop: "-0.5rem"
            },
            children: [
              renderAction("alignTop"),
              renderAction("alignVerticallyCentered"),
              renderAction("alignBottom"),
              targetElements.length > 2 && renderAction("distributeVertically")
            ]
          }
        )
      ] })
    ] }),
    !isEditingTextOrNewElement && targetElements.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)("fieldset", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("legend", { children: t("labels.actions") }),
      /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)("div", { className: "buttonList", children: [
        !device.editor.isMobile && renderAction("duplicateSelection"),
        !device.editor.isMobile && renderAction("deleteSelectedElements"),
        renderAction("group"),
        renderAction("ungroup"),
        showLinkIcon && renderAction("hyperlink"),
        showLineEditorAction && renderAction("toggleLinearEditor")
      ] })
    ] })
  ] });
};
var ShapesSwitcher = ({
  activeTool,
  appState,
  app,
  UIOptions
}) => {
  const [isExtraToolsMenuOpen, setIsExtraToolsMenuOpen] = (0, import_react75.useState)(false);
  const frameToolSelected = activeTool.type === "frame";
  const laserToolSelected = activeTool.type === "laser";
  const embeddableToolSelected = activeTool.type === "embeddable";
  const { TTDDialogTriggerTunnel } = useTunnels();
  return /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)(import_jsx_runtime71.Fragment, { children: [
    SHAPES.map(({ value, icon, key, numericKey, fillable }, index2) => {
      if (UIOptions.tools?.[value] === false) {
        return null;
      }
      const label = t(`toolBar.${value}`);
      const letter = key && capitalizeString(typeof key === "string" ? key : key[0]);
      const shortcut = letter ? `${letter} ${t("helpDialog.or")} ${numericKey}` : `${numericKey}`;
      return /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
        ToolButton,
        {
          className: clsx_m_default("Shape", { fillable }),
          type: "radio",
          icon,
          checked: activeTool.type === value,
          name: "editor-current-shape",
          title: `${capitalizeString(label)} \u2014 ${shortcut}`,
          keyBindingLabel: numericKey || letter,
          "aria-label": capitalizeString(label),
          "aria-keyshortcuts": shortcut,
          "data-testid": `toolbar-${value}`,
          onPointerDown: ({ pointerType }) => {
            if (!appState.penDetected && pointerType === "pen") {
              app.togglePenMode(true);
            }
          },
          onChange: ({ pointerType }) => {
            if (appState.activeTool.type !== value) {
              trackEvent("toolbar", value, "ui");
            }
            if (value === "image") {
              app.setActiveTool({
                type: value,
                insertOnCanvasDirectly: pointerType !== "mouse"
              });
            } else {
              app.setActiveTool({ type: value });
            }
          }
        },
        value
      );
    }),
    /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("div", { className: "App-toolbar__divider" }),
    /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)(DropdownMenu_default, { open: isExtraToolsMenuOpen, children: [
      /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)(
        DropdownMenu_default.Trigger,
        {
          className: clsx_m_default("App-toolbar__extra-tools-trigger", {
            "App-toolbar__extra-tools-trigger--selected": frameToolSelected || embeddableToolSelected || // in collab we're already highlighting the laser button
            // outside toolbar, so let's not highlight extra-tools button
            // on top of it
            laserToolSelected && !app.props.isCollaborating
          }),
          onToggle: () => setIsExtraToolsMenuOpen(!isExtraToolsMenuOpen),
          title: t("toolBar.extraTools"),
          children: [
            extraToolsIcon,
            app.props.aiEnabled !== false && /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
              "div",
              {
                style: {
                  display: "inline-flex",
                  marginLeft: "auto",
                  padding: "2px 4px",
                  borderRadius: 6,
                  fontSize: 8,
                  fontFamily: "Cascadia, monospace",
                  position: "absolute",
                  background: "var(--color-promo)",
                  color: "var(--color-surface-lowest)",
                  bottom: 3,
                  right: 4
                },
                children: "AI"
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)(
        DropdownMenu_default.Content,
        {
          onClickOutside: () => setIsExtraToolsMenuOpen(false),
          onSelect: () => setIsExtraToolsMenuOpen(false),
          className: "App-toolbar__extra-tools-dropdown",
          style: {
            position: "fixed",
            top: 260,
            left: 60,
            width: 240
          },
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
              DropdownMenu_default.Item,
              {
                onSelect: () => app.setActiveTool({ type: "frame" }),
                icon: frameToolIcon,
                shortcut: KEYS.F.toLocaleUpperCase(),
                "data-testid": "toolbar-frame",
                selected: frameToolSelected,
                children: t("toolBar.frame")
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
              DropdownMenu_default.Item,
              {
                onSelect: () => app.setActiveTool({ type: "embeddable" }),
                icon: EmbedIcon,
                "data-testid": "toolbar-embeddable",
                selected: embeddableToolSelected,
                children: t("toolBar.embeddable")
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
              DropdownMenu_default.Item,
              {
                onSelect: () => app.setActiveTool({ type: "laser" }),
                icon: laserPointerToolIcon,
                "data-testid": "toolbar-laser",
                selected: laserToolSelected,
                shortcut: KEYS.K.toLocaleUpperCase(),
                children: t("toolBar.laser")
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("div", { style: { margin: "6px 0", fontSize: 14, fontWeight: 600 }, children: "Generate" }),
            app.props.aiEnabled !== false && /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(TTDDialogTriggerTunnel.Out, {}),
            /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
              DropdownMenu_default.Item,
              {
                onSelect: () => app.setOpenDialog({ name: "ttd", tab: "mermaid" }),
                icon: mermaidLogoIcon,
                "data-testid": "toolbar-embeddable",
                children: t("toolBar.mermaidToExcalidraw")
              }
            ),
            app.props.aiEnabled !== false && app.plugins.diagramToCode && /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(import_jsx_runtime71.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)(
              DropdownMenu_default.Item,
              {
                onSelect: () => app.onMagicframeToolSelect(),
                icon: MagicIcon,
                "data-testid": "toolbar-magicframe",
                children: [
                  t("toolBar.magicframe"),
                  /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(DropdownMenu_default.Item.Badge, { children: "AI" })
                ]
              }
            ) })
          ]
        }
      )
    ] })
  ] });
};
var ZoomActions = ({
  renderAction,
  zoom
}) => /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(Stack_default.Col, { gap: 1, className: CLASSES.ZOOM_ACTIONS, children: /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)(Stack_default.Row, { align: "center", children: [
  renderAction("zoomOut"),
  renderAction("resetZoom"),
  renderAction("zoomIn")
] }) });
var UndoRedoActions = ({
  renderAction,
  className
}) => /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)("div", { className: `undo-redo-buttons ${className}`, children: [
  /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("div", { className: "undo-button-container", children: /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(Tooltip, { label: t("buttons.undo"), children: renderAction("undo") }) }),
  /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("div", { className: "redo-button-container", children: /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)(Tooltip, { label: t("buttons.redo"), children: [
    " ",
    renderAction("redo")
  ] }) })
] });
var ExitZenModeAction = ({
  actionManager,
  showExitZenModeBtn
}) => /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(
  "button",
  {
    type: "button",
    className: clsx_m_default("disable-zen-mode", {
      "disable-zen-mode--visible": showExitZenModeBtn
    }),
    onClick: () => actionManager.executeAction(actionToggleZenMode),
    children: t("buttons.exitZenMode")
  }
);
var FinalizeAction = ({
  renderAction,
  className
}) => /* @__PURE__ */ (0, import_jsx_runtime71.jsx)("div", { className: `finalize-button ${className}`, children: renderAction("finalize", { size: "small" }) });

// hooks/useStableCallback.ts
init_define_import_meta_env();
var import_react76 = __toESM(require_react(), 1);
var useStableCallback = (userFn) => {
  const stableRef = (0, import_react76.useRef)({ userFn });
  stableRef.current.userFn = userFn;
  if (!stableRef.current.stableFn) {
    stableRef.current.stableFn = (...args) => stableRef.current.userFn(...args);
  }
  return stableRef.current.stableFn;
};

// components/ActiveConfirmDialog.tsx
init_define_import_meta_env();
var import_jsx_runtime72 = __toESM(require_jsx_runtime(), 1);
var activeConfirmDialogAtom = atom2(null);
var ActiveConfirmDialog = () => {
  const [activeConfirmDialog, setActiveConfirmDialog] = useAtom(
    activeConfirmDialogAtom,
    jotaiScope
  );
  const actionManager = useExcalidrawActionManager();
  if (!activeConfirmDialog) {
    return null;
  }
  if (activeConfirmDialog === "clearCanvas") {
    return /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(
      ConfirmDialog_default,
      {
        onConfirm: () => {
          actionManager.executeAction(actionClearCanvas);
          setActiveConfirmDialog(null);
        },
        onCancel: () => setActiveConfirmDialog(null),
        title: t("clearCanvasDialog.title"),
        children: /* @__PURE__ */ (0, import_jsx_runtime72.jsxs)("p", { className: "clear-canvas__content", children: [
          " ",
          t("alerts.clearReset")
        ] })
      }
    );
  }
  return null;
};

// components/CommandPalette/defaultCommandPaletteItems.ts
var defaultCommandPaletteItems_exports = {};
__export(defaultCommandPaletteItems_exports, {
  toggleTheme: () => toggleTheme
});
init_define_import_meta_env();
var toggleTheme = {
  ...actionToggleTheme,
  category: "App",
  label: "Toggle theme",
  perform: ({ actionManager }) => {
    actionManager.executeAction(actionToggleTheme, "commandPalette");
  }
};

// components/CommandPalette/CommandPalette.tsx
var import_jsx_runtime73 = __toESM(require_jsx_runtime(), 1);
var lastUsedPaletteItem = atom2(null);
var DEFAULT_CATEGORIES = {
  app: "App",
  export: "Export",
  tools: "Tools",
  editor: "Editor",
  elements: "Elements",
  links: "Links"
};
var getCategoryOrder = (category) => {
  switch (category) {
    case DEFAULT_CATEGORIES.app:
      return 1;
    case DEFAULT_CATEGORIES.export:
      return 2;
    case DEFAULT_CATEGORIES.editor:
      return 3;
    case DEFAULT_CATEGORIES.tools:
      return 4;
    case DEFAULT_CATEGORIES.elements:
      return 5;
    case DEFAULT_CATEGORIES.links:
      return 6;
    default:
      return 10;
  }
};
var CommandShortcutHint = ({
  shortcut,
  className,
  children
}) => {
  const shortcuts = shortcut.replace("++", "+$").split("+");
  return /* @__PURE__ */ (0, import_jsx_runtime73.jsxs)("div", { className: clsx_m_default("shortcut", className), children: [
    shortcuts.map((item, idx) => {
      return /* @__PURE__ */ (0, import_jsx_runtime73.jsx)("div", { className: "shortcut-wrapper", children: /* @__PURE__ */ (0, import_jsx_runtime73.jsx)("div", { className: "shortcut-key", children: item === "$" ? "+" : item }) }, item);
    }),
    /* @__PURE__ */ (0, import_jsx_runtime73.jsx)("div", { className: "shortcut-desc", children })
  ] });
};
var isCommandPaletteToggleShortcut = (event) => {
  return !event.altKey && event[KEYS.CTRL_OR_CMD] && (event.shiftKey && event.key.toLowerCase() === KEYS.P || event.key === KEYS.SLASH);
};
var CommandPalette = Object.assign(
  (props) => {
    const uiAppState = useUIAppState();
    const setAppState = useExcalidrawSetAppState();
    (0, import_react77.useEffect)(() => {
      const commandPaletteShortcut = (event) => {
        if (isCommandPaletteToggleShortcut(event)) {
          event.preventDefault();
          event.stopPropagation();
          setAppState((appState) => {
            const nextState = appState.openDialog?.name === "commandPalette" ? null : { name: "commandPalette" };
            if (nextState) {
              trackEvent("command_palette", "open", "shortcut");
            }
            return {
              openDialog: nextState
            };
          });
        }
      };
      window.addEventListener("keydown" /* KEYDOWN */, commandPaletteShortcut, {
        capture: true
      });
      return () => window.removeEventListener("keydown" /* KEYDOWN */, commandPaletteShortcut, {
        capture: true
      });
    }, [setAppState]);
    if (uiAppState.openDialog?.name !== "commandPalette") {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(CommandPaletteInner, { ...props });
  },
  {
    defaultItems: defaultCommandPaletteItems_exports
  }
);
function CommandPaletteInner({
  customCommandPaletteItems
}) {
  const app = useApp();
  const uiAppState = useUIAppState();
  const setAppState = useExcalidrawSetAppState();
  const appProps = useAppProps();
  const actionManager = useExcalidrawActionManager();
  const [lastUsed, setLastUsed] = useAtom(lastUsedPaletteItem);
  const [allCommands, setAllCommands] = (0, import_react77.useState)(null);
  const inputRef = (0, import_react77.useRef)(null);
  const stableDeps = useStable({
    uiAppState,
    customCommandPaletteItems,
    appProps
  });
  (0, import_react77.useEffect)(() => {
    const { uiAppState: uiAppState2, customCommandPaletteItems: customCommandPaletteItems2, appProps: appProps2 } = stableDeps;
    const getActionLabel = (action) => {
      let label = "";
      if (action.label) {
        if (typeof action.label === "function") {
          label = t(
            action.label(
              app.scene.getNonDeletedElements(),
              uiAppState2,
              app
            )
          );
        } else {
          label = t(action.label);
        }
      }
      return label;
    };
    const getActionIcon = (action) => {
      if (typeof action.icon === "function") {
        return action.icon(uiAppState2, app.scene.getNonDeletedElements());
      }
      return action.icon;
    };
    let commandsFromActions = [];
    const actionToCommand = (action, category, transformer) => {
      const command = {
        label: getActionLabel(action),
        icon: getActionIcon(action),
        category,
        shortcut: getShortcutFromShortcutName(action.name),
        keywords: action.keywords,
        predicate: action.predicate,
        viewMode: action.viewMode,
        perform: () => {
          actionManager.executeAction(action, "commandPalette");
        }
      };
      return transformer ? transformer(command, action) : command;
    };
    if (uiAppState2 && app.scene && actionManager) {
      const elementsCommands = [
        actionManager.actions.group,
        actionManager.actions.ungroup,
        actionManager.actions.cut,
        actionManager.actions.copy,
        actionManager.actions.deleteSelectedElements,
        actionManager.actions.copyStyles,
        actionManager.actions.pasteStyles,
        actionManager.actions.bringToFront,
        actionManager.actions.bringForward,
        actionManager.actions.sendBackward,
        actionManager.actions.sendToBack,
        actionManager.actions.alignTop,
        actionManager.actions.alignBottom,
        actionManager.actions.alignLeft,
        actionManager.actions.alignRight,
        actionManager.actions.alignVerticallyCentered,
        actionManager.actions.alignHorizontallyCentered,
        actionManager.actions.duplicateSelection,
        actionManager.actions.flipHorizontal,
        actionManager.actions.flipVertical,
        actionManager.actions.zoomToFitSelection,
        actionManager.actions.zoomToFitSelectionInViewport,
        actionManager.actions.increaseFontSize,
        actionManager.actions.decreaseFontSize,
        actionManager.actions.toggleLinearEditor,
        actionLink
      ].map(
        (action) => actionToCommand(
          action,
          DEFAULT_CATEGORIES.elements,
          (command, action2) => ({
            ...command,
            predicate: action2.predicate ? action2.predicate : (elements, appState, appProps3, app2) => {
              const selectedElements = getSelectedElements(
                elements,
                appState
              );
              return selectedElements.length > 0;
            }
          })
        )
      );
      const toolCommands = [
        actionManager.actions.toggleHandTool,
        actionManager.actions.setFrameAsActiveTool
      ].map((action) => actionToCommand(action, DEFAULT_CATEGORIES.tools));
      const editorCommands = [
        actionManager.actions.undo,
        actionManager.actions.redo,
        actionManager.actions.zoomIn,
        actionManager.actions.zoomOut,
        actionManager.actions.resetZoom,
        actionManager.actions.zoomToFit,
        actionManager.actions.zenMode,
        actionManager.actions.viewMode,
        actionManager.actions.gridMode,
        actionManager.actions.objectsSnapMode,
        actionManager.actions.toggleShortcuts,
        actionManager.actions.selectAll,
        actionManager.actions.toggleElementLock,
        actionManager.actions.unlockAllElements,
        actionManager.actions.stats
      ].map((action) => actionToCommand(action, DEFAULT_CATEGORIES.editor));
      const exportCommands = [
        actionManager.actions.saveToActiveFile,
        actionManager.actions.saveFileToDisk,
        actionManager.actions.copyAsPng,
        actionManager.actions.copyAsSvg
      ].map((action) => actionToCommand(action, DEFAULT_CATEGORIES.export));
      commandsFromActions = [
        ...elementsCommands,
        ...editorCommands,
        {
          label: getActionLabel(actionClearCanvas),
          icon: getActionIcon(actionClearCanvas),
          shortcut: getShortcutFromShortcutName(
            actionClearCanvas.name
          ),
          category: DEFAULT_CATEGORIES.editor,
          keywords: ["delete", "destroy"],
          viewMode: false,
          perform: () => {
            jotaiStore.set(activeConfirmDialogAtom, "clearCanvas");
          }
        },
        {
          label: t("buttons.exportImage"),
          category: DEFAULT_CATEGORIES.export,
          icon: ExportImageIcon,
          shortcut: getShortcutFromShortcutName("imageExport"),
          keywords: [
            "export",
            "image",
            "png",
            "jpeg",
            "svg",
            "clipboard",
            "picture"
          ],
          perform: () => {
            setAppState({ openDialog: { name: "imageExport" } });
          }
        },
        ...exportCommands
      ];
      const additionalCommands = [
        {
          label: t("toolBar.library"),
          category: DEFAULT_CATEGORIES.app,
          icon: LibraryIcon,
          viewMode: false,
          perform: () => {
            if (uiAppState2.openSidebar) {
              setAppState({
                openSidebar: null
              });
            } else {
              setAppState({
                openSidebar: {
                  name: DEFAULT_SIDEBAR.name,
                  tab: DEFAULT_SIDEBAR.defaultTab
                }
              });
            }
          }
        },
        {
          label: t("search.title"),
          category: DEFAULT_CATEGORIES.app,
          icon: searchIcon,
          viewMode: true,
          perform: () => {
            actionManager.executeAction(actionToggleSearchMenu);
          }
        },
        {
          label: t("labels.changeStroke"),
          keywords: ["color", "outline"],
          category: DEFAULT_CATEGORIES.elements,
          icon: bucketFillIcon,
          viewMode: false,
          predicate: (elements, appState) => {
            const selectedElements = getSelectedElements(elements, appState);
            return selectedElements.length > 0 && canChangeStrokeColor(appState, selectedElements);
          },
          perform: () => {
            setAppState((prevState) => ({
              openMenu: prevState.openMenu === "shape" ? null : "shape",
              openPopup: "elementStroke"
            }));
          }
        },
        {
          label: t("labels.changeBackground"),
          keywords: ["color", "fill"],
          icon: bucketFillIcon,
          category: DEFAULT_CATEGORIES.elements,
          viewMode: false,
          predicate: (elements, appState) => {
            const selectedElements = getSelectedElements(elements, appState);
            return selectedElements.length > 0 && canChangeBackgroundColor(appState, selectedElements);
          },
          perform: () => {
            setAppState((prevState) => ({
              openMenu: prevState.openMenu === "shape" ? null : "shape",
              openPopup: "elementBackground"
            }));
          }
        },
        {
          label: t("labels.canvasBackground"),
          keywords: ["color"],
          icon: bucketFillIcon,
          category: DEFAULT_CATEGORIES.editor,
          viewMode: false,
          perform: () => {
            setAppState((prevState) => ({
              openMenu: prevState.openMenu === "canvas" ? null : "canvas",
              openPopup: "canvasBackground"
            }));
          }
        },
        ...SHAPES.reduce((acc, shape) => {
          const { value, icon, key, numericKey } = shape;
          if (appProps2.UIOptions.tools?.[value] === false) {
            return acc;
          }
          const letter = key && capitalizeString(typeof key === "string" ? key : key[0]);
          const shortcut = letter || numericKey;
          const command = {
            label: t(`toolBar.${value}`),
            category: DEFAULT_CATEGORIES.tools,
            shortcut,
            icon,
            keywords: ["toolbar"],
            viewMode: false,
            perform: ({ event }) => {
              if (value === "image") {
                app.setActiveTool({
                  type: value,
                  insertOnCanvasDirectly: event.type === "keydown" /* KEYDOWN */
                });
              } else {
                app.setActiveTool({ type: value });
              }
            }
          };
          acc.push(command);
          return acc;
        }, []),
        ...toolCommands,
        {
          label: t("toolBar.lock"),
          category: DEFAULT_CATEGORIES.tools,
          icon: uiAppState2.activeTool.locked ? LockedIcon : UnlockedIcon,
          shortcut: KEYS.Q.toLocaleUpperCase(),
          viewMode: false,
          perform: () => {
            app.toggleLock();
          }
        },
        {
          label: `${t("labels.textToDiagram")}...`,
          category: DEFAULT_CATEGORIES.tools,
          icon: brainIconThin,
          viewMode: false,
          predicate: appProps2.aiEnabled,
          perform: () => {
            setAppState((state) => ({
              ...state,
              openDialog: {
                name: "ttd",
                tab: "text-to-diagram"
              }
            }));
          }
        },
        {
          label: `${t("toolBar.mermaidToExcalidraw")}...`,
          category: DEFAULT_CATEGORIES.tools,
          icon: mermaidLogoIcon,
          viewMode: false,
          predicate: appProps2.aiEnabled,
          perform: () => {
            setAppState((state) => ({
              ...state,
              openDialog: {
                name: "ttd",
                tab: "mermaid"
              }
            }));
          }
        }
        // {
        //   label: `${t("toolBar.magicframe")}...`,
        //   category: DEFAULT_CATEGORIES.tools,
        //   icon: MagicIconThin,
        //   viewMode: false,
        //   predicate: appProps.aiEnabled,
        //   perform: () => {
        //     app.onMagicframeToolSelect();
        //   },
        // },
      ];
      const allCommands2 = [
        ...commandsFromActions,
        ...additionalCommands,
        ...customCommandPaletteItems2 || []
      ].map((command) => {
        return {
          ...command,
          icon: command.icon || boltIcon,
          order: command.order ?? getCategoryOrder(command.category),
          haystack: `${deburr(command.label.toLocaleLowerCase())} ${command.keywords?.join(" ") || ""}`
        };
      });
      setAllCommands(allCommands2);
      setLastUsed(
        allCommands2.find((command) => command.label === lastUsed?.label) ?? null
      );
    }
  }, [
    stableDeps,
    app,
    actionManager,
    setAllCommands,
    lastUsed?.label,
    setLastUsed,
    setAppState
  ]);
  const [commandSearch, setCommandSearch] = (0, import_react77.useState)("");
  const [currentCommand, setCurrentCommand] = (0, import_react77.useState)(null);
  const [commandsByCategory, setCommandsByCategory] = (0, import_react77.useState)({});
  const closeCommandPalette = (cb) => {
    setAppState(
      {
        openDialog: null
      },
      cb
    );
    setCommandSearch("");
  };
  const executeCommand = (command, event) => {
    if (uiAppState.openDialog?.name === "commandPalette") {
      event.stopPropagation();
      event.preventDefault();
      document.body.classList.add("excalidraw-animations-disabled");
      closeCommandPalette(() => {
        command.perform({ actionManager, event });
        setLastUsed(command);
        requestAnimationFrame(() => {
          document.body.classList.remove("excalidraw-animations-disabled");
        });
      });
    }
  };
  const isCommandAvailable = useStableCallback(
    (command) => {
      if (command.viewMode === false && uiAppState.viewModeEnabled) {
        return false;
      }
      return typeof command.predicate === "function" ? command.predicate(
        app.scene.getNonDeletedElements(),
        uiAppState,
        appProps,
        app
      ) : command.predicate === void 0 || command.predicate;
    }
  );
  const handleKeyDown = useStableCallback((event) => {
    const ignoreAlphanumerics = isWritableElement(event.target) || isCommandPaletteToggleShortcut(event) || event.key === KEYS.ESCAPE;
    if (ignoreAlphanumerics && event.key !== KEYS.ARROW_UP && event.key !== KEYS.ARROW_DOWN && event.key !== KEYS.ENTER) {
      return;
    }
    const matchingCommands = Object.values(commandsByCategory).flat();
    const shouldConsiderLastUsed = lastUsed && !commandSearch && isCommandAvailable(lastUsed);
    if (event.key === KEYS.ARROW_UP) {
      event.preventDefault();
      const index2 = matchingCommands.findIndex(
        (item) => item.label === currentCommand?.label
      );
      if (shouldConsiderLastUsed) {
        if (index2 === 0) {
          setCurrentCommand(lastUsed);
          return;
        }
        if (currentCommand === lastUsed) {
          const nextItem2 = matchingCommands[matchingCommands.length - 1];
          if (nextItem2) {
            setCurrentCommand(nextItem2);
          }
          return;
        }
      }
      let nextIndex;
      if (index2 === -1) {
        nextIndex = matchingCommands.length - 1;
      } else {
        nextIndex = index2 === 0 ? matchingCommands.length - 1 : (index2 - 1) % matchingCommands.length;
      }
      const nextItem = matchingCommands[nextIndex];
      if (nextItem) {
        setCurrentCommand(nextItem);
      }
      return;
    }
    if (event.key === KEYS.ARROW_DOWN) {
      event.preventDefault();
      const index2 = matchingCommands.findIndex(
        (item) => item.label === currentCommand?.label
      );
      if (shouldConsiderLastUsed) {
        if (!currentCommand || index2 === matchingCommands.length - 1) {
          setCurrentCommand(lastUsed);
          return;
        }
        if (currentCommand === lastUsed) {
          const nextItem2 = matchingCommands[0];
          if (nextItem2) {
            setCurrentCommand(nextItem2);
          }
          return;
        }
      }
      const nextIndex = (index2 + 1) % matchingCommands.length;
      const nextItem = matchingCommands[nextIndex];
      if (nextItem) {
        setCurrentCommand(nextItem);
      }
      return;
    }
    if (event.key === KEYS.ENTER) {
      if (currentCommand) {
        setTimeout(() => {
          executeCommand(currentCommand, event);
        });
      }
    }
    if (ignoreAlphanumerics) {
      return;
    }
    event.stopPropagation();
    if (/^[a-zA-Z0-9]$/.test(event.key)) {
      inputRef?.current?.focus();
      return;
    }
    event.preventDefault();
  });
  (0, import_react77.useEffect)(() => {
    window.addEventListener("keydown" /* KEYDOWN */, handleKeyDown, {
      capture: true
    });
    return () => window.removeEventListener("keydown" /* KEYDOWN */, handleKeyDown, {
      capture: true
    });
  }, [handleKeyDown]);
  (0, import_react77.useEffect)(() => {
    if (!allCommands) {
      return;
    }
    const getNextCommandsByCategory = (commands) => {
      const nextCommandsByCategory = {};
      for (const command of commands) {
        if (nextCommandsByCategory[command.category]) {
          nextCommandsByCategory[command.category].push(command);
        } else {
          nextCommandsByCategory[command.category] = [command];
        }
      }
      return nextCommandsByCategory;
    };
    let matchingCommands = allCommands.filter(isCommandAvailable).sort((a3, b3) => a3.order - b3.order);
    const showLastUsed = !commandSearch && lastUsed && isCommandAvailable(lastUsed);
    if (!commandSearch) {
      setCommandsByCategory(
        getNextCommandsByCategory(
          showLastUsed ? matchingCommands.filter(
            (command) => command.label !== lastUsed?.label
          ) : matchingCommands
        )
      );
      setCurrentCommand(showLastUsed ? lastUsed : matchingCommands[0] || null);
      return;
    }
    const _query = deburr(
      commandSearch.toLocaleLowerCase().replace(/[<>_| -]/g, "")
    );
    matchingCommands = import_fuzzy.default.filter(_query, matchingCommands, {
      extract: (command) => command.haystack
    }).sort((a3, b3) => b3.score - a3.score).map((item) => item.original);
    setCommandsByCategory(getNextCommandsByCategory(matchingCommands));
    setCurrentCommand(matchingCommands[0] ?? null);
  }, [commandSearch, allCommands, isCommandAvailable, lastUsed]);
  return /* @__PURE__ */ (0, import_jsx_runtime73.jsxs)(
    Dialog,
    {
      onCloseRequest: () => closeCommandPalette(),
      closeOnClickOutside: true,
      title: false,
      size: 720,
      autofocus: true,
      className: "command-palette-dialog",
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
          TextField,
          {
            value: commandSearch,
            placeholder: t("commandPalette.search.placeholder"),
            onChange: (value) => {
              setCommandSearch(value);
            },
            selectOnRender: true,
            ref: inputRef
          }
        ),
        !app.device.viewport.isMobile && /* @__PURE__ */ (0, import_jsx_runtime73.jsxs)("div", { className: "shortcuts-wrapper", children: [
          /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(CommandShortcutHint, { shortcut: "\u2191\u2193", children: t("commandPalette.shortcuts.select") }),
          /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(CommandShortcutHint, { shortcut: "\u21B5", children: t("commandPalette.shortcuts.confirm") }),
          /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(CommandShortcutHint, { shortcut: getShortcutKey("Esc"), children: t("commandPalette.shortcuts.close") })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime73.jsxs)("div", { className: "commands", children: [
          lastUsed && !commandSearch && /* @__PURE__ */ (0, import_jsx_runtime73.jsxs)("div", { className: "command-category", children: [
            /* @__PURE__ */ (0, import_jsx_runtime73.jsxs)("div", { className: "command-category-title", children: [
              t("commandPalette.recents"),
              /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
                "div",
                {
                  className: "icon",
                  style: {
                    marginLeft: "6px"
                  },
                  children: clockIcon
                }
              )
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
              CommandItem,
              {
                command: lastUsed,
                isSelected: lastUsed.label === currentCommand?.label,
                onClick: (event) => executeCommand(lastUsed, event),
                disabled: !isCommandAvailable(lastUsed),
                onMouseMove: () => setCurrentCommand(lastUsed),
                showShortcut: !app.device.viewport.isMobile,
                appState: uiAppState
              }
            )
          ] }),
          Object.keys(commandsByCategory).length > 0 ? Object.keys(commandsByCategory).map((category, idx) => {
            return /* @__PURE__ */ (0, import_jsx_runtime73.jsxs)("div", { className: "command-category", children: [
              /* @__PURE__ */ (0, import_jsx_runtime73.jsx)("div", { className: "command-category-title", children: category }),
              commandsByCategory[category].map((command) => /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
                CommandItem,
                {
                  command,
                  isSelected: command.label === currentCommand?.label,
                  onClick: (event) => executeCommand(command, event),
                  onMouseMove: () => setCurrentCommand(command),
                  showShortcut: !app.device.viewport.isMobile,
                  appState: uiAppState
                },
                command.label
              ))
            ] }, category);
          }) : allCommands ? /* @__PURE__ */ (0, import_jsx_runtime73.jsxs)("div", { className: "no-match", children: [
            /* @__PURE__ */ (0, import_jsx_runtime73.jsx)("div", { className: "icon", children: searchIcon }),
            " ",
            t("commandPalette.search.noMatch")
          ] }) : null
        ] })
      ]
    }
  );
}
var CommandItem = ({
  command,
  isSelected,
  disabled,
  onMouseMove,
  onClick,
  showShortcut,
  appState
}) => {
  const noop = () => {
  };
  return /* @__PURE__ */ (0, import_jsx_runtime73.jsxs)(
    "div",
    {
      className: clsx_m_default("command-item", {
        "item-selected": isSelected,
        "item-disabled": disabled
      }),
      ref: (ref) => {
        if (isSelected && !disabled) {
          ref?.scrollIntoView?.({
            block: "nearest"
          });
        }
      },
      onClick: disabled ? noop : onClick,
      onMouseMove: disabled ? noop : onMouseMove,
      title: disabled ? t("commandPalette.itemNotAvailable") : "",
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime73.jsxs)("div", { className: "name", children: [
          command.icon && /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
            InlineIcon,
            {
              icon: typeof command.icon === "function" ? command.icon(appState) : command.icon
            }
          ),
          command.label
        ] }),
        showShortcut && command.shortcut && /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(CommandShortcutHint, { shortcut: command.shortcut })
      ]
    }
  );
};

// actions/actionLinearEditor.tsx
var import_jsx_runtime74 = __toESM(require_jsx_runtime(), 1);
var actionToggleLinearEditor = register({
  name: "toggleLinearEditor",
  category: DEFAULT_CATEGORIES.elements,
  label: (elements, appState, app) => {
    const selectedElement = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds
    })[0];
    return selectedElement?.type === "arrow" ? "labels.lineEditor.editArrow" : "labels.lineEditor.edit";
  },
  keywords: ["line"],
  trackEvent: {
    category: "element"
  },
  predicate: (elements, appState, _, app) => {
    const selectedElements = app.scene.getSelectedElements(appState);
    if (!appState.editingLinearElement && selectedElements.length === 1 && isLinearElement(selectedElements[0]) && !isElbowArrow(selectedElements[0])) {
      return true;
    }
    return false;
  },
  perform(elements, appState, _, app) {
    const selectedElement = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds,
      includeBoundTextElement: true
    })[0];
    const editingLinearElement = appState.editingLinearElement?.elementId === selectedElement.id ? null : new LinearElementEditor(selectedElement);
    return {
      appState: {
        ...appState,
        editingLinearElement
      },
      storeAction: StoreAction.CAPTURE
    };
  },
  PanelComponent: ({ appState, updateData, app }) => {
    const selectedElement = app.scene.getSelectedElements({
      selectedElementIds: appState.selectedElementIds
    })[0];
    const label = t(
      selectedElement.type === "arrow" ? "labels.lineEditor.editArrow" : "labels.lineEditor.edit"
    );
    return /* @__PURE__ */ (0, import_jsx_runtime74.jsx)(
      ToolButton,
      {
        type: "button",
        icon: lineEditorIcon,
        title: label,
        "aria-label": label,
        onClick: () => updateData(null)
      }
    );
  }
});

// actions/actionToggleSearchMenu.ts
init_define_import_meta_env();
var actionToggleSearchMenu = register({
  name: "searchMenu",
  icon: searchIcon,
  keywords: ["search", "find"],
  label: "search.title",
  viewMode: true,
  trackEvent: {
    category: "search_menu",
    action: "toggle",
    predicate: (appState) => appState.gridModeEnabled
  },
  perform(elements, appState, _, app) {
    if (appState.openSidebar?.name === DEFAULT_SIDEBAR.name && appState.openSidebar.tab === CANVAS_SEARCH_TAB) {
      const searchInput = app.excalidrawContainerValue.container?.querySelector(
        `.${CLASSES.SEARCH_MENU_INPUT_WRAPPER} input`
      );
      if (searchInput?.matches(":focus")) {
        return {
          appState: { ...appState, openSidebar: null },
          storeAction: StoreAction.NONE
        };
      }
      searchInput?.focus();
      searchInput?.select();
      return false;
    }
    return {
      appState: {
        ...appState,
        openSidebar: { name: DEFAULT_SIDEBAR.name, tab: CANVAS_SEARCH_TAB },
        openDialog: null
      },
      storeAction: StoreAction.NONE
    };
  },
  checked: (appState) => appState.gridModeEnabled,
  predicate: (element, appState, props) => {
    return props.gridModeEnabled === void 0;
  },
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key === KEYS.F
});

// actions/actionHistory.tsx
init_define_import_meta_env();

// history.ts
init_define_import_meta_env();
var HistoryChangedEvent = class {
  constructor(isUndoStackEmpty = true, isRedoStackEmpty = true) {
    this.isUndoStackEmpty = isUndoStackEmpty;
    this.isRedoStackEmpty = isRedoStackEmpty;
  }
};
var History = class _History {
  onHistoryChangedEmitter = new Emitter();
  undoStack = [];
  redoStack = [];
  get isUndoStackEmpty() {
    return this.undoStack.length === 0;
  }
  get isRedoStackEmpty() {
    return this.redoStack.length === 0;
  }
  clear() {
    this.undoStack.length = 0;
    this.redoStack.length = 0;
  }
  /**
   * Record a local change which will go into the history
   */
  record(elementsChange, appStateChange) {
    const entry = HistoryEntry.create(appStateChange, elementsChange);
    if (!entry.isEmpty()) {
      this.undoStack.push(entry.inverse());
      if (!entry.elementsChange.isEmpty()) {
        this.redoStack.length = 0;
      }
      this.onHistoryChangedEmitter.trigger(
        new HistoryChangedEvent(this.isUndoStackEmpty, this.isRedoStackEmpty)
      );
    }
  }
  undo(elements, appState, snapshot) {
    return this.perform(
      elements,
      appState,
      snapshot,
      () => _History.pop(this.undoStack),
      (entry) => _History.push(this.redoStack, entry, elements)
    );
  }
  redo(elements, appState, snapshot) {
    return this.perform(
      elements,
      appState,
      snapshot,
      () => _History.pop(this.redoStack),
      (entry) => _History.push(this.undoStack, entry, elements)
    );
  }
  perform(elements, appState, snapshot, pop, push) {
    try {
      let historyEntry = pop();
      if (historyEntry === null) {
        return;
      }
      let nextElements = elements;
      let nextAppState = appState;
      let containsVisibleChange = false;
      while (historyEntry) {
        try {
          [nextElements, nextAppState, containsVisibleChange] = historyEntry.applyTo(nextElements, nextAppState, snapshot);
        } finally {
          push(historyEntry);
        }
        if (containsVisibleChange) {
          break;
        }
        historyEntry = pop();
      }
      return [nextElements, nextAppState];
    } finally {
      this.onHistoryChangedEmitter.trigger(
        new HistoryChangedEvent(this.isUndoStackEmpty, this.isRedoStackEmpty)
      );
    }
  }
  static pop(stack) {
    if (!stack.length) {
      return null;
    }
    const entry = stack.pop();
    if (entry !== void 0) {
      return entry;
    }
    return null;
  }
  static push(stack, entry, prevElements) {
    const updatedEntry = entry.inverse().applyLatestChanges(prevElements);
    return stack.push(updatedEntry);
  }
};
var HistoryEntry = class _HistoryEntry {
  constructor(appStateChange, elementsChange) {
    this.appStateChange = appStateChange;
    this.elementsChange = elementsChange;
  }
  static create(appStateChange, elementsChange) {
    return new _HistoryEntry(appStateChange, elementsChange);
  }
  inverse() {
    return new _HistoryEntry(
      this.appStateChange.inverse(),
      this.elementsChange.inverse()
    );
  }
  applyTo(elements, appState, snapshot) {
    const [nextElements, elementsContainVisibleChange] = this.elementsChange.applyTo(elements, snapshot.elements);
    const [nextAppState, appStateContainsVisibleChange] = this.appStateChange.applyTo(appState, nextElements);
    const appliedVisibleChanges = elementsContainVisibleChange || appStateContainsVisibleChange;
    return [nextElements, nextAppState, appliedVisibleChanges];
  }
  /**
   * Apply latest (remote) changes to the history entry, creates new instance of `HistoryEntry`.
   */
  applyLatestChanges(elements) {
    const updatedElementsChange = this.elementsChange.applyLatestChanges(elements);
    return _HistoryEntry.create(this.appStateChange, updatedElementsChange);
  }
  isEmpty() {
    return this.appStateChange.isEmpty() && this.elementsChange.isEmpty();
  }
};

// hooks/useEmitter.ts
init_define_import_meta_env();
var import_react78 = __toESM(require_react(), 1);
var useEmitter = (emitter, initialState) => {
  const [event, setEvent] = (0, import_react78.useState)(initialState);
  (0, import_react78.useEffect)(() => {
    const unsubscribe = emitter.on((event2) => {
      setEvent(event2);
    });
    return () => {
      unsubscribe();
    };
  }, [emitter]);
  return event;
};

// actions/actionHistory.tsx
var import_jsx_runtime75 = __toESM(require_jsx_runtime(), 1);
var executeHistoryAction = (app, appState, updater) => {
  if (!appState.multiElement && !appState.resizingElement && !appState.editingTextElement && !appState.newElement && !appState.selectedElementsAreBeingDragged && !appState.selectionElement && !app.flowChartCreator.isCreatingChart) {
    const result = updater();
    if (!result) {
      return { storeAction: StoreAction.NONE };
    }
    const [nextElementsMap, nextAppState] = result;
    const nextElements = Array.from(nextElementsMap.values());
    return {
      appState: nextAppState,
      elements: nextElements,
      storeAction: StoreAction.UPDATE
    };
  }
  return { storeAction: StoreAction.NONE };
};
var createUndoAction = (history, store) => ({
  name: "undo",
  label: "buttons.undo",
  icon: UndoIcon,
  trackEvent: { category: "history" },
  viewMode: false,
  perform: (elements, appState, value, app) => executeHistoryAction(
    app,
    appState,
    () => history.undo(
      arrayToMap(elements),
      // TODO: #7348 refactor action manager to already include `SceneElementsMap`
      appState,
      store.snapshot
    )
  ),
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.key.toLowerCase() === KEYS.Z && !event.shiftKey,
  PanelComponent: ({ updateData, data }) => {
    const { isUndoStackEmpty } = useEmitter(
      history.onHistoryChangedEmitter,
      new HistoryChangedEvent(
        history.isUndoStackEmpty,
        history.isRedoStackEmpty
      )
    );
    return /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
      ToolButton,
      {
        type: "button",
        icon: UndoIcon,
        "aria-label": t("buttons.undo"),
        onClick: updateData,
        size: data?.size || "medium",
        disabled: isUndoStackEmpty,
        "data-testid": "button-undo"
      }
    );
  }
});
var createRedoAction = (history, store) => ({
  name: "redo",
  label: "buttons.redo",
  icon: RedoIcon,
  trackEvent: { category: "history" },
  viewMode: false,
  perform: (elements, appState, _, app) => executeHistoryAction(
    app,
    appState,
    () => history.redo(
      arrayToMap(elements),
      // TODO: #7348 refactor action manager to already include `SceneElementsMap`
      appState,
      store.snapshot
    )
  ),
  keyTest: (event) => event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key.toLowerCase() === KEYS.Z || isWindows && event.ctrlKey && !event.shiftKey && event.key === KEYS.Y,
  PanelComponent: ({ updateData, data }) => {
    const { isRedoStackEmpty } = useEmitter(
      history.onHistoryChangedEmitter,
      new HistoryChangedEvent(
        history.isUndoStackEmpty,
        history.isRedoStackEmpty
      )
    );
    return /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(
      ToolButton,
      {
        type: "button",
        icon: RedoIcon,
        "aria-label": t("buttons.redo"),
        onClick: updateData,
        size: data?.size || "medium",
        disabled: isRedoStackEmpty,
        "data-testid": "button-redo"
      }
    );
  }
});

// actions/manager.tsx
init_define_import_meta_env();
var import_jsx_runtime76 = __toESM(require_jsx_runtime(), 1);
var trackAction = (action, source, appState, elements, app, value) => {
  if (action.trackEvent) {
    try {
      if (typeof action.trackEvent === "object") {
        const shouldTrack = action.trackEvent.predicate ? action.trackEvent.predicate(appState, elements, value) : true;
        if (shouldTrack) {
          trackEvent(
            action.trackEvent.category,
            action.trackEvent.action || action.name,
            `${source} (${app.device.editor.isMobile ? "mobile" : "desktop"})`
          );
        }
      }
    } catch (error) {
      console.error("error while logging action:", error);
    }
  }
};
var ActionManager = class {
  actions = {};
  updater;
  getAppState;
  getElementsIncludingDeleted;
  app;
  constructor(updater, getAppState, getElementsIncludingDeleted, app) {
    this.updater = (actionResult) => {
      if (isPromiseLike(actionResult)) {
        actionResult.then((actionResult2) => {
          return updater(actionResult2);
        });
      } else {
        return updater(actionResult);
      }
    };
    this.getAppState = getAppState;
    this.getElementsIncludingDeleted = getElementsIncludingDeleted;
    this.app = app;
  }
  registerAction(action) {
    this.actions[action.name] = action;
  }
  registerAll(actions2) {
    actions2.forEach((action) => this.registerAction(action));
  }
  handleKeyDown(event) {
    const canvasActions = this.app.props.UIOptions.canvasActions;
    const data = Object.values(this.actions).sort((a3, b3) => (b3.keyPriority || 0) - (a3.keyPriority || 0)).filter(
      (action2) => (action2.name in canvasActions ? canvasActions[action2.name] : true) && action2.keyTest && action2.keyTest(
        event,
        this.getAppState(),
        this.getElementsIncludingDeleted(),
        this.app
      )
    );
    if (data.length !== 1) {
      if (data.length > 1) {
        console.warn("Canceling as multiple actions match this shortcut", data);
      }
      return false;
    }
    const action = data[0];
    if (this.getAppState().viewModeEnabled && action.viewMode !== true) {
      return false;
    }
    const elements = this.getElementsIncludingDeleted();
    const appState = this.getAppState();
    const value = null;
    trackAction(action, "keyboard", appState, elements, this.app, null);
    event.preventDefault();
    event.stopPropagation();
    this.updater(data[0].perform(elements, appState, value, this.app));
    return true;
  }
  executeAction(action, source = "api", value = null) {
    const elements = this.getElementsIncludingDeleted();
    const appState = this.getAppState();
    trackAction(action, source, appState, elements, this.app, value);
    this.updater(action.perform(elements, appState, value, this.app));
  }
  /**
   * @param data additional data sent to the PanelComponent
   */
  renderAction = (name, data) => {
    const canvasActions = this.app.props.UIOptions.canvasActions;
    if (this.actions[name] && "PanelComponent" in this.actions[name] && (name in canvasActions ? canvasActions[name] : true)) {
      const action = this.actions[name];
      const PanelComponent = action.PanelComponent;
      PanelComponent.displayName = "PanelComponent";
      const elements = this.getElementsIncludingDeleted();
      const appState = this.getAppState();
      const updateData = (formState) => {
        trackAction(action, "ui", appState, elements, this.app, formState);
        this.updater(
          action.perform(
            this.getElementsIncludingDeleted(),
            this.getAppState(),
            formState,
            this.app
          )
        );
      };
      return /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(
        PanelComponent,
        {
          elements: this.getElementsIncludingDeleted(),
          appState: this.getAppState(),
          updateData,
          appProps: this.app.props,
          app: this.app,
          data
        }
      );
    }
    return null;
  };
  isActionEnabled = (action) => {
    const elements = this.getElementsIncludingDeleted();
    const appState = this.getAppState();
    return !action.predicate || action.predicate(elements, appState, this.app.props, this.app);
  };
};

// gesture.ts
init_define_import_meta_env();
var getCenter = (pointers) => {
  const allCoords = Array.from(pointers.values());
  return {
    x: sum(allCoords, (coords) => coords.x) / allCoords.length,
    y: sum(allCoords, (coords) => coords.y) / allCoords.length
  };
};
var getDistance = ([a3, b3]) => Math.hypot(a3.x - b3.x, a3.y - b3.y);
var sum = (array, mapper) => array.reduce((acc, item) => acc + mapper(item), 0);

// components/ContextMenu.tsx
init_define_import_meta_env();
var import_react79 = __toESM(require_react(), 1);
var import_jsx_runtime77 = __toESM(require_jsx_runtime(), 1);
var CONTEXT_MENU_SEPARATOR = "separator";
var ContextMenu = import_react79.default.memo(
  ({ actionManager, items, top, left, onClose }) => {
    const appState = useExcalidrawAppState();
    const elements = useExcalidrawElements();
    const filteredItems = items.reduce((acc, item) => {
      if (item && (item === CONTEXT_MENU_SEPARATOR || !item.predicate || item.predicate(
        elements,
        appState,
        actionManager.app.props,
        actionManager.app
      ))) {
        acc.push(item);
      }
      return acc;
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(
      Popover,
      {
        onCloseRequest: () => {
          onClose();
        },
        top,
        left,
        fitInViewport: true,
        offsetLeft: appState.offsetLeft,
        offsetTop: appState.offsetTop,
        viewportWidth: appState.width,
        viewportHeight: appState.height,
        children: /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(
          "ul",
          {
            className: "context-menu",
            onContextMenu: (event) => event.preventDefault(),
            children: filteredItems.map((item, idx) => {
              if (item === CONTEXT_MENU_SEPARATOR) {
                if (!filteredItems[idx - 1] || filteredItems[idx - 1] === CONTEXT_MENU_SEPARATOR) {
                  return null;
                }
                return /* @__PURE__ */ (0, import_jsx_runtime77.jsx)("hr", { className: "context-menu-item-separator" }, idx);
              }
              const actionName = item.name;
              let label = "";
              if (item.label) {
                if (typeof item.label === "function") {
                  label = t(
                    item.label(
                      elements,
                      appState,
                      actionManager.app
                    )
                  );
                } else {
                  label = t(item.label);
                }
              }
              return /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(
                "li",
                {
                  "data-testid": actionName,
                  onClick: () => {
                    onClose(() => {
                      actionManager.executeAction(item, "contextMenu");
                    });
                  },
                  children: /* @__PURE__ */ (0, import_jsx_runtime77.jsxs)(
                    "button",
                    {
                      type: "button",
                      className: clsx_m_default("context-menu-item", {
                        dangerous: actionName === "deleteSelectedElements",
                        checkmark: item.checked?.(appState)
                      }),
                      children: [
                        /* @__PURE__ */ (0, import_jsx_runtime77.jsx)("div", { className: "context-menu-item__label", children: label }),
                        /* @__PURE__ */ (0, import_jsx_runtime77.jsx)("kbd", { className: "context-menu-item__shortcut", children: actionName ? getShortcutFromShortcutName(actionName) : "" })
                      ]
                    }
                  )
                },
                idx
              );
            })
          }
        )
      }
    );
  }
);

// components/LayerUI.tsx
init_define_import_meta_env();
var import_react107 = __toESM(require_react(), 1);

// components/ErrorDialog.tsx
init_define_import_meta_env();
var import_react80 = __toESM(require_react(), 1);
var import_jsx_runtime78 = __toESM(require_jsx_runtime(), 1);
var ErrorDialog = ({
  children,
  onClose
}) => {
  const [modalIsShown, setModalIsShown] = (0, import_react80.useState)(!!children);
  const { container: excalidrawContainer } = useExcalidrawContainer();
  const handleClose = import_react80.default.useCallback(() => {
    setModalIsShown(false);
    if (onClose) {
      onClose();
    }
    excalidrawContainer?.focus();
  }, [onClose, excalidrawContainer]);
  return /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(import_jsx_runtime78.Fragment, { children: modalIsShown && /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(
    Dialog,
    {
      size: "small",
      onCloseRequest: handleClose,
      title: t("errorDialog.title"),
      children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)("div", { style: { whiteSpace: "pre-wrap" }, children })
    }
  ) });
};

// components/ImageExportDialog.tsx
init_define_import_meta_env();
var import_react83 = __toESM(require_react(), 1);

// components/RadioGroup.tsx
init_define_import_meta_env();
var import_jsx_runtime79 = __toESM(require_jsx_runtime(), 1);
var RadioGroup = function({
  onChange,
  value,
  choices,
  name
}) {
  return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)("div", { className: "RadioGroup", children: choices.map((choice) => /* @__PURE__ */ (0, import_jsx_runtime79.jsxs)(
    "div",
    {
      className: clsx_m_default("RadioGroup__choice", {
        active: choice.value === value
      }),
      title: choice.ariaLabel,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
          "input",
          {
            name,
            type: "radio",
            checked: choice.value === value,
            onChange: () => onChange(choice.value),
            "aria-label": choice.ariaLabel
          }
        ),
        choice.label
      ]
    },
    String(choice.value)
  )) });
};

// components/Switch.tsx
init_define_import_meta_env();
var import_jsx_runtime80 = __toESM(require_jsx_runtime(), 1);
var Switch = ({
  title,
  name,
  checked,
  onChange,
  disabled = false
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime80.jsx)("div", { className: clsx_m_default("Switch", { toggled: checked, disabled }), children: /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(
    "input",
    {
      name,
      id: name,
      title,
      type: "checkbox",
      checked,
      disabled,
      onChange: () => onChange(!checked),
      onKeyDown: (event) => {
        if (event.key === " ") {
          onChange(!checked);
        }
      }
    }
  ) });
};

// components/FilledButton.tsx
init_define_import_meta_env();
var import_react81 = __toESM(require_react(), 1);
var import_jsx_runtime81 = __toESM(require_jsx_runtime(), 1);
var FilledButton = (0, import_react81.forwardRef)(
  ({
    children,
    icon,
    onClick,
    label,
    variant = "filled",
    color = "primary",
    size = "medium",
    fullWidth,
    className,
    status
  }, ref) => {
    const [isLoading, setIsLoading] = (0, import_react81.useState)(false);
    const _onClick = async (event) => {
      const ret = onClick?.(event);
      if (isPromiseLike(ret)) {
        const timer = window.setTimeout(() => {
          setIsLoading(true);
        }, 50);
        try {
          await ret;
        } catch (error) {
          if (!(error instanceof AbortError)) {
            throw error;
          } else {
            console.warn(error);
          }
        } finally {
          clearTimeout(timer);
          setIsLoading(false);
        }
      }
    };
    const _status = isLoading ? "loading" : status;
    color = _status === "success" ? "success" : color;
    return /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
      "button",
      {
        className: clsx_m_default(
          "ExcButton",
          `ExcButton--color-${color}`,
          `ExcButton--variant-${variant}`,
          `ExcButton--size-${size}`,
          `ExcButton--status-${_status}`,
          { "ExcButton--fullWidth": fullWidth },
          className
        ),
        onClick: _onClick,
        type: "button",
        "aria-label": label,
        ref,
        disabled: _status === "loading" || _status === "success",
        children: /* @__PURE__ */ (0, import_jsx_runtime81.jsxs)("div", { className: "ExcButton__contents", children: [
          _status === "loading" ? /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(Spinner_default, { className: "ExcButton__statusIcon" }) : _status === "success" && /* @__PURE__ */ (0, import_jsx_runtime81.jsx)("div", { className: "ExcButton__statusIcon", children: tablerCheckIcon }),
          icon && /* @__PURE__ */ (0, import_jsx_runtime81.jsx)("div", { className: "ExcButton__icon", "aria-hidden": true, children: icon }),
          variant !== "icon" && (children ?? label)
        ] })
      }
    );
  }
);

// hooks/useCopiedIndicator.ts
init_define_import_meta_env();
var import_react82 = __toESM(require_react(), 1);
var TIMEOUT = 2e3;
var useCopyStatus = () => {
  const [copyStatus, setCopyStatus] = (0, import_react82.useState)(null);
  const timeoutRef = (0, import_react82.useRef)(0);
  const onCopy = () => {
    clearTimeout(timeoutRef.current);
    setCopyStatus("success");
    timeoutRef.current = window.setTimeout(() => {
      setCopyStatus(null);
    }, TIMEOUT);
  };
  const resetCopyStatus = (0, import_react82.useCallback)(() => {
    setCopyStatus(null);
  }, []);
  return {
    copyStatus,
    resetCopyStatus,
    onCopy
  };
};

// components/ImageExportDialog.tsx
var import_jsx_runtime82 = __toESM(require_jsx_runtime(), 1);
var supportsContextFilters = "filter" in document.createElement("canvas").getContext("2d");
var ErrorCanvasPreview = () => {
  return /* @__PURE__ */ (0, import_jsx_runtime82.jsxs)("div", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime82.jsx)("h3", { children: t("canvasError.cannotShowPreview") }),
    /* @__PURE__ */ (0, import_jsx_runtime82.jsx)("p", { children: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)("span", { children: t("canvasError.canvasTooBig") }) }),
    /* @__PURE__ */ (0, import_jsx_runtime82.jsxs)("em", { children: [
      "(",
      t("canvasError.canvasTooBigTip"),
      ")"
    ] })
  ] });
};
var ImageExportModal = ({
  appStateSnapshot,
  elementsSnapshot,
  files,
  actionManager,
  onExportImage,
  name
}) => {
  const hasSelection = isSomeElementSelected(
    elementsSnapshot,
    appStateSnapshot
  );
  const [projectName, setProjectName] = (0, import_react83.useState)(name);
  const [exportSelectionOnly, setExportSelectionOnly] = (0, import_react83.useState)(hasSelection);
  const [exportWithBackground, setExportWithBackground] = (0, import_react83.useState)(
    appStateSnapshot.exportBackground
  );
  const [exportDarkMode, setExportDarkMode] = (0, import_react83.useState)(
    appStateSnapshot.exportWithDarkMode
  );
  const [embedScene, setEmbedScene] = (0, import_react83.useState)(
    appStateSnapshot.exportEmbedScene
  );
  const [exportScale, setExportScale] = (0, import_react83.useState)(appStateSnapshot.exportScale);
  const previewRef = (0, import_react83.useRef)(null);
  const [renderError, setRenderError] = (0, import_react83.useState)(null);
  const { onCopy, copyStatus, resetCopyStatus } = useCopyStatus();
  (0, import_react83.useEffect)(() => {
    resetCopyStatus();
  }, [
    projectName,
    exportWithBackground,
    exportDarkMode,
    exportScale,
    embedScene,
    resetCopyStatus
  ]);
  const { exportedElements, exportingFrame } = prepareElementsForExport(
    elementsSnapshot,
    appStateSnapshot,
    exportSelectionOnly
  );
  (0, import_react83.useEffect)(() => {
    const previewNode = previewRef.current;
    if (!previewNode) {
      return;
    }
    const maxWidth = previewNode.offsetWidth;
    const maxHeight = previewNode.offsetHeight;
    if (!maxWidth) {
      return;
    }
    exportToCanvas2({
      elements: exportedElements,
      appState: {
        ...appStateSnapshot,
        name: projectName,
        exportBackground: exportWithBackground,
        exportWithDarkMode: exportDarkMode,
        exportScale,
        exportEmbedScene: embedScene
      },
      files,
      exportPadding: DEFAULT_EXPORT_PADDING,
      maxWidthOrHeight: Math.max(maxWidth, maxHeight),
      exportingFrame
    }).then((canvas) => {
      setRenderError(null);
      return canvasToBlob(canvas).then(() => {
        previewNode.replaceChildren(canvas);
      }).catch((e3) => {
        if (e3.name === "CANVAS_POSSIBLY_TOO_BIG") {
          throw new Error(t("canvasError.canvasTooBig"));
        }
        throw e3;
      });
    }).catch((error) => {
      console.error(error);
      setRenderError(error);
    });
  }, [
    appStateSnapshot,
    files,
    exportedElements,
    exportingFrame,
    projectName,
    exportWithBackground,
    exportDarkMode,
    exportScale,
    embedScene
  ]);
  return /* @__PURE__ */ (0, import_jsx_runtime82.jsxs)("div", { className: "ImageExportModal", children: [
    /* @__PURE__ */ (0, import_jsx_runtime82.jsx)("h3", { children: t("imageExportDialog.header") }),
    /* @__PURE__ */ (0, import_jsx_runtime82.jsxs)("div", { className: "ImageExportModal__preview", children: [
      /* @__PURE__ */ (0, import_jsx_runtime82.jsx)("div", { className: "ImageExportModal__preview__canvas", ref: previewRef, children: renderError && /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(ErrorCanvasPreview, {}) }),
      /* @__PURE__ */ (0, import_jsx_runtime82.jsx)("div", { className: "ImageExportModal__preview__filename", children: !e && /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(
        "input",
        {
          type: "text",
          className: "TextInput",
          value: projectName,
          style: { width: "30ch" },
          onChange: (event) => {
            setProjectName(event.target.value);
            actionManager.executeAction(
              actionChangeProjectName,
              "ui",
              event.target.value
            );
          }
        }
      ) })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime82.jsxs)("div", { className: "ImageExportModal__settings", children: [
      /* @__PURE__ */ (0, import_jsx_runtime82.jsx)("h3", { children: t("imageExportDialog.header") }),
      hasSelection && /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(
        ExportSetting,
        {
          label: t("imageExportDialog.label.onlySelected"),
          name: "exportOnlySelected",
          children: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(
            Switch,
            {
              name: "exportOnlySelected",
              checked: exportSelectionOnly,
              onChange: (checked) => {
                setExportSelectionOnly(checked);
              }
            }
          )
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(
        ExportSetting,
        {
          label: t("imageExportDialog.label.withBackground"),
          name: "exportBackgroundSwitch",
          children: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(
            Switch,
            {
              name: "exportBackgroundSwitch",
              checked: exportWithBackground,
              onChange: (checked) => {
                setExportWithBackground(checked);
                actionManager.executeAction(
                  actionChangeExportBackground,
                  "ui",
                  checked
                );
              }
            }
          )
        }
      ),
      supportsContextFilters && /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(
        ExportSetting,
        {
          label: t("imageExportDialog.label.darkMode"),
          name: "exportDarkModeSwitch",
          children: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(
            Switch,
            {
              name: "exportDarkModeSwitch",
              checked: exportDarkMode,
              onChange: (checked) => {
                setExportDarkMode(checked);
                actionManager.executeAction(
                  actionExportWithDarkMode,
                  "ui",
                  checked
                );
              }
            }
          )
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(
        ExportSetting,
        {
          label: t("imageExportDialog.label.embedScene"),
          tooltip: t("imageExportDialog.tooltip.embedScene"),
          name: "exportEmbedSwitch",
          children: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(
            Switch,
            {
              name: "exportEmbedSwitch",
              checked: embedScene,
              onChange: (checked) => {
                setEmbedScene(checked);
                actionManager.executeAction(
                  actionChangeExportEmbedScene,
                  "ui",
                  checked
                );
              }
            }
          )
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(
        ExportSetting,
        {
          label: t("imageExportDialog.label.scale"),
          name: "exportScale",
          children: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(
            RadioGroup,
            {
              name: "exportScale",
              value: exportScale,
              onChange: (scale) => {
                setExportScale(scale);
                actionManager.executeAction(actionChangeExportScale, "ui", scale);
              },
              choices: EXPORT_SCALES.map((scale) => ({
                value: scale,
                label: `${scale}\xD7`
              }))
            }
          )
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime82.jsxs)("div", { className: "ImageExportModal__settings__buttons", children: [
        /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(
          FilledButton,
          {
            className: "ImageExportModal__settings__buttons__button",
            label: t("imageExportDialog.title.exportToPng"),
            onClick: () => onExportImage(EXPORT_IMAGE_TYPES.png, exportedElements, {
              exportingFrame
            }),
            icon: downloadIcon,
            children: t("imageExportDialog.button.exportToPng")
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(
          FilledButton,
          {
            className: "ImageExportModal__settings__buttons__button",
            label: t("imageExportDialog.title.exportToSvg"),
            onClick: () => onExportImage(EXPORT_IMAGE_TYPES.svg, exportedElements, {
              exportingFrame
            }),
            icon: downloadIcon,
            children: t("imageExportDialog.button.exportToSvg")
          }
        ),
        (probablySupportsClipboardBlob || isFirefox) && /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(
          FilledButton,
          {
            className: "ImageExportModal__settings__buttons__button",
            label: t("imageExportDialog.title.copyPngToClipboard"),
            status: copyStatus,
            onClick: async () => {
              await onExportImage(
                EXPORT_IMAGE_TYPES.clipboard,
                exportedElements,
                {
                  exportingFrame
                }
              );
              onCopy();
            },
            icon: copyIcon,
            children: t("imageExportDialog.button.copyPngToClipboard")
          }
        )
      ] })
    ] })
  ] });
};
var ExportSetting = ({
  label,
  children,
  tooltip,
  name
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime82.jsxs)("div", { className: "ImageExportModal__settings__setting", title: label, children: [
    /* @__PURE__ */ (0, import_jsx_runtime82.jsxs)(
      "label",
      {
        htmlFor: name,
        className: "ImageExportModal__settings__setting__label",
        children: [
          label,
          tooltip && /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(Tooltip, { label: tooltip, long: true, children: helpIcon })
        ]
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime82.jsx)("div", { className: "ImageExportModal__settings__setting__content", children })
  ] });
};
var ImageExportDialog = ({
  elements,
  appState,
  files,
  actionManager,
  onExportImage,
  onCloseRequest,
  name
}) => {
  const [{ appStateSnapshot, elementsSnapshot }] = (0, import_react83.useState)(() => {
    return {
      appStateSnapshot: cloneJSON(appState),
      elementsSnapshot: cloneJSON(elements)
    };
  });
  return /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(Dialog, { onCloseRequest, size: "wide", title: false, children: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(
    ImageExportModal,
    {
      elementsSnapshot,
      appStateSnapshot,
      files,
      actionManager,
      onExportImage,
      name
    }
  ) });
};

// components/FixedSideContainer.tsx
init_define_import_meta_env();
var import_jsx_runtime83 = __toESM(require_jsx_runtime(), 1);
var FixedSideContainer = ({
  children,
  side,
  className
}) => /* @__PURE__ */ (0, import_jsx_runtime83.jsx)(
  "div",
  {
    className: clsx_m_default(
      "FixedSideContainer",
      `FixedSideContainer_side_${side}`,
      className
    ),
    children
  }
);

// components/HintViewer.tsx
init_define_import_meta_env();

// element/flowchart.ts
init_define_import_meta_env();
var VERTICAL_OFFSET = 100;
var HORIZONTAL_OFFSET = 100;
var getLinkDirectionFromKey = (key) => {
  switch (key) {
    case KEYS.ARROW_UP:
      return "up";
    case KEYS.ARROW_DOWN:
      return "down";
    case KEYS.ARROW_RIGHT:
      return "right";
    case KEYS.ARROW_LEFT:
      return "left";
    default:
      return "right";
  }
};
var getNodeRelatives = (type, node, elementsMap, direction) => {
  const items = [...elementsMap.values()].reduce(
    (acc, el) => {
      let oppositeBinding;
      if (isElbowArrow(el) && // we want check existence of the opposite binding, in the direction
      // we're interested in
      (oppositeBinding = el[type === "predecessors" ? "startBinding" : "endBinding"]) && // similarly, we need to filter only arrows bound to target node
      el[type === "predecessors" ? "endBinding" : "startBinding"]?.elementId === node.id) {
        const relative = elementsMap.get(oppositeBinding.elementId);
        if (!relative) {
          return acc;
        }
        invariant(
          isBindableElement(relative),
          "not an ExcalidrawBindableElement"
        );
        const edgePoint = type === "predecessors" ? el.points[el.points.length - 1] : [0, 0];
        const heading = headingForPointFromElement(node, aabbForElement(node), [
          edgePoint[0] + el.x,
          edgePoint[1] + el.y
        ]);
        acc.push({
          relative,
          heading
        });
      }
      return acc;
    },
    []
  );
  switch (direction) {
    case "up":
      return items.filter((item) => compareHeading(item.heading, HEADING_UP)).map((item) => item.relative);
    case "down":
      return items.filter((item) => compareHeading(item.heading, HEADING_DOWN)).map((item) => item.relative);
    case "right":
      return items.filter((item) => compareHeading(item.heading, HEADING_RIGHT)).map((item) => item.relative);
    case "left":
      return items.filter((item) => compareHeading(item.heading, HEADING_LEFT)).map((item) => item.relative);
  }
};
var getSuccessors = (node, elementsMap, direction) => {
  return getNodeRelatives("successors", node, elementsMap, direction);
};
var getPredecessors = (node, elementsMap, direction) => {
  return getNodeRelatives("predecessors", node, elementsMap, direction);
};
var getOffsets = (element, linkedNodes, direction) => {
  const _HORIZONTAL_OFFSET = HORIZONTAL_OFFSET + element.width;
  if (direction === "up" || direction === "down") {
    const _VERTICAL_OFFSET2 = VERTICAL_OFFSET + element.height;
    const minX = element.x;
    const maxX = element.x + element.width;
    if (linkedNodes.every(
      (linkedNode) => linkedNode.x + linkedNode.width < minX || linkedNode.x > maxX
    )) {
      return {
        x: 0,
        y: _VERTICAL_OFFSET2 * (direction === "up" ? -1 : 1)
      };
    }
  } else if (direction === "right" || direction === "left") {
    const minY = element.y;
    const maxY = element.y + element.height;
    if (linkedNodes.every(
      (linkedNode) => linkedNode.y + linkedNode.height < minY || linkedNode.y > maxY
    )) {
      return {
        x: (HORIZONTAL_OFFSET + element.width) * (direction === "left" ? -1 : 1),
        y: 0
      };
    }
  }
  if (direction === "up" || direction === "down") {
    const _VERTICAL_OFFSET2 = VERTICAL_OFFSET + element.height;
    const y4 = linkedNodes.length === 0 ? _VERTICAL_OFFSET2 : _VERTICAL_OFFSET2;
    const x4 = linkedNodes.length === 0 ? 0 : (linkedNodes.length + 1) % 2 === 0 ? (linkedNodes.length + 1) / 2 * _HORIZONTAL_OFFSET : linkedNodes.length / 2 * _HORIZONTAL_OFFSET * -1;
    if (direction === "up") {
      return {
        x: x4,
        y: y4 * -1
      };
    }
    return {
      x: x4,
      y: y4
    };
  }
  const _VERTICAL_OFFSET = VERTICAL_OFFSET + element.height;
  const x3 = (linkedNodes.length === 0 ? HORIZONTAL_OFFSET : HORIZONTAL_OFFSET) + element.width;
  const y3 = linkedNodes.length === 0 ? 0 : (linkedNodes.length + 1) % 2 === 0 ? (linkedNodes.length + 1) / 2 * _VERTICAL_OFFSET : linkedNodes.length / 2 * _VERTICAL_OFFSET * -1;
  if (direction === "left") {
    return {
      x: x3 * -1,
      y: y3
    };
  }
  return {
    x: x3,
    y: y3
  };
};
var addNewNode = (element, elementsMap, appState, direction) => {
  const successors = getSuccessors(element, elementsMap, direction);
  const predeccessors = getPredecessors(element, elementsMap, direction);
  const offsets = getOffsets(
    element,
    [...successors, ...predeccessors],
    direction
  );
  const nextNode = newElement({
    type: element.type,
    x: element.x + offsets.x,
    y: element.y + offsets.y,
    // TODO: extract this to a util
    width: element.width,
    height: element.height,
    roundness: element.roundness,
    roughness: element.roughness,
    backgroundColor: element.backgroundColor,
    strokeColor: element.strokeColor,
    strokeWidth: element.strokeWidth
  });
  invariant(
    isFlowchartNodeElement(nextNode),
    "not an ExcalidrawFlowchartNodeElement"
  );
  const bindingArrow = createBindingArrow(
    element,
    nextNode,
    elementsMap,
    direction,
    appState
  );
  return {
    nextNode,
    bindingArrow
  };
};
var addNewNodes = (startNode, elementsMap, appState, direction, numberOfNodes) => {
  const newNodes = [];
  for (let i3 = 0; i3 < numberOfNodes; i3++) {
    let nextX;
    let nextY;
    if (direction === "left" || direction === "right") {
      const totalHeight = VERTICAL_OFFSET * (numberOfNodes - 1) + numberOfNodes * startNode.height;
      const startY = startNode.y + startNode.height / 2 - totalHeight / 2;
      let offsetX = HORIZONTAL_OFFSET + startNode.width;
      if (direction === "left") {
        offsetX *= -1;
      }
      nextX = startNode.x + offsetX;
      const offsetY = (VERTICAL_OFFSET + startNode.height) * i3;
      nextY = startY + offsetY;
    } else {
      const totalWidth = HORIZONTAL_OFFSET * (numberOfNodes - 1) + numberOfNodes * startNode.width;
      const startX = startNode.x + startNode.width / 2 - totalWidth / 2;
      let offsetY = VERTICAL_OFFSET + startNode.height;
      if (direction === "up") {
        offsetY *= -1;
      }
      nextY = startNode.y + offsetY;
      const offsetX = (HORIZONTAL_OFFSET + startNode.width) * i3;
      nextX = startX + offsetX;
    }
    const nextNode = newElement({
      type: startNode.type,
      x: nextX,
      y: nextY,
      // TODO: extract this to a util
      width: startNode.width,
      height: startNode.height,
      roundness: startNode.roundness,
      roughness: startNode.roughness,
      backgroundColor: startNode.backgroundColor,
      strokeColor: startNode.strokeColor,
      strokeWidth: startNode.strokeWidth
    });
    invariant(
      isFlowchartNodeElement(nextNode),
      "not an ExcalidrawFlowchartNodeElement"
    );
    const bindingArrow = createBindingArrow(
      startNode,
      nextNode,
      elementsMap,
      direction,
      appState
    );
    newNodes.push(nextNode);
    newNodes.push(bindingArrow);
  }
  return newNodes;
};
var createBindingArrow = (startBindingElement, endBindingElement, elementsMap, direction, appState) => {
  let startX;
  let startY;
  const PADDING = 6;
  switch (direction) {
    case "up": {
      startX = startBindingElement.x + startBindingElement.width / 2;
      startY = startBindingElement.y - PADDING;
      break;
    }
    case "down": {
      startX = startBindingElement.x + startBindingElement.width / 2;
      startY = startBindingElement.y + startBindingElement.height + PADDING;
      break;
    }
    case "right": {
      startX = startBindingElement.x + startBindingElement.width + PADDING;
      startY = startBindingElement.y + startBindingElement.height / 2;
      break;
    }
    case "left": {
      startX = startBindingElement.x - PADDING;
      startY = startBindingElement.y + startBindingElement.height / 2;
      break;
    }
  }
  let endX;
  let endY;
  switch (direction) {
    case "up": {
      endX = endBindingElement.x + endBindingElement.width / 2 - startX;
      endY = endBindingElement.y + endBindingElement.height - startY + PADDING;
      break;
    }
    case "down": {
      endX = endBindingElement.x + endBindingElement.width / 2 - startX;
      endY = endBindingElement.y - startY - PADDING;
      break;
    }
    case "right": {
      endX = endBindingElement.x - startX - PADDING;
      endY = endBindingElement.y - startY + endBindingElement.height / 2;
      break;
    }
    case "left": {
      endX = endBindingElement.x + endBindingElement.width - startX + PADDING;
      endY = endBindingElement.y - startY + endBindingElement.height / 2;
      break;
    }
  }
  const bindingArrow = newArrowElement({
    type: "arrow",
    x: startX,
    y: startY,
    startArrowhead: appState.currentItemStartArrowhead,
    endArrowhead: appState.currentItemEndArrowhead,
    strokeColor: appState.currentItemStrokeColor,
    strokeStyle: appState.currentItemStrokeStyle,
    strokeWidth: appState.currentItemStrokeWidth,
    points: [pointFrom(0, 0), pointFrom(endX, endY)],
    elbowed: true
  });
  bindLinearElement(
    bindingArrow,
    startBindingElement,
    "start",
    elementsMap
  );
  bindLinearElement(
    bindingArrow,
    endBindingElement,
    "end",
    elementsMap
  );
  const changedElements = /* @__PURE__ */ new Map();
  changedElements.set(
    startBindingElement.id,
    startBindingElement
  );
  changedElements.set(
    endBindingElement.id,
    endBindingElement
  );
  changedElements.set(
    bindingArrow.id,
    bindingArrow
  );
  LinearElementEditor.movePoints(
    bindingArrow,
    [
      {
        index: 1,
        point: bindingArrow.points[1]
      }
    ],
    elementsMap,
    void 0,
    {
      changedElements
    }
  );
  return bindingArrow;
};
var FlowChartNavigator = class {
  isExploring = false;
  // nodes that are ONE link away (successor and predecessor both included)
  sameLevelNodes = [];
  sameLevelIndex = 0;
  // set it to the opposite of the defalut creation direction
  direction = null;
  // for speedier navigation
  visitedNodes = /* @__PURE__ */ new Set();
  clear() {
    this.isExploring = false;
    this.sameLevelNodes = [];
    this.sameLevelIndex = 0;
    this.direction = null;
    this.visitedNodes.clear();
  }
  exploreByDirection(element, elementsMap, direction) {
    if (!isBindableElement(element)) {
      return null;
    }
    if (direction !== this.direction) {
      this.clear();
    }
    if (!this.visitedNodes.has(element.id)) {
      this.visitedNodes.add(element.id);
    }
    if (this.isExploring && direction === this.direction && this.sameLevelNodes.length > 1) {
      this.sameLevelIndex = (this.sameLevelIndex + 1) % this.sameLevelNodes.length;
      return this.sameLevelNodes[this.sameLevelIndex].id;
    }
    const nodes = [
      ...getSuccessors(element, elementsMap, direction),
      ...getPredecessors(element, elementsMap, direction)
    ];
    if (nodes.length > 0) {
      this.sameLevelIndex = 0;
      this.isExploring = true;
      this.sameLevelNodes = nodes;
      this.direction = direction;
      this.visitedNodes.add(nodes[0].id);
      return nodes[0].id;
    }
    if (direction === this.direction || !this.isExploring) {
      if (!this.isExploring) {
        this.visitedNodes.add(element.id);
      }
      const otherDirections = [
        "up",
        "right",
        "down",
        "left"
      ].filter((dir) => dir !== direction);
      const otherLinkedNodes = otherDirections.map((dir) => [
        ...getSuccessors(element, elementsMap, dir),
        ...getPredecessors(element, elementsMap, dir)
      ]).flat().filter((linkedNode) => !this.visitedNodes.has(linkedNode.id));
      for (const linkedNode of otherLinkedNodes) {
        if (!this.visitedNodes.has(linkedNode.id)) {
          this.visitedNodes.add(linkedNode.id);
          this.isExploring = true;
          this.direction = direction;
          return linkedNode.id;
        }
      }
    }
    return null;
  }
};
var FlowChartCreator = class {
  isCreatingChart = false;
  numberOfNodes = 0;
  direction = "right";
  pendingNodes = null;
  createNodes(startNode, elementsMap, appState, direction) {
    if (direction !== this.direction) {
      const { nextNode, bindingArrow } = addNewNode(
        startNode,
        elementsMap,
        appState,
        direction
      );
      this.numberOfNodes = 1;
      this.isCreatingChart = true;
      this.direction = direction;
      this.pendingNodes = [nextNode, bindingArrow];
    } else {
      this.numberOfNodes += 1;
      const newNodes = addNewNodes(
        startNode,
        elementsMap,
        appState,
        direction,
        this.numberOfNodes
      );
      this.isCreatingChart = true;
      this.direction = direction;
      this.pendingNodes = newNodes;
    }
    if (startNode.frameId) {
      const frame = elementsMap.get(startNode.frameId);
      invariant(
        frame && isFrameElement(frame),
        "not an ExcalidrawFrameElement"
      );
      if (frame && this.pendingNodes.every(
        (node) => elementsAreInFrameBounds([node], frame, elementsMap) || elementOverlapsWithFrame(node, frame, elementsMap)
      )) {
        this.pendingNodes = this.pendingNodes.map(
          (node) => mutateElement(
            node,
            {
              frameId: startNode.frameId
            },
            false
          )
        );
      }
    }
  }
  clear() {
    this.isCreatingChart = false;
    this.pendingNodes = null;
    this.direction = null;
    this.numberOfNodes = 0;
  }
};
var isNodeInFlowchart = (element, elementsMap) => {
  for (const [, el] of elementsMap) {
    if (el.type === "arrow" && (el.startBinding?.elementId === element.id || el.endBinding?.elementId === element.id)) {
      return true;
    }
  }
  return false;
};

// components/HintViewer.tsx
var import_jsx_runtime84 = __toESM(require_jsx_runtime(), 1);
var getHints = ({
  appState,
  isMobile,
  device,
  app
}) => {
  const { activeTool, isResizing, isRotating, lastPointerDownWith } = appState;
  const multiMode = appState.multiElement !== null;
  if (appState.openSidebar?.name === DEFAULT_SIDEBAR.name && appState.openSidebar.tab === CANVAS_SEARCH_TAB && appState.searchMatches?.length) {
    return t("hints.dismissSearch");
  }
  if (appState.openSidebar && !device.editor.canFitSidebar) {
    return null;
  }
  if (isEraserActive(appState)) {
    return t("hints.eraserRevert");
  }
  if (activeTool.type === "arrow" || activeTool.type === "line") {
    if (multiMode) {
      return t("hints.linearElementMulti");
    }
    if (activeTool.type === "arrow") {
      return t("hints.arrowTool", { arrowShortcut: getShortcutKey("A") });
    }
    return t("hints.linearElement");
  }
  if (activeTool.type === "freedraw") {
    return t("hints.freeDraw");
  }
  if (activeTool.type === "text") {
    return t("hints.text");
  }
  if (activeTool.type === "embeddable") {
    return t("hints.embeddable");
  }
  if (appState.activeTool.type === "image" && appState.pendingImageElementId) {
    return t("hints.placeImage");
  }
  const selectedElements = app.scene.getSelectedElements(appState);
  if (isResizing && lastPointerDownWith === "mouse" && selectedElements.length === 1) {
    const targetElement = selectedElements[0];
    if (isLinearElement(targetElement) && targetElement.points.length === 2) {
      return t("hints.lockAngle");
    }
    return isImageElement(targetElement) ? t("hints.resizeImage") : t("hints.resize");
  }
  if (isRotating && lastPointerDownWith === "mouse") {
    return t("hints.rotate");
  }
  if (selectedElements.length === 1 && isTextElement(selectedElements[0])) {
    return t("hints.text_selected");
  }
  if (appState.editingTextElement) {
    return t("hints.text_editing");
  }
  if (activeTool.type === "selection") {
    if (appState.selectionElement && !selectedElements.length && !appState.editingTextElement && !appState.editingLinearElement) {
      if (isGridModeEnabled(app) && appState.selectedElementsAreBeingDragged) {
        return t("hints.disableSnapping");
      }
    }
    if (selectedElements.length === 1) {
      if (isLinearElement(selectedElements[0])) {
        if (appState.editingLinearElement) {
          return appState.editingLinearElement.selectedPointsIndices ? t("hints.lineEditor_pointSelected") : t("hints.lineEditor_nothingSelected");
        }
        return t("hints.lineEditor_info");
      }
      if (!appState.newElement && !appState.selectedElementsAreBeingDragged && isTextBindableContainer(selectedElements[0])) {
        if (isFlowchartNodeElement(selectedElements[0])) {
          if (isNodeInFlowchart(
            selectedElements[0],
            app.scene.getNonDeletedElementsMap()
          )) {
            return [t("hints.bindTextToElement"), t("hints.createFlowchart")];
          }
          return [t("hints.bindTextToElement"), t("hints.createFlowchart")];
        }
        return t("hints.bindTextToElement");
      }
    }
  }
  return null;
};
var HintViewer = ({
  appState,
  isMobile,
  device,
  app
}) => {
  const hints = getHints({
    appState,
    isMobile,
    device,
    app
  });
  if (!hints) {
    return null;
  }
  const hint = Array.isArray(hints) ? hints.map((hint2) => {
    return getShortcutKey(hint2).replace(/\. ?$/, "");
  }).join(". ") : getShortcutKey(hints);
  return /* @__PURE__ */ (0, import_jsx_runtime84.jsx)("div", { className: "HintViewer", children: /* @__PURE__ */ (0, import_jsx_runtime84.jsx)("span", { children: hint }) });
};

// components/LockButton.tsx
init_define_import_meta_env();
var import_jsx_runtime85 = __toESM(require_jsx_runtime(), 1);
var DEFAULT_SIZE = "medium";
var ICONS2 = {
  CHECKED: LockedIcon,
  UNCHECKED: UnlockedIcon
};
var LockButton = (props) => {
  return /* @__PURE__ */ (0, import_jsx_runtime85.jsxs)(
    "label",
    {
      className: clsx_m_default(
        "ToolIcon ToolIcon__lock",
        `ToolIcon_size_${DEFAULT_SIZE}`,
        {
          "is-mobile": props.isMobile
        }
      ),
      title: `${props.title} \u2014 Q`,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime85.jsx)(
          "input",
          {
            className: "ToolIcon_type_checkbox",
            type: "checkbox",
            name: props.name,
            onChange: props.onChange,
            checked: props.checked,
            "aria-label": props.title,
            "data-testid": "toolbar-lock"
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime85.jsx)("div", { className: "ToolIcon__icon", children: props.checked ? ICONS2.CHECKED : ICONS2.UNCHECKED })
      ]
    }
  );
};

// components/MobileMenu.tsx
init_define_import_meta_env();

// components/Section.tsx
init_define_import_meta_env();
var import_jsx_runtime86 = __toESM(require_jsx_runtime(), 1);
var Section = ({ heading, children, ...props }) => {
  const { id } = useExcalidrawContainer();
  const header = /* @__PURE__ */ (0, import_jsx_runtime86.jsx)("h2", { className: "visually-hidden", id: `${id}-${heading}-title`, children: t(`headings.${heading}`) });
  return /* @__PURE__ */ (0, import_jsx_runtime86.jsx)("section", { ...props, "aria-labelledby": `${id}-${heading}-title`, style: { marginTop: 80 }, children: typeof children === "function" ? children(header) : /* @__PURE__ */ (0, import_jsx_runtime86.jsxs)(import_jsx_runtime86.Fragment, { children: [
    header,
    children
  ] }) });
};

// scene/scrollbars.ts
init_define_import_meta_env();
var SCROLLBAR_MARGIN = 4;
var SCROLLBAR_WIDTH = 6;
var SCROLLBAR_COLOR = "rgba(0,0,0,0.3)";
var getScrollBars = (elements, viewportWidth, viewportHeight, appState) => {
  if (!elements.length) {
    return {
      horizontal: null,
      vertical: null
    };
  }
  const [elementsMinX, elementsMinY, elementsMaxX, elementsMaxY] = getCommonBounds(elements);
  const viewportWidthWithZoom = viewportWidth / appState.zoom.value;
  const viewportHeightWithZoom = viewportHeight / appState.zoom.value;
  const viewportWidthDiff = viewportWidth - viewportWidthWithZoom;
  const viewportHeightDiff = viewportHeight - viewportHeightWithZoom;
  const safeArea = {
    top: parseInt(getGlobalCSSVariable("sat")) || 0,
    bottom: parseInt(getGlobalCSSVariable("sab")) || 0,
    left: parseInt(getGlobalCSSVariable("sal")) || 0,
    right: parseInt(getGlobalCSSVariable("sar")) || 0
  };
  const isRTL = getLanguage().rtl;
  const viewportMinX = -appState.scrollX + viewportWidthDiff / 2 + safeArea.left;
  const viewportMinY = -appState.scrollY + viewportHeightDiff / 2 + safeArea.top;
  const viewportMaxX = viewportMinX + viewportWidthWithZoom - safeArea.right;
  const viewportMaxY = viewportMinY + viewportHeightWithZoom - safeArea.bottom;
  const sceneMinX = Math.min(elementsMinX, viewportMinX);
  const sceneMinY = Math.min(elementsMinY, viewportMinY);
  const sceneMaxX = Math.max(elementsMaxX, viewportMaxX);
  const sceneMaxY = Math.max(elementsMaxY, viewportMaxY);
  return {
    horizontal: viewportMinX === sceneMinX && viewportMaxX === sceneMaxX ? null : {
      x: Math.max(safeArea.left, SCROLLBAR_MARGIN) + (viewportMinX - sceneMinX) / (sceneMaxX - sceneMinX) * viewportWidth,
      y: viewportHeight - SCROLLBAR_WIDTH - Math.max(SCROLLBAR_MARGIN, safeArea.bottom),
      width: (viewportMaxX - viewportMinX) / (sceneMaxX - sceneMinX) * viewportWidth - Math.max(SCROLLBAR_MARGIN * 2, safeArea.left + safeArea.right),
      height: SCROLLBAR_WIDTH
    },
    vertical: viewportMinY === sceneMinY && viewportMaxY === sceneMaxY ? null : {
      x: isRTL ? Math.max(safeArea.left, SCROLLBAR_MARGIN) : viewportWidth - SCROLLBAR_WIDTH - Math.max(safeArea.right, SCROLLBAR_MARGIN),
      y: (viewportMinY - sceneMinY) / (sceneMaxY - sceneMinY) * viewportHeight + Math.max(safeArea.top, SCROLLBAR_MARGIN),
      width: SCROLLBAR_WIDTH,
      height: (viewportMaxY - viewportMinY) / (sceneMaxY - sceneMinY) * viewportHeight - Math.max(SCROLLBAR_MARGIN * 2, safeArea.top + safeArea.bottom)
    }
  };
};
var isOverScrollBars = (scrollBars, x3, y3) => {
  const [isOverHorizontal, isOverVertical] = [
    scrollBars.horizontal,
    scrollBars.vertical
  ].map((scrollBar) => {
    return scrollBar != null && scrollBar.x <= x3 && x3 <= scrollBar.x + scrollBar.width && scrollBar.y <= y3 && y3 <= scrollBar.y + scrollBar.height;
  });
  const isOverEither = isOverHorizontal || isOverVertical;
  return { isOverEither, isOverHorizontal, isOverVertical };
};

// components/PenModeButton.tsx
init_define_import_meta_env();
var import_jsx_runtime87 = __toESM(require_jsx_runtime(), 1);
var DEFAULT_SIZE2 = "medium";
var PenModeButton = (props) => {
  if (!props.penDetected) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime87.jsxs)(
    "label",
    {
      className: clsx_m_default(
        "ToolIcon ToolIcon__penMode",
        `ToolIcon_size_${DEFAULT_SIZE2}`,
        {
          "is-mobile": props.isMobile
        }
      ),
      title: `${props.title}`,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(
          "input",
          {
            className: "ToolIcon_type_checkbox",
            type: "checkbox",
            name: props.name,
            onChange: props.onChange,
            checked: props.checked,
            "aria-label": props.title
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime87.jsx)("div", { className: "ToolIcon__icon", children: PenModeIcon })
      ]
    }
  );
};

// components/HandButton.tsx
init_define_import_meta_env();
var import_jsx_runtime88 = __toESM(require_jsx_runtime(), 1);
var HandButton = (props) => {
  return /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(
    ToolButton,
    {
      className: clsx_m_default("Shape", { fillable: false }),
      type: "radio",
      icon: handIcon,
      name: "editor-current-shape",
      checked: props.checked,
      title: `${props.title} \u2014 H`,
      keyBindingLabel: !props.isMobile ? KEYS.H.toLocaleUpperCase() : void 0,
      "aria-label": `${props.title} \u2014 H`,
      "aria-keyshortcuts": KEYS.H,
      "data-testid": `toolbar-hand`,
      onChange: () => props.onChange?.()
    }
  );
};

// components/MobileMenu.tsx
var import_jsx_runtime89 = __toESM(require_jsx_runtime(), 1);
var MobileMenu = ({
  appState,
  elements,
  actionManager,
  setAppState,
  onLockToggle,
  onHandToolToggle,
  onPenModeToggle,
  renderTopRightUI,
  renderCustomStats,
  renderSidebars,
  device,
  renderWelcomeScreen,
  UIOptions,
  app
}) => {
  const {
    WelcomeScreenCenterTunnel,
    MainMenuTunnel,
    DefaultSidebarTriggerTunnel
  } = useTunnels();
  const renderToolbar = () => {
    return /* @__PURE__ */ (0, import_jsx_runtime89.jsxs)(FixedSideContainer, { side: "top", className: "App-top-bar", children: [
      renderWelcomeScreen && /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(WelcomeScreenCenterTunnel.Out, {}),
      /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(Section, { heading: "shapes", children: (heading) => /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(Stack_default.Col, { gap: 4, align: "center", children: /* @__PURE__ */ (0, import_jsx_runtime89.jsxs)(Stack_default.Row, { gap: 1, className: "App-toolbar-container", children: [
        /* @__PURE__ */ (0, import_jsx_runtime89.jsxs)(Island, { padding: 1, className: "App-toolbar App-toolbar--mobile", children: [
          heading,
          /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(Stack_default.Row, { gap: 1, children: /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(
            ShapesSwitcher,
            {
              appState,
              activeTool: appState.activeTool,
              UIOptions,
              app
            }
          ) })
        ] }),
        renderTopRightUI && renderTopRightUI(true, appState),
        /* @__PURE__ */ (0, import_jsx_runtime89.jsxs)("div", { className: "mobile-misc-tools-container", children: [
          !appState.viewModeEnabled && /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(DefaultSidebarTriggerTunnel.Out, {}),
          /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(
            PenModeButton,
            {
              checked: appState.penMode,
              onChange: () => onPenModeToggle(null),
              title: t("toolBar.penMode"),
              isMobile: true,
              penDetected: appState.penDetected
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(
            LockButton,
            {
              checked: appState.activeTool.locked,
              onChange: onLockToggle,
              title: t("toolBar.lock"),
              isMobile: true
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(
            HandButton,
            {
              checked: isHandToolActive(appState),
              onChange: () => onHandToolToggle(),
              title: t("toolBar.hand"),
              isMobile: true
            }
          )
        ] })
      ] }) }) }),
      /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(
        HintViewer,
        {
          appState,
          isMobile: true,
          device,
          app
        }
      )
    ] });
  };
  const renderAppToolbar = () => {
    if (appState.viewModeEnabled) {
      return /* @__PURE__ */ (0, import_jsx_runtime89.jsx)("div", { className: "App-toolbar-content", children: /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(MainMenuTunnel.Out, {}) });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime89.jsxs)("div", { className: "App-toolbar-content", children: [
      /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(MainMenuTunnel.Out, {}),
      actionManager.renderAction("toggleEditMenu"),
      actionManager.renderAction("undo"),
      actionManager.renderAction("redo"),
      actionManager.renderAction(
        appState.multiElement ? "finalize" : "duplicateSelection"
      ),
      actionManager.renderAction("deleteSelectedElements")
    ] });
  };
  return /* @__PURE__ */ (0, import_jsx_runtime89.jsxs)(import_jsx_runtime89.Fragment, { children: [
    renderSidebars(),
    !appState.viewModeEnabled && renderToolbar(),
    /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(
      "div",
      {
        className: "App-bottom-bar",
        style: {
          marginBottom: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2,
          marginLeft: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2,
          marginRight: SCROLLBAR_WIDTH + SCROLLBAR_MARGIN * 2
        },
        children: /* @__PURE__ */ (0, import_jsx_runtime89.jsxs)(Island, { padding: 0, children: [
          appState.openMenu === "shape" && !appState.viewModeEnabled && showSelectedShapeActions(appState, elements) ? /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(Section, { className: "App-mobile-menu", heading: "selectedShapeActions", children: /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(
            SelectedShapeActions,
            {
              appState,
              elementsMap: app.scene.getNonDeletedElementsMap(),
              renderAction: actionManager.renderAction
            }
          ) }) : null,
          /* @__PURE__ */ (0, import_jsx_runtime89.jsxs)("footer", { className: "App-toolbar", children: [
            renderAppToolbar(),
            appState.scrolledOutside && !appState.openMenu && !appState.openSidebar && /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(
              "button",
              {
                type: "button",
                className: "scroll-back-to-content",
                onClick: () => {
                  setAppState((appState2) => ({
                    ...calculateScrollCenter(elements, appState2)
                  }));
                },
                children: t("buttons.scrollBackToContent")
              }
            )
          ] })
        ] })
      }
    )
  ] });
};

// components/PasteChartDialog.tsx
init_define_import_meta_env();
var import_react84 = __toESM(require_react(), 1);
var import_jsx_runtime90 = __toESM(require_jsx_runtime(), 1);
var ChartPreviewBtn = (props) => {
  const previewRef = (0, import_react84.useRef)(null);
  const [chartElements, setChartElements] = (0, import_react84.useState)(
    null
  );
  (0, import_react84.useLayoutEffect)(() => {
    if (!props.spreadsheet) {
      return;
    }
    const elements = renderSpreadsheet(
      props.chartType,
      props.spreadsheet,
      0,
      0
    );
    setChartElements(elements);
    let svg;
    const previewNode = previewRef.current;
    (async () => {
      svg = await exportToSvg(
        elements,
        {
          exportBackground: false,
          viewBackgroundColor: open_color_default.white
        },
        null
        // files
      );
      svg.querySelector(".style-fonts")?.remove();
      previewNode.replaceChildren();
      previewNode.appendChild(svg);
      if (props.selected) {
        previewNode.parentNode.focus();
      }
    })();
    return () => {
      previewNode.replaceChildren();
    };
  }, [props.spreadsheet, props.chartType, props.selected]);
  return /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
    "button",
    {
      type: "button",
      className: "ChartPreview",
      onClick: () => {
        if (chartElements) {
          props.onClick(props.chartType, chartElements);
        }
      },
      children: /* @__PURE__ */ (0, import_jsx_runtime90.jsx)("div", { ref: previewRef })
    }
  );
};
var PasteChartDialog = ({
  setAppState,
  appState,
  onClose
}) => {
  const { onInsertElements } = useApp();
  const handleClose = import_react84.default.useCallback(() => {
    if (onClose) {
      onClose();
    }
  }, [onClose]);
  const handleChartClick = (chartType, elements) => {
    onInsertElements(elements);
    trackEvent("paste", "chart", chartType);
    setAppState({
      currentChartType: chartType,
      pasteDialog: {
        shown: false,
        data: null
      }
    });
  };
  return /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
    Dialog,
    {
      size: "small",
      onCloseRequest: handleClose,
      title: t("labels.pasteCharts"),
      className: "PasteChartDialog",
      autofocus: false,
      children: /* @__PURE__ */ (0, import_jsx_runtime90.jsxs)("div", { className: "container", children: [
        /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
          ChartPreviewBtn,
          {
            chartType: "bar",
            spreadsheet: appState.pasteDialog.data,
            selected: appState.currentChartType === "bar",
            onClick: handleChartClick
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
          ChartPreviewBtn,
          {
            chartType: "line",
            spreadsheet: appState.pasteDialog.data,
            selected: appState.currentChartType === "line",
            onClick: handleChartClick
          }
        )
      ] })
    }
  );
};

// components/HelpDialog.tsx
init_define_import_meta_env();
var import_react85 = __toESM(require_react(), 1);
var import_jsx_runtime91 = __toESM(require_jsx_runtime(), 1);
var Section2 = (props) => /* @__PURE__ */ (0, import_jsx_runtime91.jsxs)(import_jsx_runtime91.Fragment, { children: [
  /* @__PURE__ */ (0, import_jsx_runtime91.jsx)("h3", { children: props.title }),
  /* @__PURE__ */ (0, import_jsx_runtime91.jsx)("div", { className: "HelpDialog__islands-container", children: props.children })
] });
var ShortcutIsland = (props) => /* @__PURE__ */ (0, import_jsx_runtime91.jsxs)("div", { className: `HelpDialog__island ${props.className}`, children: [
  /* @__PURE__ */ (0, import_jsx_runtime91.jsx)("h4", { className: "HelpDialog__island-title", children: props.caption }),
  /* @__PURE__ */ (0, import_jsx_runtime91.jsx)("div", { className: "HelpDialog__island-content", children: props.children })
] });
function* intersperse(as, delim) {
  let first = true;
  for (const x3 of as) {
    if (!first) {
      yield delim;
    }
    first = false;
    yield x3;
  }
}
var upperCaseSingleChars = (str) => {
  return str.replace(/\b[a-z]\b/, (c3) => c3.toUpperCase());
};
var Shortcut = ({
  label,
  shortcuts,
  isOr = true
}) => {
  const splitShortcutKeys = shortcuts.map((shortcut) => {
    const keys = shortcut.endsWith("++") ? [...shortcut.slice(0, -2).split("+"), "+"] : shortcut.split("+");
    return keys.map((key) => /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(ShortcutKey, { children: upperCaseSingleChars(key) }, key));
  });
  return /* @__PURE__ */ (0, import_jsx_runtime91.jsxs)("div", { className: "HelpDialog__shortcut", children: [
    /* @__PURE__ */ (0, import_jsx_runtime91.jsx)("div", { children: label }),
    /* @__PURE__ */ (0, import_jsx_runtime91.jsx)("div", { className: "HelpDialog__key-container", children: [...intersperse(splitShortcutKeys, isOr ? t("helpDialog.or") : null)] })
  ] });
};
var ShortcutKey = (props) => /* @__PURE__ */ (0, import_jsx_runtime91.jsx)("kbd", { className: "HelpDialog__key", ...props });
var HelpDialog = ({ onClose }) => {
  const handleClose = import_react85.default.useCallback(() => {
    if (onClose) {
      onClose();
    }
  }, [onClose]);
  return /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(import_jsx_runtime91.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
    Dialog,
    {
      onCloseRequest: handleClose,
      title: t("helpDialog.title"),
      className: "HelpDialog",
      children: /* @__PURE__ */ (0, import_jsx_runtime91.jsxs)(Section2, { title: t("helpDialog.shortcuts"), children: [
        /* @__PURE__ */ (0, import_jsx_runtime91.jsxs)(
          ShortcutIsland,
          {
            className: "HelpDialog__island--tools",
            caption: t("helpDialog.tools"),
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(Shortcut, { label: t("toolBar.hand"), shortcuts: [KEYS.H] }),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("toolBar.selection"),
                  shortcuts: [KEYS.V, KEYS["1"]]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("toolBar.rectangle"),
                  shortcuts: [KEYS.R, KEYS["2"]]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("toolBar.diamond"),
                  shortcuts: [KEYS.D, KEYS["3"]]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("toolBar.ellipse"),
                  shortcuts: [KEYS.O, KEYS["4"]]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("toolBar.arrow"),
                  shortcuts: [KEYS.A, KEYS["5"]]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("toolBar.line"),
                  shortcuts: [KEYS.L, KEYS["6"]]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("toolBar.freedraw"),
                  shortcuts: [KEYS.P, KEYS["7"]]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("toolBar.text"),
                  shortcuts: [KEYS.T, KEYS["8"]]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(Shortcut, { label: t("toolBar.image"), shortcuts: [KEYS["9"]] }),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("toolBar.eraser"),
                  shortcuts: [KEYS.E, KEYS["0"]]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(Shortcut, { label: t("toolBar.frame"), shortcuts: [KEYS.F] }),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(Shortcut, { label: t("toolBar.laser"), shortcuts: [KEYS.K] }),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.eyeDropper"),
                  shortcuts: [KEYS.I, "Shift+S", "Shift+G"]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("helpDialog.editLineArrowPoints"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Enter")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("helpDialog.editText"),
                  shortcuts: [getShortcutKey("Enter")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("helpDialog.textNewLine"),
                  shortcuts: [
                    getShortcutKey("Enter"),
                    getShortcutKey("Shift+Enter")
                  ]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("helpDialog.textFinish"),
                  shortcuts: [
                    getShortcutKey("Esc"),
                    getShortcutKey("CtrlOrCmd+Enter")
                  ]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("helpDialog.curvedArrow"),
                  shortcuts: [
                    "A",
                    t("helpDialog.click"),
                    t("helpDialog.click"),
                    t("helpDialog.click")
                  ],
                  isOr: false
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("helpDialog.curvedLine"),
                  shortcuts: [
                    "L",
                    t("helpDialog.click"),
                    t("helpDialog.click"),
                    t("helpDialog.click")
                  ],
                  isOr: false
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(Shortcut, { label: t("toolBar.lock"), shortcuts: [KEYS.Q] }),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("helpDialog.preventBinding"),
                  shortcuts: [getShortcutKey("CtrlOrCmd")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("toolBar.link"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+K")]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime91.jsxs)(
          ShortcutIsland,
          {
            className: "HelpDialog__island--view",
            caption: t("helpDialog.view"),
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("buttons.zoomIn"),
                  shortcuts: [getShortcutKey("CtrlOrCmd++")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("buttons.zoomOut"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+-")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("buttons.resetZoom"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+0")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("helpDialog.zoomToFit"),
                  shortcuts: ["Shift+1"]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("helpDialog.zoomToSelection"),
                  shortcuts: ["Shift+2"]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("helpDialog.movePageUpDown"),
                  shortcuts: ["PgUp/PgDn"]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("helpDialog.movePageLeftRight"),
                  shortcuts: ["Shift+PgUp/PgDn"]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("buttons.zenMode"),
                  shortcuts: [getShortcutKey("Alt+Z")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("buttons.objectsSnapMode"),
                  shortcuts: [getShortcutKey("Alt+S")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.toggleGrid"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+'")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.viewMode"),
                  shortcuts: [getShortcutKey("Alt+R")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.toggleTheme"),
                  shortcuts: [getShortcutKey("Alt+Shift+D")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("stats.fullTitle"),
                  shortcuts: [getShortcutKey("Alt+/")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("search.title"),
                  shortcuts: [getShortcutFromShortcutName("searchMenu")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("commandPalette.title"),
                  shortcuts: isFirefox ? [getShortcutFromShortcutName("commandPalette")] : [
                    getShortcutFromShortcutName("commandPalette"),
                    getShortcutFromShortcutName("commandPalette", 1)
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime91.jsxs)(
          ShortcutIsland,
          {
            className: "HelpDialog__island--editor",
            caption: t("helpDialog.editor"),
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("helpDialog.createFlowchart"),
                  shortcuts: [getShortcutKey(`CtrlOrCmd+Arrow Key`)],
                  isOr: true
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("helpDialog.navigateFlowchart"),
                  shortcuts: [getShortcutKey(`Alt+Arrow Key`)],
                  isOr: true
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.moveCanvas"),
                  shortcuts: [
                    getShortcutKey(`Space+${t("helpDialog.drag")}`),
                    getShortcutKey(`Wheel+${t("helpDialog.drag")}`)
                  ],
                  isOr: true
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("buttons.clearReset"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Delete")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.delete"),
                  shortcuts: [getShortcutKey("Delete")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.cut"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+X")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.copy"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+C")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.paste"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+V")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.pasteAsPlaintext"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Shift+V")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.selectAll"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+A")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.multiSelect"),
                  shortcuts: [getShortcutKey(`Shift+${t("helpDialog.click")}`)]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("helpDialog.deepSelect"),
                  shortcuts: [getShortcutKey(`CtrlOrCmd+${t("helpDialog.click")}`)]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("helpDialog.deepBoxSelect"),
                  shortcuts: [getShortcutKey(`CtrlOrCmd+${t("helpDialog.drag")}`)]
                }
              ),
              (probablySupportsClipboardBlob || isFirefox) && /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.copyAsPng"),
                  shortcuts: [getShortcutKey("Shift+Alt+C")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.copyStyles"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Alt+C")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.pasteStyles"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Alt+V")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.sendToBack"),
                  shortcuts: [
                    isDarwin ? getShortcutKey("CtrlOrCmd+Alt+[") : getShortcutKey("CtrlOrCmd+Shift+[")
                  ]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.bringToFront"),
                  shortcuts: [
                    isDarwin ? getShortcutKey("CtrlOrCmd+Alt+]") : getShortcutKey("CtrlOrCmd+Shift+]")
                  ]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.sendBackward"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+[")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.bringForward"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+]")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.alignTop"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Shift+Up")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.alignBottom"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Shift+Down")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.alignLeft"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Shift+Left")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.alignRight"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Shift+Right")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.duplicateSelection"),
                  shortcuts: [
                    getShortcutKey("CtrlOrCmd+D"),
                    getShortcutKey(`Alt+${t("helpDialog.drag")}`)
                  ]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("helpDialog.toggleElementLock"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Shift+L")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("buttons.undo"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Z")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("buttons.redo"),
                  shortcuts: isWindows ? [
                    getShortcutKey("CtrlOrCmd+Y"),
                    getShortcutKey("CtrlOrCmd+Shift+Z")
                  ] : [getShortcutKey("CtrlOrCmd+Shift+Z")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.group"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+G")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.ungroup"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Shift+G")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.flipHorizontal"),
                  shortcuts: [getShortcutKey("Shift+H")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.flipVertical"),
                  shortcuts: [getShortcutKey("Shift+V")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.showStroke"),
                  shortcuts: [getShortcutKey("S")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.showBackground"),
                  shortcuts: [getShortcutKey("G")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.showFonts"),
                  shortcuts: [getShortcutKey("Shift+F")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.decreaseFontSize"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Shift+<")]
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                Shortcut,
                {
                  label: t("labels.increaseFontSize"),
                  shortcuts: [getShortcutKey("CtrlOrCmd+Shift+>")]
                }
              )
            ]
          }
        )
      ] })
    }
  ) });
};

// components/UserList.tsx
init_define_import_meta_env();
var import_react86 = __toESM(require_react(), 1);
var import_jsx_runtime92 = __toESM(require_jsx_runtime(), 1);
var DEFAULT_MAX_AVATARS = 4;
var SHOW_COLLABORATORS_FILTER_AT = 8;
var ConditionalTooltipWrapper = ({
  shouldWrap,
  children,
  username
}) => shouldWrap ? /* @__PURE__ */ (0, import_jsx_runtime92.jsx)(Tooltip, { label: username || "Unknown user", children }) : /* @__PURE__ */ (0, import_jsx_runtime92.jsx)(import_jsx_runtime92.Fragment, { children });
var renderCollaborator = ({
  actionManager,
  collaborator,
  socketId,
  withName = false,
  shouldWrapWithTooltip = false,
  isBeingFollowed
}) => {
  const data = {
    socketId,
    collaborator,
    withName,
    isBeingFollowed
  };
  const avatarJSX = actionManager.renderAction("goToCollaborator", data);
  return /* @__PURE__ */ (0, import_jsx_runtime92.jsx)(
    ConditionalTooltipWrapper,
    {
      username: collaborator.username,
      shouldWrap: shouldWrapWithTooltip,
      children: avatarJSX
    },
    socketId
  );
};
var collaboratorComparatorKeys = [
  "avatarUrl",
  "id",
  "socketId",
  "username",
  "isInCall",
  "isSpeaking",
  "isMuted"
];
var UserList = import_react86.default.memo(
  ({ className, mobile, collaborators, userToFollow }) => {
    const actionManager = useExcalidrawActionManager();
    const uniqueCollaboratorsMap = /* @__PURE__ */ new Map();
    collaborators.forEach((collaborator, socketId) => {
      const userId = collaborator.id || socketId;
      uniqueCollaboratorsMap.set(
        // filter on user id, else fall back on unique socketId
        userId,
        { ...collaborator, socketId }
      );
    });
    const uniqueCollaboratorsArray = Array.from(
      uniqueCollaboratorsMap.values()
    ).filter((collaborator) => collaborator.username?.trim());
    const [searchTerm, setSearchTerm] = import_react86.default.useState("");
    const filteredCollaborators = uniqueCollaboratorsArray.filter(
      (collaborator) => collaborator.username?.toLowerCase().includes(searchTerm)
    );
    const userListWrapper = import_react86.default.useRef(null);
    (0, import_react86.useLayoutEffect)(() => {
      if (userListWrapper.current) {
        const updateMaxAvatars = (width) => {
          const maxAvatars2 = Math.max(1, Math.min(8, Math.floor(width / 38)));
          setMaxAvatars(maxAvatars2);
        };
        updateMaxAvatars(userListWrapper.current.clientWidth);
        if (!supportsResizeObserver) {
          return;
        }
        const resizeObserver = new ResizeObserver((entries) => {
          for (const entry of entries) {
            const { width } = entry.contentRect;
            updateMaxAvatars(width);
          }
        });
        resizeObserver.observe(userListWrapper.current);
        return () => {
          resizeObserver.disconnect();
        };
      }
    }, []);
    const [maxAvatars, setMaxAvatars] = import_react86.default.useState(DEFAULT_MAX_AVATARS);
    const firstNCollaborators = uniqueCollaboratorsArray.slice(
      0,
      maxAvatars - 1
    );
    const firstNAvatarsJSX = firstNCollaborators.map(
      (collaborator) => renderCollaborator({
        actionManager,
        collaborator,
        socketId: collaborator.socketId,
        shouldWrapWithTooltip: true,
        isBeingFollowed: collaborator.socketId === userToFollow
      })
    );
    return mobile ? /* @__PURE__ */ (0, import_jsx_runtime92.jsx)("div", { className: clsx_m_default("UserList UserList_mobile", className), children: uniqueCollaboratorsArray.map(
      (collaborator) => renderCollaborator({
        actionManager,
        collaborator,
        socketId: collaborator.socketId,
        shouldWrapWithTooltip: true,
        isBeingFollowed: collaborator.socketId === userToFollow
      })
    ) }) : /* @__PURE__ */ (0, import_jsx_runtime92.jsx)("div", { className: "UserList__wrapper", ref: userListWrapper, children: /* @__PURE__ */ (0, import_jsx_runtime92.jsxs)(
      "div",
      {
        className: clsx_m_default("UserList", className),
        style: { [`--max-avatars`]: maxAvatars },
        children: [
          firstNAvatarsJSX,
          uniqueCollaboratorsArray.length > maxAvatars - 1 && /* @__PURE__ */ (0, import_jsx_runtime92.jsxs)($cb5cc270b50c6fcd$export$be92b6f5f03c0fe9, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime92.jsxs)($cb5cc270b50c6fcd$export$41fb9f06171c75f4, { className: "UserList__more", children: [
              "+",
              uniqueCollaboratorsArray.length - maxAvatars + 1
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime92.jsx)(
              $cb5cc270b50c6fcd$export$7c6e2c02157bb7d2,
              {
                style: {
                  zIndex: 2,
                  width: "15rem",
                  textAlign: "left"
                },
                align: "end",
                sideOffset: 10,
                children: /* @__PURE__ */ (0, import_jsx_runtime92.jsxs)(Island, { padding: 2, children: [
                  uniqueCollaboratorsArray.length >= SHOW_COLLABORATORS_FILTER_AT && /* @__PURE__ */ (0, import_jsx_runtime92.jsx)(
                    QuickSearch,
                    {
                      placeholder: t("quickSearch.placeholder"),
                      onChange: setSearchTerm
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime92.jsx)(
                    ScrollableList,
                    {
                      className: "dropdown-menu UserList__collaborators",
                      placeholder: t("userList.empty"),
                      children: filteredCollaborators.length > 0 ? [
                        /* @__PURE__ */ (0, import_jsx_runtime92.jsx)("div", { className: "hint", children: t("userList.hint.text") }),
                        filteredCollaborators.map(
                          (collaborator) => renderCollaborator({
                            actionManager,
                            collaborator,
                            socketId: collaborator.socketId,
                            withName: true,
                            isBeingFollowed: collaborator.socketId === userToFollow
                          })
                        )
                      ] : []
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime92.jsx)(
                    $cb5cc270b50c6fcd$export$21b07c8f274aebd5,
                    {
                      width: 20,
                      height: 10,
                      style: {
                        fill: "var(--popup-bg-color)",
                        filter: "drop-shadow(rgba(0, 0, 0, 0.05) 0px 3px 2px)"
                      }
                    }
                  )
                ] })
              }
            )
          ] })
        ]
      }
    ) });
  },
  (prev, next) => {
    if (prev.collaborators.size !== next.collaborators.size || prev.mobile !== next.mobile || prev.className !== next.className || prev.userToFollow !== next.userToFollow) {
      return false;
    }
    const nextCollaboratorSocketIds = next.collaborators.keys();
    for (const [socketId, collaborator] of prev.collaborators) {
      const nextCollaborator = next.collaborators.get(socketId);
      if (!nextCollaborator || // this checks order of collaborators in the map is the same
      // as previous render
      socketId !== nextCollaboratorSocketIds.next().value || !isShallowEqual(
        collaborator,
        nextCollaborator,
        collaboratorComparatorKeys
      )) {
        return false;
      }
    }
    return true;
  }
);

// components/JSONExportDialog.tsx
init_define_import_meta_env();
var import_react87 = __toESM(require_react(), 1);

// components/Card.tsx
init_define_import_meta_env();
var import_jsx_runtime93 = __toESM(require_jsx_runtime(), 1);
var Card = ({ children, color }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(
    "div",
    {
      className: "Card",
      style: {
        ["--card-color"]: color === "primary" ? "var(--color-primary)" : open_color_default[color][7],
        ["--card-color-darker"]: color === "primary" ? "var(--color-primary-darker)" : open_color_default[color][8],
        ["--card-color-darkest"]: color === "primary" ? "var(--color-primary-darkest)" : open_color_default[color][9]
      },
      children
    }
  );
};

// components/JSONExportDialog.tsx
var import_jsx_runtime94 = __toESM(require_jsx_runtime(), 1);
var JSONExportModal = ({
  elements,
  appState,
  setAppState,
  files,
  actionManager,
  exportOpts,
  canvas,
  onCloseRequest
}) => {
  const { onExportToBackend } = exportOpts;
  return /* @__PURE__ */ (0, import_jsx_runtime94.jsx)("div", { className: "ExportDialog ExportDialog--json", children: /* @__PURE__ */ (0, import_jsx_runtime94.jsxs)("div", { className: "ExportDialog-cards", children: [
    exportOpts.saveFileToDisk && /* @__PURE__ */ (0, import_jsx_runtime94.jsxs)(Card, { color: "lime", children: [
      /* @__PURE__ */ (0, import_jsx_runtime94.jsx)("div", { className: "Card-icon", children: exportToFileIcon }),
      /* @__PURE__ */ (0, import_jsx_runtime94.jsx)("h2", { children: t("exportDialog.disk_title") }),
      /* @__PURE__ */ (0, import_jsx_runtime94.jsxs)("div", { className: "Card-details", children: [
        t("exportDialog.disk_details"),
        !e && actionManager.renderAction("changeProjectName")
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(
        ToolButton,
        {
          className: "Card-button",
          type: "button",
          title: t("exportDialog.disk_button"),
          "aria-label": t("exportDialog.disk_button"),
          showAriaLabel: true,
          onClick: () => {
            actionManager.executeAction(actionSaveFileToDisk, "ui");
          }
        }
      )
    ] }),
    onExportToBackend && /* @__PURE__ */ (0, import_jsx_runtime94.jsxs)(Card, { color: "pink", children: [
      /* @__PURE__ */ (0, import_jsx_runtime94.jsx)("div", { className: "Card-icon", children: LinkIcon }),
      /* @__PURE__ */ (0, import_jsx_runtime94.jsx)("h2", { children: t("exportDialog.link_title") }),
      /* @__PURE__ */ (0, import_jsx_runtime94.jsx)("div", { className: "Card-details", children: t("exportDialog.link_details") }),
      /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(
        ToolButton,
        {
          className: "Card-button",
          type: "button",
          title: t("exportDialog.link_button"),
          "aria-label": t("exportDialog.link_button"),
          showAriaLabel: true,
          onClick: async () => {
            try {
              trackEvent("export", "link", `ui (${getFrame()})`);
              await onExportToBackend(elements, appState, files);
              onCloseRequest();
            } catch (error) {
              setAppState({ errorMessage: error.message });
            }
          }
        }
      )
    ] }),
    exportOpts.renderCustomUI && exportOpts.renderCustomUI(elements, appState, files, canvas)
  ] }) });
};
var JSONExportDialog = ({
  elements,
  appState,
  files,
  actionManager,
  exportOpts,
  canvas,
  setAppState
}) => {
  const handleClose = import_react87.default.useCallback(() => {
    setAppState({ openDialog: null });
  }, [setAppState]);
  return /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(import_jsx_runtime94.Fragment, { children: appState.openDialog?.name === "jsonExport" && /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(Dialog, { onCloseRequest: handleClose, title: t("buttons.export"), children: /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(
    JSONExportModal,
    {
      elements,
      appState,
      setAppState,
      files,
      actionManager,
      onCloseRequest: handleClose,
      exportOpts,
      canvas
    }
  ) }) });
};

// components/footer/Footer.tsx
init_define_import_meta_env();

// components/HelpButton.tsx
init_define_import_meta_env();
var import_jsx_runtime95 = __toESM(require_jsx_runtime(), 1);
var HelpButton = (props) => /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(
  "button",
  {
    className: "help-icon",
    onClick: props.onClick,
    type: "button",
    title: `${t("helpDialog.title")} \u2014 ?`,
    "aria-label": t("helpDialog.title"),
    children: HelpIcon
  }
);

// components/footer/Footer.tsx
var import_jsx_runtime96 = __toESM(require_jsx_runtime(), 1);
var Footer = ({
  appState,
  actionManager,
  showExitZenModeBtn,
  renderWelcomeScreen
}) => {
  const { FooterCenterTunnel, WelcomeScreenHelpHintTunnel } = useTunnels();
  const device = useDevice();
  const showFinalize = !appState.viewModeEnabled && appState.multiElement && device.isTouchScreen;
  return /* @__PURE__ */ (0, import_jsx_runtime96.jsxs)(
    "footer",
    {
      role: "contentinfo",
      className: "layer-ui__wrapper__footer App-menu App-menu_bottom",
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime96.jsx)(
          "div",
          {
            className: clsx_m_default("layer-ui__wrapper__footer-left zen-mode-transition", {
              "layer-ui__wrapper__footer-left--transition-left": appState.zenModeEnabled
            }),
            children: /* @__PURE__ */ (0, import_jsx_runtime96.jsx)(Stack_default.Col, { gap: 2, children: /* @__PURE__ */ (0, import_jsx_runtime96.jsxs)(Section, { heading: "canvasActions", children: [
              /* @__PURE__ */ (0, import_jsx_runtime96.jsx)(
                ZoomActions,
                {
                  renderAction: actionManager.renderAction,
                  zoom: appState.zoom
                }
              ),
              !appState.viewModeEnabled && /* @__PURE__ */ (0, import_jsx_runtime96.jsx)(
                UndoRedoActions,
                {
                  renderAction: actionManager.renderAction,
                  className: clsx_m_default("zen-mode-transition", {
                    "layer-ui__wrapper__footer-left--transition-bottom": appState.zenModeEnabled
                  })
                }
              ),
              showFinalize && /* @__PURE__ */ (0, import_jsx_runtime96.jsx)(
                FinalizeAction,
                {
                  renderAction: actionManager.renderAction,
                  className: clsx_m_default("zen-mode-transition", {
                    "layer-ui__wrapper__footer-left--transition-left": appState.zenModeEnabled
                  })
                }
              )
            ] }) })
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime96.jsx)(FooterCenterTunnel.Out, {}),
        /* @__PURE__ */ (0, import_jsx_runtime96.jsx)(
          "div",
          {
            className: clsx_m_default("layer-ui__wrapper__footer-right zen-mode-transition", {
              "transition-right": appState.zenModeEnabled
            }),
            children: /* @__PURE__ */ (0, import_jsx_runtime96.jsxs)("div", { style: { position: "relative" }, children: [
              renderWelcomeScreen && /* @__PURE__ */ (0, import_jsx_runtime96.jsx)(WelcomeScreenHelpHintTunnel.Out, {}),
              /* @__PURE__ */ (0, import_jsx_runtime96.jsx)(
                HelpButton,
                {
                  onClick: () => actionManager.executeAction(actionShortcuts)
                }
              )
            ] })
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime96.jsx)(
          ExitZenModeAction,
          {
            actionManager,
            showExitZenModeBtn
          }
        )
      ]
    }
  );
};
var Footer_default = Footer;
Footer.displayName = "Footer";

// components/Sidebar/Sidebar.tsx
init_define_import_meta_env();
var import_react94 = __toESM(require_react(), 1);

// components/Sidebar/common.ts
init_define_import_meta_env();
var import_react88 = __toESM(require_react(), 1);
var SidebarPropsContext = import_react88.default.createContext({});

// components/Sidebar/SidebarHeader.tsx
init_define_import_meta_env();
var import_react89 = __toESM(require_react(), 1);
var import_jsx_runtime97 = __toESM(require_jsx_runtime(), 1);
var SidebarHeader = ({
  children,
  className
}) => {
  const device = useDevice();
  const props = (0, import_react89.useContext)(SidebarPropsContext);
  const renderDockButton = !!(device.editor.canFitSidebar && props.shouldRenderDockButton);
  return /* @__PURE__ */ (0, import_jsx_runtime97.jsxs)(
    "div",
    {
      className: clsx_m_default("sidebar__header", className),
      "data-testid": "sidebar-header",
      children: [
        children,
        /* @__PURE__ */ (0, import_jsx_runtime97.jsxs)("div", { className: "sidebar__header__buttons", children: [
          renderDockButton && /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(Tooltip, { label: t("labels.sidebarLock"), children: /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(
            Button,
            {
              onSelect: () => props.onDock?.(!props.docked),
              selected: !!props.docked,
              className: "sidebar__dock",
              "data-testid": "sidebar-dock",
              "aria-label": t("labels.sidebarLock"),
              children: PinIcon
            }
          ) }),
          /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(
            Button,
            {
              "data-testid": "sidebar-close",
              className: "sidebar__close",
              onSelect: props.onCloseRequest,
              "aria-label": t("buttons.close"),
              children: CloseIcon
            }
          )
        ] })
      ]
    }
  );
};
SidebarHeader.displayName = "SidebarHeader";

// components/Sidebar/SidebarTrigger.tsx
init_define_import_meta_env();
var import_jsx_runtime98 = __toESM(require_jsx_runtime(), 1);
var SidebarTrigger = ({
  name,
  tab,
  icon,
  title,
  children,
  onToggle,
  className,
  style
}) => {
  const setAppState = useExcalidrawSetAppState();
  const appState = useUIAppState();
  return /* @__PURE__ */ (0, import_jsx_runtime98.jsxs)("label", { title, className: "sidebar-trigger__label-element", children: [
    /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(
      "input",
      {
        className: "ToolIcon_type_checkbox",
        type: "checkbox",
        onChange: (event) => {
          document.querySelector(".layer-ui__wrapper")?.classList.remove("animate");
          const isOpen = event.target.checked;
          setAppState({ openSidebar: isOpen ? { name, tab } : null });
          onToggle?.(isOpen);
        },
        checked: appState.openSidebar?.name === name,
        "aria-label": title,
        "aria-keyshortcuts": "0"
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime98.jsxs)("div", { className: clsx_m_default("sidebar-trigger", className), style, children: [
      icon && /* @__PURE__ */ (0, import_jsx_runtime98.jsx)("div", { children: icon }),
      children && /* @__PURE__ */ (0, import_jsx_runtime98.jsx)("div", { className: "sidebar-trigger__label", children })
    ] })
  ] });
};
SidebarTrigger.displayName = "SidebarTrigger";

// components/Sidebar/SidebarTabTriggers.tsx
init_define_import_meta_env();

// ../../node_modules/@radix-ui/react-tabs/dist/index.module.js
init_define_import_meta_env();
var import_react93 = __toESM(require_react());

// ../../node_modules/@radix-ui/react-roving-focus/dist/index.module.js
init_define_import_meta_env();
var import_react92 = __toESM(require_react());

// ../../node_modules/@radix-ui/react-collection/dist/index.module.js
init_define_import_meta_env();
var import_react90 = __toESM(require_react());
function $e02a7d9cb1dc128c$export$c74125a8e3af6bb2(name) {
  const PROVIDER_NAME = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope] = $c512c27ab02ef895$export$50c7b4e9d9f19c1(PROVIDER_NAME);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(PROVIDER_NAME, {
    collectionRef: {
      current: null
    },
    itemMap: /* @__PURE__ */ new Map()
  });
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = import_react90.default.useRef(null);
    const itemMap = import_react90.default.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ import_react90.default.createElement(CollectionProviderImpl, {
      scope,
      itemMap,
      collectionRef: ref
    }, children);
  };
  /* @__PURE__ */ Object.assign(CollectionProvider, {
    displayName: PROVIDER_NAME
  });
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlot = /* @__PURE__ */ import_react90.default.forwardRef((props, forwardedRef) => {
    const { scope, children } = props;
    const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.collectionRef);
    return /* @__PURE__ */ import_react90.default.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360, {
      ref: composedRefs
    }, children);
  });
  /* @__PURE__ */ Object.assign(CollectionSlot, {
    displayName: COLLECTION_SLOT_NAME
  });
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlot = /* @__PURE__ */ import_react90.default.forwardRef((props, forwardedRef) => {
    const { scope, children, ...itemData } = props;
    const ref = import_react90.default.useRef(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
    const context = useCollectionContext(ITEM_SLOT_NAME, scope);
    import_react90.default.useEffect(() => {
      context.itemMap.set(ref, {
        ref,
        ...itemData
      });
      return () => void context.itemMap.delete(ref);
    });
    return /* @__PURE__ */ import_react90.default.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360, {
      [ITEM_DATA_ATTR]: "",
      ref: composedRefs
    }, children);
  });
  /* @__PURE__ */ Object.assign(CollectionItemSlot, {
    displayName: ITEM_SLOT_NAME
  });
  function useCollection(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = import_react90.default.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode)
        return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a3, b3) => orderedNodes.indexOf(a3.ref.current) - orderedNodes.indexOf(b3.ref.current)
      );
      return orderedItems;
    }, [
      context.collectionRef,
      context.itemMap
    ]);
    return getItems;
  }
  return [
    {
      Provider: CollectionProvider,
      Slot: CollectionSlot,
      ItemSlot: CollectionItemSlot
    },
    useCollection,
    createCollectionScope
  ];
}

// ../../node_modules/@radix-ui/react-direction/dist/index.module.js
init_define_import_meta_env();
var import_react91 = __toESM(require_react());
var $f631663db3294ace$var$DirectionContext = /* @__PURE__ */ (0, import_react91.createContext)(void 0);
function $f631663db3294ace$export$b39126d51d94e6f3(localDir) {
  const globalDir = (0, import_react91.useContext)($f631663db3294ace$var$DirectionContext);
  return localDir || globalDir || "ltr";
}

// ../../node_modules/@radix-ui/react-roving-focus/dist/index.module.js
var $d7bdfb9eb0fdf311$var$ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var $d7bdfb9eb0fdf311$var$EVENT_OPTIONS = {
  bubbles: false,
  cancelable: true
};
var $d7bdfb9eb0fdf311$var$GROUP_NAME = "RovingFocusGroup";
var [$d7bdfb9eb0fdf311$var$Collection, $d7bdfb9eb0fdf311$var$useCollection, $d7bdfb9eb0fdf311$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($d7bdfb9eb0fdf311$var$GROUP_NAME);
var [$d7bdfb9eb0fdf311$var$createRovingFocusGroupContext, $d7bdfb9eb0fdf311$export$c7109489551a4f4] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($d7bdfb9eb0fdf311$var$GROUP_NAME, [
  $d7bdfb9eb0fdf311$var$createCollectionScope
]);
var [$d7bdfb9eb0fdf311$var$RovingFocusProvider, $d7bdfb9eb0fdf311$var$useRovingFocusContext] = $d7bdfb9eb0fdf311$var$createRovingFocusGroupContext($d7bdfb9eb0fdf311$var$GROUP_NAME);
var $d7bdfb9eb0fdf311$export$8699f7c8af148338 = /* @__PURE__ */ (0, import_react92.forwardRef)((props, forwardedRef) => {
  return /* @__PURE__ */ (0, import_react92.createElement)($d7bdfb9eb0fdf311$var$Collection.Provider, {
    scope: props.__scopeRovingFocusGroup
  }, /* @__PURE__ */ (0, import_react92.createElement)($d7bdfb9eb0fdf311$var$Collection.Slot, {
    scope: props.__scopeRovingFocusGroup
  }, /* @__PURE__ */ (0, import_react92.createElement)($d7bdfb9eb0fdf311$var$RovingFocusGroupImpl, _extends({}, props, {
    ref: forwardedRef
  }))));
});
var $d7bdfb9eb0fdf311$var$RovingFocusGroupImpl = /* @__PURE__ */ (0, import_react92.forwardRef)((props, forwardedRef) => {
  const { __scopeRovingFocusGroup, orientation, loop = false, dir, currentTabStopId: currentTabStopIdProp, defaultCurrentTabStopId, onCurrentTabStopIdChange, onEntryFocus, ...groupProps } = props;
  const ref = (0, import_react92.useRef)(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
  const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
  const [currentTabStopId = null, setCurrentTabStopId] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId,
    onChange: onCurrentTabStopIdChange
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = (0, import_react92.useState)(false);
  const handleEntryFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEntryFocus);
  const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);
  const isClickFocusRef = (0, import_react92.useRef)(false);
  const [focusableItemsCount, setFocusableItemsCount] = (0, import_react92.useState)(0);
  (0, import_react92.useEffect)(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);
    }
  }, [
    handleEntryFocus
  ]);
  return /* @__PURE__ */ (0, import_react92.createElement)($d7bdfb9eb0fdf311$var$RovingFocusProvider, {
    scope: __scopeRovingFocusGroup,
    orientation,
    dir: direction,
    loop,
    currentTabStopId,
    onItemFocus: (0, import_react92.useCallback)(
      (tabStopId) => setCurrentTabStopId(tabStopId),
      [
        setCurrentTabStopId
      ]
    ),
    onItemShiftTab: (0, import_react92.useCallback)(
      () => setIsTabbingBackOut(true),
      []
    ),
    onFocusableItemAdd: (0, import_react92.useCallback)(
      () => setFocusableItemsCount(
        (prevCount) => prevCount + 1
      ),
      []
    ),
    onFocusableItemRemove: (0, import_react92.useCallback)(
      () => setFocusableItemsCount(
        (prevCount) => prevCount - 1
      ),
      []
    )
  }, /* @__PURE__ */ (0, import_react92.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
    "data-orientation": orientation
  }, groupProps, {
    ref: composedRefs,
    style: {
      outline: "none",
      ...props.style
    },
    onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, () => {
      isClickFocusRef.current = true;
    }),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, (event) => {
      const isKeyboardFocus = !isClickFocusRef.current;
      if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
        const entryFocusEvent = new CustomEvent($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, $d7bdfb9eb0fdf311$var$EVENT_OPTIONS);
        event.currentTarget.dispatchEvent(entryFocusEvent);
        if (!entryFocusEvent.defaultPrevented) {
          const items = getItems().filter(
            (item) => item.focusable
          );
          const activeItem = items.find(
            (item) => item.active
          );
          const currentItem = items.find(
            (item) => item.id === currentTabStopId
          );
          const candidateItems = [
            activeItem,
            currentItem,
            ...items
          ].filter(Boolean);
          const candidateNodes = candidateItems.map(
            (item) => item.ref.current
          );
          $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes);
        }
      }
      isClickFocusRef.current = false;
    }),
    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onBlur,
      () => setIsTabbingBackOut(false)
    )
  })));
});
var $d7bdfb9eb0fdf311$var$ITEM_NAME = "RovingFocusGroupItem";
var $d7bdfb9eb0fdf311$export$ab9df7c53fe8454 = /* @__PURE__ */ (0, import_react92.forwardRef)((props, forwardedRef) => {
  const { __scopeRovingFocusGroup, focusable = true, active = false, tabStopId, ...itemProps } = props;
  const autoId = $1746a345f3d73bb7$export$f680877a34711e37();
  const id = tabStopId || autoId;
  const context = $d7bdfb9eb0fdf311$var$useRovingFocusContext($d7bdfb9eb0fdf311$var$ITEM_NAME, __scopeRovingFocusGroup);
  const isCurrentTabStop = context.currentTabStopId === id;
  const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);
  const { onFocusableItemAdd, onFocusableItemRemove } = context;
  (0, import_react92.useEffect)(() => {
    if (focusable) {
      onFocusableItemAdd();
      return () => onFocusableItemRemove();
    }
  }, [
    focusable,
    onFocusableItemAdd,
    onFocusableItemRemove
  ]);
  return /* @__PURE__ */ (0, import_react92.createElement)($d7bdfb9eb0fdf311$var$Collection.ItemSlot, {
    scope: __scopeRovingFocusGroup,
    id,
    focusable,
    active
  }, /* @__PURE__ */ (0, import_react92.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({
    tabIndex: isCurrentTabStop ? 0 : -1,
    "data-orientation": context.orientation
  }, itemProps, {
    ref: forwardedRef,
    onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, (event) => {
      if (!focusable)
        event.preventDefault();
      else
        context.onItemFocus(id);
    }),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocus,
      () => context.onItemFocus(id)
    ),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      if (event.key === "Tab" && event.shiftKey) {
        context.onItemShiftTab();
        return;
      }
      if (event.target !== event.currentTarget)
        return;
      const focusIntent = $d7bdfb9eb0fdf311$var$getFocusIntent(event, context.orientation, context.dir);
      if (focusIntent !== void 0) {
        event.preventDefault();
        const items = getItems().filter(
          (item) => item.focusable
        );
        let candidateNodes = items.map(
          (item) => item.ref.current
        );
        if (focusIntent === "last")
          candidateNodes.reverse();
        else if (focusIntent === "prev" || focusIntent === "next") {
          if (focusIntent === "prev")
            candidateNodes.reverse();
          const currentIndex = candidateNodes.indexOf(event.currentTarget);
          candidateNodes = context.loop ? $d7bdfb9eb0fdf311$var$wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
        }
        setTimeout(
          () => $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes)
        );
      }
    })
  })));
});
var $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function $d7bdfb9eb0fdf311$var$getDirectionAwareKey(key, dir) {
  if (dir !== "rtl")
    return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function $d7bdfb9eb0fdf311$var$getFocusIntent(event, orientation, dir) {
  const key = $d7bdfb9eb0fdf311$var$getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && [
    "ArrowLeft",
    "ArrowRight"
  ].includes(key))
    return void 0;
  if (orientation === "horizontal" && [
    "ArrowUp",
    "ArrowDown"
  ].includes(key))
    return void 0;
  return $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT[key];
}
function $d7bdfb9eb0fdf311$var$focusFirst(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
      return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
      return;
  }
}
function $d7bdfb9eb0fdf311$var$wrapArray(array, startIndex) {
  return array.map(
    (_, index2) => array[(startIndex + index2) % array.length]
  );
}
var $d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9 = $d7bdfb9eb0fdf311$export$8699f7c8af148338;
var $d7bdfb9eb0fdf311$export$6d08773d2e66f8f2 = $d7bdfb9eb0fdf311$export$ab9df7c53fe8454;

// ../../node_modules/@radix-ui/react-tabs/dist/index.module.js
var $69cb30bb0017df05$var$TABS_NAME = "Tabs";
var [$69cb30bb0017df05$var$createTabsContext, $69cb30bb0017df05$export$355f5bd209d7b13a] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($69cb30bb0017df05$var$TABS_NAME, [
  $d7bdfb9eb0fdf311$export$c7109489551a4f4
]);
var $69cb30bb0017df05$var$useRovingFocusGroupScope = $d7bdfb9eb0fdf311$export$c7109489551a4f4();
var [$69cb30bb0017df05$var$TabsProvider, $69cb30bb0017df05$var$useTabsContext] = $69cb30bb0017df05$var$createTabsContext($69cb30bb0017df05$var$TABS_NAME);
var $69cb30bb0017df05$export$b2539bed5023c21c = /* @__PURE__ */ (0, import_react93.forwardRef)((props, forwardedRef) => {
  const { __scopeTabs, value: valueProp, onValueChange, defaultValue, orientation = "horizontal", dir, activationMode = "automatic", ...tabsProps } = props;
  const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
  const [value, setValue] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: valueProp,
    onChange: onValueChange,
    defaultProp: defaultValue
  });
  return /* @__PURE__ */ (0, import_react93.createElement)($69cb30bb0017df05$var$TabsProvider, {
    scope: __scopeTabs,
    baseId: $1746a345f3d73bb7$export$f680877a34711e37(),
    value,
    onValueChange: setValue,
    orientation,
    dir: direction,
    activationMode
  }, /* @__PURE__ */ (0, import_react93.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    dir: direction,
    "data-orientation": orientation
  }, tabsProps, {
    ref: forwardedRef
  })));
});
var $69cb30bb0017df05$var$TAB_LIST_NAME = "TabsList";
var $69cb30bb0017df05$export$9712d22edc0d78c1 = /* @__PURE__ */ (0, import_react93.forwardRef)((props, forwardedRef) => {
  const { __scopeTabs, loop = true, ...listProps } = props;
  const context = $69cb30bb0017df05$var$useTabsContext($69cb30bb0017df05$var$TAB_LIST_NAME, __scopeTabs);
  const rovingFocusGroupScope = $69cb30bb0017df05$var$useRovingFocusGroupScope(__scopeTabs);
  return /* @__PURE__ */ (0, import_react93.createElement)($d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9, _extends({
    asChild: true
  }, rovingFocusGroupScope, {
    orientation: context.orientation,
    dir: context.dir,
    loop
  }), /* @__PURE__ */ (0, import_react93.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    role: "tablist",
    "aria-orientation": context.orientation
  }, listProps, {
    ref: forwardedRef
  })));
});
var $69cb30bb0017df05$var$TRIGGER_NAME = "TabsTrigger";
var $69cb30bb0017df05$export$8114b9fdfdf9f3ba = /* @__PURE__ */ (0, import_react93.forwardRef)((props, forwardedRef) => {
  const { __scopeTabs, value, disabled = false, ...triggerProps } = props;
  const context = $69cb30bb0017df05$var$useTabsContext($69cb30bb0017df05$var$TRIGGER_NAME, __scopeTabs);
  const rovingFocusGroupScope = $69cb30bb0017df05$var$useRovingFocusGroupScope(__scopeTabs);
  const triggerId = $69cb30bb0017df05$var$makeTriggerId(context.baseId, value);
  const contentId = $69cb30bb0017df05$var$makeContentId(context.baseId, value);
  const isSelected = value === context.value;
  return /* @__PURE__ */ (0, import_react93.createElement)($d7bdfb9eb0fdf311$export$6d08773d2e66f8f2, _extends({
    asChild: true
  }, rovingFocusGroupScope, {
    focusable: !disabled,
    active: isSelected
  }), /* @__PURE__ */ (0, import_react93.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
    type: "button",
    role: "tab",
    "aria-selected": isSelected,
    "aria-controls": contentId,
    "data-state": isSelected ? "active" : "inactive",
    "data-disabled": disabled ? "" : void 0,
    disabled,
    id: triggerId
  }, triggerProps, {
    ref: forwardedRef,
    onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, (event) => {
      if (!disabled && event.button === 0 && event.ctrlKey === false)
        context.onValueChange(value);
      else
        event.preventDefault();
    }),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      if ([
        " ",
        "Enter"
      ].includes(event.key))
        context.onValueChange(value);
    }),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, () => {
      const isAutomaticActivation = context.activationMode !== "manual";
      if (!isSelected && !disabled && isAutomaticActivation)
        context.onValueChange(value);
    })
  })));
});
var $69cb30bb0017df05$var$CONTENT_NAME = "TabsContent";
var $69cb30bb0017df05$export$bd905d70e8fd2ebb = /* @__PURE__ */ (0, import_react93.forwardRef)((props, forwardedRef) => {
  const { __scopeTabs, value, forceMount, children, ...contentProps } = props;
  const context = $69cb30bb0017df05$var$useTabsContext($69cb30bb0017df05$var$CONTENT_NAME, __scopeTabs);
  const triggerId = $69cb30bb0017df05$var$makeTriggerId(context.baseId, value);
  const contentId = $69cb30bb0017df05$var$makeContentId(context.baseId, value);
  const isSelected = value === context.value;
  const isMountAnimationPreventedRef = (0, import_react93.useRef)(isSelected);
  (0, import_react93.useEffect)(() => {
    const rAF = requestAnimationFrame(
      () => isMountAnimationPreventedRef.current = false
    );
    return () => cancelAnimationFrame(rAF);
  }, []);
  return /* @__PURE__ */ (0, import_react93.createElement)(
    $921a889cee6df7e8$export$99c2b779aa4e8b8b,
    {
      present: forceMount || isSelected
    },
    ({ present }) => /* @__PURE__ */ (0, import_react93.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
      "data-state": isSelected ? "active" : "inactive",
      "data-orientation": context.orientation,
      role: "tabpanel",
      "aria-labelledby": triggerId,
      hidden: !present,
      id: contentId,
      tabIndex: 0
    }, contentProps, {
      ref: forwardedRef,
      style: {
        ...props.style,
        animationDuration: isMountAnimationPreventedRef.current ? "0s" : void 0
      }
    }), present && children)
  );
});
function $69cb30bb0017df05$var$makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function $69cb30bb0017df05$var$makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
var $69cb30bb0017df05$export$be92b6f5f03c0fe9 = $69cb30bb0017df05$export$b2539bed5023c21c;
var $69cb30bb0017df05$export$54c2e3dc7acea9f5 = $69cb30bb0017df05$export$9712d22edc0d78c1;
var $69cb30bb0017df05$export$41fb9f06171c75f4 = $69cb30bb0017df05$export$8114b9fdfdf9f3ba;
var $69cb30bb0017df05$export$7c6e2c02157bb7d2 = $69cb30bb0017df05$export$bd905d70e8fd2ebb;

// components/Sidebar/SidebarTabTriggers.tsx
var import_jsx_runtime99 = __toESM(require_jsx_runtime(), 1);
var SidebarTabTriggers = ({
  children,
  ...rest
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime99.jsx)($69cb30bb0017df05$export$54c2e3dc7acea9f5, { className: "sidebar-triggers", ...rest, children });
};
SidebarTabTriggers.displayName = "SidebarTabTriggers";

// components/Sidebar/SidebarTabTrigger.tsx
init_define_import_meta_env();
var import_jsx_runtime100 = __toESM(require_jsx_runtime(), 1);
var SidebarTabTrigger = ({
  children,
  tab,
  onSelect,
  ...rest
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime100.jsx)($69cb30bb0017df05$export$41fb9f06171c75f4, { value: tab, asChild: true, onSelect, children: /* @__PURE__ */ (0, import_jsx_runtime100.jsx)(
    "button",
    {
      type: "button",
      className: `excalidraw-button sidebar-tab-trigger`,
      ...rest,
      children
    }
  ) });
};
SidebarTabTrigger.displayName = "SidebarTabTrigger";

// components/Sidebar/SidebarTabs.tsx
init_define_import_meta_env();
var import_jsx_runtime101 = __toESM(require_jsx_runtime(), 1);
var SidebarTabs = ({
  children,
  ...rest
}) => {
  const appState = useUIAppState();
  const setAppState = useExcalidrawSetAppState();
  if (!appState.openSidebar) {
    return null;
  }
  const { name } = appState.openSidebar;
  return /* @__PURE__ */ (0, import_jsx_runtime101.jsx)(
    $69cb30bb0017df05$export$be92b6f5f03c0fe9,
    {
      className: "sidebar-tabs-root",
      value: appState.openSidebar.tab,
      onValueChange: (tab) => setAppState((state) => ({
        ...state,
        openSidebar: { ...state.openSidebar, name, tab }
      })),
      ...rest,
      children
    }
  );
};
SidebarTabs.displayName = "SidebarTabs";

// components/Sidebar/SidebarTab.tsx
init_define_import_meta_env();
var import_jsx_runtime102 = __toESM(require_jsx_runtime(), 1);
var SidebarTab = ({
  tab,
  children,
  ...rest
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime102.jsx)($69cb30bb0017df05$export$7c6e2c02157bb7d2, { ...rest, value: tab, "data-testid": tab, children });
};
SidebarTab.displayName = "SidebarTab";

// components/Sidebar/Sidebar.tsx
var import_jsx_runtime103 = __toESM(require_jsx_runtime(), 1);
var import_react95 = __toESM(require_react(), 1);
var isSidebarDockedAtom = atom2(false);
var SidebarInner = (0, import_react94.forwardRef)(
  ({
    name,
    children,
    onDock,
    docked,
    className,
    ...rest
  }, ref) => {
    if (define_import_meta_env_default.DEV && onDock && docked == null) {
      console.warn(
        "Sidebar: `docked` must be set when `onDock` is supplied for the sidebar to be user-dockable. To hide this message, either pass `docked` or remove `onDock`"
      );
    }
    const setAppState = useExcalidrawSetAppState();
    const setIsSidebarDockedAtom = useSetAtom(isSidebarDockedAtom, jotaiScope);
    (0, import_react94.useLayoutEffect)(() => {
      setIsSidebarDockedAtom(!!docked);
      return () => {
        setIsSidebarDockedAtom(false);
      };
    }, [setIsSidebarDockedAtom, docked]);
    const headerPropsRef = (0, import_react94.useRef)(
      {}
    );
    headerPropsRef.current.onCloseRequest = () => {
      setAppState({ openSidebar: null });
    };
    headerPropsRef.current.onDock = (isDocked) => onDock?.(isDocked);
    headerPropsRef.current = updateObject(headerPropsRef.current, {
      docked,
      // explicit prop to rerender on update
      shouldRenderDockButton: !!onDock && docked != null
    });
    const islandRef = (0, import_react94.useRef)(null);
    (0, import_react94.useImperativeHandle)(ref, () => {
      return islandRef.current;
    });
    const device = useDevice();
    const closeLibrary = (0, import_react94.useCallback)(() => {
      const isDialogOpen = !!document.querySelector(".Dialog");
      if (isDialogOpen) {
        return;
      }
      setAppState({ openSidebar: null });
    }, [setAppState]);
    useOutsideClick(
      islandRef,
      (0, import_react94.useCallback)(
        (event) => {
          if (event.target.closest(".sidebar-trigger")) {
            return;
          }
          if (!docked || !device.editor.canFitSidebar) {
            closeLibrary();
          }
        },
        [closeLibrary, docked, device.editor.canFitSidebar]
      )
    );
    (0, import_react94.useEffect)(() => {
      const handleKeyDown = (event) => {
        if (event.key === KEYS.ESCAPE && (!docked || !device.editor.canFitSidebar)) {
          closeLibrary();
        }
      };
      document.addEventListener("keydown" /* KEYDOWN */, handleKeyDown);
      return () => {
        document.removeEventListener("keydown" /* KEYDOWN */, handleKeyDown);
      };
    }, [closeLibrary, docked, device.editor.canFitSidebar]);
    return /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(
      Island,
      {
        ...rest,
        className: clsx_m_default("sidebar", { "sidebar--docked": docked }, className),
        ref: islandRef,
        children: /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(SidebarPropsContext.Provider, { value: headerPropsRef.current, children })
      }
    );
  }
);
SidebarInner.displayName = "SidebarInner";
var Sidebar = Object.assign(
  (0, import_react94.forwardRef)((props, ref) => {
    const appState = useUIAppState();
    const { onStateChange } = props;
    const refPrevOpenSidebar = (0, import_react94.useRef)(appState.openSidebar);
    (0, import_react94.useEffect)(() => {
      if (
        // closing sidebar
        (!appState.openSidebar && refPrevOpenSidebar?.current?.name === props.name || // opening current sidebar
        appState.openSidebar?.name === props.name && refPrevOpenSidebar?.current?.name !== props.name || // switching tabs or switching to a different sidebar
        refPrevOpenSidebar.current?.name === props.name) && appState.openSidebar !== refPrevOpenSidebar.current
      ) {
        onStateChange?.(
          appState.openSidebar?.name !== props.name ? null : appState.openSidebar
        );
      }
      refPrevOpenSidebar.current = appState.openSidebar;
    }, [appState.openSidebar, onStateChange, props.name]);
    const [mounted, setMounted] = (0, import_react94.useState)(false);
    (0, import_react94.useLayoutEffect)(() => {
      setMounted(true);
      return () => setMounted(false);
    }, []);
    const shouldRender = mounted && appState.openSidebar?.name === props.name;
    if (!shouldRender) {
      return null;
    }
    return /* @__PURE__ */ (0, import_react95.createElement)(SidebarInner, { ...props, ref, key: props.name });
  }),
  {
    Header: SidebarHeader,
    TabTriggers: SidebarTabTriggers,
    TabTrigger: SidebarTabTrigger,
    Tabs: SidebarTabs,
    Tab: SidebarTab,
    Trigger: SidebarTrigger
  }
);
Sidebar.displayName = "Sidebar";

// components/main-menu/MainMenu.tsx
init_define_import_meta_env();

// components/main-menu/DefaultItems.tsx
var DefaultItems_exports = {};
__export(DefaultItems_exports, {
  ChangeCanvasBackground: () => ChangeCanvasBackground,
  ClearCanvas: () => ClearCanvas,
  CommandPalette: () => CommandPalette2,
  Export: () => Export,
  Help: () => Help,
  LiveCollaborationTrigger: () => LiveCollaborationTrigger,
  LoadScene: () => LoadScene,
  SaveAsImage: () => SaveAsImage,
  SaveToActiveFile: () => SaveToActiveFile,
  SearchMenu: () => SearchMenu,
  Socials: () => Socials,
  ToggleTheme: () => ToggleTheme
});
init_define_import_meta_env();

// components/OverwriteConfirm/OverwriteConfirmState.ts
init_define_import_meta_env();
var overwriteConfirmStateAtom = atom2({
  active: false
});
async function openConfirmModal({
  title,
  description,
  actionLabel,
  color
}) {
  return new Promise((resolve) => {
    jotaiStore.set(overwriteConfirmStateAtom, {
      active: true,
      onConfirm: () => resolve(true),
      onClose: () => resolve(false),
      onReject: () => resolve(false),
      title,
      description,
      actionLabel,
      color
    });
  });
}

// components/dropdownMenu/DropdownMenuItemContentRadio.tsx
init_define_import_meta_env();
var import_jsx_runtime104 = __toESM(require_jsx_runtime(), 1);
var DropdownMenuItemContentRadio = ({
  value,
  shortcut,
  onChange,
  choices,
  children,
  name
}) => {
  const device = useDevice();
  return /* @__PURE__ */ (0, import_jsx_runtime104.jsxs)(import_jsx_runtime104.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime104.jsxs)("div", { className: "dropdown-menu-item-base dropdown-menu-item-bare", children: [
      /* @__PURE__ */ (0, import_jsx_runtime104.jsx)("label", { className: "dropdown-menu-item__text", htmlFor: name, children }),
      /* @__PURE__ */ (0, import_jsx_runtime104.jsx)(
        RadioGroup,
        {
          name,
          value,
          onChange,
          choices
        }
      )
    ] }),
    shortcut && !device.editor.isMobile && /* @__PURE__ */ (0, import_jsx_runtime104.jsx)("div", { className: "dropdown-menu-item__shortcut dropdown-menu-item__shortcut--orphaned", children: shortcut })
  ] });
};
DropdownMenuItemContentRadio.displayName = "DropdownMenuItemContentRadio";
var DropdownMenuItemContentRadio_default = DropdownMenuItemContentRadio;

// components/main-menu/DefaultItems.tsx
var import_jsx_runtime105 = __toESM(require_jsx_runtime(), 1);
var LoadScene = () => {
  const { t: t3 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  const elements = useExcalidrawElements();
  if (!actionManager.isActionEnabled(actionLoadScene)) {
    return null;
  }
  const handleSelect = async () => {
    if (!elements.length || await openConfirmModal({
      title: t3("overwriteConfirm.modal.loadFromFile.title"),
      actionLabel: t3("overwriteConfirm.modal.loadFromFile.button"),
      color: "warning",
      description: /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
        Trans_default,
        {
          i18nKey: "overwriteConfirm.modal.loadFromFile.description",
          bold: (text) => /* @__PURE__ */ (0, import_jsx_runtime105.jsx)("strong", { children: text }),
          br: () => /* @__PURE__ */ (0, import_jsx_runtime105.jsx)("br", {})
        }
      )
    })) {
      actionManager.executeAction(actionLoadScene);
    }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
    DropdownMenuItem_default,
    {
      icon: LoadIcon,
      onSelect: handleSelect,
      "data-testid": "load-button",
      shortcut: getShortcutFromShortcutName("loadScene"),
      "aria-label": t3("buttons.load"),
      children: t3("buttons.load")
    }
  );
};
LoadScene.displayName = "LoadScene";
var SaveToActiveFile = () => {
  const { t: t3 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  if (!actionManager.isActionEnabled(actionSaveToActiveFile)) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
    DropdownMenuItem_default,
    {
      shortcut: getShortcutFromShortcutName("saveScene"),
      "data-testid": "save-button",
      onSelect: () => actionManager.executeAction(actionSaveToActiveFile),
      icon: save,
      "aria-label": `${t3("buttons.save")}`,
      children: `${t3("buttons.save")}`
    }
  );
};
SaveToActiveFile.displayName = "SaveToActiveFile";
var SaveAsImage = () => {
  const setAppState = useExcalidrawSetAppState();
  const { t: t3 } = useI18n();
  return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
    DropdownMenuItem_default,
    {
      icon: ExportImageIcon,
      "data-testid": "image-export-button",
      onSelect: () => setAppState({ openDialog: { name: "imageExport" } }),
      shortcut: getShortcutFromShortcutName("imageExport"),
      "aria-label": t3("buttons.exportImage"),
      children: t3("buttons.exportImage")
    }
  );
};
SaveAsImage.displayName = "SaveAsImage";
var CommandPalette2 = (opts) => {
  const setAppState = useExcalidrawSetAppState();
  const { t: t3 } = useI18n();
  return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
    DropdownMenuItem_default,
    {
      icon: boltIcon,
      "data-testid": "command-palette-button",
      onSelect: () => {
        trackEvent("command_palette", "open", "menu");
        setAppState({ openDialog: { name: "commandPalette" } });
      },
      shortcut: getShortcutFromShortcutName("commandPalette"),
      "aria-label": t3("commandPalette.title"),
      className: opts?.className,
      children: t3("commandPalette.title")
    }
  );
};
CommandPalette2.displayName = "CommandPalette";
var SearchMenu = (opts) => {
  const { t: t3 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
    DropdownMenuItem_default,
    {
      icon: searchIcon,
      "data-testid": "search-menu-button",
      onSelect: () => {
        actionManager.executeAction(actionToggleSearchMenu);
      },
      shortcut: getShortcutFromShortcutName("searchMenu"),
      "aria-label": t3("search.title"),
      className: opts?.className,
      children: t3("search.title")
    }
  );
};
SearchMenu.displayName = "SearchMenu";
var Help = () => {
  const { t: t3 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
    DropdownMenuItem_default,
    {
      "data-testid": "help-menu-item",
      icon: HelpIcon,
      onSelect: () => actionManager.executeAction(actionShortcuts),
      shortcut: "?",
      "aria-label": t3("helpDialog.title"),
      children: t3("helpDialog.title")
    }
  );
};
Help.displayName = "Help";
var ClearCanvas = () => {
  const { t: t3 } = useI18n();
  const setActiveConfirmDialog = useSetAtom(
    activeConfirmDialogAtom,
    jotaiScope
  );
  const actionManager = useExcalidrawActionManager();
  if (!actionManager.isActionEnabled(actionClearCanvas)) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
    DropdownMenuItem_default,
    {
      icon: TrashIcon,
      onSelect: () => setActiveConfirmDialog("clearCanvas"),
      "data-testid": "clear-canvas-button",
      "aria-label": t3("buttons.clearReset"),
      children: t3("buttons.clearReset")
    }
  );
};
ClearCanvas.displayName = "ClearCanvas";
var ToggleTheme = (props) => {
  const { t: t3 } = useI18n();
  const appState = useUIAppState();
  const actionManager = useExcalidrawActionManager();
  const shortcut = getShortcutFromShortcutName("toggleTheme");
  if (!actionManager.isActionEnabled(actionToggleTheme)) {
    return null;
  }
  if (props?.allowSystemTheme) {
    return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
      DropdownMenuItemContentRadio_default,
      {
        name: "theme",
        value: props.theme,
        onChange: (value) => props.onSelect(value),
        choices: [
          {
            value: THEME.LIGHT,
            label: SunIcon,
            ariaLabel: `${t3("buttons.lightMode")} - ${shortcut}`
          },
          {
            value: THEME.DARK,
            label: MoonIcon,
            ariaLabel: `${t3("buttons.darkMode")} - ${shortcut}`
          },
          {
            value: "system",
            label: DeviceDesktopIcon,
            ariaLabel: t3("buttons.systemMode")
          }
        ],
        children: t3("labels.theme")
      }
    );
  }
  return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
    DropdownMenuItem_default,
    {
      onSelect: (event) => {
        event.preventDefault();
        if (props?.onSelect) {
          props.onSelect(
            appState.theme === THEME.DARK ? THEME.LIGHT : THEME.DARK
          );
        } else {
          return actionManager.executeAction(actionToggleTheme);
        }
      },
      icon: appState.theme === THEME.DARK ? SunIcon : MoonIcon,
      "data-testid": "toggle-dark-mode",
      shortcut,
      "aria-label": appState.theme === THEME.DARK ? t3("buttons.lightMode") : t3("buttons.darkMode"),
      children: appState.theme === THEME.DARK ? t3("buttons.lightMode") : t3("buttons.darkMode")
    }
  );
};
ToggleTheme.displayName = "ToggleTheme";
var ChangeCanvasBackground = () => {
  const { t: t3 } = useI18n();
  const appState = useUIAppState();
  const actionManager = useExcalidrawActionManager();
  const appProps = useAppProps();
  if (appState.viewModeEnabled || !appProps.UIOptions.canvasActions.changeViewBackgroundColor) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime105.jsxs)("div", { style: { marginTop: "0.5rem" }, children: [
    /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
      "div",
      {
        "data-testid": "canvas-background-label",
        style: { fontSize: ".75rem", marginBottom: ".5rem" },
        children: t3("labels.canvasBackground")
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime105.jsx)("div", { style: { padding: "0 0.625rem" }, children: actionManager.renderAction("changeViewBackgroundColor") })
  ] });
};
ChangeCanvasBackground.displayName = "ChangeCanvasBackground";
var Export = () => {
  const { t: t3 } = useI18n();
  const setAppState = useExcalidrawSetAppState();
  return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
    DropdownMenuItem_default,
    {
      icon: ExportIcon,
      onSelect: () => {
        setAppState({ openDialog: { name: "jsonExport" } });
      },
      "data-testid": "json-export-button",
      "aria-label": t3("buttons.export"),
      children: t3("buttons.export")
    }
  );
};
Export.displayName = "Export";
var Socials = () => {
  const { t: t3 } = useI18n();
  return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(import_jsx_runtime105.Fragment, {});
};
Socials.displayName = "Socials";
var LiveCollaborationTrigger = ({
  onSelect,
  isCollaborating
}) => {
  const { t: t3 } = useI18n();
  return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
    DropdownMenuItem_default,
    {
      "data-testid": "collab-button",
      icon: usersIcon,
      className: clsx_m_default({
        "active-collab": isCollaborating
      }),
      onSelect,
      children: t3("labels.liveCollaboration")
    }
  );
};
LiveCollaborationTrigger.displayName = "LiveCollaborationTrigger";

// components/hoc/withInternalFallback.tsx
init_define_import_meta_env();
var import_react96 = __toESM(require_react(), 1);
var import_jsx_runtime106 = __toESM(require_jsx_runtime(), 1);
var withInternalFallback = (componentName, Component) => {
  const renderAtom = atom2(0);
  const WrapperComponent = (props) => {
    const { jotaiScope: jotaiScope2 } = useTunnels();
    const [, setCounter] = useAtom(renderAtom, jotaiScope2);
    const metaRef = (0, import_react96.useRef)({
      // flag set on initial render to tell the fallback component to skip the
      // render until mount counter are initialized. This is because the counter
      // is initialized in an effect, and thus we could end rendering both
      // components at the same time until counter is initialized.
      preferHost: false,
      counter: 0
    });
    (0, import_react96.useLayoutEffect)(() => {
      const meta = metaRef.current;
      setCounter((c3) => {
        const next = c3 + 1;
        meta.counter = next;
        return next;
      });
      return () => {
        setCounter((c3) => {
          const next = c3 - 1;
          meta.counter = next;
          if (!next) {
            meta.preferHost = false;
          }
          return next;
        });
      };
    }, [setCounter]);
    if (!props.__fallback) {
      metaRef.current.preferHost = true;
    }
    if (
      // either before the counters are initialized
      !metaRef.current.counter && props.__fallback && metaRef.current.preferHost || // or after the counters are initialized, and both are rendered
      // (this is the default when host renders as well)
      metaRef.current.counter > 1 && props.__fallback
    ) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(Component, { ...props });
  };
  WrapperComponent.displayName = componentName;
  return WrapperComponent;
};

// components/main-menu/MainMenu.tsx
var import_jsx_runtime107 = __toESM(require_jsx_runtime(), 1);
var MainMenu = Object.assign(
  withInternalFallback(
    "MainMenu",
    ({
      children,
      onSelect
    }) => {
      const { MainMenuTunnel } = useTunnels();
      const device = useDevice();
      const appState = useUIAppState();
      const setAppState = useExcalidrawSetAppState();
      const onClickOutside = device.editor.isMobile ? void 0 : () => setAppState({ openMenu: null });
      return /* @__PURE__ */ (0, import_jsx_runtime107.jsx)(MainMenuTunnel.In, { children: /* @__PURE__ */ (0, import_jsx_runtime107.jsxs)(DropdownMenu_default, { open: appState.openMenu === "canvas", children: [
        /* @__PURE__ */ (0, import_jsx_runtime107.jsx)(
          DropdownMenu_default.Trigger,
          {
            onToggle: () => {
              setAppState({
                openMenu: appState.openMenu === "canvas" ? null : "canvas"
              });
            },
            "data-testid": "main-menu-trigger",
            className: "main-menu-trigger",
            children: HamburgerMenuIcon
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime107.jsxs)(
          DropdownMenu_default.Content,
          {
            onClickOutside,
            onSelect: composeEventHandlers(onSelect, () => {
              setAppState({ openMenu: null });
            }),
            children: [
              children,
              device.editor.isMobile && appState.collaborators.size > 0 && /* @__PURE__ */ (0, import_jsx_runtime107.jsxs)("fieldset", { className: "UserList-Wrapper", children: [
                /* @__PURE__ */ (0, import_jsx_runtime107.jsx)("legend", { children: t("labels.collaborators") }),
                /* @__PURE__ */ (0, import_jsx_runtime107.jsx)(
                  UserList,
                  {
                    mobile: true,
                    collaborators: appState.collaborators,
                    userToFollow: appState.userToFollow?.socketId || null
                  }
                )
              ] })
            ]
          }
        )
      ] }) });
    }
  ),
  {
    Trigger: DropdownMenu_default.Trigger,
    Item: DropdownMenu_default.Item,
    ItemLink: DropdownMenu_default.ItemLink,
    ItemCustom: DropdownMenu_default.ItemCustom,
    Group: DropdownMenu_default.Group,
    Separator: DropdownMenu_default.Separator,
    DefaultItems: DefaultItems_exports
  }
);
var MainMenu_default = MainMenu;

// components/OverwriteConfirm/OverwriteConfirm.tsx
init_define_import_meta_env();

// components/OverwriteConfirm/OverwriteConfirmActions.tsx
init_define_import_meta_env();
var import_jsx_runtime108 = __toESM(require_jsx_runtime(), 1);
var Action = ({
  title,
  children,
  actionLabel,
  onClick
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime108.jsxs)("div", { className: "OverwriteConfirm__Actions__Action", children: [
    /* @__PURE__ */ (0, import_jsx_runtime108.jsx)("h4", { children: title }),
    /* @__PURE__ */ (0, import_jsx_runtime108.jsx)("div", { className: "OverwriteConfirm__Actions__Action__content", children }),
    /* @__PURE__ */ (0, import_jsx_runtime108.jsx)(
      FilledButton,
      {
        variant: "outlined",
        color: "muted",
        label: actionLabel,
        size: "large",
        fullWidth: true,
        onClick
      }
    )
  ] });
};
var ExportToImage = () => {
  const { t: t3 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  const setAppState = useExcalidrawSetAppState();
  return /* @__PURE__ */ (0, import_jsx_runtime108.jsx)(
    Action,
    {
      title: t3("overwriteConfirm.action.exportToImage.title"),
      actionLabel: t3("overwriteConfirm.action.exportToImage.button"),
      onClick: () => {
        actionManager.executeAction(actionChangeExportEmbedScene, "ui", true);
        setAppState({ openDialog: { name: "imageExport" } });
      },
      children: t3("overwriteConfirm.action.exportToImage.description")
    }
  );
};
var SaveToDisk = () => {
  const { t: t3 } = useI18n();
  const actionManager = useExcalidrawActionManager();
  return /* @__PURE__ */ (0, import_jsx_runtime108.jsx)(
    Action,
    {
      title: t3("overwriteConfirm.action.saveToDisk.title"),
      actionLabel: t3("overwriteConfirm.action.saveToDisk.button"),
      onClick: () => {
        actionManager.executeAction(actionSaveFileToDisk, "ui");
      },
      children: t3("overwriteConfirm.action.saveToDisk.description")
    }
  );
};
var Actions = Object.assign(
  ({ children }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime108.jsx)("div", { className: "OverwriteConfirm__Actions", children });
  },
  {
    ExportToImage,
    SaveToDisk
  }
);

// components/OverwriteConfirm/OverwriteConfirm.tsx
var import_jsx_runtime109 = __toESM(require_jsx_runtime(), 1);
var OverwriteConfirmDialog = Object.assign(
  withInternalFallback(
    "OverwriteConfirmDialog",
    ({ children }) => {
      const { OverwriteConfirmDialogTunnel } = useTunnels();
      const [overwriteConfirmState, setState] = useAtom(
        overwriteConfirmStateAtom,
        jotaiScope
      );
      if (!overwriteConfirmState.active) {
        return null;
      }
      const handleClose = () => {
        overwriteConfirmState.onClose();
        setState((state) => ({ ...state, active: false }));
      };
      const handleConfirm = () => {
        overwriteConfirmState.onConfirm();
        setState((state) => ({ ...state, active: false }));
      };
      return /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(OverwriteConfirmDialogTunnel.In, { children: /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(Dialog, { onCloseRequest: handleClose, title: false, size: 916, children: /* @__PURE__ */ (0, import_jsx_runtime109.jsxs)("div", { className: "OverwriteConfirm", children: [
        /* @__PURE__ */ (0, import_jsx_runtime109.jsx)("h3", { children: overwriteConfirmState.title }),
        /* @__PURE__ */ (0, import_jsx_runtime109.jsxs)(
          "div",
          {
            className: `OverwriteConfirm__Description OverwriteConfirm__Description--color-${overwriteConfirmState.color}`,
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime109.jsx)("div", { className: "OverwriteConfirm__Description__icon", children: alertTriangleIcon }),
              /* @__PURE__ */ (0, import_jsx_runtime109.jsx)("div", { children: overwriteConfirmState.description }),
              /* @__PURE__ */ (0, import_jsx_runtime109.jsx)("div", { className: "OverwriteConfirm__Description__spacer" }),
              /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(
                FilledButton,
                {
                  color: overwriteConfirmState.color,
                  size: "large",
                  label: overwriteConfirmState.actionLabel,
                  onClick: handleConfirm
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(Actions, { children })
      ] }) }) });
    }
  ),
  {
    Actions,
    Action
  }
);

// components/DefaultSidebar.tsx
init_define_import_meta_env();

// components/SearchMenu.tsx
init_define_import_meta_env();
var import_react97 = __toESM(require_react(), 1);
var import_lodash2 = __toESM(require_lodash2(), 1);
var import_jsx_runtime110 = __toESM(require_jsx_runtime(), 1);
var searchQueryAtom = atom2("");
var searchItemInFocusAtom = atom2(null);
var SEARCH_DEBOUNCE = 350;
var SearchMenu2 = () => {
  const app = useApp();
  const setAppState = useExcalidrawSetAppState();
  const searchInputRef = (0, import_react97.useRef)(null);
  const [inputValue, setInputValue] = useAtom(searchQueryAtom, jotaiScope);
  const searchQuery = inputValue.trim();
  const [isSearching, setIsSearching] = (0, import_react97.useState)(false);
  const [searchMatches, setSearchMatches] = (0, import_react97.useState)({
    nonce: null,
    items: []
  });
  const searchedQueryRef = (0, import_react97.useRef)(null);
  const lastSceneNonceRef = (0, import_react97.useRef)(void 0);
  const [focusIndex, setFocusIndex] = useAtom(
    searchItemInFocusAtom,
    jotaiScope
  );
  const elementsMap = app.scene.getNonDeletedElementsMap();
  (0, import_react97.useEffect)(() => {
    if (isSearching) {
      return;
    }
    if (searchQuery !== searchedQueryRef.current || app.scene.getSceneNonce() !== lastSceneNonceRef.current) {
      searchedQueryRef.current = null;
      handleSearch(searchQuery, app, (matchItems, index2) => {
        setSearchMatches({
          nonce: randomInteger(),
          items: matchItems
        });
        searchedQueryRef.current = searchQuery;
        lastSceneNonceRef.current = app.scene.getSceneNonce();
        setAppState({
          searchMatches: matchItems.map((searchMatch) => ({
            id: searchMatch.textElement.id,
            focus: false,
            matchedLines: searchMatch.matchedLines
          }))
        });
      });
    }
  }, [
    isSearching,
    searchQuery,
    elementsMap,
    app,
    setAppState,
    setFocusIndex,
    lastSceneNonceRef
  ]);
  const goToNextItem = () => {
    if (searchMatches.items.length > 0) {
      setFocusIndex((focusIndex2) => {
        if (focusIndex2 === null) {
          return 0;
        }
        return (focusIndex2 + 1) % searchMatches.items.length;
      });
    }
  };
  const goToPreviousItem = () => {
    if (searchMatches.items.length > 0) {
      setFocusIndex((focusIndex2) => {
        if (focusIndex2 === null) {
          return 0;
        }
        return focusIndex2 - 1 < 0 ? searchMatches.items.length - 1 : focusIndex2 - 1;
      });
    }
  };
  (0, import_react97.useEffect)(() => {
    setAppState((state) => {
      return {
        searchMatches: state.searchMatches.map((match, index2) => {
          if (index2 === focusIndex) {
            return { ...match, focus: true };
          }
          return { ...match, focus: false };
        })
      };
    });
  }, [focusIndex, setAppState]);
  (0, import_react97.useEffect)(() => {
    if (searchMatches.items.length > 0 && focusIndex !== null) {
      const match = searchMatches.items[focusIndex];
      if (match) {
        const zoomValue = app.state.zoom.value;
        const matchAsElement = newTextElement({
          text: match.searchQuery,
          x: match.textElement.x + (match.matchedLines[0]?.offsetX ?? 0),
          y: match.textElement.y + (match.matchedLines[0]?.offsetY ?? 0),
          width: match.matchedLines[0]?.width,
          height: match.matchedLines[0]?.height,
          fontSize: match.textElement.fontSize,
          fontFamily: match.textElement.fontFamily
        });
        const FONT_SIZE_LEGIBILITY_THRESHOLD = 14;
        const fontSize = match.textElement.fontSize;
        const isTextTiny = fontSize * zoomValue < FONT_SIZE_LEGIBILITY_THRESHOLD;
        if (!isElementCompletelyInViewport(
          [matchAsElement],
          app.canvas.width / window.devicePixelRatio,
          app.canvas.height / window.devicePixelRatio,
          {
            offsetLeft: app.state.offsetLeft,
            offsetTop: app.state.offsetTop,
            scrollX: app.state.scrollX,
            scrollY: app.state.scrollY,
            zoom: app.state.zoom
          },
          app.scene.getNonDeletedElementsMap(),
          app.getEditorUIOffsets()
        ) || isTextTiny) {
          let zoomOptions;
          if (isTextTiny) {
            if (fontSize >= FONT_SIZE_LEGIBILITY_THRESHOLD) {
              zoomOptions = { fitToContent: true };
            } else {
              zoomOptions = {
                fitToViewport: true,
                // calculate zoom level to make the fontSize ~equal to FONT_SIZE_THRESHOLD, rounded to nearest 10%
                maxZoom: round(FONT_SIZE_LEGIBILITY_THRESHOLD / fontSize, 1)
              };
            }
          } else {
            zoomOptions = { fitToContent: true };
          }
          app.scrollToContent(matchAsElement, {
            animate: true,
            duration: 300,
            ...zoomOptions,
            canvasOffsets: app.getEditorUIOffsets()
          });
        }
      }
    }
  }, [focusIndex, searchMatches, app]);
  (0, import_react97.useEffect)(() => {
    return () => {
      setFocusIndex(null);
      searchedQueryRef.current = null;
      lastSceneNonceRef.current = void 0;
      setAppState({
        searchMatches: []
      });
      setIsSearching(false);
    };
  }, [setAppState, setFocusIndex]);
  const stableState = useStable({
    goToNextItem,
    goToPreviousItem,
    searchMatches
  });
  (0, import_react97.useEffect)(() => {
    const eventHandler = (event) => {
      if (event.key === KEYS.ESCAPE && !app.state.openDialog && !app.state.openPopup) {
        event.preventDefault();
        event.stopPropagation();
        setAppState({
          openSidebar: null
        });
        return;
      }
      if (event[KEYS.CTRL_OR_CMD] && event.key === KEYS.F) {
        event.preventDefault();
        event.stopPropagation();
        if (!searchInputRef.current?.matches(":focus")) {
          if (app.state.openDialog) {
            setAppState({
              openDialog: null
            });
          }
          searchInputRef.current?.focus();
          searchInputRef.current?.select();
        } else {
          setAppState({
            openSidebar: null
          });
        }
      }
      if (event.target instanceof HTMLElement && event.target.closest(".layer-ui__search")) {
        if (stableState.searchMatches.items.length) {
          if (event.key === KEYS.ENTER) {
            event.stopPropagation();
            stableState.goToNextItem();
          }
          if (event.key === KEYS.ARROW_UP) {
            event.stopPropagation();
            stableState.goToPreviousItem();
          } else if (event.key === KEYS.ARROW_DOWN) {
            event.stopPropagation();
            stableState.goToNextItem();
          }
        }
      }
    };
    return addEventListener(window, "keydown" /* KEYDOWN */, eventHandler, {
      capture: true
    });
  }, [setAppState, stableState, app]);
  const matchCount = `${searchMatches.items.length} ${searchMatches.items.length === 1 ? t("search.singleResult") : t("search.multipleResults")}`;
  return /* @__PURE__ */ (0, import_jsx_runtime110.jsxs)("div", { className: "layer-ui__search", children: [
    /* @__PURE__ */ (0, import_jsx_runtime110.jsx)("div", { className: "layer-ui__search-header", children: /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(
      TextField,
      {
        className: CLASSES.SEARCH_MENU_INPUT_WRAPPER,
        value: inputValue,
        ref: searchInputRef,
        placeholder: t("search.placeholder"),
        icon: searchIcon,
        onChange: (value) => {
          setInputValue(value);
          setIsSearching(true);
          const searchQuery2 = value.trim();
          handleSearch(searchQuery2, app, (matchItems, index2) => {
            setSearchMatches({
              nonce: randomInteger(),
              items: matchItems
            });
            setFocusIndex(index2);
            searchedQueryRef.current = searchQuery2;
            lastSceneNonceRef.current = app.scene.getSceneNonce();
            setAppState({
              searchMatches: matchItems.map((searchMatch) => ({
                id: searchMatch.textElement.id,
                focus: false,
                matchedLines: searchMatch.matchedLines
              }))
            });
            setIsSearching(false);
          });
        },
        selectOnRender: true
      }
    ) }),
    /* @__PURE__ */ (0, import_jsx_runtime110.jsxs)("div", { className: "layer-ui__search-count", children: [
      searchMatches.items.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime110.jsxs)(import_jsx_runtime110.Fragment, { children: [
        focusIndex !== null && focusIndex > -1 ? /* @__PURE__ */ (0, import_jsx_runtime110.jsxs)("div", { children: [
          focusIndex + 1,
          " / ",
          matchCount
        ] }) : /* @__PURE__ */ (0, import_jsx_runtime110.jsx)("div", { children: matchCount }),
        /* @__PURE__ */ (0, import_jsx_runtime110.jsxs)("div", { className: "result-nav", children: [
          /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(
            Button,
            {
              onSelect: () => {
                goToNextItem();
              },
              className: "result-nav-btn",
              children: collapseDownIcon
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(
            Button,
            {
              onSelect: () => {
                goToPreviousItem();
              },
              className: "result-nav-btn",
              children: upIcon
            }
          )
        ] })
      ] }),
      searchMatches.items.length === 0 && searchQuery && searchedQueryRef.current && /* @__PURE__ */ (0, import_jsx_runtime110.jsx)("div", { style: { margin: "1rem auto" }, children: t("search.noMatch") })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(
      MatchList,
      {
        matches: searchMatches,
        onItemClick: setFocusIndex,
        focusIndex,
        searchQuery
      }
    )
  ] });
};
var ListItem = (props) => {
  const preview = [
    props.preview.moreBefore ? "..." : "",
    props.preview.previewText.slice(0, props.preview.indexInSearchQuery),
    props.preview.previewText.slice(
      props.preview.indexInSearchQuery,
      props.preview.indexInSearchQuery + props.searchQuery.length
    ),
    props.preview.previewText.slice(
      props.preview.indexInSearchQuery + props.searchQuery.length
    ),
    props.preview.moreAfter ? "..." : ""
  ];
  return /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(
    "div",
    {
      tabIndex: -1,
      className: clsx_m_default("layer-ui__result-item", {
        active: props.highlighted
      }),
      onClick: props.onClick,
      ref: (ref) => {
        if (props.highlighted) {
          ref?.scrollIntoView({ behavior: "auto", block: "nearest" });
        }
      },
      children: /* @__PURE__ */ (0, import_jsx_runtime110.jsx)("div", { className: "preview-text", children: preview.flatMap((text, idx) => /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(import_react97.Fragment, { children: idx === 2 ? /* @__PURE__ */ (0, import_jsx_runtime110.jsx)("b", { children: text }) : text }, idx)) })
    }
  );
};
var MatchListBase = (props) => {
  return /* @__PURE__ */ (0, import_jsx_runtime110.jsx)("div", { className: "layer-ui__search-result-container", children: props.matches.items.map((searchMatch, index2) => /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(
    ListItem,
    {
      searchQuery: props.searchQuery,
      preview: searchMatch.preview,
      highlighted: index2 === props.focusIndex,
      onClick: () => props.onItemClick(index2)
    },
    searchMatch.textElement.id + searchMatch.index
  )) });
};
var areEqual = (prevProps, nextProps) => {
  return prevProps.matches.nonce === nextProps.matches.nonce && prevProps.focusIndex === nextProps.focusIndex;
};
var MatchList = (0, import_react97.memo)(MatchListBase, areEqual);
var getMatchPreview = (text, index2, searchQuery) => {
  const WORDS_BEFORE = 2;
  const WORDS_AFTER = 5;
  const substrBeforeQuery = text.slice(0, index2);
  const wordsBeforeQuery = substrBeforeQuery.split(/\s+/);
  const isQueryCompleteBefore = substrBeforeQuery.endsWith(" ");
  const startWordIndex = wordsBeforeQuery.length - WORDS_BEFORE - 1 - (isQueryCompleteBefore ? 0 : 1);
  let wordsBeforeAsString = wordsBeforeQuery.slice(startWordIndex <= 0 ? 0 : startWordIndex).join(" ") + (isQueryCompleteBefore ? " " : "");
  const MAX_ALLOWED_CHARS = 20;
  wordsBeforeAsString = wordsBeforeAsString.length > MAX_ALLOWED_CHARS ? wordsBeforeAsString.slice(-MAX_ALLOWED_CHARS) : wordsBeforeAsString;
  const substrAfterQuery = text.slice(index2 + searchQuery.length);
  const wordsAfter = substrAfterQuery.split(/\s+/);
  const isQueryCompleteAfter = !substrAfterQuery.startsWith(" ");
  const numberOfWordsToTake = isQueryCompleteAfter ? WORDS_AFTER + 1 : WORDS_AFTER;
  const wordsAfterAsString = (isQueryCompleteAfter ? "" : " ") + wordsAfter.slice(0, numberOfWordsToTake).join(" ");
  return {
    indexInSearchQuery: wordsBeforeAsString.length,
    previewText: wordsBeforeAsString + searchQuery + wordsAfterAsString,
    moreBefore: startWordIndex > 0,
    moreAfter: wordsAfter.length > numberOfWordsToTake
  };
};
var normalizeWrappedText = (wrappedText, originalText) => {
  const wrappedLines = wrappedText.split("\n");
  const normalizedLines = [];
  let originalIndex = 0;
  for (let i3 = 0; i3 < wrappedLines.length; i3++) {
    let currentLine = wrappedLines[i3];
    const nextLine = wrappedLines[i3 + 1];
    if (nextLine) {
      const nextLineIndexInOriginal = originalText.indexOf(
        nextLine,
        originalIndex
      );
      if (nextLineIndexInOriginal > currentLine.length + originalIndex) {
        let j = nextLineIndexInOriginal - (currentLine.length + originalIndex);
        while (j > 0) {
          currentLine += " ";
          j--;
        }
      }
    }
    normalizedLines.push(currentLine);
    originalIndex = originalIndex + currentLine.length;
  }
  return normalizedLines.join("\n");
};
var getMatchedLines = (textElement, searchQuery, index2) => {
  const normalizedText = normalizeWrappedText(
    textElement.text,
    textElement.originalText
  );
  const lines = normalizedText.split("\n");
  const lineIndexRanges = [];
  let currentIndex = 0;
  let lineNumber = 0;
  for (const line of lines) {
    const startIndex2 = currentIndex;
    const endIndex = startIndex2 + line.length - 1;
    lineIndexRanges.push({
      line,
      startIndex: startIndex2,
      endIndex,
      lineNumber
    });
    currentIndex = endIndex + 1;
    lineNumber++;
  }
  let startIndex = index2;
  let remainingQuery = textElement.originalText.slice(
    index2,
    index2 + searchQuery.length
  );
  const matchedLines = [];
  for (const lineIndexRange of lineIndexRanges) {
    if (remainingQuery === "") {
      break;
    }
    if (startIndex >= lineIndexRange.startIndex && startIndex <= lineIndexRange.endIndex) {
      const matchCapacity = lineIndexRange.endIndex + 1 - startIndex;
      const textToStart = lineIndexRange.line.slice(
        0,
        startIndex - lineIndexRange.startIndex
      );
      const matchedWord = remainingQuery.slice(0, matchCapacity);
      remainingQuery = remainingQuery.slice(matchCapacity);
      const offset = measureText(
        textToStart,
        getFontString(textElement),
        textElement.lineHeight,
        true
      );
      if (textToStart === "") {
        offset.width = 0;
      }
      if (textElement.textAlign !== "left" && lineIndexRange.line.length > 0) {
        const lineLength = measureText(
          lineIndexRange.line,
          getFontString(textElement),
          textElement.lineHeight,
          true
        );
        const spaceToStart = textElement.textAlign === "center" ? (textElement.width - lineLength.width) / 2 : textElement.width - lineLength.width;
        offset.width += spaceToStart;
      }
      const { width, height } = measureText(
        matchedWord,
        getFontString(textElement),
        textElement.lineHeight
      );
      const offsetX = offset.width;
      const offsetY = lineIndexRange.lineNumber * offset.height;
      matchedLines.push({
        offsetX,
        offsetY,
        width,
        height
      });
      startIndex += matchCapacity;
    }
  }
  return matchedLines;
};
var escapeSpecialCharacters = (string) => {
  return string.replace(/[.*+?^${}()|[\]\\-]/g, "\\$&");
};
var handleSearch = (0, import_lodash2.debounce)(
  (searchQuery, app, cb) => {
    if (!searchQuery || searchQuery === "") {
      cb([], null);
      return;
    }
    const elements = app.scene.getNonDeletedElements();
    const texts = elements.filter(
      (el) => isTextElement(el)
    );
    texts.sort((a3, b3) => a3.y - b3.y);
    const matchItems = [];
    const regex = new RegExp(escapeSpecialCharacters(searchQuery), "gi");
    for (const textEl of texts) {
      let match = null;
      const text = textEl.originalText;
      while ((match = regex.exec(text)) !== null) {
        const preview = getMatchPreview(text, match.index, searchQuery);
        const matchedLines = getMatchedLines(textEl, searchQuery, match.index);
        if (matchedLines.length > 0) {
          matchItems.push({
            textElement: textEl,
            searchQuery,
            preview,
            index: match.index,
            matchedLines
          });
        }
      }
    }
    const visibleIds = new Set(
      app.visibleElements.map((visibleElement) => visibleElement.id)
    );
    const focusIndex = matchItems.findIndex(
      (matchItem) => visibleIds.has(matchItem.textElement.id)
    ) ?? null;
    cb(matchItems, focusIndex);
  },
  SEARCH_DEBOUNCE
);

// components/DefaultSidebar.tsx
var import_jsx_runtime111 = __toESM(require_jsx_runtime(), 1);
var import_react98 = __toESM(require_react(), 1);
var DefaultSidebarTrigger = withInternalFallback(
  "DefaultSidebarTrigger",
  (props) => {
    const { DefaultSidebarTriggerTunnel } = useTunnels();
    return /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(DefaultSidebarTriggerTunnel.In, { children: /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(
      Sidebar.Trigger,
      {
        ...props,
        className: "default-sidebar-trigger",
        name: DEFAULT_SIDEBAR.name
      }
    ) });
  }
);
DefaultSidebarTrigger.displayName = "DefaultSidebarTrigger";
var DefaultTabTriggers = ({ children }) => {
  const { DefaultSidebarTabTriggersTunnel } = useTunnels();
  return /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(DefaultSidebarTabTriggersTunnel.In, { children });
};
DefaultTabTriggers.displayName = "DefaultTabTriggers";
var DefaultSidebar = Object.assign(
  withInternalFallback(
    "DefaultSidebar",
    ({
      children,
      className,
      onDock,
      docked,
      ...rest
    }) => {
      const appState = useUIAppState();
      const setAppState = useExcalidrawSetAppState();
      const { DefaultSidebarTabTriggersTunnel } = useTunnels();
      const isForceDocked = appState.openSidebar?.tab === CANVAS_SEARCH_TAB;
      return /* @__PURE__ */ (0, import_react98.createElement)(
        Sidebar,
        {
          ...rest,
          name: "default",
          key: "default",
          className: clsx_m_default("default-sidebar", className),
          docked: isForceDocked || (docked ?? appState.defaultSidebarDockedPreference),
          onDock: (
            // `onDock=false` disables docking.
            // if `docked` passed, but no onDock passed, disable manual docking.
            isForceDocked || onDock === false || !onDock && docked != null ? void 0 : (
              // compose to allow the host app to listen on default behavior
              composeEventHandlers(onDock, (docked2) => {
                setAppState({ defaultSidebarDockedPreference: docked2 });
              })
            )
          )
        },
        /* @__PURE__ */ (0, import_jsx_runtime111.jsxs)(Sidebar.Tabs, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(Sidebar.Header, { children: /* @__PURE__ */ (0, import_jsx_runtime111.jsxs)(Sidebar.TabTriggers, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(Sidebar.TabTrigger, { tab: CANVAS_SEARCH_TAB, children: searchIcon }),
            /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(Sidebar.TabTrigger, { tab: LIBRARY_SIDEBAR_TAB, children: LibraryIcon }),
            /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(DefaultSidebarTabTriggersTunnel.Out, {})
          ] }) }),
          /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(Sidebar.Tab, { tab: LIBRARY_SIDEBAR_TAB, children: /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(LibraryMenu, {}) }),
          /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(Sidebar.Tab, { tab: CANVAS_SEARCH_TAB, children: /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(SearchMenu2, {}) }),
          children
        ] })
      );
    }
  ),
  {
    Trigger: DefaultSidebarTrigger,
    TabTriggers: DefaultTabTriggers
  }
);

// components/LaserPointerButton.tsx
init_define_import_meta_env();
var import_jsx_runtime112 = __toESM(require_jsx_runtime(), 1);
var DEFAULT_SIZE3 = "small";
var LaserPointerButton = (props) => {
  return /* @__PURE__ */ (0, import_jsx_runtime112.jsxs)(
    "label",
    {
      className: clsx_m_default(
        "ToolIcon ToolIcon__LaserPointer",
        `ToolIcon_size_${DEFAULT_SIZE3}`,
        {
          "is-mobile": props.isMobile
        }
      ),
      title: `${props.title}`,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(
          "input",
          {
            className: "ToolIcon_type_checkbox",
            type: "checkbox",
            name: props.name,
            onChange: props.onChange,
            checked: props.checked,
            "aria-label": props.title,
            "data-testid": "toolbar-LaserPointer"
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime112.jsx)("div", { className: "ToolIcon__icon", children: laserPointerToolIcon })
      ]
    }
  );
};

// components/TTDDialog/TTDDialog.tsx
init_define_import_meta_env();

// components/TTDDialog/MermaidToExcalidraw.tsx
init_define_import_meta_env();
var import_react100 = __toESM(require_react(), 1);

// components/TTDDialog/common.ts
init_define_import_meta_env();
var resetPreview = ({
  canvasRef,
  setError
}) => {
  const canvasNode = canvasRef.current;
  if (!canvasNode) {
    return;
  }
  const parent = canvasNode.parentElement;
  if (!parent) {
    return;
  }
  parent.style.background = "";
  setError(null);
  canvasNode.replaceChildren();
};
var convertMermaidToExcalidraw = async ({
  canvasRef,
  mermaidToExcalidrawLib,
  mermaidDefinition,
  setError,
  data
}) => {
  const canvasNode = canvasRef.current;
  const parent = canvasNode?.parentElement;
  if (!canvasNode || !parent) {
    return;
  }
  if (!mermaidDefinition) {
    resetPreview({ canvasRef, setError });
    return;
  }
  try {
    const api = await mermaidToExcalidrawLib.api;
    let ret;
    try {
      ret = await api.parseMermaidToExcalidraw(mermaidDefinition);
    } catch (err) {
      ret = await api.parseMermaidToExcalidraw(
        mermaidDefinition.replace(/"/g, "'")
      );
    }
    const { elements, files } = ret;
    setError(null);
    data.current = {
      elements: convertToExcalidrawElements(elements, {
        regenerateIds: true
      }),
      files
    };
    const canvas = await exportToCanvas2({
      elements: data.current.elements,
      files: data.current.files,
      exportPadding: DEFAULT_EXPORT_PADDING,
      maxWidthOrHeight: Math.max(parent.offsetWidth, parent.offsetHeight) * window.devicePixelRatio
    });
    try {
      await canvasToBlob(canvas);
    } catch (e3) {
      if (e3.name === "CANVAS_POSSIBLY_TOO_BIG") {
        throw new Error(t("canvasError.canvasTooBig"));
      }
      throw e3;
    }
    parent.style.background = "var(--default-bg-color)";
    canvasNode.replaceChildren(canvas);
  } catch (err) {
    parent.style.background = "var(--default-bg-color)";
    if (mermaidDefinition) {
      setError(err);
    }
    throw err;
  }
};
var saveMermaidDataToStorage = (mermaidDefinition) => {
  EditorLocalStorage.set(
    EDITOR_LS_KEYS.MERMAID_TO_EXCALIDRAW,
    mermaidDefinition
  );
};
var insertToEditor = ({
  app,
  data,
  text,
  shouldSaveMermaidDataToStorage
}) => {
  const { elements: newElements, files } = data.current;
  if (!newElements.length) {
    return;
  }
  app.addElementsFromPasteOrLibrary({
    elements: newElements,
    files,
    position: "center",
    fitToContent: true
  });
  app.setOpenDialog(null);
  if (shouldSaveMermaidDataToStorage && text) {
    saveMermaidDataToStorage(text);
  }
};

// components/TTDDialog/TTDDialogPanels.tsx
init_define_import_meta_env();
var import_jsx_runtime113 = __toESM(require_jsx_runtime(), 1);
var TTDDialogPanels = ({ children }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime113.jsx)("div", { className: "ttd-dialog-panels", children });
};

// components/TTDDialog/TTDDialogPanel.tsx
init_define_import_meta_env();
var import_jsx_runtime114 = __toESM(require_jsx_runtime(), 1);
var TTDDialogPanel = ({
  label,
  children,
  panelAction,
  panelActionDisabled = false,
  onTextSubmitInProgess,
  renderTopRight,
  renderSubmitShortcut,
  renderBottomRight
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime114.jsxs)("div", { className: "ttd-dialog-panel", children: [
    /* @__PURE__ */ (0, import_jsx_runtime114.jsxs)("div", { className: "ttd-dialog-panel__header", children: [
      /* @__PURE__ */ (0, import_jsx_runtime114.jsx)("label", { children: label }),
      renderTopRight?.()
    ] }),
    children,
    /* @__PURE__ */ (0, import_jsx_runtime114.jsxs)(
      "div",
      {
        className: clsx_m_default("ttd-dialog-panel-button-container", {
          invisible: !panelAction
        }),
        style: { display: "flex", alignItems: "center" },
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime114.jsxs)(
            Button,
            {
              className: "ttd-dialog-panel-button",
              onSelect: panelAction ? panelAction.action : () => {
              },
              disabled: panelActionDisabled || onTextSubmitInProgess,
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime114.jsxs)("div", { className: clsx_m_default({ invisible: onTextSubmitInProgess }), children: [
                  panelAction?.label,
                  panelAction?.icon && /* @__PURE__ */ (0, import_jsx_runtime114.jsx)("span", { children: panelAction.icon })
                ] }),
                onTextSubmitInProgess && /* @__PURE__ */ (0, import_jsx_runtime114.jsx)(Spinner_default, {})
              ]
            }
          ),
          !panelActionDisabled && !onTextSubmitInProgess && renderSubmitShortcut?.(),
          renderBottomRight?.()
        ]
      }
    )
  ] });
};

// components/TTDDialog/TTDDialogInput.tsx
init_define_import_meta_env();
var import_react99 = __toESM(require_react(), 1);
var import_jsx_runtime115 = __toESM(require_jsx_runtime(), 1);
var TTDDialogInput = ({
  input,
  placeholder,
  onChange,
  onKeyboardSubmit
}) => {
  const ref = (0, import_react99.useRef)(null);
  const callbackRef = (0, import_react99.useRef)(onKeyboardSubmit);
  callbackRef.current = onKeyboardSubmit;
  (0, import_react99.useEffect)(() => {
    if (!callbackRef.current) {
      return;
    }
    const textarea = ref.current;
    if (textarea) {
      const handleKeyDown = (event) => {
        if (event[KEYS.CTRL_OR_CMD] && event.key === KEYS.ENTER) {
          event.preventDefault();
          callbackRef.current?.();
        }
      };
      textarea.addEventListener("keydown" /* KEYDOWN */, handleKeyDown);
      return () => {
        textarea.removeEventListener("keydown" /* KEYDOWN */, handleKeyDown);
      };
    }
  }, []);
  return /* @__PURE__ */ (0, import_jsx_runtime115.jsx)(
    "textarea",
    {
      className: "ttd-dialog-input",
      onChange,
      value: input,
      placeholder,
      autoFocus: true,
      ref
    }
  );
};

// components/TTDDialog/TTDDialogOutput.tsx
init_define_import_meta_env();
var import_jsx_runtime116 = __toESM(require_jsx_runtime(), 1);
var ErrorComp = ({ error }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime116.jsxs)(
    "div",
    {
      "data-testid": "ttd-dialog-output-error",
      className: "ttd-dialog-output-error",
      children: [
        "Error! ",
        /* @__PURE__ */ (0, import_jsx_runtime116.jsx)("p", { children: error })
      ]
    }
  );
};
var TTDDialogOutput = ({
  error,
  canvasRef,
  loaded
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime116.jsxs)("div", { className: "ttd-dialog-output-wrapper", children: [
    error && /* @__PURE__ */ (0, import_jsx_runtime116.jsx)(ErrorComp, { error: error.message }),
    loaded ? /* @__PURE__ */ (0, import_jsx_runtime116.jsx)(
      "div",
      {
        ref: canvasRef,
        style: { opacity: error ? "0.15" : 1 },
        className: "ttd-dialog-output-canvas-container"
      }
    ) : /* @__PURE__ */ (0, import_jsx_runtime116.jsx)(Spinner_default, { size: "2rem" })
  ] });
};

// components/TTDDialog/TTDDialogSubmitShortcut.tsx
init_define_import_meta_env();
var import_jsx_runtime117 = __toESM(require_jsx_runtime(), 1);
var TTDDialogSubmitShortcut = () => {
  return /* @__PURE__ */ (0, import_jsx_runtime117.jsxs)("div", { className: "ttd-dialog-submit-shortcut", children: [
    /* @__PURE__ */ (0, import_jsx_runtime117.jsx)("div", { className: "ttd-dialog-submit-shortcut__key", children: getShortcutKey("CtrlOrCmd") }),
    /* @__PURE__ */ (0, import_jsx_runtime117.jsx)("div", { className: "ttd-dialog-submit-shortcut__key", children: getShortcutKey("Enter") })
  ] });
};

// components/TTDDialog/MermaidToExcalidraw.tsx
var import_jsx_runtime118 = __toESM(require_jsx_runtime(), 1);
var MERMAID_EXAMPLE = "flowchart TD\n A[Christmas] -->|Get money| B(Go shopping)\n B --> C{Let me think}\n C -->|One| D[Laptop]\n C -->|Two| E[iPhone]\n C -->|Three| F[Car]";
var debouncedSaveMermaidDefinition = debounce(saveMermaidDataToStorage, 300);
var MermaidToExcalidraw = ({
  mermaidToExcalidrawLib
}) => {
  const [text, setText] = (0, import_react100.useState)(
    () => EditorLocalStorage.get(EDITOR_LS_KEYS.MERMAID_TO_EXCALIDRAW) || MERMAID_EXAMPLE
  );
  const deferredText = (0, import_react100.useDeferredValue)(text.trim());
  const [error, setError] = (0, import_react100.useState)(null);
  const canvasRef = (0, import_react100.useRef)(null);
  const data = (0, import_react100.useRef)({ elements: [], files: null });
  const app = useApp();
  (0, import_react100.useEffect)(() => {
    convertMermaidToExcalidraw({
      canvasRef,
      data,
      mermaidToExcalidrawLib,
      setError,
      mermaidDefinition: deferredText
    }).catch((err) => {
      if (isDevEnv()) {
        console.error("Failed to parse mermaid definition", err);
      }
    });
    debouncedSaveMermaidDefinition(deferredText);
  }, [deferredText, mermaidToExcalidrawLib]);
  (0, import_react100.useEffect)(
    () => () => {
      debouncedSaveMermaidDefinition.flush();
    },
    []
  );
  const onInsertToEditor = () => {
    insertToEditor({
      app,
      data,
      text,
      shouldSaveMermaidDataToStorage: true
    });
  };
  return /* @__PURE__ */ (0, import_jsx_runtime118.jsxs)(import_jsx_runtime118.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime118.jsx)("div", { className: "ttd-dialog-desc", children: /* @__PURE__ */ (0, import_jsx_runtime118.jsx)(
      Trans_default,
      {
        i18nKey: "mermaid.description",
        flowchartLink: (el) => /* @__PURE__ */ (0, import_jsx_runtime118.jsx)("a", { href: "https://mermaid.js.org/syntax/flowchart.html", children: el }),
        sequenceLink: (el) => /* @__PURE__ */ (0, import_jsx_runtime118.jsx)("a", { href: "https://mermaid.js.org/syntax/sequenceDiagram.html", children: el }),
        classLink: (el) => /* @__PURE__ */ (0, import_jsx_runtime118.jsx)("a", { href: "https://mermaid.js.org/syntax/classDiagram.html", children: el })
      }
    ) }),
    /* @__PURE__ */ (0, import_jsx_runtime118.jsxs)(TTDDialogPanels, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime118.jsx)(TTDDialogPanel, { label: t("mermaid.syntax"), children: /* @__PURE__ */ (0, import_jsx_runtime118.jsx)(
        TTDDialogInput,
        {
          input: text,
          placeholder: "Write Mermaid diagram defintion here...",
          onChange: (event) => setText(event.target.value),
          onKeyboardSubmit: () => {
            onInsertToEditor();
          }
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime118.jsx)(
        TTDDialogPanel,
        {
          label: t("mermaid.preview"),
          panelAction: {
            action: () => {
              onInsertToEditor();
            },
            label: t("mermaid.button"),
            icon: ArrowRightIcon
          },
          renderSubmitShortcut: () => /* @__PURE__ */ (0, import_jsx_runtime118.jsx)(TTDDialogSubmitShortcut, {}),
          children: /* @__PURE__ */ (0, import_jsx_runtime118.jsx)(
            TTDDialogOutput,
            {
              canvasRef,
              loaded: mermaidToExcalidrawLib.loaded,
              error
            }
          )
        }
      )
    ] })
  ] });
};
var MermaidToExcalidraw_default = MermaidToExcalidraw;

// components/TTDDialog/TTDDialogTabs.tsx
init_define_import_meta_env();
var import_react101 = __toESM(require_react(), 1);
var import_jsx_runtime119 = __toESM(require_jsx_runtime(), 1);
var TTDDialogTabs = (props) => {
  const setAppState = useExcalidrawSetAppState();
  const rootRef = (0, import_react101.useRef)(null);
  const minHeightRef = (0, import_react101.useRef)(0);
  return /* @__PURE__ */ (0, import_jsx_runtime119.jsx)(
    $69cb30bb0017df05$export$be92b6f5f03c0fe9,
    {
      ref: rootRef,
      className: "ttd-dialog-tabs-root",
      value: props.tab,
      onValueChange: (tab) => {
        if (!tab) {
          return;
        }
        const modalContentNode = rootRef.current?.closest(".Modal__content");
        if (modalContentNode) {
          const currHeight = modalContentNode.offsetHeight || 0;
          if (currHeight > minHeightRef.current) {
            minHeightRef.current = currHeight;
            modalContentNode.style.minHeight = `min(${minHeightRef.current}px, 100%)`;
          }
        }
        if (props.dialog === "ttd" && isMemberOf(["text-to-diagram", "mermaid"], tab)) {
          setAppState({
            openDialog: { name: props.dialog, tab }
          });
        }
      },
      children: props.children
    }
  );
};
TTDDialogTabs.displayName = "TTDDialogTabs";
var TTDDialogTabs_default = TTDDialogTabs;

// components/TTDDialog/TTDDialog.tsx
var import_react102 = __toESM(require_react(), 1);

// components/TTDDialog/TTDDialogTabTriggers.tsx
init_define_import_meta_env();
var import_jsx_runtime120 = __toESM(require_jsx_runtime(), 1);
var TTDDialogTabTriggers = ({
  children,
  ...rest
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime120.jsx)($69cb30bb0017df05$export$54c2e3dc7acea9f5, { className: "ttd-dialog-triggers", ...rest, children });
};
TTDDialogTabTriggers.displayName = "TTDDialogTabTriggers";

// components/TTDDialog/TTDDialogTabTrigger.tsx
init_define_import_meta_env();
var import_jsx_runtime121 = __toESM(require_jsx_runtime(), 1);
var TTDDialogTabTrigger = ({
  children,
  tab,
  onSelect,
  ...rest
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime121.jsx)($69cb30bb0017df05$export$41fb9f06171c75f4, { value: tab, asChild: true, onSelect, children: /* @__PURE__ */ (0, import_jsx_runtime121.jsx)("button", { type: "button", className: "ttd-dialog-tab-trigger", ...rest, children }) });
};
TTDDialogTabTrigger.displayName = "TTDDialogTabTrigger";

// components/TTDDialog/TTDDialogTab.tsx
init_define_import_meta_env();
var import_jsx_runtime122 = __toESM(require_jsx_runtime(), 1);
var TTDDialogTab = ({
  tab,
  children,
  ...rest
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime122.jsx)($69cb30bb0017df05$export$7c6e2c02157bb7d2, { ...rest, value: tab, children });
};
TTDDialogTab.displayName = "TTDDialogTab";

// components/TTDDialog/TTDDialog.tsx
var import_jsx_runtime123 = __toESM(require_jsx_runtime(), 1);
var MIN_PROMPT_LENGTH = 3;
var MAX_PROMPT_LENGTH = 1e3;
var rateLimitsAtom = atom2(null);
var ttdGenerationAtom = atom2(null);
var TTDDialog = (props) => {
  const appState = useUIAppState();
  if (appState.openDialog?.name !== "ttd") {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(TTDDialogBase, { ...props, tab: appState.openDialog.tab });
};
var TTDDialogBase = withInternalFallback(
  "TTDDialogBase",
  ({
    tab,
    ...rest
  }) => {
    const app = useApp();
    const setAppState = useExcalidrawSetAppState();
    const someRandomDivRef = (0, import_react102.useRef)(null);
    const [ttdGeneration, setTtdGeneration] = useAtom(ttdGenerationAtom);
    const [text, setText] = (0, import_react102.useState)(ttdGeneration?.prompt ?? "");
    const prompt = text.trim();
    const handleTextChange = (event) => {
      setText(event.target.value);
      setTtdGeneration((s3) => ({
        generatedResponse: s3?.generatedResponse ?? null,
        prompt: event.target.value
      }));
    };
    const [onTextSubmitInProgess, setOnTextSubmitInProgess] = (0, import_react102.useState)(false);
    const [rateLimits, setRateLimits] = useAtom(rateLimitsAtom);
    const onGenerate = async () => {
      if (prompt.length > MAX_PROMPT_LENGTH || prompt.length < MIN_PROMPT_LENGTH || onTextSubmitInProgess || rateLimits?.rateLimitRemaining === 0 || // means this is not a text-to-diagram dialog (needed for TS only)
      "__fallback" in rest) {
        if (prompt.length < MIN_PROMPT_LENGTH) {
          setError(
            new Error(
              `Prompt is too short (min ${MIN_PROMPT_LENGTH} characters)`
            )
          );
        }
        if (prompt.length > MAX_PROMPT_LENGTH) {
          setError(
            new Error(
              `Prompt is too long (max ${MAX_PROMPT_LENGTH} characters)`
            )
          );
        }
        return;
      }
      try {
        setOnTextSubmitInProgess(true);
        trackEvent("ai", "generate", "ttd");
        const { generatedResponse, error: error2, rateLimit, rateLimitRemaining } = await rest.onTextSubmit(prompt);
        if (typeof generatedResponse === "string") {
          setTtdGeneration((s3) => ({
            generatedResponse,
            prompt: s3?.prompt ?? null
          }));
        }
        if (isFiniteNumber(rateLimit) && isFiniteNumber(rateLimitRemaining)) {
          setRateLimits({ rateLimit, rateLimitRemaining });
        }
        if (error2) {
          setError(error2);
          return;
        }
        if (!generatedResponse) {
          setError(new Error("Generation failed"));
          return;
        }
        try {
          await convertMermaidToExcalidraw({
            canvasRef: someRandomDivRef,
            data,
            mermaidToExcalidrawLib,
            setError,
            mermaidDefinition: generatedResponse
          });
          trackEvent("ai", "mermaid parse success", "ttd");
        } catch (error3) {
          console.info(
            `%cTTD mermaid render errror: ${error3.message}`,
            "color: red"
          );
          console.info(
            `>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
TTD mermaid definition render errror: ${error3.message}`,
            "color: yellow"
          );
          trackEvent("ai", "mermaid parse failed", "ttd");
          setError(
            new Error(
              "Generated an invalid diagram :(. You may also try a different prompt."
            )
          );
        }
      } catch (error2) {
        let message = error2.message;
        if (!message || message === "Failed to fetch") {
          message = "Request failed";
        }
        setError(new Error(message));
      } finally {
        setOnTextSubmitInProgess(false);
      }
    };
    const refOnGenerate = (0, import_react102.useRef)(onGenerate);
    refOnGenerate.current = onGenerate;
    const [mermaidToExcalidrawLib, setMermaidToExcalidrawLib] = (0, import_react102.useState)({
      loaded: false,
      api: import("./excalidraw-assets-dev/dist-YRQVIX7L.js")
    });
    (0, import_react102.useEffect)(() => {
      const fn = async () => {
        await mermaidToExcalidrawLib.api;
        setMermaidToExcalidrawLib((prev) => ({ ...prev, loaded: true }));
      };
      fn();
    }, [mermaidToExcalidrawLib.api]);
    const data = (0, import_react102.useRef)({ elements: [], files: null });
    const [error, setError] = (0, import_react102.useState)(null);
    return /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(
      Dialog,
      {
        className: "ttd-dialog",
        onCloseRequest: () => {
          app.setOpenDialog(null);
        },
        size: 1200,
        title: false,
        ...rest,
        autofocus: false,
        children: /* @__PURE__ */ (0, import_jsx_runtime123.jsxs)(TTDDialogTabs_default, { dialog: "ttd", tab, children: [
          "__fallback" in rest && rest.__fallback ? /* @__PURE__ */ (0, import_jsx_runtime123.jsx)("p", { className: "dialog-mermaid-title", children: t("mermaid.title") }) : /* @__PURE__ */ (0, import_jsx_runtime123.jsxs)(TTDDialogTabTriggers, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(TTDDialogTabTrigger, { tab: "text-to-diagram", children: /* @__PURE__ */ (0, import_jsx_runtime123.jsxs)("div", { style: { display: "flex", alignItems: "center" }, children: [
              t("labels.textToDiagram"),
              /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(
                "div",
                {
                  style: {
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    padding: "1px 6px",
                    marginLeft: "10px",
                    fontSize: 10,
                    borderRadius: "12px",
                    background: "var(--color-promo)",
                    color: "var(--color-surface-lowest)"
                  },
                  children: "AI Beta"
                }
              )
            ] }) }),
            /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(TTDDialogTabTrigger, { tab: "mermaid", children: "Mermaid" })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(TTDDialogTab, { className: "ttd-dialog-content", tab: "mermaid", children: /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(
            MermaidToExcalidraw_default,
            {
              mermaidToExcalidrawLib
            }
          ) }),
          !("__fallback" in rest) && /* @__PURE__ */ (0, import_jsx_runtime123.jsxs)(TTDDialogTab, { className: "ttd-dialog-content", tab: "text-to-diagram", children: [
            /* @__PURE__ */ (0, import_jsx_runtime123.jsx)("div", { className: "ttd-dialog-desc", children: "Currently we use Mermaid as a middle step, so you'll get best results if you describe a diagram, workflow, flow chart, and similar." }),
            /* @__PURE__ */ (0, import_jsx_runtime123.jsxs)(TTDDialogPanels, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(
                TTDDialogPanel,
                {
                  label: t("labels.prompt"),
                  panelAction: {
                    action: onGenerate,
                    label: "Generate",
                    icon: ArrowRightIcon
                  },
                  onTextSubmitInProgess,
                  panelActionDisabled: prompt.length > MAX_PROMPT_LENGTH || rateLimits?.rateLimitRemaining === 0,
                  renderTopRight: () => {
                    if (!rateLimits) {
                      return null;
                    }
                    return /* @__PURE__ */ (0, import_jsx_runtime123.jsxs)(
                      "div",
                      {
                        className: "ttd-dialog-rate-limit",
                        style: {
                          fontSize: 12,
                          marginLeft: "auto",
                          color: rateLimits.rateLimitRemaining === 0 ? "var(--color-danger)" : void 0
                        },
                        children: [
                          rateLimits.rateLimitRemaining,
                          " requests left today"
                        ]
                      }
                    );
                  },
                  renderSubmitShortcut: () => /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(TTDDialogSubmitShortcut, {}),
                  renderBottomRight: () => {
                    if (typeof ttdGeneration?.generatedResponse === "string") {
                      return /* @__PURE__ */ (0, import_jsx_runtime123.jsxs)(
                        "div",
                        {
                          className: "excalidraw-link",
                          style: { marginLeft: "auto", fontSize: 14 },
                          onClick: () => {
                            if (typeof ttdGeneration?.generatedResponse === "string") {
                              saveMermaidDataToStorage(
                                ttdGeneration.generatedResponse
                              );
                              setAppState({
                                openDialog: { name: "ttd", tab: "mermaid" }
                              });
                            }
                          },
                          children: [
                            "View as Mermaid",
                            /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(InlineIcon, { icon: ArrowRightIcon })
                          ]
                        }
                      );
                    }
                    const ratio = prompt.length / MAX_PROMPT_LENGTH;
                    if (ratio > 0.8) {
                      return /* @__PURE__ */ (0, import_jsx_runtime123.jsxs)(
                        "div",
                        {
                          style: {
                            marginLeft: "auto",
                            fontSize: 12,
                            fontFamily: "monospace",
                            color: ratio > 1 ? "var(--color-danger)" : void 0
                          },
                          children: [
                            "Length: ",
                            prompt.length,
                            "/",
                            MAX_PROMPT_LENGTH
                          ]
                        }
                      );
                    }
                    return null;
                  },
                  children: /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(
                    TTDDialogInput,
                    {
                      onChange: handleTextChange,
                      input: text,
                      placeholder: "Describe what you want to see...",
                      onKeyboardSubmit: () => {
                        refOnGenerate.current();
                      }
                    }
                  )
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(
                TTDDialogPanel,
                {
                  label: "Preview",
                  panelAction: {
                    action: () => {
                      console.info("Panel action clicked");
                      insertToEditor({ app, data });
                    },
                    label: "Insert",
                    icon: ArrowRightIcon
                  },
                  children: /* @__PURE__ */ (0, import_jsx_runtime123.jsx)(
                    TTDDialogOutput,
                    {
                      canvasRef: someRandomDivRef,
                      error,
                      loaded: mermaidToExcalidrawLib.loaded
                    }
                  )
                }
              )
            ] })
          ] })
        ] })
      }
    );
  }
);

// components/Stats/index.tsx
init_define_import_meta_env();
var import_react106 = __toESM(require_react(), 1);
var import_lodash3 = __toESM(require_lodash2(), 1);

// components/Stats/Dimension.tsx
init_define_import_meta_env();

// components/Stats/DragInput.tsx
init_define_import_meta_env();
var import_react103 = __toESM(require_react(), 1);

// components/Stats/utils.ts
init_define_import_meta_env();
var SMALLEST_DELTA = 0.01;
var isPropertyEditable = (element, property) => {
  if (property === "height" && isTextElement(element)) {
    return false;
  }
  if (property === "width" && isTextElement(element)) {
    return false;
  }
  if (property === "angle" && isFrameLikeElement(element)) {
    return false;
  }
  return true;
};
var getStepSizedValue = (value, stepSize) => {
  const v3 = value + stepSize / 2;
  return v3 - v3 % stepSize;
};
var getElementsInAtomicUnit = (atomicUnit, elementsMap, originalElementsMap) => {
  return Object.keys(atomicUnit).map((id) => ({
    original: (originalElementsMap ?? elementsMap).get(id),
    latest: elementsMap.get(id)
  })).filter((el) => el.original !== void 0 && el.latest !== void 0);
};
var newOrigin = (x1, y1, w1, h1, w22, h22, angle) => {
  return {
    x: x1 + (w1 - w22) / 2 + (w22 - w1) / 2 * Math.cos(angle) + (h1 - h22) / 2 * Math.sin(angle),
    y: y1 + (h1 - h22) / 2 + (w22 - w1) / 2 * Math.sin(angle) + (h22 - h1) / 2 * Math.cos(angle)
  };
};
var resizeElement = (nextWidth, nextHeight, keepAspectRatio, origElement, elementsMap, elements, scene, shouldInformMutation = true) => {
  const latestElement = elementsMap.get(origElement.id);
  if (!latestElement) {
    return;
  }
  let boundTextFont = {};
  const boundTextElement = getBoundTextElement(latestElement, elementsMap);
  if (boundTextElement) {
    const minWidth = getApproxMinLineWidth(
      getFontString(boundTextElement),
      boundTextElement.lineHeight
    );
    const minHeight = getApproxMinLineHeight(
      boundTextElement.fontSize,
      boundTextElement.lineHeight
    );
    nextWidth = Math.max(nextWidth, minWidth);
    nextHeight = Math.max(nextHeight, minHeight);
  }
  const { width: oldWidth, height: oldHeight } = latestElement;
  mutateElement(
    latestElement,
    {
      ...newOrigin(
        latestElement.x,
        latestElement.y,
        latestElement.width,
        latestElement.height,
        nextWidth,
        nextHeight,
        latestElement.angle
      ),
      width: nextWidth,
      height: nextHeight,
      ...rescalePointsInElement(origElement, nextWidth, nextHeight, true)
    },
    shouldInformMutation
  );
  updateBindings(latestElement, elementsMap, elements, scene, {
    newSize: {
      width: nextWidth,
      height: nextHeight
    }
  });
  if (boundTextElement) {
    boundTextFont = {
      fontSize: boundTextElement.fontSize
    };
    if (keepAspectRatio) {
      const updatedElement = {
        ...latestElement,
        width: nextWidth,
        height: nextHeight
      };
      const nextFont = measureFontSizeFromWidth(
        boundTextElement,
        elementsMap,
        getBoundTextMaxWidth(updatedElement, boundTextElement)
      );
      boundTextFont = {
        fontSize: nextFont?.size ?? boundTextElement.fontSize
      };
    }
  }
  updateBoundElements(latestElement, elementsMap, {
    oldSize: { width: oldWidth, height: oldHeight }
  });
  if (boundTextElement && boundTextFont) {
    mutateElement(boundTextElement, {
      fontSize: boundTextFont.fontSize
    });
  }
  handleBindTextResize(latestElement, elementsMap, "e", keepAspectRatio);
};
var moveElement = (newTopLeftX, newTopLeftY, originalElement, elementsMap, elements, scene, originalElementsMap, shouldInformMutation = true) => {
  const latestElement = elementsMap.get(originalElement.id);
  if (!latestElement) {
    return;
  }
  const [cx, cy] = [
    originalElement.x + originalElement.width / 2,
    originalElement.y + originalElement.height / 2
  ];
  const [topLeftX, topLeftY] = pointRotateRads(
    pointFrom(originalElement.x, originalElement.y),
    pointFrom(cx, cy),
    originalElement.angle
  );
  const changeInX = newTopLeftX - topLeftX;
  const changeInY = newTopLeftY - topLeftY;
  const [x3, y3] = pointRotateRads(
    pointFrom(newTopLeftX, newTopLeftY),
    pointFrom(cx + changeInX, cy + changeInY),
    -originalElement.angle
  );
  mutateElement(
    latestElement,
    {
      x: x3,
      y: y3
    },
    shouldInformMutation
  );
  updateBindings(latestElement, elementsMap, elements, scene);
  const boundTextElement = getBoundTextElement(
    originalElement,
    originalElementsMap
  );
  if (boundTextElement) {
    const latestBoundTextElement = elementsMap.get(boundTextElement.id);
    latestBoundTextElement && mutateElement(
      latestBoundTextElement,
      {
        x: boundTextElement.x + changeInX,
        y: boundTextElement.y + changeInY
      },
      shouldInformMutation
    );
  }
};
var getAtomicUnits = (targetElements, appState) => {
  const selectedGroupIds = getSelectedGroupIds(appState);
  const _atomicUnits = selectedGroupIds.map((gid) => {
    return getElementsInGroup(targetElements, gid).reduce((acc, el) => {
      acc[el.id] = true;
      return acc;
    }, {});
  });
  targetElements.filter((el) => !isInGroup(el)).forEach((el) => {
    _atomicUnits.push({
      [el.id]: true
    });
  });
  return _atomicUnits;
};
var updateBindings = (latestElement, elementsMap, elements, scene, options) => {
  if (isLinearElement(latestElement)) {
    bindOrUnbindLinearElements(
      [latestElement],
      elementsMap,
      elements,
      scene,
      true,
      []
    );
  } else {
    updateBoundElements(latestElement, elementsMap, options);
  }
};

// components/Stats/DragInput.tsx
var import_jsx_runtime124 = __toESM(require_jsx_runtime(), 1);
var StatsDragInput = ({
  label,
  icon,
  dragInputCallback,
  value,
  elements,
  editable = true,
  shouldKeepAspectRatio,
  property,
  scene,
  appState,
  sensitivity = 1
}) => {
  const app = useApp();
  const inputRef = (0, import_react103.useRef)(null);
  const labelRef = (0, import_react103.useRef)(null);
  const [inputValue, setInputValue] = (0, import_react103.useState)(value.toString());
  const stateRef = (0, import_react103.useRef)(null);
  if (!stateRef.current) {
    stateRef.current = {
      originalAppState: cloneJSON(appState),
      originalElements: elements,
      lastUpdatedValue: inputValue,
      updatePending: false
    };
  }
  (0, import_react103.useEffect)(() => {
    const inputValue2 = value.toString();
    setInputValue(inputValue2);
    stateRef.current.lastUpdatedValue = inputValue2;
  }, [value]);
  const handleInputValue = (updatedValue, elements2, appState2) => {
    if (!stateRef.current.updatePending) {
      return false;
    }
    stateRef.current.updatePending = false;
    const parsed = Number(updatedValue);
    if (isNaN(parsed)) {
      setInputValue(value.toString());
      return;
    }
    const rounded = Number(parsed.toFixed(2));
    const original = Number(value);
    if (isNaN(original) || Math.abs(rounded - original) >= SMALLEST_DELTA) {
      stateRef.current.lastUpdatedValue = updatedValue;
      dragInputCallback({
        accumulatedChange: 0,
        instantChange: 0,
        originalElements: elements2,
        originalElementsMap: app.scene.getNonDeletedElementsMap(),
        shouldKeepAspectRatio,
        shouldChangeByStepSize: false,
        scene,
        nextValue: rounded,
        property,
        originalAppState: appState2,
        setInputValue: (value2) => setInputValue(String(value2))
      });
      app.syncActionResult({ storeAction: StoreAction.CAPTURE });
    }
  };
  const callbacksRef = (0, import_react103.useRef)({});
  callbacksRef.current.handleInputValue = handleInputValue;
  (0, import_react103.useEffect)(() => {
    const input = inputRef.current;
    const callbacks = callbacksRef.current;
    return () => {
      const nextValue = input?.value;
      if (nextValue) {
        callbacks.handleInputValue?.(
          nextValue,
          stateRef.current.originalElements,
          stateRef.current.originalAppState
        );
      }
      window.removeEventListener(
        "pointermove" /* POINTER_MOVE */,
        callbacks.onPointerMove,
        false
      );
      window.removeEventListener(
        "pointerup" /* POINTER_UP */,
        callbacks.onPointerUp,
        false
      );
    };
  }, [
    // we need to track change of `editable` state as mount/unmount
    // because react doesn't trigger `blur` when a an input is blurred due
    // to being disabled (https://github.com/facebook/react/issues/9142).
    // As such, if we keep rendering disabled inputs, then change in selection
    // to an element that has a given property as non-editable would not trigger
    // blur/unmount and wouldn't update the value.
    editable
  ]);
  if (!editable) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime124.jsxs)(
    "div",
    {
      className: clsx_m_default("drag-input-container", !editable && "disabled"),
      "data-testid": label,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime124.jsx)(
          "div",
          {
            className: "drag-input-label",
            ref: labelRef,
            onPointerDown: (event) => {
              if (inputRef.current && editable) {
                document.body.classList.add("excalidraw-cursor-resize");
                let startValue = Number(inputRef.current.value);
                if (isNaN(startValue)) {
                  startValue = 0;
                }
                let lastPointer = null;
                let originalElementsMap = app.scene.getNonDeletedElements().reduce((acc, element) => {
                  acc.set(element.id, deepCopyElement(element));
                  return acc;
                }, /* @__PURE__ */ new Map());
                let originalElements = elements.map(
                  (element) => originalElementsMap.get(element.id)
                );
                const originalAppState = cloneJSON(appState);
                let accumulatedChange = 0;
                let stepChange = 0;
                const onPointerMove = (event2) => {
                  if (lastPointer && originalElementsMap !== null && originalElements !== null) {
                    const instantChange = event2.clientX - lastPointer.x;
                    if (instantChange !== 0) {
                      stepChange += instantChange;
                      if (Math.abs(stepChange) >= sensitivity) {
                        stepChange = Math.sign(stepChange) * Math.floor(Math.abs(stepChange) / sensitivity);
                        accumulatedChange += stepChange;
                        dragInputCallback({
                          accumulatedChange,
                          instantChange: stepChange,
                          originalElements,
                          originalElementsMap,
                          shouldKeepAspectRatio,
                          shouldChangeByStepSize: event2.shiftKey,
                          property,
                          scene,
                          originalAppState,
                          setInputValue: (value2) => setInputValue(String(value2))
                        });
                        stepChange = 0;
                      }
                    }
                  }
                  lastPointer = {
                    x: event2.clientX,
                    y: event2.clientY
                  };
                };
                const onPointerUp = () => {
                  window.removeEventListener(
                    "pointermove" /* POINTER_MOVE */,
                    onPointerMove,
                    false
                  );
                  app.syncActionResult({ storeAction: StoreAction.CAPTURE });
                  lastPointer = null;
                  accumulatedChange = 0;
                  stepChange = 0;
                  originalElements = null;
                  originalElementsMap = null;
                  document.body.classList.remove("excalidraw-cursor-resize");
                  window.removeEventListener("pointerup" /* POINTER_UP */, onPointerUp, false);
                };
                callbacksRef.current.onPointerMove = onPointerMove;
                callbacksRef.current.onPointerUp = onPointerUp;
                window.addEventListener("pointermove" /* POINTER_MOVE */, onPointerMove, false);
                window.addEventListener("pointerup" /* POINTER_UP */, onPointerUp, false);
              }
            },
            onPointerEnter: () => {
              if (labelRef.current) {
                labelRef.current.style.cursor = "ew-resize";
              }
            },
            children: icon ? /* @__PURE__ */ (0, import_jsx_runtime124.jsx)(InlineIcon, { icon }) : label
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime124.jsx)(
          "input",
          {
            className: "drag-input",
            autoComplete: "off",
            spellCheck: "false",
            onKeyDown: (event) => {
              if (editable) {
                const eventTarget = event.target;
                if (eventTarget instanceof HTMLInputElement && event.key === KEYS.ENTER) {
                  handleInputValue(eventTarget.value, elements, appState);
                  app.focusContainer();
                }
              }
            },
            ref: inputRef,
            value: inputValue,
            onChange: (event) => {
              stateRef.current.updatePending = true;
              setInputValue(event.target.value);
            },
            onFocus: (event) => {
              event.target.select();
              stateRef.current.originalElements = elements;
              stateRef.current.originalAppState = cloneJSON(appState);
            },
            onBlur: (event) => {
              if (!inputValue) {
                setInputValue(value.toString());
              } else if (editable) {
                handleInputValue(
                  event.target.value,
                  stateRef.current.originalElements,
                  stateRef.current.originalAppState
                );
              }
            },
            disabled: !editable
          }
        )
      ]
    }
  );
};
var DragInput_default = StatsDragInput;

// components/Stats/Dimension.tsx
var import_jsx_runtime125 = __toESM(require_jsx_runtime(), 1);
var STEP_SIZE = 10;
var _shouldKeepAspectRatio = (element) => {
  return element.type === "image";
};
var handleDimensionChange = ({
  accumulatedChange,
  originalElements,
  shouldKeepAspectRatio,
  shouldChangeByStepSize,
  nextValue,
  property,
  scene
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const elements = scene.getNonDeletedElements();
  const origElement = originalElements[0];
  if (origElement) {
    const keepAspectRatio = shouldKeepAspectRatio || _shouldKeepAspectRatio(origElement);
    const aspectRatio = origElement.width / origElement.height;
    if (nextValue !== void 0) {
      const nextWidth2 = Math.max(
        property === "width" ? nextValue : keepAspectRatio ? nextValue * aspectRatio : origElement.width,
        MIN_WIDTH_OR_HEIGHT
      );
      const nextHeight2 = Math.max(
        property === "height" ? nextValue : keepAspectRatio ? nextValue / aspectRatio : origElement.height,
        MIN_WIDTH_OR_HEIGHT
      );
      resizeElement(
        nextWidth2,
        nextHeight2,
        keepAspectRatio,
        origElement,
        elementsMap,
        elements,
        scene
      );
      return;
    }
    const changeInWidth = property === "width" ? accumulatedChange : 0;
    const changeInHeight = property === "height" ? accumulatedChange : 0;
    let nextWidth = Math.max(0, origElement.width + changeInWidth);
    if (property === "width") {
      if (shouldChangeByStepSize) {
        nextWidth = getStepSizedValue(nextWidth, STEP_SIZE);
      } else {
        nextWidth = Math.round(nextWidth);
      }
    }
    let nextHeight = Math.max(0, origElement.height + changeInHeight);
    if (property === "height") {
      if (shouldChangeByStepSize) {
        nextHeight = getStepSizedValue(nextHeight, STEP_SIZE);
      } else {
        nextHeight = Math.round(nextHeight);
      }
    }
    if (keepAspectRatio) {
      if (property === "width") {
        nextHeight = Math.round(nextWidth / aspectRatio * 100) / 100;
      } else {
        nextWidth = Math.round(nextHeight * aspectRatio * 100) / 100;
      }
    }
    nextHeight = Math.max(MIN_WIDTH_OR_HEIGHT, nextHeight);
    nextWidth = Math.max(MIN_WIDTH_OR_HEIGHT, nextWidth);
    resizeElement(
      nextWidth,
      nextHeight,
      keepAspectRatio,
      origElement,
      elementsMap,
      elements,
      scene
    );
  }
};
var DimensionDragInput = ({
  property,
  element,
  scene,
  appState
}) => {
  const value = Math.round((property === "width" ? element.width : element.height) * 100) / 100;
  return /* @__PURE__ */ (0, import_jsx_runtime125.jsx)(
    DragInput_default,
    {
      label: property === "width" ? "W" : "H",
      elements: [element],
      dragInputCallback: handleDimensionChange,
      value,
      editable: isPropertyEditable(element, property),
      scene,
      appState,
      property
    }
  );
};
var Dimension_default = DimensionDragInput;

// components/Stats/Angle.tsx
init_define_import_meta_env();
var import_jsx_runtime126 = __toESM(require_jsx_runtime(), 1);
var STEP_SIZE2 = 15;
var handleDegreeChange = ({
  accumulatedChange,
  originalElements,
  shouldChangeByStepSize,
  nextValue,
  scene
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const elements = scene.getNonDeletedElements();
  const origElement = originalElements[0];
  if (origElement && !isElbowArrow(origElement)) {
    const latestElement = elementsMap.get(origElement.id);
    if (!latestElement) {
      return;
    }
    if (nextValue !== void 0) {
      const nextAngle2 = degreesToRadians(nextValue);
      mutateElement(latestElement, {
        angle: nextAngle2
      });
      updateBindings(latestElement, elementsMap, elements, scene);
      const boundTextElement2 = getBoundTextElement(latestElement, elementsMap);
      if (boundTextElement2 && !isArrowElement(latestElement)) {
        mutateElement(boundTextElement2, { angle: nextAngle2 });
      }
      return;
    }
    const originalAngleInDegrees = Math.round(radiansToDegrees(origElement.angle) * 100) / 100;
    const changeInDegrees = Math.round(accumulatedChange);
    let nextAngleInDegrees = (originalAngleInDegrees + changeInDegrees) % 360;
    if (shouldChangeByStepSize) {
      nextAngleInDegrees = getStepSizedValue(nextAngleInDegrees, STEP_SIZE2);
    }
    nextAngleInDegrees = nextAngleInDegrees < 0 ? nextAngleInDegrees + 360 : nextAngleInDegrees;
    const nextAngle = degreesToRadians(nextAngleInDegrees);
    mutateElement(latestElement, {
      angle: nextAngle
    });
    updateBindings(latestElement, elementsMap, elements, scene);
    const boundTextElement = getBoundTextElement(latestElement, elementsMap);
    if (boundTextElement && !isArrowElement(latestElement)) {
      mutateElement(boundTextElement, { angle: nextAngle });
    }
  }
};
var Angle = ({ element, scene, appState, property }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime126.jsx)(
    DragInput_default,
    {
      label: "A",
      icon: angleIcon,
      value: Math.round(radiansToDegrees(element.angle) % 360 * 100) / 100,
      elements: [element],
      dragInputCallback: handleDegreeChange,
      editable: isPropertyEditable(element, "angle"),
      scene,
      appState,
      property
    }
  );
};
var Angle_default = Angle;

// components/Stats/FontSize.tsx
init_define_import_meta_env();
var import_jsx_runtime127 = __toESM(require_jsx_runtime(), 1);
var MIN_FONT_SIZE = 4;
var STEP_SIZE3 = 4;
var handleFontSizeChange = ({
  accumulatedChange,
  originalElements,
  shouldChangeByStepSize,
  nextValue,
  scene
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const origElement = originalElements[0];
  if (origElement) {
    const latestElement = elementsMap.get(origElement.id);
    if (!latestElement || !isTextElement(latestElement)) {
      return;
    }
    let nextFontSize;
    if (nextValue !== void 0) {
      nextFontSize = Math.max(Math.round(nextValue), MIN_FONT_SIZE);
    } else if (origElement.type === "text") {
      const originalFontSize = Math.round(origElement.fontSize);
      const changeInFontSize = Math.round(accumulatedChange);
      nextFontSize = Math.max(
        originalFontSize + changeInFontSize,
        MIN_FONT_SIZE
      );
      if (shouldChangeByStepSize) {
        nextFontSize = getStepSizedValue(nextFontSize, STEP_SIZE3);
      }
    }
    if (nextFontSize) {
      mutateElement(latestElement, {
        fontSize: nextFontSize
      });
      redrawTextBoundingBox(
        latestElement,
        scene.getContainerElement(latestElement),
        scene.getNonDeletedElementsMap()
      );
    }
  }
};
var FontSize = ({ element, scene, appState, property }) => {
  const _element = isTextElement(element) ? element : hasBoundTextElement(element) ? getBoundTextElement(element, scene.getNonDeletedElementsMap()) : null;
  if (!_element) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime127.jsx)(
    DragInput_default,
    {
      label: "F",
      value: Math.round(_element.fontSize * 10) / 10,
      elements: [_element],
      dragInputCallback: handleFontSizeChange,
      icon: fontSizeIcon,
      appState,
      scene,
      property
    }
  );
};
var FontSize_default = FontSize;

// components/Stats/MultiDimension.tsx
init_define_import_meta_env();
var import_react104 = __toESM(require_react(), 1);
var import_jsx_runtime128 = __toESM(require_jsx_runtime(), 1);
var STEP_SIZE4 = 10;
var getResizedUpdates = (anchorX, anchorY, scale, origElement) => {
  const offsetX = origElement.x - anchorX;
  const offsetY = origElement.y - anchorY;
  const nextWidth = origElement.width * scale;
  const nextHeight = origElement.height * scale;
  const x3 = anchorX + offsetX * scale;
  const y3 = anchorY + offsetY * scale;
  return {
    width: nextWidth,
    height: nextHeight,
    x: x3,
    y: y3,
    ...rescalePointsInElement(origElement, nextWidth, nextHeight, false),
    ...isTextElement(origElement) ? { fontSize: origElement.fontSize * scale } : {}
  };
};
var resizeElementInGroup = (anchorX, anchorY, property, scale, latestElement, origElement, elementsMap, originalElementsMap) => {
  const updates = getResizedUpdates(anchorX, anchorY, scale, origElement);
  const { width: oldWidth, height: oldHeight } = latestElement;
  mutateElement(latestElement, updates, false);
  const boundTextElement = getBoundTextElement(
    origElement,
    originalElementsMap
  );
  if (boundTextElement) {
    const newFontSize = boundTextElement.fontSize * scale;
    updateBoundElements(latestElement, elementsMap, {
      oldSize: { width: oldWidth, height: oldHeight }
    });
    const latestBoundTextElement = elementsMap.get(boundTextElement.id);
    if (latestBoundTextElement && isTextElement(latestBoundTextElement)) {
      mutateElement(
        latestBoundTextElement,
        {
          fontSize: newFontSize
        },
        false
      );
      handleBindTextResize(
        latestElement,
        elementsMap,
        property === "width" ? "e" : "s",
        true
      );
    }
  }
};
var resizeGroup = (nextWidth, nextHeight, initialHeight, aspectRatio, anchor, property, latestElements, originalElements, elementsMap, originalElementsMap) => {
  if (property === "width") {
    nextHeight = Math.round(nextWidth / aspectRatio * 100) / 100;
  } else {
    nextWidth = Math.round(nextHeight * aspectRatio * 100) / 100;
  }
  const scale = nextHeight / initialHeight;
  for (let i3 = 0; i3 < originalElements.length; i3++) {
    const origElement = originalElements[i3];
    const latestElement = latestElements[i3];
    resizeElementInGroup(
      anchor[0],
      anchor[1],
      property,
      scale,
      latestElement,
      origElement,
      elementsMap,
      originalElementsMap
    );
  }
};
var handleDimensionChange2 = ({
  accumulatedChange,
  originalElements,
  originalElementsMap,
  originalAppState,
  shouldChangeByStepSize,
  nextValue,
  scene,
  property
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const elements = scene.getNonDeletedElements();
  const atomicUnits = getAtomicUnits(originalElements, originalAppState);
  if (nextValue !== void 0) {
    for (const atomicUnit of atomicUnits) {
      const elementsInUnit = getElementsInAtomicUnit(
        atomicUnit,
        elementsMap,
        originalElementsMap
      );
      if (elementsInUnit.length > 1) {
        const latestElements = elementsInUnit.map((el) => el.latest);
        const originalElements2 = elementsInUnit.map((el) => el.original);
        const [x1, y1, x22, y22] = getCommonBounds(originalElements2);
        const initialWidth = x22 - x1;
        const initialHeight = y22 - y1;
        const aspectRatio = initialWidth / initialHeight;
        const nextWidth = Math.max(
          MIN_WIDTH_OR_HEIGHT,
          property === "width" ? Math.max(0, nextValue) : initialWidth
        );
        const nextHeight = Math.max(
          MIN_WIDTH_OR_HEIGHT,
          property === "height" ? Math.max(0, nextValue) : initialHeight
        );
        resizeGroup(
          nextWidth,
          nextHeight,
          initialHeight,
          aspectRatio,
          pointFrom(x1, y1),
          property,
          latestElements,
          originalElements2,
          elementsMap,
          originalElementsMap
        );
      } else {
        const [el] = elementsInUnit;
        const latestElement = el?.latest;
        const origElement = el?.original;
        if (latestElement && origElement && isPropertyEditable(latestElement, property)) {
          let nextWidth = property === "width" ? Math.max(0, nextValue) : latestElement.width;
          if (property === "width") {
            if (shouldChangeByStepSize) {
              nextWidth = getStepSizedValue(nextWidth, STEP_SIZE4);
            } else {
              nextWidth = Math.round(nextWidth);
            }
          }
          let nextHeight = property === "height" ? Math.max(0, nextValue) : latestElement.height;
          if (property === "height") {
            if (shouldChangeByStepSize) {
              nextHeight = getStepSizedValue(nextHeight, STEP_SIZE4);
            } else {
              nextHeight = Math.round(nextHeight);
            }
          }
          nextWidth = Math.max(MIN_WIDTH_OR_HEIGHT, nextWidth);
          nextHeight = Math.max(MIN_WIDTH_OR_HEIGHT, nextHeight);
          resizeElement(
            nextWidth,
            nextHeight,
            false,
            origElement,
            elementsMap,
            elements,
            scene,
            false
          );
        }
      }
    }
    scene.triggerUpdate();
    return;
  }
  const changeInWidth = property === "width" ? accumulatedChange : 0;
  const changeInHeight = property === "height" ? accumulatedChange : 0;
  for (const atomicUnit of atomicUnits) {
    const elementsInUnit = getElementsInAtomicUnit(
      atomicUnit,
      elementsMap,
      originalElementsMap
    );
    if (elementsInUnit.length > 1) {
      const latestElements = elementsInUnit.map((el) => el.latest);
      const originalElements2 = elementsInUnit.map((el) => el.original);
      const [x1, y1, x22, y22] = getCommonBounds(originalElements2);
      const initialWidth = x22 - x1;
      const initialHeight = y22 - y1;
      const aspectRatio = initialWidth / initialHeight;
      let nextWidth = Math.max(0, initialWidth + changeInWidth);
      if (property === "width") {
        if (shouldChangeByStepSize) {
          nextWidth = getStepSizedValue(nextWidth, STEP_SIZE4);
        } else {
          nextWidth = Math.round(nextWidth);
        }
      }
      let nextHeight = Math.max(0, initialHeight + changeInHeight);
      if (property === "height") {
        if (shouldChangeByStepSize) {
          nextHeight = getStepSizedValue(nextHeight, STEP_SIZE4);
        } else {
          nextHeight = Math.round(nextHeight);
        }
      }
      nextWidth = Math.max(MIN_WIDTH_OR_HEIGHT, nextWidth);
      nextHeight = Math.max(MIN_WIDTH_OR_HEIGHT, nextHeight);
      resizeGroup(
        nextWidth,
        nextHeight,
        initialHeight,
        aspectRatio,
        pointFrom(x1, y1),
        property,
        latestElements,
        originalElements2,
        elementsMap,
        originalElementsMap
      );
    } else {
      const [el] = elementsInUnit;
      const latestElement = el?.latest;
      const origElement = el?.original;
      if (latestElement && origElement && isPropertyEditable(latestElement, property)) {
        let nextWidth = Math.max(0, origElement.width + changeInWidth);
        if (property === "width") {
          if (shouldChangeByStepSize) {
            nextWidth = getStepSizedValue(nextWidth, STEP_SIZE4);
          } else {
            nextWidth = Math.round(nextWidth);
          }
        }
        let nextHeight = Math.max(0, origElement.height + changeInHeight);
        if (property === "height") {
          if (shouldChangeByStepSize) {
            nextHeight = getStepSizedValue(nextHeight, STEP_SIZE4);
          } else {
            nextHeight = Math.round(nextHeight);
          }
        }
        nextWidth = Math.max(MIN_WIDTH_OR_HEIGHT, nextWidth);
        nextHeight = Math.max(MIN_WIDTH_OR_HEIGHT, nextHeight);
        resizeElement(
          nextWidth,
          nextHeight,
          false,
          origElement,
          elementsMap,
          elements,
          scene
        );
      }
    }
  }
  scene.triggerUpdate();
};
var MultiDimension = ({
  property,
  elements,
  elementsMap,
  atomicUnits,
  scene,
  appState
}) => {
  const sizes = (0, import_react104.useMemo)(
    () => atomicUnits.map((atomicUnit) => {
      const elementsInUnit = getElementsInAtomicUnit(atomicUnit, elementsMap);
      if (elementsInUnit.length > 1) {
        const [x1, y1, x22, y22] = getCommonBounds(
          elementsInUnit.map((el2) => el2.latest)
        );
        return Math.round((property === "width" ? x22 - x1 : y22 - y1) * 100) / 100;
      }
      const [el] = elementsInUnit;
      return Math.round(
        (property === "width" ? el.latest.width : el.latest.height) * 100
      ) / 100;
    }),
    [elementsMap, atomicUnits, property]
  );
  const value = new Set(sizes).size === 1 ? Math.round(sizes[0] * 100) / 100 : "Mixed";
  const editable = sizes.length > 0;
  return /* @__PURE__ */ (0, import_jsx_runtime128.jsx)(
    DragInput_default,
    {
      label: property === "width" ? "W" : "H",
      elements,
      dragInputCallback: handleDimensionChange2,
      value,
      editable,
      appState,
      property,
      scene
    }
  );
};
var MultiDimension_default = MultiDimension;

// components/Stats/MultiAngle.tsx
init_define_import_meta_env();
var import_jsx_runtime129 = __toESM(require_jsx_runtime(), 1);
var STEP_SIZE5 = 15;
var handleDegreeChange2 = ({
  accumulatedChange,
  originalElements,
  shouldChangeByStepSize,
  nextValue,
  property,
  scene
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const editableLatestIndividualElements = originalElements.map((el) => elementsMap.get(el.id)).filter((el) => el && !isInGroup(el) && isPropertyEditable(el, property));
  const editableOriginalIndividualElements = originalElements.filter(
    (el) => !isInGroup(el) && isPropertyEditable(el, property)
  );
  if (nextValue !== void 0) {
    const nextAngle = degreesToRadians(nextValue);
    for (const element of editableLatestIndividualElements) {
      if (!element) {
        continue;
      }
      mutateElement(
        element,
        {
          angle: nextAngle
        },
        false
      );
      const boundTextElement = getBoundTextElement(element, elementsMap);
      if (boundTextElement && !isArrowElement(element)) {
        mutateElement(boundTextElement, { angle: nextAngle }, false);
      }
    }
    scene.triggerUpdate();
    return;
  }
  for (let i3 = 0; i3 < editableLatestIndividualElements.length; i3++) {
    const latestElement = editableLatestIndividualElements[i3];
    if (!latestElement) {
      continue;
    }
    const originalElement = editableOriginalIndividualElements[i3];
    const originalAngleInDegrees = Math.round(radiansToDegrees(originalElement.angle) * 100) / 100;
    const changeInDegrees = Math.round(accumulatedChange);
    let nextAngleInDegrees = (originalAngleInDegrees + changeInDegrees) % 360;
    if (shouldChangeByStepSize) {
      nextAngleInDegrees = getStepSizedValue(nextAngleInDegrees, STEP_SIZE5);
    }
    nextAngleInDegrees = nextAngleInDegrees < 0 ? nextAngleInDegrees + 360 : nextAngleInDegrees;
    const nextAngle = degreesToRadians(nextAngleInDegrees);
    mutateElement(
      latestElement,
      {
        angle: nextAngle
      },
      false
    );
    const boundTextElement = getBoundTextElement(latestElement, elementsMap);
    if (boundTextElement && !isArrowElement(latestElement)) {
      mutateElement(boundTextElement, { angle: nextAngle }, false);
    }
  }
  scene.triggerUpdate();
};
var MultiAngle = ({
  elements,
  scene,
  appState,
  property
}) => {
  const editableLatestIndividualElements = elements.filter(
    (el) => !isInGroup(el) && isPropertyEditable(el, "angle")
  );
  const angles = editableLatestIndividualElements.map(
    (el) => Math.round(radiansToDegrees(el.angle) % 360 * 100) / 100
  );
  const value = new Set(angles).size === 1 ? angles[0] : "Mixed";
  const editable = editableLatestIndividualElements.some(
    (el) => isPropertyEditable(el, "angle")
  );
  return /* @__PURE__ */ (0, import_jsx_runtime129.jsx)(
    DragInput_default,
    {
      label: "A",
      icon: angleIcon,
      value,
      elements,
      dragInputCallback: handleDegreeChange2,
      editable,
      appState,
      scene,
      property
    }
  );
};
var MultiAngle_default = MultiAngle;

// components/Stats/MultiFontSize.tsx
init_define_import_meta_env();
var import_jsx_runtime130 = __toESM(require_jsx_runtime(), 1);
var MIN_FONT_SIZE2 = 4;
var STEP_SIZE6 = 4;
var getApplicableTextElements = (elements, elementsMap) => elements.reduce(
  (acc, el) => {
    if (!el || isInGroup(el)) {
      return acc;
    }
    if (isTextElement(el)) {
      acc.push(el);
      return acc;
    }
    if (hasBoundTextElement(el)) {
      const boundTextElement = getBoundTextElement(el, elementsMap);
      if (boundTextElement) {
        acc.push(boundTextElement);
        return acc;
      }
    }
    return acc;
  },
  []
);
var handleFontSizeChange2 = ({
  accumulatedChange,
  originalElements,
  shouldChangeByStepSize,
  nextValue,
  scene
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const latestTextElements = originalElements.map(
    (el) => elementsMap.get(el.id)
  );
  let nextFontSize;
  if (nextValue) {
    nextFontSize = Math.max(Math.round(nextValue), MIN_FONT_SIZE2);
    for (const textElement of latestTextElements) {
      mutateElement(
        textElement,
        {
          fontSize: nextFontSize
        },
        false
      );
      redrawTextBoundingBox(
        textElement,
        scene.getContainerElement(textElement),
        elementsMap,
        false
      );
    }
    scene.triggerUpdate();
  } else {
    const originalTextElements = originalElements;
    for (let i3 = 0; i3 < latestTextElements.length; i3++) {
      const latestElement = latestTextElements[i3];
      const originalElement = originalTextElements[i3];
      const originalFontSize = Math.round(originalElement.fontSize);
      const changeInFontSize = Math.round(accumulatedChange);
      let nextFontSize2 = Math.max(
        originalFontSize + changeInFontSize,
        MIN_FONT_SIZE2
      );
      if (shouldChangeByStepSize) {
        nextFontSize2 = getStepSizedValue(nextFontSize2, STEP_SIZE6);
      }
      mutateElement(
        latestElement,
        {
          fontSize: nextFontSize2
        },
        false
      );
      redrawTextBoundingBox(
        latestElement,
        scene.getContainerElement(latestElement),
        elementsMap,
        false
      );
    }
    scene.triggerUpdate();
  }
};
var MultiFontSize = ({
  elements,
  scene,
  appState,
  property,
  elementsMap
}) => {
  const latestTextElements = getApplicableTextElements(elements, elementsMap);
  if (!latestTextElements.length) {
    return null;
  }
  const fontSizes = latestTextElements.map(
    (textEl) => Math.round(textEl.fontSize * 10) / 10
  );
  const value = new Set(fontSizes).size === 1 ? fontSizes[0] : "Mixed";
  const editable = fontSizes.length > 0;
  return /* @__PURE__ */ (0, import_jsx_runtime130.jsx)(
    DragInput_default,
    {
      label: "F",
      icon: fontSizeIcon,
      elements: latestTextElements,
      dragInputCallback: handleFontSizeChange2,
      value,
      editable,
      scene,
      property,
      appState
    }
  );
};
var MultiFontSize_default = MultiFontSize;

// components/Stats/Position.tsx
init_define_import_meta_env();
var import_jsx_runtime131 = __toESM(require_jsx_runtime(), 1);
var STEP_SIZE7 = 10;
var handlePositionChange = ({
  accumulatedChange,
  originalElements,
  originalElementsMap,
  shouldChangeByStepSize,
  nextValue,
  property,
  scene
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const elements = scene.getNonDeletedElements();
  const origElement = originalElements[0];
  const [cx, cy] = [
    origElement.x + origElement.width / 2,
    origElement.y + origElement.height / 2
  ];
  const [topLeftX, topLeftY] = pointRotateRads(
    pointFrom(origElement.x, origElement.y),
    pointFrom(cx, cy),
    origElement.angle
  );
  if (nextValue !== void 0) {
    const newTopLeftX2 = property === "x" ? nextValue : topLeftX;
    const newTopLeftY2 = property === "y" ? nextValue : topLeftY;
    moveElement(
      newTopLeftX2,
      newTopLeftY2,
      origElement,
      elementsMap,
      elements,
      scene,
      originalElementsMap
    );
    return;
  }
  const changeInTopX = property === "x" ? accumulatedChange : 0;
  const changeInTopY = property === "y" ? accumulatedChange : 0;
  const newTopLeftX = property === "x" ? Math.round(
    shouldChangeByStepSize ? getStepSizedValue(origElement.x + changeInTopX, STEP_SIZE7) : topLeftX + changeInTopX
  ) : topLeftX;
  const newTopLeftY = property === "y" ? Math.round(
    shouldChangeByStepSize ? getStepSizedValue(origElement.y + changeInTopY, STEP_SIZE7) : topLeftY + changeInTopY
  ) : topLeftY;
  moveElement(
    newTopLeftX,
    newTopLeftY,
    origElement,
    elementsMap,
    elements,
    scene,
    originalElementsMap
  );
};
var Position = ({
  property,
  element,
  elementsMap,
  scene,
  appState
}) => {
  const [topLeftX, topLeftY] = pointRotateRads(
    pointFrom(element.x, element.y),
    pointFrom(element.x + element.width / 2, element.y + element.height / 2),
    element.angle
  );
  const value = Math.round((property === "x" ? topLeftX : topLeftY) * 100) / 100;
  return /* @__PURE__ */ (0, import_jsx_runtime131.jsx)(
    DragInput_default,
    {
      label: property === "x" ? "X" : "Y",
      elements: [element],
      dragInputCallback: handlePositionChange,
      scene,
      value,
      property,
      appState
    }
  );
};
var Position_default = Position;

// components/Stats/MultiPosition.tsx
init_define_import_meta_env();
var import_react105 = __toESM(require_react(), 1);
var import_jsx_runtime132 = __toESM(require_jsx_runtime(), 1);
var STEP_SIZE8 = 10;
var moveElements = (property, changeInTopX, changeInTopY, elements, originalElements, elementsMap, originalElementsMap, scene) => {
  for (let i3 = 0; i3 < elements.length; i3++) {
    const origElement = originalElements[i3];
    const [cx, cy] = [
      origElement.x + origElement.width / 2,
      origElement.y + origElement.height / 2
    ];
    const [topLeftX, topLeftY] = pointRotateRads(
      pointFrom(origElement.x, origElement.y),
      pointFrom(cx, cy),
      origElement.angle
    );
    const newTopLeftX = property === "x" ? Math.round(topLeftX + changeInTopX) : topLeftX;
    const newTopLeftY = property === "y" ? Math.round(topLeftY + changeInTopY) : topLeftY;
    moveElement(
      newTopLeftX,
      newTopLeftY,
      origElement,
      elementsMap,
      elements,
      scene,
      originalElementsMap,
      false
    );
  }
};
var moveGroupTo = (nextX, nextY, originalElements, elementsMap, elements, originalElementsMap, scene) => {
  const [x1, y1, ,] = getCommonBounds(originalElements);
  const offsetX = nextX - x1;
  const offsetY = nextY - y1;
  for (let i3 = 0; i3 < originalElements.length; i3++) {
    const origElement = originalElements[i3];
    const latestElement = elementsMap.get(origElement.id);
    if (!latestElement) {
      continue;
    }
    if (!isTextElement(latestElement) || !latestElement.containerId) {
      const [cx, cy] = [
        latestElement.x + latestElement.width / 2,
        latestElement.y + latestElement.height / 2
      ];
      const [topLeftX, topLeftY] = pointRotateRads(
        pointFrom(latestElement.x, latestElement.y),
        pointFrom(cx, cy),
        latestElement.angle
      );
      moveElement(
        topLeftX + offsetX,
        topLeftY + offsetY,
        origElement,
        elementsMap,
        elements,
        scene,
        originalElementsMap,
        false
      );
    }
  }
};
var handlePositionChange2 = ({
  accumulatedChange,
  originalElements,
  originalElementsMap,
  shouldChangeByStepSize,
  nextValue,
  property,
  scene,
  originalAppState
}) => {
  const elementsMap = scene.getNonDeletedElementsMap();
  const elements = scene.getNonDeletedElements();
  if (nextValue !== void 0) {
    for (const atomicUnit of getAtomicUnits(
      originalElements,
      originalAppState
    )) {
      const elementsInUnit = getElementsInAtomicUnit(
        atomicUnit,
        elementsMap,
        originalElementsMap
      );
      if (elementsInUnit.length > 1) {
        const [x1, y1, ,] = getCommonBounds(
          elementsInUnit.map((el) => el.latest)
        );
        const newTopLeftX = property === "x" ? nextValue : x1;
        const newTopLeftY = property === "y" ? nextValue : y1;
        moveGroupTo(
          newTopLeftX,
          newTopLeftY,
          elementsInUnit.map((el) => el.original),
          elementsMap,
          elements,
          originalElementsMap,
          scene
        );
      } else {
        const origElement = elementsInUnit[0]?.original;
        const latestElement = elementsInUnit[0]?.latest;
        if (origElement && latestElement && isPropertyEditable(latestElement, property)) {
          const [cx, cy] = [
            origElement.x + origElement.width / 2,
            origElement.y + origElement.height / 2
          ];
          const [topLeftX, topLeftY] = pointRotateRads(
            pointFrom(origElement.x, origElement.y),
            pointFrom(cx, cy),
            origElement.angle
          );
          const newTopLeftX = property === "x" ? nextValue : topLeftX;
          const newTopLeftY = property === "y" ? nextValue : topLeftY;
          moveElement(
            newTopLeftX,
            newTopLeftY,
            origElement,
            elementsMap,
            elements,
            scene,
            originalElementsMap,
            false
          );
        }
      }
    }
    scene.triggerUpdate();
    return;
  }
  const change = shouldChangeByStepSize ? getStepSizedValue(accumulatedChange, STEP_SIZE8) : accumulatedChange;
  const changeInTopX = property === "x" ? change : 0;
  const changeInTopY = property === "y" ? change : 0;
  moveElements(
    property,
    changeInTopX,
    changeInTopY,
    originalElements,
    originalElements,
    elementsMap,
    originalElementsMap,
    scene
  );
  scene.triggerUpdate();
};
var MultiPosition = ({
  property,
  elements,
  elementsMap,
  atomicUnits,
  scene,
  appState
}) => {
  const positions = (0, import_react105.useMemo)(
    () => atomicUnits.map((atomicUnit) => {
      const elementsInUnit = Object.keys(atomicUnit).map((id) => elementsMap.get(id)).filter((el2) => el2 !== void 0);
      if (elementsInUnit.length > 1) {
        const [x1, y1] = getCommonBounds(elementsInUnit);
        return Math.round((property === "x" ? x1 : y1) * 100) / 100;
      }
      const [el] = elementsInUnit;
      const [cx, cy] = [el.x + el.width / 2, el.y + el.height / 2];
      const [topLeftX, topLeftY] = pointRotateRads(
        pointFrom(el.x, el.y),
        pointFrom(cx, cy),
        el.angle
      );
      return Math.round((property === "x" ? topLeftX : topLeftY) * 100) / 100;
    }),
    [atomicUnits, elementsMap, property]
  );
  const value = new Set(positions).size === 1 ? positions[0] : "Mixed";
  return /* @__PURE__ */ (0, import_jsx_runtime132.jsx)(
    DragInput_default,
    {
      label: property === "x" ? "X" : "Y",
      elements,
      dragInputCallback: handlePositionChange2,
      value,
      property,
      scene,
      appState
    }
  );
};
var MultiPosition_default = MultiPosition;

// components/Stats/Collapsible.tsx
init_define_import_meta_env();
var import_jsx_runtime133 = __toESM(require_jsx_runtime(), 1);
var Collapsible = ({
  label,
  open,
  openTrigger,
  children
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime133.jsxs)(import_jsx_runtime133.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime133.jsxs)(
      "div",
      {
        style: {
          cursor: "pointer",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center"
        },
        onClick: openTrigger,
        children: [
          label,
          /* @__PURE__ */ (0, import_jsx_runtime133.jsx)(InlineIcon, { icon: open ? collapseUpIcon : collapseDownIcon })
        ]
      }
    ),
    open && /* @__PURE__ */ (0, import_jsx_runtime133.jsx)("div", { style: { display: "flex", flexDirection: "column" }, children })
  ] });
};
var Collapsible_default = Collapsible;

// components/Stats/CanvasGrid.tsx
init_define_import_meta_env();
var import_jsx_runtime134 = __toESM(require_jsx_runtime(), 1);
var STEP_SIZE9 = 5;
var CanvasGrid = ({
  property,
  scene,
  appState,
  setAppState
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime134.jsx)(
    DragInput_default,
    {
      label: "Grid step",
      sensitivity: 8,
      elements: [],
      dragInputCallback: ({
        nextValue,
        instantChange,
        shouldChangeByStepSize,
        setInputValue
      }) => {
        setAppState((state) => {
          let nextGridStep;
          if (nextValue) {
            nextGridStep = nextValue;
          } else if (instantChange) {
            nextGridStep = shouldChangeByStepSize ? getStepSizedValue(
              state.gridStep + STEP_SIZE9 * Math.sign(instantChange),
              STEP_SIZE9
            ) : state.gridStep + instantChange;
          }
          if (!nextGridStep) {
            setInputValue(state.gridStep);
            return null;
          }
          nextGridStep = getNormalizedGridStep(nextGridStep);
          setInputValue(nextGridStep);
          return {
            gridStep: nextGridStep
          };
        });
      },
      scene,
      value: appState.gridStep,
      property,
      appState
    }
  );
};
var CanvasGrid_default = CanvasGrid;

// components/Stats/index.tsx
var import_jsx_runtime135 = __toESM(require_jsx_runtime(), 1);
var STATS_TIMEOUT = 50;
var Stats = (props) => {
  const appState = useExcalidrawAppState();
  const sceneNonce = props.app.scene.getSceneNonce() || 1;
  const selectedElements = props.app.scene.getSelectedElements({
    selectedElementIds: appState.selectedElementIds,
    includeBoundTextElement: false
  });
  const gridModeEnabled = isGridModeEnabled(props.app);
  return /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(
    StatsInner,
    {
      ...props,
      appState,
      sceneNonce,
      selectedElements,
      gridModeEnabled
    }
  );
};
var StatsRow = ({
  children,
  columns = 1,
  heading,
  style,
  ...rest
}) => /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(
  "div",
  {
    className: clsx_m_default("exc-stats__row", { "exc-stats__row--heading": heading }),
    style: {
      gridTemplateColumns: `repeat(${columns}, 1fr)`,
      ...style
    },
    ...rest,
    children
  }
);
StatsRow.displayName = "StatsRow";
var StatsRows = ({
  children,
  order,
  style,
  ...rest
}) => /* @__PURE__ */ (0, import_jsx_runtime135.jsx)("div", { className: "exc-stats__rows", style: { order, ...style }, ...rest, children });
StatsRows.displayName = "StatsRows";
Stats.StatsRow = StatsRow;
Stats.StatsRows = StatsRows;
var StatsInner = (0, import_react106.memo)(
  ({
    app,
    onClose,
    renderCustomStats,
    selectedElements,
    appState,
    sceneNonce,
    gridModeEnabled
  }) => {
    const scene = app.scene;
    const elements = scene.getNonDeletedElements();
    const elementsMap = scene.getNonDeletedElementsMap();
    const setAppState = useExcalidrawSetAppState();
    const singleElement = selectedElements.length === 1 ? selectedElements[0] : null;
    const multipleElements = selectedElements.length > 1 ? selectedElements : null;
    const [sceneDimension, setSceneDimension] = (0, import_react106.useState)({
      width: 0,
      height: 0
    });
    const throttledSetSceneDimension = (0, import_react106.useMemo)(
      () => (0, import_lodash3.throttle)((elements2) => {
        const boundingBox = getCommonBounds(elements2);
        setSceneDimension({
          width: Math.round(boundingBox[2]) - Math.round(boundingBox[0]),
          height: Math.round(boundingBox[3]) - Math.round(boundingBox[1])
        });
      }, STATS_TIMEOUT),
      []
    );
    (0, import_react106.useEffect)(() => {
      throttledSetSceneDimension(elements);
    }, [sceneNonce, elements, throttledSetSceneDimension]);
    (0, import_react106.useEffect)(
      () => () => throttledSetSceneDimension.cancel(),
      [throttledSetSceneDimension]
    );
    const atomicUnits = (0, import_react106.useMemo)(() => {
      return getAtomicUnits(selectedElements, appState);
    }, [selectedElements, appState]);
    return /* @__PURE__ */ (0, import_jsx_runtime135.jsx)("div", { className: "exc-stats", children: /* @__PURE__ */ (0, import_jsx_runtime135.jsxs)(Island, { padding: 3, children: [
      /* @__PURE__ */ (0, import_jsx_runtime135.jsxs)("div", { className: "title", children: [
        /* @__PURE__ */ (0, import_jsx_runtime135.jsx)("h2", { children: t("stats.title") }),
        /* @__PURE__ */ (0, import_jsx_runtime135.jsx)("div", { className: "close", onClick: onClose, children: CloseIcon })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime135.jsxs)(
        Collapsible_default,
        {
          label: /* @__PURE__ */ (0, import_jsx_runtime135.jsx)("h3", { children: t("stats.generalStats") }),
          open: !!(appState.stats.panels & STATS_PANELS.generalStats),
          openTrigger: () => setAppState((state) => {
            return {
              stats: {
                open: true,
                panels: state.stats.panels ^ STATS_PANELS.generalStats
              }
            };
          }),
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime135.jsxs)(StatsRows, { children: [
              /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(StatsRow, { heading: true, children: t("stats.scene") }),
              /* @__PURE__ */ (0, import_jsx_runtime135.jsxs)(StatsRow, { columns: 2, children: [
                /* @__PURE__ */ (0, import_jsx_runtime135.jsx)("div", { children: t("stats.shapes") }),
                /* @__PURE__ */ (0, import_jsx_runtime135.jsx)("div", { children: elements.length })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime135.jsxs)(StatsRow, { columns: 2, children: [
                /* @__PURE__ */ (0, import_jsx_runtime135.jsx)("div", { children: t("stats.width") }),
                /* @__PURE__ */ (0, import_jsx_runtime135.jsx)("div", { children: sceneDimension.width })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime135.jsxs)(StatsRow, { columns: 2, children: [
                /* @__PURE__ */ (0, import_jsx_runtime135.jsx)("div", { children: t("stats.height") }),
                /* @__PURE__ */ (0, import_jsx_runtime135.jsx)("div", { children: sceneDimension.height })
              ] }),
              gridModeEnabled && /* @__PURE__ */ (0, import_jsx_runtime135.jsxs)(import_jsx_runtime135.Fragment, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(StatsRow, { heading: true, children: "Canvas" }),
                /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(StatsRow, { children: /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(
                  CanvasGrid_default,
                  {
                    property: "gridStep",
                    scene,
                    appState,
                    setAppState
                  }
                ) })
              ] })
            ] }),
            renderCustomStats?.(elements, appState)
          ]
        }
      ),
      selectedElements.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(
        "div",
        {
          id: "elementStats",
          style: {
            marginTop: 12
          },
          children: /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(
            Collapsible_default,
            {
              label: /* @__PURE__ */ (0, import_jsx_runtime135.jsx)("h3", { children: t("stats.elementProperties") }),
              open: !!(appState.stats.panels & STATS_PANELS.elementProperties),
              openTrigger: () => setAppState((state) => {
                return {
                  stats: {
                    open: true,
                    panels: state.stats.panels ^ STATS_PANELS.elementProperties
                  }
                };
              }),
              children: /* @__PURE__ */ (0, import_jsx_runtime135.jsxs)(StatsRows, { children: [
                singleElement && /* @__PURE__ */ (0, import_jsx_runtime135.jsxs)(import_jsx_runtime135.Fragment, { children: [
                  /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(StatsRow, { heading: true, "data-testid": "stats-element-type", children: t(`element.${singleElement.type}`) }),
                  /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(StatsRow, { children: /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(
                    Position_default,
                    {
                      element: singleElement,
                      property: "x",
                      elementsMap,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(StatsRow, { children: /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(
                    Position_default,
                    {
                      element: singleElement,
                      property: "y",
                      elementsMap,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(StatsRow, { children: /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(
                    Dimension_default,
                    {
                      property: "width",
                      element: singleElement,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(StatsRow, { children: /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(
                    Dimension_default,
                    {
                      property: "height",
                      element: singleElement,
                      scene,
                      appState
                    }
                  ) }),
                  !isElbowArrow(singleElement) && /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(StatsRow, { children: /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(
                    Angle_default,
                    {
                      property: "angle",
                      element: singleElement,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(StatsRow, { children: /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(
                    FontSize_default,
                    {
                      property: "fontSize",
                      element: singleElement,
                      scene,
                      appState
                    }
                  ) })
                ] }),
                multipleElements && /* @__PURE__ */ (0, import_jsx_runtime135.jsxs)(import_jsx_runtime135.Fragment, { children: [
                  elementsAreInSameGroup(multipleElements) && /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(StatsRow, { heading: true, children: t("element.group") }),
                  /* @__PURE__ */ (0, import_jsx_runtime135.jsxs)(StatsRow, { columns: 2, style: { margin: "0.3125rem 0" }, children: [
                    /* @__PURE__ */ (0, import_jsx_runtime135.jsx)("div", { children: t("stats.shapes") }),
                    /* @__PURE__ */ (0, import_jsx_runtime135.jsx)("div", { children: selectedElements.length })
                  ] }),
                  /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(StatsRow, { children: /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(
                    MultiPosition_default,
                    {
                      property: "x",
                      elements: multipleElements,
                      elementsMap,
                      atomicUnits,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(StatsRow, { children: /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(
                    MultiPosition_default,
                    {
                      property: "y",
                      elements: multipleElements,
                      elementsMap,
                      atomicUnits,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(StatsRow, { children: /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(
                    MultiDimension_default,
                    {
                      property: "width",
                      elements: multipleElements,
                      elementsMap,
                      atomicUnits,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(StatsRow, { children: /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(
                    MultiDimension_default,
                    {
                      property: "height",
                      elements: multipleElements,
                      elementsMap,
                      atomicUnits,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(StatsRow, { children: /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(
                    MultiAngle_default,
                    {
                      property: "angle",
                      elements: multipleElements,
                      scene,
                      appState
                    }
                  ) }),
                  /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(StatsRow, { children: /* @__PURE__ */ (0, import_jsx_runtime135.jsx)(
                    MultiFontSize_default,
                    {
                      property: "fontSize",
                      elements: multipleElements,
                      scene,
                      appState,
                      elementsMap
                    }
                  ) })
                ] })
              ] })
            }
          )
        }
      )
    ] }) });
  },
  (prev, next) => {
    return prev.sceneNonce === next.sceneNonce && prev.selectedElements === next.selectedElements && prev.appState.stats.panels === next.appState.stats.panels && prev.gridModeEnabled === next.gridModeEnabled && prev.appState.gridStep === next.appState.gridStep;
  }
);

// components/LayerUI.tsx
var import_jsx_runtime136 = __toESM(require_jsx_runtime(), 1);
var DefaultMainMenu = ({ UIOptions }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime136.jsxs)(MainMenu_default, { __fallback: true, children: [
    /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(MainMenu_default.DefaultItems.LoadScene, {}),
    /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(MainMenu_default.DefaultItems.SaveToActiveFile, {}),
    UIOptions.canvasActions.export && /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(MainMenu_default.DefaultItems.Export, {}),
    UIOptions.canvasActions.saveAsImage && /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(MainMenu_default.DefaultItems.SaveAsImage, {}),
    /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(MainMenu_default.DefaultItems.SearchMenu, {}),
    /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(MainMenu_default.DefaultItems.Help, {}),
    /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(MainMenu_default.DefaultItems.ClearCanvas, {}),
    /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(MainMenu_default.Separator, {}),
    /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(MainMenu_default.Group, { title: "Excalidraw links", children: /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(MainMenu_default.DefaultItems.Socials, {}) }),
    /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(MainMenu_default.Separator, {}),
    /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(MainMenu_default.DefaultItems.ToggleTheme, {}),
    /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(MainMenu_default.DefaultItems.ChangeCanvasBackground, {})
  ] });
};
var DefaultOverwriteConfirmDialog = () => {
  return /* @__PURE__ */ (0, import_jsx_runtime136.jsxs)(OverwriteConfirmDialog, { __fallback: true, children: [
    /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(OverwriteConfirmDialog.Actions.SaveToDisk, {}),
    /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(OverwriteConfirmDialog.Actions.ExportToImage, {})
  ] });
};
var LayerUI = ({
  actionManager,
  appState,
  files,
  setAppState,
  elements,
  canvas,
  onLockToggle,
  onHandToolToggle,
  onPenModeToggle,
  showExitZenModeBtn,
  renderTopRightUI,
  renderCustomStats,
  UIOptions,
  onExportImage,
  renderWelcomeScreen,
  children,
  app,
  isCollaborating
}) => {
  const device = useDevice();
  const tunnels = useInitializeTunnels();
  const [eyeDropperState, setEyeDropperState] = useAtom(
    activeEyeDropperAtom,
    jotaiScope
  );
  const renderJSONExportDialog = () => {
    if (!UIOptions.canvasActions.export) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(
      JSONExportDialog,
      {
        elements,
        appState,
        files,
        actionManager,
        exportOpts: UIOptions.canvasActions.export,
        canvas,
        setAppState
      }
    );
  };
  const renderImageExportDialog = () => {
    if (!UIOptions.canvasActions.saveAsImage || appState.openDialog?.name !== "imageExport") {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(
      ImageExportDialog,
      {
        elements,
        appState,
        files,
        actionManager,
        onExportImage,
        onCloseRequest: () => setAppState({ openDialog: null }),
        name: app.getName()
      }
    );
  };
  const renderCanvasActions = () => /* @__PURE__ */ (0, import_jsx_runtime136.jsxs)("div", { style: { position: "relative" }, children: [
    /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(tunnels.MainMenuTunnel.Out, {}),
    renderWelcomeScreen && /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(tunnels.WelcomeScreenMenuHintTunnel.Out, {})
  ] });
  const renderSelectedShapeActions = () => /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(
    Section,
    {
      heading: "selectedShapeActions",
      className: clsx_m_default("selected-shape-actions zen-mode-transition", {
        "transition-left": appState.zenModeEnabled
      }),
      children: /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(
        Island,
        {
          className: CLASSES.SHAPE_ACTIONS_MENU,
          padding: 2,
          style: {
            // we want to make sure this doesn't overflow so subtracting the
            // approximate height of hamburgerMenu + footer
            maxHeight: `${appState.height - 166}px`
          },
          children: /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(
            SelectedShapeActions,
            {
              appState,
              elementsMap: app.scene.getNonDeletedElementsMap(),
              renderAction: actionManager.renderAction
            }
          )
        }
      )
    }
  );
  const renderFixedSideContainer = () => {
    const shouldRenderSelectedShapeActions = showSelectedShapeActions(
      appState,
      elements
    );
    const shouldShowStats = appState.stats.open && !appState.zenModeEnabled && !appState.viewModeEnabled;
    return /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(FixedSideContainer, { side: "left", children: /* @__PURE__ */ (0, import_jsx_runtime136.jsxs)("div", { className: "", children: [
      /* @__PURE__ */ (0, import_jsx_runtime136.jsxs)(Stack_default.Row, { gap: 6, className: clsx_m_default(""), children: [
        renderCanvasActions(),
        shouldRenderSelectedShapeActions && renderSelectedShapeActions()
      ] }),
      !appState.viewModeEnabled && /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(Section, { heading: "shapes", className: "", children: (heading) => /* @__PURE__ */ (0, import_jsx_runtime136.jsxs)("div", { children: [
        renderWelcomeScreen && /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(tunnels.WelcomeScreenToolbarHintTunnel.Out, {}),
        /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(Stack_default.Row, { gap: 4, children: /* @__PURE__ */ (0, import_jsx_runtime136.jsxs)(
          Stack_default.Row,
          {
            gap: 1,
            className: clsx_m_default("", {
              "zen-mode": appState.zenModeEnabled
            }),
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime136.jsxs)(
                Island,
                {
                  padding: 1,
                  style: {
                    marginTop: 60,
                    marginLeft: 7
                  },
                  className: clsx_m_default(".App-toolbar__tools", {
                    "zen-mode": appState.zenModeEnabled
                  }),
                  children: [
                    /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(
                      HintViewer,
                      {
                        appState,
                        isMobile: device.editor.isMobile,
                        device,
                        app
                      }
                    ),
                    heading,
                    /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(
                      PenModeButton,
                      {
                        zenModeEnabled: appState.zenModeEnabled,
                        checked: appState.penMode,
                        onChange: () => onPenModeToggle(null),
                        title: t("toolBar.penMode"),
                        penDetected: appState.penDetected
                      }
                    ),
                    /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(
                      LockButton,
                      {
                        checked: appState.activeTool.locked,
                        onChange: onLockToggle,
                        title: t("toolBar.lock")
                      }
                    ),
                    /* @__PURE__ */ (0, import_jsx_runtime136.jsx)("div", { className: "App-toolbar__divider" }),
                    /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(
                      HandButton,
                      {
                        checked: isHandToolActive(appState),
                        onChange: () => onHandToolToggle(),
                        title: t("toolBar.hand"),
                        isMobile: true
                      }
                    ),
                    /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(
                      ShapesSwitcher,
                      {
                        appState,
                        activeTool: appState.activeTool,
                        UIOptions,
                        app
                      }
                    )
                  ]
                }
              ),
              isCollaborating && /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(
                Island,
                {
                  style: {
                    marginLeft: 8,
                    alignSelf: "center",
                    height: "fit-content"
                  },
                  children: /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(
                    LaserPointerButton,
                    {
                      title: t("toolBar.laser"),
                      checked: appState.activeTool.type === TOOL_TYPE.laser,
                      onChange: () => app.setActiveTool({ type: TOOL_TYPE.laser }),
                      isMobile: true
                    }
                  )
                }
              )
            ]
          }
        ) })
      ] }) }),
      /* @__PURE__ */ (0, import_jsx_runtime136.jsxs)(
        "div",
        {
          className: clsx_m_default(
            "layer-ui__wrapper__top-right zen-mode-transition",
            {
              "transition-right": appState.zenModeEnabled
            }
          ),
          children: [
            appState.collaborators.size > 0 && /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(
              UserList,
              {
                collaborators: appState.collaborators,
                userToFollow: appState.userToFollow?.socketId || null
              }
            ),
            renderTopRightUI?.(device.editor.isMobile, appState),
            !appState.viewModeEnabled && // hide button when sidebar docked
            (!isSidebarDocked || appState.openSidebar?.name !== DEFAULT_SIDEBAR.name) && /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(tunnels.DefaultSidebarTriggerTunnel.Out, {}),
            shouldShowStats && /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(
              Stats,
              {
                app,
                onClose: () => {
                  actionManager.executeAction(actionToggleStats);
                },
                renderCustomStats
              }
            )
          ]
        }
      )
    ] }) });
  };
  const renderSidebars = () => {
    return /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(
      DefaultSidebar,
      {
        __fallback: true,
        onDock: (docked) => {
          trackEvent(
            "sidebar",
            `toggleDock (${docked ? "dock" : "undock"})`,
            `(${device.editor.isMobile ? "mobile" : "desktop"})`
          );
        }
      }
    );
  };
  const isSidebarDocked = useAtomValue(isSidebarDockedAtom, jotaiScope);
  const layerUIJSX = /* @__PURE__ */ (0, import_jsx_runtime136.jsxs)(import_jsx_runtime136.Fragment, { children: [
    children,
    /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(DefaultMainMenu, { UIOptions }),
    /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(DefaultOverwriteConfirmDialog, {}),
    appState.openDialog?.name === "ttd" && /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(TTDDialog, { __fallback: true }),
    appState.isLoading && /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(LoadingMessage, { delay: 250 }),
    appState.errorMessage && /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(ErrorDialog, { onClose: () => setAppState({ errorMessage: null }), children: appState.errorMessage }),
    eyeDropperState && !device.editor.isMobile && /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(
      EyeDropper,
      {
        colorPickerType: eyeDropperState.colorPickerType,
        onCancel: () => {
          setEyeDropperState(null);
        },
        onChange: (colorPickerType, color, selectedElements, { altKey }) => {
          if (colorPickerType !== "elementBackground" && colorPickerType !== "elementStroke") {
            return;
          }
          if (selectedElements.length) {
            for (const element of selectedElements) {
              mutateElement(
                element,
                {
                  [altKey && eyeDropperState.swapPreviewOnAlt ? colorPickerType === "elementBackground" ? "strokeColor" : "backgroundColor" : colorPickerType === "elementBackground" ? "backgroundColor" : "strokeColor"]: color
                },
                false
              );
              ShapeCache.delete(element);
            }
            Scene_default.getScene(selectedElements[0])?.triggerUpdate();
          } else if (colorPickerType === "elementBackground") {
            setAppState({
              currentItemBackgroundColor: color
            });
          } else {
            setAppState({ currentItemStrokeColor: color });
          }
        },
        onSelect: (color, event) => {
          setEyeDropperState((state) => {
            return state?.keepOpenOnAlt && event.altKey ? state : null;
          });
          eyeDropperState?.onSelect?.(color, event);
        }
      }
    ),
    appState.openDialog?.name === "help" && /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(
      HelpDialog,
      {
        onClose: () => {
          setAppState({ openDialog: null });
        }
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(ActiveConfirmDialog, {}),
    /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(tunnels.OverwriteConfirmDialogTunnel.Out, {}),
    renderImageExportDialog(),
    renderJSONExportDialog(),
    appState.pasteDialog.shown && /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(
      PasteChartDialog,
      {
        setAppState,
        appState,
        onClose: () => setAppState({
          pasteDialog: { shown: false, data: null }
        })
      }
    ),
    device.editor.isMobile && /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(
      MobileMenu,
      {
        app,
        appState,
        elements,
        actionManager,
        renderJSONExportDialog,
        renderImageExportDialog,
        setAppState,
        onLockToggle,
        onHandToolToggle,
        onPenModeToggle,
        renderTopRightUI,
        renderCustomStats,
        renderSidebars,
        device,
        renderWelcomeScreen,
        UIOptions
      }
    ),
    !device.editor.isMobile && /* @__PURE__ */ (0, import_jsx_runtime136.jsxs)(import_jsx_runtime136.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime136.jsxs)(
        "div",
        {
          className: "layer-ui__wrapper",
          style: appState.openSidebar && isSidebarDocked && device.editor.canFitSidebar ? { width: `calc(100% - ${LIBRARY_SIDEBAR_WIDTH}px)` } : {},
          children: [
            renderWelcomeScreen && /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(tunnels.WelcomeScreenCenterTunnel.Out, {}),
            renderFixedSideContainer(),
            /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(
              Footer_default,
              {
                appState,
                actionManager,
                showExitZenModeBtn,
                renderWelcomeScreen
              }
            ),
            appState.scrolledOutside && /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(
              "button",
              {
                type: "button",
                className: "scroll-back-to-content",
                onClick: () => {
                  setAppState((appState2) => ({
                    ...calculateScrollCenter(elements, appState2)
                  }));
                },
                children: t("buttons.scrollBackToContent")
              }
            )
          ]
        }
      ),
      renderSidebars()
    ] })
  ] });
  return /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(UIAppStateContext.Provider, { value: appState, children: /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(Provider, { scope: tunnels.jotaiScope, children: /* @__PURE__ */ (0, import_jsx_runtime136.jsx)(TunnelsContext.Provider, { value: tunnels, children: layerUIJSX }) }) });
};
var stripIrrelevantAppStateProps = (appState) => {
  const {
    suggestedBindings,
    startBoundElement,
    cursorButton,
    scrollX,
    scrollY,
    ...ret
  } = appState;
  return ret;
};
var areEqual2 = (prevProps, nextProps) => {
  if (prevProps.children !== nextProps.children) {
    return false;
  }
  const { canvas: _pC, appState: prevAppState, ...prev } = prevProps;
  const { canvas: _nC, appState: nextAppState, ...next } = nextProps;
  return isShallowEqual(
    // asserting AppState because we're being passed the whole AppState
    // but resolve to only the UI-relevant props
    stripIrrelevantAppStateProps(prevAppState),
    stripIrrelevantAppStateProps(nextAppState),
    {
      selectedElementIds: isShallowEqual,
      selectedGroupIds: isShallowEqual
    }
  ) && isShallowEqual(prev, next);
};
var LayerUI_default = import_react107.default.memo(LayerUI, areEqual2);

// components/Toast.tsx
init_define_import_meta_env();
var import_react108 = __toESM(require_react(), 1);
var import_jsx_runtime137 = __toESM(require_jsx_runtime(), 1);
var DEFAULT_TOAST_TIMEOUT = 5e3;
var Toast = ({
  message,
  onClose,
  closable = false,
  // To prevent autoclose, pass duration as Infinity
  duration = DEFAULT_TOAST_TIMEOUT,
  style
}) => {
  const timerRef = (0, import_react108.useRef)(0);
  const shouldAutoClose = duration !== Infinity;
  const scheduleTimeout = (0, import_react108.useCallback)(() => {
    if (!shouldAutoClose) {
      return;
    }
    timerRef.current = window.setTimeout(() => onClose(), duration);
  }, [onClose, duration, shouldAutoClose]);
  (0, import_react108.useEffect)(() => {
    if (!shouldAutoClose) {
      return;
    }
    scheduleTimeout();
    return () => clearTimeout(timerRef.current);
  }, [scheduleTimeout, message, duration, shouldAutoClose]);
  const onMouseEnter = shouldAutoClose ? () => clearTimeout(timerRef?.current) : void 0;
  const onMouseLeave = shouldAutoClose ? scheduleTimeout : void 0;
  return /* @__PURE__ */ (0, import_jsx_runtime137.jsxs)(
    "div",
    {
      className: "Toast",
      onMouseEnter,
      onMouseLeave,
      style,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime137.jsx)("p", { className: "Toast__message", children: message }),
        closable && /* @__PURE__ */ (0, import_jsx_runtime137.jsx)(
          ToolButton,
          {
            icon: CloseIcon,
            "aria-label": "close",
            type: "icon",
            onClick: onClose,
            className: "close"
          }
        )
      ]
    }
  );
};

// actions/actionToggleViewMode.tsx
init_define_import_meta_env();
var actionToggleViewMode = register({
  name: "viewMode",
  label: "labels.viewMode",
  paletteName: "Toggle view mode",
  icon: eyeIcon,
  viewMode: true,
  trackEvent: {
    category: "canvas",
    predicate: (appState) => !appState.viewModeEnabled
  },
  perform(elements, appState) {
    return {
      appState: {
        ...appState,
        viewModeEnabled: !this.checked(appState)
      },
      storeAction: StoreAction.NONE
    };
  },
  checked: (appState) => appState.viewModeEnabled,
  predicate: (elements, appState, appProps) => {
    return typeof appProps.viewModeEnabled === "undefined";
  },
  keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && event.altKey && event.code === CODES.R
});

// components/App.tsx
var import_lodash4 = __toESM(require_lodash(), 1);

// actions/actionFrame.ts
init_define_import_meta_env();
var isSingleFrameSelected = (appState, app) => {
  const selectedElements = app.scene.getSelectedElements(appState);
  return selectedElements.length === 1 && isFrameLikeElement(selectedElements[0]);
};
var actionSelectAllElementsInFrame = register({
  name: "selectAllElementsInFrame",
  label: "labels.selectAllElementsInFrame",
  trackEvent: { category: "canvas" },
  perform: (elements, appState, _, app) => {
    const selectedElement = app.scene.getSelectedElements(appState).at(0) || null;
    if (isFrameLikeElement(selectedElement)) {
      const elementsInFrame = getFrameChildren(
        getNonDeletedElements(elements),
        selectedElement.id
      ).filter((element) => !(element.type === "text" && element.containerId));
      return {
        elements,
        appState: {
          ...appState,
          selectedElementIds: elementsInFrame.reduce((acc, element) => {
            acc[element.id] = true;
            return acc;
          }, {})
        },
        storeAction: StoreAction.CAPTURE
      };
    }
    return {
      elements,
      appState,
      storeAction: StoreAction.NONE
    };
  },
  predicate: (elements, appState, _, app) => isSingleFrameSelected(appState, app)
});
var actionRemoveAllElementsFromFrame = register({
  name: "removeAllElementsFromFrame",
  label: "labels.removeAllElementsFromFrame",
  trackEvent: { category: "history" },
  perform: (elements, appState, _, app) => {
    const selectedElement = app.scene.getSelectedElements(appState).at(0) || null;
    if (isFrameLikeElement(selectedElement)) {
      return {
        elements: removeAllElementsFromFrame(elements, selectedElement),
        appState: {
          ...appState,
          selectedElementIds: {
            [selectedElement.id]: true
          }
        },
        storeAction: StoreAction.CAPTURE
      };
    }
    return {
      elements,
      appState,
      storeAction: StoreAction.NONE
    };
  },
  predicate: (elements, appState, _, app) => isSingleFrameSelected(appState, app)
});
var actionupdateFrameRendering = register({
  name: "updateFrameRendering",
  label: "labels.updateFrameRendering",
  viewMode: true,
  trackEvent: { category: "canvas" },
  perform: (elements, appState) => {
    return {
      elements,
      appState: {
        ...appState,
        frameRendering: {
          ...appState.frameRendering,
          enabled: !appState.frameRendering.enabled
        }
      },
      storeAction: StoreAction.NONE
    };
  },
  checked: (appState) => appState.frameRendering.enabled
});
var actionSetFrameAsActiveTool = register({
  name: "setFrameAsActiveTool",
  label: "toolBar.frame",
  trackEvent: { category: "toolbar" },
  icon: frameToolIcon,
  viewMode: false,
  perform: (elements, appState, _, app) => {
    const nextActiveTool = updateActiveTool(appState, {
      type: "frame"
    });
    setCursorForShape(app.interactiveCanvas, {
      ...appState,
      activeTool: nextActiveTool
    });
    return {
      elements,
      appState: {
        ...appState,
        activeTool: updateActiveTool(appState, {
          type: "frame"
        })
      },
      storeAction: StoreAction.NONE
    };
  },
  keyTest: (event) => !event[KEYS.CTRL_OR_CMD] && !event.shiftKey && !event.altKey && event.key.toLocaleLowerCase() === KEYS.F
});

// components/BraveMeasureTextError.tsx
init_define_import_meta_env();
var import_jsx_runtime138 = __toESM(require_jsx_runtime(), 1);
var BraveMeasureTextError = () => {
  return /* @__PURE__ */ (0, import_jsx_runtime138.jsxs)("div", { "data-testid": "brave-measure-text-error", children: [
    /* @__PURE__ */ (0, import_jsx_runtime138.jsx)("p", { children: /* @__PURE__ */ (0, import_jsx_runtime138.jsx)(
      Trans_default,
      {
        i18nKey: "errors.brave_measure_text_error.line1",
        bold: (el) => /* @__PURE__ */ (0, import_jsx_runtime138.jsx)("span", { style: { fontWeight: 600 }, children: el })
      }
    ) }),
    /* @__PURE__ */ (0, import_jsx_runtime138.jsx)("p", { children: /* @__PURE__ */ (0, import_jsx_runtime138.jsx)(
      Trans_default,
      {
        i18nKey: "errors.brave_measure_text_error.line2",
        bold: (el) => /* @__PURE__ */ (0, import_jsx_runtime138.jsx)("span", { style: { fontWeight: 600 }, children: el })
      }
    ) }),
    /* @__PURE__ */ (0, import_jsx_runtime138.jsx)("p", { children: /* @__PURE__ */ (0, import_jsx_runtime138.jsx)(
      Trans_default,
      {
        i18nKey: "errors.brave_measure_text_error.line3",
        link: (el) => /* @__PURE__ */ (0, import_jsx_runtime138.jsx)("a", { href: "http://docs.excalidraw.com/docs/@excalidraw/excalidraw/faq#turning-off-aggresive-block-fingerprinting-in-brave-browser", children: el })
      }
    ) }),
    /* @__PURE__ */ (0, import_jsx_runtime138.jsx)("p", { children: /* @__PURE__ */ (0, import_jsx_runtime138.jsx)(
      Trans_default,
      {
        i18nKey: "errors.brave_measure_text_error.line4",
        issueLink: (el) => /* @__PURE__ */ (0, import_jsx_runtime138.jsx)("a", { href: "https://github.com/excalidraw/excalidraw/issues/new", children: el }),
        discordLink: (el) => /* @__PURE__ */ (0, import_jsx_runtime138.jsxs)("a", { href: "https://discord.gg/UexuTaE", children: [
          el,
          "."
        ] })
      }
    ) })
  ] });
};
var BraveMeasureTextError_default = BraveMeasureTextError;

// data/transform.ts
init_define_import_meta_env();
var DEFAULT_LINEAR_ELEMENT_PROPS = {
  width: 100,
  height: 0
};
var DEFAULT_DIMENSION = 100;
var bindTextToContainer = (container, textProps, elementsMap) => {
  const textElement = newTextElement({
    x: 0,
    y: 0,
    textAlign: TEXT_ALIGN.CENTER,
    verticalAlign: VERTICAL_ALIGN.MIDDLE,
    ...textProps,
    containerId: container.id,
    strokeColor: textProps.strokeColor || container.strokeColor
  });
  Object.assign(container, {
    boundElements: (container.boundElements || []).concat({
      type: "text",
      id: textElement.id
    })
  });
  redrawTextBoundingBox(textElement, container, elementsMap);
  return [container, textElement];
};
var bindLinearElementToElement = (linearElement, start, end, elementStore, elementsMap) => {
  let startBoundElement;
  let endBoundElement;
  Object.assign(linearElement, {
    startBinding: linearElement?.startBinding || null,
    endBinding: linearElement.endBinding || null
  });
  if (start) {
    const width = start?.width ?? DEFAULT_DIMENSION;
    const height = start?.height ?? DEFAULT_DIMENSION;
    let existingElement;
    if (start.id) {
      existingElement = elementStore.getElement(start.id);
      if (!existingElement) {
        console.error(`No element for start binding with id ${start.id} found`);
      }
    }
    const startX = start.x || linearElement.x - width;
    const startY = start.y || linearElement.y - height / 2;
    const startType = existingElement ? existingElement.type : start.type;
    if (startType) {
      if (startType === "text") {
        let text = "";
        if (existingElement && existingElement.type === "text") {
          text = existingElement.text;
        } else if (start.type === "text") {
          text = start.text;
        }
        if (!text) {
          console.error(
            `No text found for start binding text element for ${linearElement.id}`
          );
        }
        startBoundElement = newTextElement({
          x: startX,
          y: startY,
          type: "text",
          ...existingElement,
          ...start,
          text
        });
        Object.assign(startBoundElement, {
          x: start.x || linearElement.x - startBoundElement.width,
          y: start.y || linearElement.y - startBoundElement.height / 2
        });
      } else {
        switch (startType) {
          case "rectangle":
          case "ellipse":
          case "diamond": {
            startBoundElement = newElement({
              x: startX,
              y: startY,
              width,
              height,
              ...existingElement,
              ...start,
              type: startType
            });
            break;
          }
          default: {
            assertNever(
              linearElement,
              `Unhandled element start type "${start.type}"`,
              true
            );
          }
        }
      }
      bindLinearElement(
        linearElement,
        startBoundElement,
        "start",
        elementsMap
      );
    }
  }
  if (end) {
    const height = end?.height ?? DEFAULT_DIMENSION;
    const width = end?.width ?? DEFAULT_DIMENSION;
    let existingElement;
    if (end.id) {
      existingElement = elementStore.getElement(end.id);
      if (!existingElement) {
        console.error(`No element for end binding with id ${end.id} found`);
      }
    }
    const endX = end.x || linearElement.x + linearElement.width;
    const endY = end.y || linearElement.y - height / 2;
    const endType = existingElement ? existingElement.type : end.type;
    if (endType) {
      if (endType === "text") {
        let text = "";
        if (existingElement && existingElement.type === "text") {
          text = existingElement.text;
        } else if (end.type === "text") {
          text = end.text;
        }
        if (!text) {
          console.error(
            `No text found for end binding text element for ${linearElement.id}`
          );
        }
        endBoundElement = newTextElement({
          x: endX,
          y: endY,
          type: "text",
          ...existingElement,
          ...end,
          text
        });
        Object.assign(endBoundElement, {
          y: end.y || linearElement.y - endBoundElement.height / 2
        });
      } else {
        switch (endType) {
          case "rectangle":
          case "ellipse":
          case "diamond": {
            endBoundElement = newElement({
              x: endX,
              y: endY,
              width,
              height,
              ...existingElement,
              ...end,
              type: endType
            });
            break;
          }
          default: {
            assertNever(
              linearElement,
              `Unhandled element end type "${endType}"`,
              true
            );
          }
        }
      }
      bindLinearElement(
        linearElement,
        endBoundElement,
        "end",
        elementsMap
      );
    }
  }
  if (linearElement.points.length < 2) {
    return {
      linearElement,
      startBoundElement,
      endBoundElement
    };
  }
  const endPointIndex = linearElement.points.length - 1;
  const delta = 0.5;
  const newPoints = cloneJSON(linearElement.points);
  if (linearElement.points[endPointIndex][0] > linearElement.points[endPointIndex - 1][0]) {
    newPoints[0][0] = delta;
    newPoints[endPointIndex][0] -= delta;
  }
  if (linearElement.points[endPointIndex][0] < linearElement.points[endPointIndex - 1][0]) {
    newPoints[0][0] = -delta;
    newPoints[endPointIndex][0] += delta;
  }
  if (linearElement.points[endPointIndex][1] > linearElement.points[endPointIndex - 1][1]) {
    newPoints[0][1] = delta;
    newPoints[endPointIndex][1] -= delta;
  }
  if (linearElement.points[endPointIndex][1] < linearElement.points[endPointIndex - 1][1]) {
    newPoints[0][1] = -delta;
    newPoints[endPointIndex][1] += delta;
  }
  Object.assign(linearElement, { points: newPoints });
  return {
    linearElement,
    startBoundElement,
    endBoundElement
  };
};
var ElementStore = class {
  excalidrawElements = /* @__PURE__ */ new Map();
  add = (ele) => {
    if (!ele) {
      return;
    }
    this.excalidrawElements.set(ele.id, ele);
  };
  getElements = () => {
    return syncInvalidIndices(Array.from(this.excalidrawElements.values()));
  };
  getElementsMap = () => {
    return toBrandedType(
      arrayToMap(this.getElements())
    );
  };
  getElement = (id) => {
    return this.excalidrawElements.get(id);
  };
};
var convertToExcalidrawElements = (elementsSkeleton, opts) => {
  if (!elementsSkeleton) {
    return [];
  }
  const elements = cloneJSON(elementsSkeleton);
  const elementStore = new ElementStore();
  const elementsWithIds = /* @__PURE__ */ new Map();
  const oldToNewElementIdMap = /* @__PURE__ */ new Map();
  for (const element of elements) {
    let excalidrawElement;
    const originalId = element.id;
    if (opts?.regenerateIds !== false) {
      Object.assign(element, { id: randomId() });
    }
    switch (element.type) {
      case "rectangle":
      case "ellipse":
      case "diamond": {
        const width = element?.label?.text && element.width === void 0 ? 0 : element?.width || DEFAULT_DIMENSION;
        const height = element?.label?.text && element.height === void 0 ? 0 : element?.height || DEFAULT_DIMENSION;
        excalidrawElement = newElement({
          ...element,
          width,
          height
        });
        break;
      }
      case "line": {
        const width = element.width || DEFAULT_LINEAR_ELEMENT_PROPS.width;
        const height = element.height || DEFAULT_LINEAR_ELEMENT_PROPS.height;
        excalidrawElement = newLinearElement({
          width,
          height,
          points: [pointFrom(0, 0), pointFrom(width, height)],
          ...element
        });
        break;
      }
      case "arrow": {
        const width = element.width || DEFAULT_LINEAR_ELEMENT_PROPS.width;
        const height = element.height || DEFAULT_LINEAR_ELEMENT_PROPS.height;
        excalidrawElement = newArrowElement({
          width,
          height,
          endArrowhead: "arrow",
          points: [pointFrom(0, 0), pointFrom(width, height)],
          ...element,
          type: "arrow"
        });
        Object.assign(
          excalidrawElement,
          getSizeFromPoints(excalidrawElement.points)
        );
        break;
      }
      case "text": {
        const fontFamily = element?.fontFamily || DEFAULT_FONT_FAMILY;
        const fontSize = element?.fontSize || DEFAULT_FONT_SIZE;
        const lineHeight = element?.lineHeight || getLineHeight(fontFamily);
        const text = element.text ?? "";
        const normalizedText = normalizeText(text);
        const metrics = measureText(
          normalizedText,
          getFontString({ fontFamily, fontSize }),
          lineHeight
        );
        excalidrawElement = newTextElement({
          width: metrics.width,
          height: metrics.height,
          fontFamily,
          fontSize,
          ...element
        });
        break;
      }
      case "image": {
        excalidrawElement = newImageElement({
          width: element?.width || DEFAULT_DIMENSION,
          height: element?.height || DEFAULT_DIMENSION,
          ...element
        });
        break;
      }
      case "frame": {
        excalidrawElement = newFrameElement({
          x: 0,
          y: 0,
          ...element
        });
        break;
      }
      case "magicframe": {
        excalidrawElement = newMagicFrameElement({
          x: 0,
          y: 0,
          ...element
        });
        break;
      }
      case "freedraw":
      case "iframe":
      case "embeddable": {
        excalidrawElement = element;
        break;
      }
      default: {
        excalidrawElement = element;
        assertNever(
          element,
          `Unhandled element type "${element.type}"`,
          true
        );
      }
    }
    const existingElement = elementStore.getElement(excalidrawElement.id);
    if (existingElement) {
      console.error(`Duplicate id found for ${excalidrawElement.id}`);
    } else {
      elementStore.add(excalidrawElement);
      elementsWithIds.set(excalidrawElement.id, element);
      if (originalId) {
        oldToNewElementIdMap.set(originalId, excalidrawElement.id);
      }
    }
  }
  const elementsMap = elementStore.getElementsMap();
  for (const [id, element] of elementsWithIds) {
    const excalidrawElement = elementStore.getElement(id);
    switch (element.type) {
      case "rectangle":
      case "ellipse":
      case "diamond":
      case "arrow": {
        if (element.label?.text) {
          let [container, text] = bindTextToContainer(
            excalidrawElement,
            element?.label,
            elementsMap
          );
          elementStore.add(container);
          elementStore.add(text);
          if (isArrowElement(container)) {
            const originalStart = element.type === "arrow" ? element?.start : void 0;
            const originalEnd = element.type === "arrow" ? element?.end : void 0;
            if (originalStart && originalStart.id) {
              const newStartId = oldToNewElementIdMap.get(originalStart.id);
              if (newStartId) {
                Object.assign(originalStart, { id: newStartId });
              }
            }
            if (originalEnd && originalEnd.id) {
              const newEndId = oldToNewElementIdMap.get(originalEnd.id);
              if (newEndId) {
                Object.assign(originalEnd, { id: newEndId });
              }
            }
            const { linearElement, startBoundElement, endBoundElement } = bindLinearElementToElement(
              container,
              originalStart,
              originalEnd,
              elementStore,
              elementsMap
            );
            container = linearElement;
            elementStore.add(linearElement);
            elementStore.add(startBoundElement);
            elementStore.add(endBoundElement);
          }
        } else {
          switch (element.type) {
            case "arrow": {
              const { start, end } = element;
              if (start && start.id) {
                const newStartId = oldToNewElementIdMap.get(start.id);
                Object.assign(start, { id: newStartId });
              }
              if (end && end.id) {
                const newEndId = oldToNewElementIdMap.get(end.id);
                Object.assign(end, { id: newEndId });
              }
              const { linearElement, startBoundElement, endBoundElement } = bindLinearElementToElement(
                excalidrawElement,
                start,
                end,
                elementStore,
                elementsMap
              );
              elementStore.add(linearElement);
              elementStore.add(startBoundElement);
              elementStore.add(endBoundElement);
              break;
            }
          }
        }
        break;
      }
    }
  }
  for (const [id, element] of elementsWithIds) {
    if (element.type !== "frame" && element.type !== "magicframe") {
      continue;
    }
    const frame = elementStore.getElement(id);
    if (!frame) {
      throw new Error(`Excalidraw element with id ${id} doesn't exist`);
    }
    const childrenElements = [];
    element.children.forEach((id2) => {
      const newElementId = oldToNewElementIdMap.get(id2);
      if (!newElementId) {
        throw new Error(`Element with ${id2} wasn't mapped correctly`);
      }
      const elementInFrame = elementStore.getElement(newElementId);
      if (!elementInFrame) {
        throw new Error(`Frame element with id ${newElementId} doesn't exist`);
      }
      Object.assign(elementInFrame, { frameId: frame.id });
      elementInFrame?.boundElements?.forEach((boundElement) => {
        const ele = elementStore.getElement(boundElement.id);
        if (!ele) {
          throw new Error(
            `Bound element with id ${boundElement.id} doesn't exist`
          );
        }
        Object.assign(ele, { frameId: frame.id });
        childrenElements.push(ele);
      });
      childrenElements.push(elementInFrame);
    });
    let [minX, minY, maxX, maxY] = getCommonBounds(childrenElements);
    const PADDING = 10;
    minX = minX - PADDING;
    minY = minY - PADDING;
    maxX = maxX + PADDING;
    maxY = maxY + PADDING;
    const frameX = frame?.x || minX;
    const frameY = frame?.y || minY;
    const frameWidth = frame?.width || maxX - minX;
    const frameHeight = frame?.height || maxY - minY;
    Object.assign(frame, {
      x: frameX,
      y: frameY,
      width: frameWidth,
      height: frameHeight
    });
    if (isDevEnv() && element.children.length && (frame?.x || frame?.y || frame?.width || frame?.height)) {
      console.info(
        "User provided frame attributes are being considered, if you find this inaccurate, please remove any of the attributes - x, y, width and height so frame coordinates and dimensions are calculated automatically"
      );
    }
  }
  return elementStore.getElements();
};

// components/canvases/index.tsx
init_define_import_meta_env();

// components/canvases/InteractiveCanvas.tsx
init_define_import_meta_env();
var import_react110 = __toESM(require_react(), 1);

// reactUtils.ts
init_define_import_meta_env();
var import_react_dom8 = __toESM(require_react_dom(), 1);
var import_react109 = __toESM(require_react(), 1);
var withBatchedUpdates = (func) => (event) => {
  (0, import_react_dom8.unstable_batchedUpdates)(func, event);
};
var withBatchedUpdatesThrottled = (func) => {
  return throttleRAF((event) => {
    (0, import_react_dom8.unstable_batchedUpdates)(func, event);
  });
};
var isRenderThrottlingEnabled = (() => {
  let IS_REACT_18_AND_UP;
  try {
    const version = import_react109.version.split(".");
    IS_REACT_18_AND_UP = Number(version[0]) > 17;
  } catch {
    IS_REACT_18_AND_UP = false;
  }
  let hasWarned = false;
  return () => {
    if (window.EXCALIDRAW_THROTTLE_RENDER === true) {
      if (!IS_REACT_18_AND_UP) {
        if (!hasWarned) {
          hasWarned = true;
          console.warn(
            "Excalidraw: render throttling is disabled on React versions < 18."
          );
        }
        return false;
      }
      return true;
    }
    return false;
  };
})();

// renderer/interactiveScene.ts
init_define_import_meta_env();

// renderer/renderSnaps.ts
init_define_import_meta_env();
var SNAP_COLOR_LIGHT = "#ff6b6b";
var SNAP_COLOR_DARK = "#ff0000";
var SNAP_WIDTH = 1;
var SNAP_CROSS_SIZE = 2;
var renderSnaps = (context, appState) => {
  if (!appState.snapLines.length) {
    return;
  }
  const snapColor = appState.theme === THEME.LIGHT || appState.zenModeEnabled ? SNAP_COLOR_LIGHT : SNAP_COLOR_DARK;
  const snapWidth = (appState.zenModeEnabled ? SNAP_WIDTH * 1.5 : SNAP_WIDTH) / appState.zoom.value;
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  for (const snapLine of appState.snapLines) {
    if (snapLine.type === "pointer") {
      context.lineWidth = snapWidth;
      context.strokeStyle = snapColor;
      drawPointerSnapLine(snapLine, context, appState);
    } else if (snapLine.type === "gap") {
      context.lineWidth = snapWidth;
      context.strokeStyle = snapColor;
      drawGapLine(
        snapLine.points[0],
        snapLine.points[1],
        snapLine.direction,
        appState,
        context
      );
    } else if (snapLine.type === "points") {
      context.lineWidth = snapWidth;
      context.strokeStyle = snapColor;
      drawPointsSnapLine(snapLine, context, appState);
    }
  }
  context.restore();
};
var drawPointsSnapLine = (pointSnapLine, context, appState) => {
  if (!appState.zenModeEnabled) {
    const firstPoint = pointSnapLine.points[0];
    const lastPoint = pointSnapLine.points[pointSnapLine.points.length - 1];
    drawLine(firstPoint, lastPoint, context);
  }
  for (const point of pointSnapLine.points) {
    drawCross(point, appState, context);
  }
};
var drawPointerSnapLine = (pointerSnapLine, context, appState) => {
  drawCross(pointerSnapLine.points[0], appState, context);
  if (!appState.zenModeEnabled) {
    drawLine(pointerSnapLine.points[0], pointerSnapLine.points[1], context);
  }
};
var drawCross = ([x3, y3], appState, context) => {
  context.save();
  const size = (appState.zenModeEnabled ? SNAP_CROSS_SIZE * 1.5 : SNAP_CROSS_SIZE) / appState.zoom.value;
  context.beginPath();
  context.moveTo(x3 - size, y3 - size);
  context.lineTo(x3 + size, y3 + size);
  context.moveTo(x3 + size, y3 - size);
  context.lineTo(x3 - size, y3 + size);
  context.stroke();
  context.restore();
};
var drawLine = (from, to, context) => {
  context.beginPath();
  context.lineTo(from[0], from[1]);
  context.lineTo(to[0], to[1]);
  context.stroke();
};
var drawGapLine = (from, to, direction, appState, context) => {
  const FULL = 8 / appState.zoom.value;
  const HALF = FULL / 2;
  const QUARTER = FULL / 4;
  if (direction === "horizontal") {
    const halfPoint = [(from[0] + to[0]) / 2, from[1]];
    if (!appState.zenModeEnabled) {
      drawLine(
        pointFrom(from[0], from[1] - FULL),
        pointFrom(from[0], from[1] + FULL),
        context
      );
    }
    drawLine(
      pointFrom(halfPoint[0] - QUARTER, halfPoint[1] - HALF),
      pointFrom(halfPoint[0] - QUARTER, halfPoint[1] + HALF),
      context
    );
    drawLine(
      pointFrom(halfPoint[0] + QUARTER, halfPoint[1] - HALF),
      pointFrom(halfPoint[0] + QUARTER, halfPoint[1] + HALF),
      context
    );
    if (!appState.zenModeEnabled) {
      drawLine(
        pointFrom(to[0], to[1] - FULL),
        pointFrom(to[0], to[1] + FULL),
        context
      );
      drawLine(from, to, context);
    }
  } else {
    const halfPoint = [from[0], (from[1] + to[1]) / 2];
    if (!appState.zenModeEnabled) {
      drawLine(
        pointFrom(from[0] - FULL, from[1]),
        pointFrom(from[0] + FULL, from[1]),
        context
      );
    }
    drawLine(
      pointFrom(halfPoint[0] - HALF, halfPoint[1] - QUARTER),
      pointFrom(halfPoint[0] + HALF, halfPoint[1] - QUARTER),
      context
    );
    drawLine(
      pointFrom(halfPoint[0] - HALF, halfPoint[1] + QUARTER),
      pointFrom(halfPoint[0] + HALF, halfPoint[1] + QUARTER),
      context
    );
    if (!appState.zenModeEnabled) {
      drawLine(
        pointFrom(to[0] - FULL, to[1]),
        pointFrom(to[0] + FULL, to[1]),
        context
      );
      drawLine(from, to, context);
    }
  }
};

// renderer/interactiveScene.ts
var renderLinearElementPointHighlight = (context, appState, elementsMap) => {
  const { elementId, hoverPointIndex } = appState.selectedLinearElement;
  if (appState.editingLinearElement?.selectedPointsIndices?.includes(
    hoverPointIndex
  )) {
    return;
  }
  const element = LinearElementEditor.getElement(elementId, elementsMap);
  if (!element) {
    return;
  }
  const point = LinearElementEditor.getPointAtIndexGlobalCoordinates(
    element,
    hoverPointIndex,
    elementsMap
  );
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  highlightPoint(point, context, appState);
  context.restore();
};
var highlightPoint = (point, context, appState) => {
  context.fillStyle = "rgba(105, 101, 219, 0.4)";
  fillCircle(
    context,
    point[0],
    point[1],
    LinearElementEditor.POINT_HANDLE_SIZE / appState.zoom.value,
    false
  );
};
var strokeRectWithRotation = (context, x3, y3, width, height, cx, cy, angle, fill = false, radius = 0) => {
  context.save();
  context.translate(cx, cy);
  context.rotate(angle);
  if (fill) {
    context.fillRect(x3 - cx, y3 - cy, width, height);
  }
  if (radius && context.roundRect) {
    context.beginPath();
    context.roundRect(x3 - cx, y3 - cy, width, height, radius);
    context.stroke();
    context.closePath();
  } else {
    context.strokeRect(x3 - cx, y3 - cy, width, height);
  }
  context.restore();
};
var strokeDiamondWithRotation = (context, width, height, cx, cy, angle) => {
  context.save();
  context.translate(cx, cy);
  context.rotate(angle);
  context.beginPath();
  context.moveTo(0, height / 2);
  context.lineTo(width / 2, 0);
  context.lineTo(0, -height / 2);
  context.lineTo(-width / 2, 0);
  context.closePath();
  context.stroke();
  context.restore();
};
var renderSingleLinearPoint = (context, appState, point, radius, isSelected, isPhantomPoint = false) => {
  context.strokeStyle = "#5e5ad8";
  context.setLineDash([]);
  context.fillStyle = "rgba(255, 255, 255, 0.9)";
  if (isSelected) {
    context.fillStyle = "rgba(134, 131, 226, 0.9)";
  } else if (isPhantomPoint) {
    context.fillStyle = "rgba(177, 151, 252, 0.7)";
  }
  fillCircle(
    context,
    point[0],
    point[1],
    radius / appState.zoom.value,
    !isPhantomPoint
  );
};
var strokeEllipseWithRotation = (context, width, height, cx, cy, angle) => {
  context.beginPath();
  context.ellipse(cx, cy, width / 2, height / 2, angle, 0, Math.PI * 2);
  context.stroke();
};
var renderBindingHighlightForBindableElement = (context, element, elementsMap) => {
  const [x1, y1, x22, y22] = getElementAbsoluteCoords(element, elementsMap);
  const width = x22 - x1;
  const height = y22 - y1;
  const thickness = 10;
  const strokeOffset = 4;
  context.strokeStyle = "rgba(0,0,0,.05)";
  context.lineWidth = thickness - strokeOffset;
  const padding = strokeOffset / 2 + thickness / 2;
  const radius = getCornerRadius(
    Math.min(element.width, element.height),
    element
  );
  switch (element.type) {
    case "rectangle":
    case "text":
    case "image":
    case "iframe":
    case "embeddable":
    case "frame":
    case "magicframe":
      strokeRectWithRotation(
        context,
        x1 - padding,
        y1 - padding,
        width + padding * 2,
        height + padding * 2,
        x1 + width / 2,
        y1 + height / 2,
        element.angle,
        void 0,
        radius
      );
      break;
    case "diamond":
      const side = Math.hypot(width, height);
      const wPadding = padding * side / height;
      const hPadding = padding * side / width;
      strokeDiamondWithRotation(
        context,
        width + wPadding * 2,
        height + hPadding * 2,
        x1 + width / 2,
        y1 + height / 2,
        element.angle
      );
      break;
    case "ellipse":
      strokeEllipseWithRotation(
        context,
        width + padding * 2,
        height + padding * 2,
        x1 + width / 2,
        y1 + height / 2,
        element.angle
      );
      break;
  }
};
var renderBindingHighlightForSuggestedPointBinding = (context, suggestedBinding, elementsMap) => {
  const [element, startOrEnd, bindableElement] = suggestedBinding;
  const threshold = maxBindingGap(
    bindableElement,
    bindableElement.width,
    bindableElement.height
  );
  context.strokeStyle = "rgba(0,0,0,0)";
  context.fillStyle = "rgba(0,0,0,.05)";
  const pointIndices = startOrEnd === "both" ? [0, -1] : startOrEnd === "start" ? [0] : [-1];
  pointIndices.forEach((index2) => {
    const [x3, y3] = LinearElementEditor.getPointAtIndexGlobalCoordinates(
      element,
      index2,
      elementsMap
    );
    fillCircle(context, x3, y3, threshold);
  });
};
var renderSelectionBorder = (context, appState, elementProperties) => {
  const {
    angle,
    elementX1,
    elementY1,
    elementX2,
    elementY2,
    selectionColors,
    cx,
    cy,
    dashed,
    activeEmbeddable
  } = elementProperties;
  const elementWidth = elementX2 - elementX1;
  const elementHeight = elementY2 - elementY1;
  const padding = DEFAULT_TRANSFORM_HANDLE_SPACING * 2;
  const linePadding = padding / appState.zoom.value;
  const lineWidth = 8 / appState.zoom.value;
  const spaceWidth = 4 / appState.zoom.value;
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  context.lineWidth = (activeEmbeddable ? 4 : 1) / appState.zoom.value;
  const count = selectionColors.length;
  for (let index2 = 0; index2 < count; ++index2) {
    context.strokeStyle = selectionColors[index2];
    if (dashed) {
      context.setLineDash([
        lineWidth,
        spaceWidth + (lineWidth + spaceWidth) * (count - 1)
      ]);
    }
    context.lineDashOffset = (lineWidth + spaceWidth) * index2;
    strokeRectWithRotation(
      context,
      elementX1 - linePadding,
      elementY1 - linePadding,
      elementWidth + linePadding * 2,
      elementHeight + linePadding * 2,
      cx,
      cy,
      angle
    );
  }
  context.restore();
};
var renderBindingHighlight = (context, appState, suggestedBinding, elementsMap) => {
  const renderHighlight = Array.isArray(suggestedBinding) ? renderBindingHighlightForSuggestedPointBinding : renderBindingHighlightForBindableElement;
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  renderHighlight(context, suggestedBinding, elementsMap);
  context.restore();
};
var renderFrameHighlight = (context, appState, frame, elementsMap) => {
  const [x1, y1, x22, y22] = getElementAbsoluteCoords(frame, elementsMap);
  const width = x22 - x1;
  const height = y22 - y1;
  context.strokeStyle = "rgb(0,118,255)";
  context.lineWidth = FRAME_STYLE.strokeWidth / appState.zoom.value;
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  strokeRectWithRotation(
    context,
    x1,
    y1,
    width,
    height,
    x1 + width / 2,
    y1 + height / 2,
    frame.angle,
    false,
    FRAME_STYLE.radius / appState.zoom.value
  );
  context.restore();
};
var renderElementsBoxHighlight = (context, appState, elements) => {
  const individualElements = elements.filter(
    (element) => element.groupIds.length === 0
  );
  const elementsInGroups = elements.filter(
    (element) => element.groupIds.length > 0
  );
  const getSelectionFromElements = (elements2) => {
    const [elementX1, elementY1, elementX2, elementY2] = getCommonBounds(elements2);
    return {
      angle: 0,
      elementX1,
      elementX2,
      elementY1,
      elementY2,
      selectionColors: ["rgb(0,118,255)"],
      dashed: false,
      cx: elementX1 + (elementX2 - elementX1) / 2,
      cy: elementY1 + (elementY2 - elementY1) / 2,
      activeEmbeddable: false
    };
  };
  const getSelectionForGroupId = (groupId) => {
    const groupElements = getElementsInGroup(elements, groupId);
    return getSelectionFromElements(groupElements);
  };
  Object.entries(selectGroupsFromGivenElements(elementsInGroups, appState)).filter(([id, isSelected]) => isSelected).map(([id, isSelected]) => id).map((groupId) => getSelectionForGroupId(groupId)).concat(
    individualElements.map((element) => getSelectionFromElements([element]))
  ).forEach(
    (selection) => renderSelectionBorder(context, appState, selection)
  );
};
var renderLinearPointHandles = (context, appState, element, elementsMap) => {
  if (!appState.selectedLinearElement) {
    return;
  }
  context.save();
  context.translate(appState.scrollX, appState.scrollY);
  context.lineWidth = 1 / appState.zoom.value;
  const points = LinearElementEditor.getPointsGlobalCoordinates(
    element,
    elementsMap
  );
  const { POINT_HANDLE_SIZE } = LinearElementEditor;
  const radius = appState.editingLinearElement ? POINT_HANDLE_SIZE : POINT_HANDLE_SIZE / 2;
  points.forEach((point, idx) => {
    if (isElbowArrow(element) && idx !== 0 && idx !== points.length - 1) {
      return;
    }
    const isSelected = !!appState.editingLinearElement?.selectedPointsIndices?.includes(idx);
    renderSingleLinearPoint(context, appState, point, radius, isSelected);
  });
  const midPoints = LinearElementEditor.getEditorMidPoints(
    element,
    elementsMap,
    appState
  ).filter((midPoint) => midPoint !== null);
  midPoints.forEach((segmentMidPoint) => {
    if (appState?.selectedLinearElement?.segmentMidPointHoveredCoords && LinearElementEditor.arePointsEqual(
      segmentMidPoint,
      appState.selectedLinearElement.segmentMidPointHoveredCoords
    )) {
      if (appState.editingLinearElement) {
        renderSingleLinearPoint(
          context,
          appState,
          segmentMidPoint,
          radius,
          false
        );
        highlightPoint(segmentMidPoint, context, appState);
      } else {
        highlightPoint(segmentMidPoint, context, appState);
        renderSingleLinearPoint(
          context,
          appState,
          segmentMidPoint,
          radius,
          false
        );
      }
    } else if (appState.editingLinearElement || points.length === 2) {
      renderSingleLinearPoint(
        context,
        appState,
        segmentMidPoint,
        POINT_HANDLE_SIZE / 2,
        false,
        true
      );
    }
  });
  context.restore();
};
var renderTransformHandles = (context, renderConfig, appState, transformHandles, angle) => {
  Object.keys(transformHandles).forEach((key) => {
    const transformHandle = transformHandles[key];
    if (transformHandle !== void 0) {
      const [x3, y3, width, height] = transformHandle;
      context.save();
      context.lineWidth = 1 / appState.zoom.value;
      if (renderConfig.selectionColor) {
        context.strokeStyle = renderConfig.selectionColor;
      }
      if (key === "rotation") {
        fillCircle(context, x3 + width / 2, y3 + height / 2, width / 2);
      } else if (context.roundRect) {
        context.beginPath();
        context.roundRect(x3, y3, width, height, 2 / appState.zoom.value);
        context.fill();
        context.stroke();
      } else {
        strokeRectWithRotation(
          context,
          x3,
          y3,
          width,
          height,
          x3 + width / 2,
          y3 + height / 2,
          angle,
          true
          // fill before stroke
        );
      }
      context.restore();
    }
  });
};
var renderTextBox = (text, context, appState, selectionColor) => {
  context.save();
  const padding = DEFAULT_TRANSFORM_HANDLE_SPACING * 2 / appState.zoom.value;
  const width = text.width + padding * 2;
  const height = text.height + padding * 2;
  const cx = text.x + width / 2;
  const cy = text.y + height / 2;
  const shiftX = -(width / 2 + padding);
  const shiftY = -(height / 2 + padding);
  context.translate(cx + appState.scrollX, cy + appState.scrollY);
  context.rotate(text.angle);
  context.lineWidth = 1 / appState.zoom.value;
  context.strokeStyle = selectionColor;
  context.strokeRect(shiftX, shiftY, width, height);
  context.restore();
};
var _renderInteractiveScene = ({
  canvas,
  elementsMap,
  visibleElements,
  selectedElements,
  allElementsMap,
  scale,
  appState,
  renderConfig,
  device
}) => {
  if (canvas === null) {
    return { atLeastOneVisibleElement: false, elementsMap };
  }
  const [normalizedWidth, normalizedHeight] = getNormalizedCanvasDimensions(
    canvas,
    scale
  );
  const context = bootstrapCanvas({
    canvas,
    scale,
    normalizedWidth,
    normalizedHeight
  });
  context.save();
  context.scale(appState.zoom.value, appState.zoom.value);
  let editingLinearElement = void 0;
  visibleElements.forEach((element) => {
    if (appState.editingLinearElement?.elementId === element.id) {
      if (element) {
        editingLinearElement = element;
      }
    }
  });
  if (editingLinearElement) {
    renderLinearPointHandles(
      context,
      appState,
      editingLinearElement,
      elementsMap
    );
  }
  if (appState.selectionElement) {
    try {
      renderSelectionElement(
        appState.selectionElement,
        context,
        appState,
        renderConfig.selectionColor
      );
    } catch (error) {
      console.error(error);
    }
  }
  if (appState.editingTextElement && isTextElement(appState.editingTextElement)) {
    const textElement = allElementsMap.get(appState.editingTextElement.id);
    if (textElement && !textElement.autoResize) {
      renderTextBox(
        textElement,
        context,
        appState,
        renderConfig.selectionColor
      );
    }
  }
  if (appState.isBindingEnabled) {
    appState.suggestedBindings.filter((binding) => binding != null).forEach((suggestedBinding) => {
      renderBindingHighlight(
        context,
        appState,
        suggestedBinding,
        elementsMap
      );
    });
  }
  if (appState.frameToHighlight) {
    renderFrameHighlight(
      context,
      appState,
      appState.frameToHighlight,
      elementsMap
    );
  }
  if (appState.elementsToHighlight) {
    renderElementsBoxHighlight(context, appState, appState.elementsToHighlight);
  }
  const isFrameSelected = selectedElements.some(
    (element) => isFrameLikeElement(element)
  );
  if (selectedElements.length === 1 && appState.editingLinearElement?.elementId === selectedElements[0].id) {
    renderLinearPointHandles(
      context,
      appState,
      selectedElements[0],
      elementsMap
    );
  }
  if (appState.selectedLinearElement && appState.selectedLinearElement.hoverPointIndex >= 0 && !(isElbowArrow(selectedElements[0]) && appState.selectedLinearElement.hoverPointIndex > 0 && appState.selectedLinearElement.hoverPointIndex < selectedElements[0].points.length - 1)) {
    renderLinearElementPointHighlight(context, appState, elementsMap);
  }
  if (!appState.multiElement && !appState.editingLinearElement) {
    const showBoundingBox = shouldShowBoundingBox(selectedElements, appState);
    const isSingleLinearElementSelected = selectedElements.length === 1 && isLinearElement(selectedElements[0]);
    if (isSingleLinearElementSelected && appState.selectedLinearElement?.elementId === selectedElements[0].id && !selectedElements[0].locked) {
      renderLinearPointHandles(
        context,
        appState,
        selectedElements[0],
        elementsMap
      );
    }
    const selectionColor = renderConfig.selectionColor || open_color_default.black;
    if (showBoundingBox) {
      const locallySelectedIds = arrayToMap(selectedElements);
      const selections = [];
      for (const element of elementsMap.values()) {
        const selectionColors = [];
        const remoteClients = renderConfig.remoteSelectedElementIds.get(
          element.id
        );
        if (!// Elbow arrow elements cannot be selected when bound on either end
        (isSingleLinearElementSelected && isElbowArrow(element) && (element.startBinding || element.endBinding))) {
          if (locallySelectedIds.has(element.id) && !isSelectedViaGroup(appState, element)) {
            selectionColors.push(selectionColor);
          }
          if (remoteClients) {
            selectionColors.push(
              ...remoteClients.map((socketId) => {
                const background = getClientColor(
                  socketId,
                  appState.collaborators.get(socketId)
                );
                return background;
              })
            );
          }
        }
        if (selectionColors.length) {
          const [elementX1, elementY1, elementX2, elementY2, cx, cy] = getElementAbsoluteCoords(element, elementsMap, true);
          selections.push({
            angle: element.angle,
            elementX1,
            elementY1,
            elementX2,
            elementY2,
            selectionColors,
            dashed: !!remoteClients,
            cx,
            cy,
            activeEmbeddable: appState.activeEmbeddable?.element === element && appState.activeEmbeddable.state === "active"
          });
        }
      }
      const addSelectionForGroupId = (groupId) => {
        const groupElements = getElementsInGroup(elementsMap, groupId);
        const [elementX1, elementY1, elementX2, elementY2] = getCommonBounds(groupElements);
        selections.push({
          angle: 0,
          elementX1,
          elementX2,
          elementY1,
          elementY2,
          selectionColors: [open_color_default.black],
          dashed: true,
          cx: elementX1 + (elementX2 - elementX1) / 2,
          cy: elementY1 + (elementY2 - elementY1) / 2,
          activeEmbeddable: false
        });
      };
      for (const groupId of getSelectedGroupIds(appState)) {
        addSelectionForGroupId(groupId);
      }
      if (appState.editingGroupId) {
        addSelectionForGroupId(appState.editingGroupId);
      }
      selections.forEach(
        (selection) => renderSelectionBorder(context, appState, selection)
      );
    }
    context.save();
    context.translate(appState.scrollX, appState.scrollY);
    if (selectedElements.length === 1) {
      context.fillStyle = open_color_default.white;
      const transformHandles = getTransformHandles(
        selectedElements[0],
        appState.zoom,
        elementsMap,
        "mouse",
        // when we render we don't know which pointer type so use mouse,
        getOmitSidesForDevice(device)
      );
      if (!appState.viewModeEnabled && showBoundingBox && // do not show transform handles when text is being edited
      !isTextElement(appState.editingTextElement)) {
        renderTransformHandles(
          context,
          renderConfig,
          appState,
          transformHandles,
          selectedElements[0].angle
        );
      }
    } else if (selectedElements.length > 1 && !appState.isRotating) {
      const dashedLinePadding = DEFAULT_TRANSFORM_HANDLE_SPACING * 2 / appState.zoom.value;
      context.fillStyle = open_color_default.white;
      const [x1, y1, x22, y22] = getCommonBounds(selectedElements);
      const initialLineDash = context.getLineDash();
      context.setLineDash([2 / appState.zoom.value]);
      const lineWidth = context.lineWidth;
      context.lineWidth = 1 / appState.zoom.value;
      context.strokeStyle = selectionColor;
      strokeRectWithRotation(
        context,
        x1 - dashedLinePadding,
        y1 - dashedLinePadding,
        x22 - x1 + dashedLinePadding * 2,
        y22 - y1 + dashedLinePadding * 2,
        (x1 + x22) / 2,
        (y1 + y22) / 2,
        0
      );
      context.lineWidth = lineWidth;
      context.setLineDash(initialLineDash);
      const transformHandles = getTransformHandlesFromCoords(
        [x1, y1, x22, y22, (x1 + x22) / 2, (y1 + y22) / 2],
        0,
        appState.zoom,
        "mouse",
        isFrameSelected ? { ...getOmitSidesForDevice(device), rotation: true } : getOmitSidesForDevice(device)
      );
      if (selectedElements.some((element) => !element.locked)) {
        renderTransformHandles(
          context,
          renderConfig,
          appState,
          transformHandles,
          0
        );
      }
    }
    context.restore();
  }
  appState.searchMatches.forEach(({ id, focus, matchedLines }) => {
    const element = elementsMap.get(id);
    if (element && isTextElement(element)) {
      const [elementX1, elementY1, , , cx, cy] = getElementAbsoluteCoords(
        element,
        elementsMap,
        true
      );
      context.save();
      if (appState.theme === THEME.LIGHT) {
        if (focus) {
          context.fillStyle = "rgba(255, 124, 0, 0.4)";
        } else {
          context.fillStyle = "rgba(255, 226, 0, 0.4)";
        }
      } else if (focus) {
        context.fillStyle = "rgba(229, 82, 0, 0.4)";
      } else {
        context.fillStyle = "rgba(99, 52, 0, 0.4)";
      }
      context.translate(appState.scrollX, appState.scrollY);
      context.translate(cx, cy);
      context.rotate(element.angle);
      matchedLines.forEach((matchedLine) => {
        context.fillRect(
          elementX1 + matchedLine.offsetX - cx,
          elementY1 + matchedLine.offsetY - cy,
          matchedLine.width,
          matchedLine.height
        );
      });
      context.restore();
    }
  });
  renderSnaps(context, appState);
  context.restore();
  renderRemoteCursors({
    context,
    renderConfig,
    appState,
    normalizedWidth,
    normalizedHeight
  });
  let scrollBars;
  if (renderConfig.renderScrollbars) {
    scrollBars = getScrollBars(
      visibleElements,
      normalizedWidth,
      normalizedHeight,
      appState
    );
    context.save();
    context.fillStyle = SCROLLBAR_COLOR;
    context.strokeStyle = "rgba(255,255,255,0.8)";
    [scrollBars.horizontal, scrollBars.vertical].forEach((scrollBar) => {
      if (scrollBar) {
        roundRect(
          context,
          scrollBar.x,
          scrollBar.y,
          scrollBar.width,
          scrollBar.height,
          SCROLLBAR_WIDTH / 2
        );
      }
    });
    context.restore();
  }
  return {
    scrollBars,
    atLeastOneVisibleElement: visibleElements.length > 0,
    elementsMap
  };
};
var renderInteractiveSceneThrottled = throttleRAF(
  (config) => {
    const ret = _renderInteractiveScene(config);
    config.callback?.(ret);
  },
  { trailing: true }
);
var renderInteractiveScene = (renderConfig, throttle5) => {
  if (throttle5) {
    renderInteractiveSceneThrottled(renderConfig);
    return void 0;
  }
  const ret = _renderInteractiveScene(renderConfig);
  renderConfig.callback(ret);
  return ret;
};

// components/canvases/InteractiveCanvas.tsx
var import_jsx_runtime139 = __toESM(require_jsx_runtime(), 1);
var InteractiveCanvas = (props) => {
  const isComponentMounted = (0, import_react110.useRef)(false);
  (0, import_react110.useEffect)(() => {
    if (!isComponentMounted.current) {
      isComponentMounted.current = true;
      return;
    }
    const remotePointerButton = /* @__PURE__ */ new Map();
    const remotePointerViewportCoords = /* @__PURE__ */ new Map();
    const remoteSelectedElementIds = /* @__PURE__ */ new Map();
    const remotePointerUsernames = /* @__PURE__ */ new Map();
    const remotePointerUserStates = /* @__PURE__ */ new Map();
    props.appState.collaborators.forEach((user, socketId) => {
      if (user.selectedElementIds) {
        for (const id of Object.keys(user.selectedElementIds)) {
          if (!remoteSelectedElementIds.has(id)) {
            remoteSelectedElementIds.set(id, []);
          }
          remoteSelectedElementIds.get(id).push(socketId);
        }
      }
      if (!user.pointer || user.pointer.renderCursor === false) {
        return;
      }
      if (user.username) {
        remotePointerUsernames.set(socketId, user.username);
      }
      if (user.userState) {
        remotePointerUserStates.set(socketId, user.userState);
      }
      remotePointerViewportCoords.set(
        socketId,
        sceneCoordsToViewportCoords(
          {
            sceneX: user.pointer.x,
            sceneY: user.pointer.y
          },
          props.appState
        )
      );
      remotePointerButton.set(socketId, user.button);
    });
    const selectionColor = props.containerRef?.current && getComputedStyle(props.containerRef.current).getPropertyValue(
      "--color-selection"
    ) || "#6965db";
    renderInteractiveScene(
      {
        canvas: props.canvas,
        elementsMap: props.elementsMap,
        visibleElements: props.visibleElements,
        selectedElements: props.selectedElements,
        allElementsMap: props.allElementsMap,
        scale: window.devicePixelRatio,
        appState: props.appState,
        renderConfig: {
          remotePointerViewportCoords,
          remotePointerButton,
          remoteSelectedElementIds,
          remotePointerUsernames,
          remotePointerUserStates,
          selectionColor,
          renderScrollbars: false
        },
        device: props.device,
        callback: props.renderInteractiveSceneCallback
      },
      isRenderThrottlingEnabled()
    );
  });
  return /* @__PURE__ */ (0, import_jsx_runtime139.jsx)(
    "canvas",
    {
      className: "excalidraw__canvas interactive",
      style: {
        width: props.appState.width,
        height: props.appState.height,
        cursor: props.appState.viewModeEnabled ? CURSOR_TYPE.GRAB : CURSOR_TYPE.AUTO
      },
      width: props.appState.width * props.scale,
      height: props.appState.height * props.scale,
      ref: props.handleCanvasRef,
      onContextMenu: props.onContextMenu,
      onPointerMove: props.onPointerMove,
      onPointerUp: props.onPointerUp,
      onPointerCancel: props.onPointerCancel,
      onTouchMove: props.onTouchMove,
      onPointerDown: props.onPointerDown,
      onDoubleClick: props.appState.viewModeEnabled ? void 0 : props.onDoubleClick,
      children: t("labels.drawingCanvas")
    }
  );
};
var getRelevantAppStateProps = (appState) => ({
  zoom: appState.zoom,
  scrollX: appState.scrollX,
  scrollY: appState.scrollY,
  width: appState.width,
  height: appState.height,
  viewModeEnabled: appState.viewModeEnabled,
  editingGroupId: appState.editingGroupId,
  editingLinearElement: appState.editingLinearElement,
  selectedElementIds: appState.selectedElementIds,
  frameToHighlight: appState.frameToHighlight,
  offsetLeft: appState.offsetLeft,
  offsetTop: appState.offsetTop,
  theme: appState.theme,
  pendingImageElementId: appState.pendingImageElementId,
  selectionElement: appState.selectionElement,
  selectedGroupIds: appState.selectedGroupIds,
  selectedLinearElement: appState.selectedLinearElement,
  multiElement: appState.multiElement,
  isBindingEnabled: appState.isBindingEnabled,
  suggestedBindings: appState.suggestedBindings,
  isRotating: appState.isRotating,
  elementsToHighlight: appState.elementsToHighlight,
  collaborators: appState.collaborators,
  // Necessary for collab. sessions
  activeEmbeddable: appState.activeEmbeddable,
  snapLines: appState.snapLines,
  zenModeEnabled: appState.zenModeEnabled,
  editingTextElement: appState.editingTextElement,
  searchMatches: appState.searchMatches
});
var areEqual3 = (prevProps, nextProps) => {
  if (prevProps.selectionNonce !== nextProps.selectionNonce || prevProps.sceneNonce !== nextProps.sceneNonce || prevProps.scale !== nextProps.scale || // we need to memoize on elementsMap because they may have renewed
  // even if sceneNonce didn't change (e.g. we filter elements out based
  // on appState)
  prevProps.elementsMap !== nextProps.elementsMap || prevProps.visibleElements !== nextProps.visibleElements || prevProps.selectedElements !== nextProps.selectedElements) {
    return false;
  }
  return isShallowEqual(
    // asserting AppState because we're being passed the whole AppState
    // but resolve to only the InteractiveCanvas-relevant props
    getRelevantAppStateProps(prevProps.appState),
    getRelevantAppStateProps(nextProps.appState)
  );
};
var InteractiveCanvas_default = import_react110.default.memo(InteractiveCanvas, areEqual3);

// components/canvases/StaticCanvas.tsx
init_define_import_meta_env();
var import_react111 = __toESM(require_react(), 1);
var import_jsx_runtime140 = __toESM(require_jsx_runtime(), 1);
var StaticCanvas = (props) => {
  const wrapperRef = (0, import_react111.useRef)(null);
  const isComponentMounted = (0, import_react111.useRef)(false);
  (0, import_react111.useEffect)(() => {
    const wrapper = wrapperRef.current;
    if (!wrapper) {
      return;
    }
    const canvas = props.canvas;
    if (!isComponentMounted.current) {
      isComponentMounted.current = true;
      wrapper.replaceChildren(canvas);
      canvas.classList.add("excalidraw__canvas", "static");
    }
    const widthString = `${props.appState.width}px`;
    const heightString = `${props.appState.height}px`;
    if (canvas.style.width !== widthString) {
      canvas.style.width = widthString;
    }
    if (canvas.style.height !== heightString) {
      canvas.style.height = heightString;
    }
    const scaledWidth = props.appState.width * props.scale;
    const scaledHeight = props.appState.height * props.scale;
    if (canvas.width !== scaledWidth) {
      canvas.width = scaledWidth;
    }
    if (canvas.height !== scaledHeight) {
      canvas.height = scaledHeight;
    }
    renderStaticScene(
      {
        canvas,
        rc: props.rc,
        scale: props.scale,
        elementsMap: props.elementsMap,
        allElementsMap: props.allElementsMap,
        visibleElements: props.visibleElements,
        appState: props.appState,
        renderConfig: props.renderConfig
      },
      isRenderThrottlingEnabled()
    );
  });
  return /* @__PURE__ */ (0, import_jsx_runtime140.jsx)("div", { className: "excalidraw__canvas-wrapper", ref: wrapperRef });
};
var getRelevantAppStateProps2 = (appState) => ({
  zoom: appState.zoom,
  scrollX: appState.scrollX,
  scrollY: appState.scrollY,
  width: appState.width,
  height: appState.height,
  viewModeEnabled: appState.viewModeEnabled,
  offsetLeft: appState.offsetLeft,
  offsetTop: appState.offsetTop,
  theme: appState.theme,
  pendingImageElementId: appState.pendingImageElementId,
  shouldCacheIgnoreZoom: appState.shouldCacheIgnoreZoom,
  viewBackgroundColor: appState.viewBackgroundColor,
  exportScale: appState.exportScale,
  selectedElementsAreBeingDragged: appState.selectedElementsAreBeingDragged,
  gridSize: appState.gridSize,
  gridStep: appState.gridStep,
  frameRendering: appState.frameRendering,
  selectedElementIds: appState.selectedElementIds,
  frameToHighlight: appState.frameToHighlight,
  editingGroupId: appState.editingGroupId,
  currentHoveredFontFamily: appState.currentHoveredFontFamily
});
var areEqual4 = (prevProps, nextProps) => {
  if (prevProps.sceneNonce !== nextProps.sceneNonce || prevProps.scale !== nextProps.scale || // we need to memoize on elementsMap because they may have renewed
  // even if sceneNonce didn't change (e.g. we filter elements out based
  // on appState)
  prevProps.elementsMap !== nextProps.elementsMap || prevProps.visibleElements !== nextProps.visibleElements) {
    return false;
  }
  return isShallowEqual(
    // asserting AppState because we're being passed the whole AppState
    // but resolve to only the StaticCanvas-relevant props
    getRelevantAppStateProps2(prevProps.appState),
    getRelevantAppStateProps2(nextProps.appState)
  ) && isShallowEqual(prevProps.renderConfig, nextProps.renderConfig);
};
var StaticCanvas_default = import_react111.default.memo(StaticCanvas, areEqual4);

// scene/Renderer.ts
init_define_import_meta_env();
var Renderer = class {
  scene;
  constructor(scene) {
    this.scene = scene;
  }
  getRenderableElements = (() => {
    const getVisibleCanvasElements = ({
      elementsMap,
      zoom,
      offsetLeft,
      offsetTop,
      scrollX,
      scrollY,
      height,
      width
    }) => {
      const visibleElements = [];
      for (const element of elementsMap.values()) {
        if (isElementInViewport(
          element,
          width,
          height,
          {
            zoom,
            offsetLeft,
            offsetTop,
            scrollX,
            scrollY
          },
          elementsMap
        )) {
          visibleElements.push(element);
        }
      }
      return visibleElements;
    };
    const getRenderableElements = ({
      elements,
      editingTextElement,
      newElementId,
      pendingImageElementId
    }) => {
      const elementsMap = toBrandedType(/* @__PURE__ */ new Map());
      for (const element of elements) {
        if (isImageElement(element)) {
          if (
            // => not placed on canvas yet (but in elements array)
            pendingImageElementId === element.id
          ) {
            continue;
          }
        }
        if (newElementId === element.id) {
          continue;
        }
        if (!editingTextElement || editingTextElement.type !== "text" || element.id !== editingTextElement.id) {
          elementsMap.set(element.id, element);
        }
      }
      return elementsMap;
    };
    return memoize(
      ({
        zoom,
        offsetLeft,
        offsetTop,
        scrollX,
        scrollY,
        height,
        width,
        editingTextElement,
        newElementId,
        pendingImageElementId,
        // cache-invalidation nonce
        sceneNonce: _sceneNonce
      }) => {
        const elements = this.scene.getNonDeletedElements();
        const elementsMap = getRenderableElements({
          elements,
          editingTextElement,
          newElementId,
          pendingImageElementId
        });
        const visibleElements = getVisibleCanvasElements({
          elementsMap,
          zoom,
          offsetLeft,
          offsetTop,
          scrollX,
          scrollY,
          height,
          width
        });
        return { elementsMap, visibleElements };
      }
    );
  })();
  // NOTE Doesn't destroy everything (scene, rc, etc.) because it may not be
  // safe to break TS contract here (for upstream cases)
  destroy() {
    renderInteractiveSceneThrottled.cancel();
    renderStaticSceneThrottled.cancel();
    this.getRenderableElements.clear();
  }
};

// components/SVGLayer.tsx
init_define_import_meta_env();
var import_react112 = __toESM(require_react(), 1);
var import_jsx_runtime141 = __toESM(require_jsx_runtime(), 1);
var SVGLayer = ({ trails }) => {
  const svgRef = (0, import_react112.useRef)(null);
  (0, import_react112.useEffect)(() => {
    if (svgRef.current) {
      for (const trail of trails) {
        trail.start(svgRef.current);
      }
    }
    return () => {
      for (const trail of trails) {
        trail.stop();
      }
    };
  }, trails);
  return /* @__PURE__ */ (0, import_jsx_runtime141.jsx)("div", { className: "SVGLayer", children: /* @__PURE__ */ (0, import_jsx_runtime141.jsx)("svg", { ref: svgRef }) });
};

// element/ElementCanvasButtons.tsx
init_define_import_meta_env();
var import_jsx_runtime142 = __toESM(require_jsx_runtime(), 1);
var CONTAINER_PADDING2 = 5;
var getContainerCoords = (element, appState, elementsMap) => {
  const [x1, y1] = getElementAbsoluteCoords(element, elementsMap);
  const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(
    { sceneX: x1 + element.width, sceneY: y1 },
    appState
  );
  const x3 = viewportX - appState.offsetLeft + 10;
  const y3 = viewportY - appState.offsetTop;
  return { x: x3, y: y3 };
};
var ElementCanvasButtons = ({
  children,
  element,
  elementsMap
}) => {
  const appState = useExcalidrawAppState();
  if (appState.contextMenu || appState.newElement || appState.resizingElement || appState.isRotating || appState.openMenu || appState.viewModeEnabled) {
    return null;
  }
  const { x: x3, y: y3 } = getContainerCoords(element, appState, elementsMap);
  return /* @__PURE__ */ (0, import_jsx_runtime142.jsx)(
    "div",
    {
      className: "excalidraw-canvas-buttons",
      style: {
        top: `${y3}px`,
        left: `${x3}px`,
        // width: CONTAINER_WIDTH,
        padding: CONTAINER_PADDING2
      },
      children
    }
  );
};

// components/MagicButton.tsx
init_define_import_meta_env();
var import_jsx_runtime143 = __toESM(require_jsx_runtime(), 1);
var DEFAULT_SIZE4 = "small";
var ElementCanvasButton = (props) => {
  return /* @__PURE__ */ (0, import_jsx_runtime143.jsxs)(
    "label",
    {
      className: clsx_m_default(
        "ToolIcon ToolIcon__MagicButton",
        `ToolIcon_size_${DEFAULT_SIZE4}`,
        {
          "is-mobile": props.isMobile
        }
      ),
      title: `${props.title}`,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime143.jsx)(
          "input",
          {
            className: "ToolIcon_type_checkbox",
            type: "checkbox",
            name: props.name,
            onChange: props.onChange,
            checked: props.checked,
            "aria-label": props.title
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime143.jsx)("div", { className: "ToolIcon__icon", children: props.icon })
      ]
    }
  );
};

// components/FollowMode/FollowMode.tsx
init_define_import_meta_env();
var import_jsx_runtime144 = __toESM(require_jsx_runtime(), 1);
var FollowMode = ({
  height,
  width,
  userToFollow,
  onDisconnect
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime144.jsx)("div", { className: "follow-mode", style: { width, height }, children: /* @__PURE__ */ (0, import_jsx_runtime144.jsxs)("div", { className: "follow-mode__badge", children: [
    /* @__PURE__ */ (0, import_jsx_runtime144.jsxs)("div", { className: "follow-mode__badge__label", children: [
      "Following",
      " ",
      /* @__PURE__ */ (0, import_jsx_runtime144.jsx)(
        "span",
        {
          className: "follow-mode__badge__username",
          title: userToFollow.username,
          children: userToFollow.username
        }
      )
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime144.jsx)(
      "button",
      {
        type: "button",
        onClick: onDisconnect,
        className: "follow-mode__disconnect-btn",
        children: CloseIcon
      }
    )
  ] }) });
};
var FollowMode_default = FollowMode;

// animation-frame-handler.ts
init_define_import_meta_env();
var AnimationFrameHandler = class {
  targets = /* @__PURE__ */ new WeakMap();
  rafIds = /* @__PURE__ */ new WeakMap();
  register(key, callback) {
    this.targets.set(key, { callback, stopped: true });
  }
  start(key) {
    const target = this.targets.get(key);
    if (!target) {
      return;
    }
    if (this.rafIds.has(key)) {
      return;
    }
    this.targets.set(key, { ...target, stopped: false });
    this.scheduleFrame(key);
  }
  stop(key) {
    const target = this.targets.get(key);
    if (target && !target.stopped) {
      this.targets.set(key, { ...target, stopped: true });
    }
    this.cancelFrame(key);
  }
  constructFrame(key) {
    return (timestamp) => {
      const target = this.targets.get(key);
      if (!target) {
        return;
      }
      const shouldAbort = this.onFrame(target, timestamp);
      if (!target.stopped && !shouldAbort) {
        this.scheduleFrame(key);
      } else {
        this.cancelFrame(key);
      }
    };
  }
  scheduleFrame(key) {
    const rafId = requestAnimationFrame(this.constructFrame(key));
    this.rafIds.set(key, rafId);
  }
  cancelFrame(key) {
    if (this.rafIds.has(key)) {
      const rafId = this.rafIds.get(key);
      cancelAnimationFrame(rafId);
    }
    this.rafIds.delete(key);
  }
  onFrame(target, timestamp) {
    const shouldAbort = target.callback(timestamp);
    return shouldAbort ?? false;
  }
};

// animated-trail.ts
init_define_import_meta_env();

// ../../node_modules/@excalidraw/laser-pointer/dist/esm.js
init_define_import_meta_env();
function $parcel$export(e3, n3, v3, s3) {
  Object.defineProperty(e3, n3, { get: v3, set: s3, enumerable: true, configurable: true });
}
var $94cfa2cfccc8cc22$exports = {};
$parcel$export($94cfa2cfccc8cc22$exports, "LaserPointer", () => $94cfa2cfccc8cc22$export$6531021b3bf36eae);
function $8cd7efb5af385306$export$e16d8520af44a096([ax, ay, ar], [bx, by, br]) {
  return [
    ax + bx,
    ay + by,
    ar + br
  ];
}
function $8cd7efb5af385306$export$f93b5905241a7cca([ax, ay, ar], [bx, by, br]) {
  return [
    ax - bx,
    ay - by,
    ar - br
  ];
}
function $8cd7efb5af385306$export$1c8884ee32bdf443([x3, y3, r3], s3) {
  return [
    x3 * s3,
    y3 * s3,
    r3 * s3
  ];
}
function $8cd7efb5af385306$export$1991ecd29cc92c6b([x3, y3, r3]) {
  return [
    x3 / Math.sqrt(x3 ** 2 + y3 ** 2),
    y3 / Math.sqrt(x3 ** 2 + y3 ** 2),
    r3
  ];
}
function $8cd7efb5af385306$export$855df823ceb9b81b([x3, y3, r3], rad) {
  return [
    Math.cos(rad) * x3 - Math.sin(rad) * y3,
    Math.sin(rad) * x3 + Math.cos(rad) * y3,
    r3
  ];
}
function $8cd7efb5af385306$export$92d8e23769117a5e(a3, b3, t3) {
  return $8cd7efb5af385306$export$e16d8520af44a096(a3, $8cd7efb5af385306$export$1c8884ee32bdf443($8cd7efb5af385306$export$f93b5905241a7cca(b3, a3), t3));
}
function $8cd7efb5af385306$export$944b09d2ad10b378(p3, p1, p22) {
  return Math.atan2(p22[1] - p3[1], p22[0] - p3[0]) - Math.atan2(p1[1] - p3[1], p1[0] - p3[0]);
}
function $8cd7efb5af385306$export$3c05aaf71f141f73(a3) {
  return Math.atan2(Math.sin(a3), Math.cos(a3));
}
function $8cd7efb5af385306$export$1b9bab504faa9305([x3, y3]) {
  return Math.sqrt(x3 ** 2 + y3 ** 2);
}
function $8cd7efb5af385306$export$6c4a311cc157c764([ax, ay], [bx, by]) {
  return Math.sqrt((bx - ax) ** 2 + (by - ay) ** 2);
}
function $8cd7efb5af385306$export$ccb1b4dfbd3f36a7(ps) {
  if (ps.length < 2)
    return 0;
  let len = 0;
  for (let i3 = 1; i3 <= ps.length - 1; i3++)
    len += $8cd7efb5af385306$export$6c4a311cc157c764(ps[i3 - 1], ps[i3]);
  len += $8cd7efb5af385306$export$6c4a311cc157c764(ps[ps.length - 2], ps[ps.length - 1]);
  return len;
}
var $8cd7efb5af385306$export$7d15b64cf5a3a4c4 = (v3, min, max) => Math.max(min, Math.min(max, v3));
function $8cd7efb5af385306$export$548cc43590159af6(p3, p1, p22) {
  const sMag = $8cd7efb5af385306$export$6c4a311cc157c764(p1, p22);
  if (sMag === 0)
    return $8cd7efb5af385306$export$6c4a311cc157c764(p3, p1);
  const u3 = $8cd7efb5af385306$export$7d15b64cf5a3a4c4(((p3[0] - p1[0]) * (p22[0] - p1[0]) + (p3[1] - p1[1]) * (p22[1] - p1[1])) / sMag ** 2, 0, 1);
  const pi = [
    p1[0] + u3 * (p22[0] - p1[0]),
    p1[1] + u3 * (p22[1] - p1[1]),
    p3[2]
  ];
  return $8cd7efb5af385306$export$6c4a311cc157c764(pi, p3);
}
function $34bab0059f842ce6$export$ef693d1572e64fb8(points, epsilon) {
  if (epsilon === 0)
    return points;
  if (points.length <= 2)
    return points;
  const first = points[0];
  const last = points[points.length - 1];
  const [maxDistance, maxIndex] = points.reduce(([maxDistance2, maxIndex2], point, index2) => {
    const distance2 = (0, $8cd7efb5af385306$export$548cc43590159af6)(point, first, last);
    return distance2 > maxDistance2 ? [
      distance2,
      index2
    ] : [
      maxDistance2,
      maxIndex2
    ];
  }, [
    0,
    -1
  ]);
  if (maxDistance >= epsilon) {
    const maxIndexPoint = points[maxIndex];
    return [
      ...$34bab0059f842ce6$export$ef693d1572e64fb8([
        first,
        ...points.slice(1, maxIndex),
        maxIndexPoint
      ], epsilon).slice(0, -1),
      maxIndexPoint,
      ...$34bab0059f842ce6$export$ef693d1572e64fb8([
        maxIndexPoint,
        ...points.slice(maxIndex, -1),
        last
      ], epsilon).slice(1)
    ];
  } else
    return [
      first,
      last
    ];
}
var $94cfa2cfccc8cc22$export$6531021b3bf36eae = class _$94cfa2cfccc8cc22$export$6531021b3bf36eae {
  static {
    this.defaults = {
      size: 2,
      streamline: 0.45,
      simplify: 0.1,
      simplifyPhase: "output",
      keepHead: false,
      sizeMapping: () => 1
    };
  }
  static {
    this.constants = {
      cornerDetectionMaxAngle: 75,
      cornerDetectionVariance: (s3) => s3 > 35 ? 0.5 : 1,
      maxTailLength: 50
    };
  }
  constructor(options) {
    this.originalPoints = [];
    this.stablePoints = [];
    this.tailPoints = [];
    this.isFresh = true;
    this.options = Object.assign({}, _$94cfa2cfccc8cc22$export$6531021b3bf36eae.defaults, options);
  }
  get lastPoint() {
    return this.tailPoints[this.tailPoints.length - 1] ?? this.stablePoints[this.stablePoints.length - 1];
  }
  addPoint(point) {
    const lastPoint = this.originalPoints[this.originalPoints.length - 1];
    if (lastPoint && lastPoint[0] === point[0] && lastPoint[1] === point[1])
      return;
    this.originalPoints.push(point);
    if (this.isFresh) {
      this.isFresh = false;
      this.stablePoints.push(point);
      return;
    }
    if (this.options.streamline > 0)
      point = $8cd7efb5af385306$export$92d8e23769117a5e(this.lastPoint, point, 1 - this.options.streamline);
    this.tailPoints.push(point);
    if ($8cd7efb5af385306$export$ccb1b4dfbd3f36a7(this.tailPoints) > _$94cfa2cfccc8cc22$export$6531021b3bf36eae.constants.maxTailLength)
      this.stabilizeTail();
  }
  close() {
    this.stabilizeTail();
  }
  stabilizeTail() {
    if (this.options.simplify > 0 && this.options.simplifyPhase == "tail")
      throw new Error("Not implemented yet");
    else {
      this.stablePoints.push(...this.tailPoints);
      this.tailPoints = [];
    }
  }
  getSize(sizeOverride, pressure, index2, totalLength, runningLength) {
    return (sizeOverride ?? this.options.size) * this.options.sizeMapping({
      pressure,
      runningLength,
      currentIndex: index2,
      totalLength
    });
  }
  getStrokeOutline(sizeOverride) {
    if (this.isFresh)
      return [];
    let points = [
      ...this.stablePoints,
      ...this.tailPoints
    ];
    if (this.options.simplify > 0 && this.options.simplifyPhase === "input")
      points = (0, $34bab0059f842ce6$export$ef693d1572e64fb8)(points, this.options.simplify);
    const len = points.length;
    if (len === 0)
      return [];
    if (len === 1) {
      const c3 = points[0];
      const size = this.getSize(sizeOverride, c3[2], 0, len, 0);
      if (size < 0.5)
        return [];
      const ps = [];
      for (let theta = 0; theta <= Math.PI * 2; theta += Math.PI / 16)
        ps.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443($8cd7efb5af385306$export$855df823ceb9b81b([
          1,
          0,
          0
        ], theta), size)));
      ps.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443([
        1,
        0,
        0
      ], this.getSize(sizeOverride, c3[2], 0, len, 0))));
      return ps;
    }
    if (len === 2) {
      const c3 = points[0];
      const n3 = points[1];
      const cSize = this.getSize(sizeOverride, c3[2], 0, len, 0);
      const nSize = this.getSize(sizeOverride, n3[2], 0, len, 0);
      if (cSize < 0.5 || nSize < 0.5)
        return [];
      const ps = [];
      const pAngle = $8cd7efb5af385306$export$944b09d2ad10b378(c3, [
        c3[0],
        c3[1] - 100,
        c3[2]
      ], n3);
      for (let theta = pAngle; theta <= Math.PI + pAngle; theta += Math.PI / 16)
        ps.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443($8cd7efb5af385306$export$855df823ceb9b81b([
          1,
          0,
          0
        ], theta), cSize)));
      for (let theta = Math.PI + pAngle; theta <= Math.PI * 2 + pAngle; theta += Math.PI / 16)
        ps.push($8cd7efb5af385306$export$e16d8520af44a096(n3, $8cd7efb5af385306$export$1c8884ee32bdf443($8cd7efb5af385306$export$855df823ceb9b81b([
          1,
          0,
          0
        ], theta), nSize)));
      ps.push(ps[0]);
      return ps;
    }
    const forwardPoints = [];
    const backwardPoints = [];
    let speed = 0;
    let prevSpeed = 0;
    let visibleStartIndex = 0;
    let runningLength = 0;
    for (let i3 = 1; i3 < len - 1; i3++) {
      const p3 = points[i3 - 1], c3 = points[i3], n3 = points[i3 + 1];
      let pressure = c3[2];
      const d3 = $8cd7efb5af385306$export$6c4a311cc157c764(p3, c3);
      runningLength += d3;
      speed = prevSpeed + (d3 - prevSpeed) * 0.2;
      const cSize = this.getSize(sizeOverride, pressure, i3, len, runningLength);
      if (cSize === 0) {
        visibleStartIndex = i3 + 1;
        continue;
      }
      const dirPC = $8cd7efb5af385306$export$1991ecd29cc92c6b($8cd7efb5af385306$export$f93b5905241a7cca(p3, c3));
      const dirNC = $8cd7efb5af385306$export$1991ecd29cc92c6b($8cd7efb5af385306$export$f93b5905241a7cca(n3, c3));
      const p1dirPC = $8cd7efb5af385306$export$855df823ceb9b81b(dirPC, Math.PI / 2);
      const p2dirPC = $8cd7efb5af385306$export$855df823ceb9b81b(dirPC, -Math.PI / 2);
      const p1dirNC = $8cd7efb5af385306$export$855df823ceb9b81b(dirNC, Math.PI / 2);
      const p2dirNC = $8cd7efb5af385306$export$855df823ceb9b81b(dirNC, -Math.PI / 2);
      const p1PC = $8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443(p1dirPC, cSize));
      const p2PC = $8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443(p2dirPC, cSize));
      const p1NC = $8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443(p1dirNC, cSize));
      const p2NC = $8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443(p2dirNC, cSize));
      const ftdir = $8cd7efb5af385306$export$e16d8520af44a096(p1dirPC, p2dirNC);
      const btdir = $8cd7efb5af385306$export$e16d8520af44a096(p2dirPC, p1dirNC);
      const paPC = $8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443($8cd7efb5af385306$export$1b9bab504faa9305(ftdir) === 0 ? dirPC : $8cd7efb5af385306$export$1991ecd29cc92c6b(ftdir), cSize));
      const paNC = $8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443($8cd7efb5af385306$export$1b9bab504faa9305(btdir) === 0 ? dirNC : $8cd7efb5af385306$export$1991ecd29cc92c6b(btdir), cSize));
      const cAngle = $8cd7efb5af385306$export$3c05aaf71f141f73($8cd7efb5af385306$export$944b09d2ad10b378(c3, p3, n3));
      const D_ANGLE = _$94cfa2cfccc8cc22$export$6531021b3bf36eae.constants.cornerDetectionMaxAngle / 180 * Math.PI * _$94cfa2cfccc8cc22$export$6531021b3bf36eae.constants.cornerDetectionVariance(speed);
      if (Math.abs(cAngle) < D_ANGLE) {
        const tAngle = Math.abs($8cd7efb5af385306$export$3c05aaf71f141f73(Math.PI - cAngle));
        if (tAngle === 0)
          continue;
        if (cAngle < 0) {
          backwardPoints.push(p2PC, paNC);
          for (let theta = 0; theta <= tAngle; theta += tAngle / 4)
            forwardPoints.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$855df823ceb9b81b($8cd7efb5af385306$export$1c8884ee32bdf443(p1dirPC, cSize), theta)));
          for (let theta = tAngle; theta >= 0; theta -= tAngle / 4)
            backwardPoints.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$855df823ceb9b81b($8cd7efb5af385306$export$1c8884ee32bdf443(p1dirPC, cSize), theta)));
          backwardPoints.push(paNC, p1NC);
        } else {
          forwardPoints.push(p1PC, paPC);
          for (let theta = 0; theta <= tAngle; theta += tAngle / 4)
            backwardPoints.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$855df823ceb9b81b($8cd7efb5af385306$export$1c8884ee32bdf443(p1dirPC, -cSize), -theta)));
          for (let theta = tAngle; theta >= 0; theta -= tAngle / 4)
            forwardPoints.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$855df823ceb9b81b($8cd7efb5af385306$export$1c8884ee32bdf443(p1dirPC, -cSize), -theta)));
          forwardPoints.push(paPC, p2NC);
        }
      } else {
        forwardPoints.push(paPC);
        backwardPoints.push(paNC);
      }
      prevSpeed = speed;
    }
    if (visibleStartIndex >= len - 2) {
      if (this.options.keepHead) {
        const c3 = points[len - 1];
        const ps = [];
        for (let theta = 0; theta <= Math.PI * 2; theta += Math.PI / 16)
          ps.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443($8cd7efb5af385306$export$855df823ceb9b81b([
            1,
            0,
            0
          ], theta), this.options.size)));
        ps.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443([
          1,
          0,
          0
        ], this.options.size)));
        return ps;
      } else
        return [];
    }
    const first = points[visibleStartIndex];
    const second = points[visibleStartIndex + 1];
    const penultimate = points[len - 2];
    const ultimate = points[len - 1];
    const dirFS = $8cd7efb5af385306$export$1991ecd29cc92c6b($8cd7efb5af385306$export$f93b5905241a7cca(second, first));
    const dirPU = $8cd7efb5af385306$export$1991ecd29cc92c6b($8cd7efb5af385306$export$f93b5905241a7cca(penultimate, ultimate));
    const ppdirFS = $8cd7efb5af385306$export$855df823ceb9b81b(dirFS, -Math.PI / 2);
    const ppdirPU = $8cd7efb5af385306$export$855df823ceb9b81b(dirPU, Math.PI / 2);
    const startCapSize = this.getSize(sizeOverride, first[2], 0, len, 0);
    const startCap = [];
    const endCapSize = this.options.keepHead ? this.options.size : this.getSize(sizeOverride, penultimate[2], len - 2, len, runningLength);
    const endCap = [];
    if (startCapSize > 1) {
      for (let theta = 0; theta <= Math.PI; theta += Math.PI / 16)
        startCap.unshift($8cd7efb5af385306$export$e16d8520af44a096(first, $8cd7efb5af385306$export$855df823ceb9b81b($8cd7efb5af385306$export$1c8884ee32bdf443(ppdirFS, startCapSize), -theta)));
      startCap.unshift($8cd7efb5af385306$export$e16d8520af44a096(first, $8cd7efb5af385306$export$1c8884ee32bdf443(ppdirFS, -startCapSize)));
    } else
      startCap.push(first);
    for (let theta = 0; theta <= Math.PI * 3; theta += Math.PI / 16)
      endCap.push($8cd7efb5af385306$export$e16d8520af44a096(ultimate, $8cd7efb5af385306$export$855df823ceb9b81b($8cd7efb5af385306$export$1c8884ee32bdf443(ppdirPU, -endCapSize), -theta)));
    const strokeOutline = [
      ...startCap,
      ...forwardPoints,
      ...endCap.reverse(),
      ...backwardPoints.reverse()
    ];
    if (startCap.length > 0)
      strokeOutline.push(startCap[0]);
    if (this.options.simplify > 0 && this.options.simplifyPhase === "output")
      return (0, $34bab0059f842ce6$export$ef693d1572e64fb8)(strokeOutline, this.options.simplify);
    return strokeOutline;
  }
};

// animated-trail.ts
var AnimatedTrail = class {
  constructor(animationFrameHandler, app, options) {
    this.animationFrameHandler = animationFrameHandler;
    this.app = app;
    this.options = options;
    this.animationFrameHandler.register(this, this.onFrame.bind(this));
    this.trailElement = document.createElementNS(SVG_NS, "path");
  }
  currentTrail;
  pastTrails = [];
  container;
  trailElement;
  get hasCurrentTrail() {
    return !!this.currentTrail;
  }
  hasLastPoint(x3, y3) {
    if (this.currentTrail) {
      const len = this.currentTrail.originalPoints.length;
      return this.currentTrail.originalPoints[len - 1][0] === x3 && this.currentTrail.originalPoints[len - 1][1] === y3;
    }
    return false;
  }
  start(container) {
    if (container) {
      this.container = container;
    }
    if (this.trailElement.parentNode !== this.container && this.container) {
      this.container.appendChild(this.trailElement);
    }
    this.animationFrameHandler.start(this);
  }
  stop() {
    this.animationFrameHandler.stop(this);
    if (this.trailElement.parentNode === this.container) {
      this.container?.removeChild(this.trailElement);
    }
  }
  startPath(x3, y3) {
    this.currentTrail = new $94cfa2cfccc8cc22$export$6531021b3bf36eae(this.options);
    this.currentTrail.addPoint([x3, y3, performance.now()]);
    this.update();
  }
  addPointToPath(x3, y3) {
    if (this.currentTrail) {
      this.currentTrail.addPoint([x3, y3, performance.now()]);
      this.update();
    }
  }
  endPath() {
    if (this.currentTrail) {
      this.currentTrail.close();
      this.currentTrail.options.keepHead = false;
      this.pastTrails.push(this.currentTrail);
      this.currentTrail = void 0;
      this.update();
    }
  }
  update() {
    this.start();
  }
  onFrame() {
    const paths = [];
    for (const trail of this.pastTrails) {
      paths.push(this.drawTrail(trail, this.app.state));
    }
    if (this.currentTrail) {
      const currentPath = this.drawTrail(this.currentTrail, this.app.state);
      paths.push(currentPath);
    }
    this.pastTrails = this.pastTrails.filter((trail) => {
      return trail.getStrokeOutline().length !== 0;
    });
    if (paths.length === 0) {
      this.stop();
    }
    const svgPaths = paths.join(" ").trim();
    this.trailElement.setAttribute("d", svgPaths);
    this.trailElement.setAttribute(
      "fill",
      (this.options.fill ?? (() => "black"))(this)
    );
  }
  drawTrail(trail, state) {
    const stroke = trail.getStrokeOutline(trail.options.size / state.zoom.value).map(([x3, y3]) => {
      const result = sceneCoordsToViewportCoords(
        { sceneX: x3, sceneY: y3 },
        state
      );
      return [result.x, result.y];
    });
    return getSvgPathFromStroke(stroke, true);
  }
};

// laser-trails.ts
init_define_import_meta_env();
var LaserTrails = class {
  constructor(animationFrameHandler, app) {
    this.animationFrameHandler = animationFrameHandler;
    this.app = app;
    this.animationFrameHandler.register(this, this.onFrame.bind(this));
    this.localTrail = new AnimatedTrail(animationFrameHandler, app, {
      ...this.getTrailOptions(),
      fill: () => DEFAULT_LASER_COLOR
    });
  }
  localTrail;
  collabTrails = /* @__PURE__ */ new Map();
  container;
  getTrailOptions() {
    return {
      simplify: 0,
      streamline: 0.4,
      sizeMapping: (c3) => {
        const DECAY_TIME = 1e3;
        const DECAY_LENGTH = 50;
        const t3 = Math.max(
          0,
          1 - (performance.now() - c3.pressure) / DECAY_TIME
        );
        const l3 = (DECAY_LENGTH - Math.min(DECAY_LENGTH, c3.totalLength - c3.currentIndex)) / DECAY_LENGTH;
        return Math.min(easeOut(l3), easeOut(t3));
      }
    };
  }
  startPath(x3, y3) {
    this.localTrail.startPath(x3, y3);
  }
  addPointToPath(x3, y3) {
    this.localTrail.addPointToPath(x3, y3);
  }
  endPath() {
    this.localTrail.endPath();
  }
  start(container) {
    this.container = container;
    this.animationFrameHandler.start(this);
    this.localTrail.start(container);
  }
  stop() {
    this.animationFrameHandler.stop(this);
    this.localTrail.stop();
  }
  onFrame() {
    this.updateCollabTrails();
  }
  updateCollabTrails() {
    if (!this.container || this.app.state.collaborators.size === 0) {
      return;
    }
    for (const [key, collaborator] of this.app.state.collaborators.entries()) {
      let trail;
      if (!this.collabTrails.has(key)) {
        trail = new AnimatedTrail(this.animationFrameHandler, this.app, {
          ...this.getTrailOptions(),
          fill: () => collaborator.pointer?.laserColor || getClientColor(key, collaborator)
        });
        trail.start(this.container);
        this.collabTrails.set(key, trail);
      } else {
        trail = this.collabTrails.get(key);
      }
      if (collaborator.pointer && collaborator.pointer.tool === "laser") {
        if (collaborator.button === "down" && !trail.hasCurrentTrail) {
          trail.startPath(collaborator.pointer.x, collaborator.pointer.y);
        }
        if (collaborator.button === "down" && trail.hasCurrentTrail && !trail.hasLastPoint(collaborator.pointer.x, collaborator.pointer.y)) {
          trail.addPointToPath(collaborator.pointer.x, collaborator.pointer.y);
        }
        if (collaborator.button === "up" && trail.hasCurrentTrail) {
          trail.addPointToPath(collaborator.pointer.x, collaborator.pointer.y);
          trail.endPath();
        }
      }
    }
    for (const key of this.collabTrails.keys()) {
      if (!this.app.state.collaborators.has(key)) {
        const trail = this.collabTrails.get(key);
        trail.stop();
        this.collabTrails.delete(key);
      }
    }
  }
};

// element/textWysiwyg.tsx
init_define_import_meta_env();
var getTransform = (width, height, angle, appState, maxWidth, maxHeight) => {
  const { zoom } = appState;
  const degree = 180 * angle / Math.PI;
  let translateX = width * (zoom.value - 1) / 2;
  let translateY = height * (zoom.value - 1) / 2;
  if (width > maxWidth && zoom.value !== 1) {
    translateX = maxWidth * (zoom.value - 1) / 2;
  }
  if (height > maxHeight && zoom.value !== 1) {
    translateY = maxHeight * (zoom.value - 1) / 2;
  }
  return `translate(${translateX}px, ${translateY}px) scale(${zoom.value}) rotate(${degree}deg)`;
};
var textWysiwyg = ({
  id,
  onChange,
  onSubmit,
  getViewportCoords,
  element,
  canvas,
  excalidrawContainer,
  app,
  autoSelect = true
}) => {
  const textPropertiesUpdated = (updatedTextElement, editable2) => {
    if (!editable2.style.fontFamily || !editable2.style.fontSize) {
      return false;
    }
    const currentFont = editable2.style.fontFamily.replace(/"/g, "");
    if (getFontFamilyString({ fontFamily: updatedTextElement.fontFamily }) !== currentFont) {
      return true;
    }
    if (`${updatedTextElement.fontSize}px` !== editable2.style.fontSize) {
      return true;
    }
    return false;
  };
  const updateWysiwygStyle = () => {
    const appState = app.state;
    const updatedTextElement = Scene_default.getScene(element)?.getElement(id);
    if (!updatedTextElement) {
      return;
    }
    const { textAlign, verticalAlign } = updatedTextElement;
    const elementsMap = app.scene.getNonDeletedElementsMap();
    if (updatedTextElement && isTextElement(updatedTextElement)) {
      let coordX = updatedTextElement.x;
      let coordY = updatedTextElement.y;
      const container = getContainerElement(
        updatedTextElement,
        app.scene.getNonDeletedElementsMap()
      );
      let width = updatedTextElement.width;
      let height = updatedTextElement.height;
      let maxWidth = updatedTextElement.width;
      let maxHeight = updatedTextElement.height;
      if (container && updatedTextElement.containerId) {
        if (isArrowElement(container)) {
          const boundTextCoords = LinearElementEditor.getBoundTextElementPosition(
            container,
            updatedTextElement,
            elementsMap
          );
          coordX = boundTextCoords.x;
          coordY = boundTextCoords.y;
        }
        const propertiesUpdated = textPropertiesUpdated(
          updatedTextElement,
          editable
        );
        let originalContainerData;
        if (propertiesUpdated) {
          originalContainerData = updateOriginalContainerCache(
            container.id,
            container.height
          );
        } else {
          originalContainerData = originalContainerCache[container.id];
          if (!originalContainerData) {
            originalContainerData = updateOriginalContainerCache(
              container.id,
              container.height
            );
          }
        }
        maxWidth = getBoundTextMaxWidth(container, updatedTextElement);
        maxHeight = getBoundTextMaxHeight(
          container,
          updatedTextElement
        );
        if (!isArrowElement(container) && height > maxHeight) {
          const targetContainerHeight = computeContainerDimensionForBoundText(
            height,
            container.type
          );
          mutateElement(container, { height: targetContainerHeight });
          return;
        } else if (
          // autoshrink container height until original container height
          // is reached when text is removed
          !isArrowElement(container) && container.height > originalContainerData.height && height < maxHeight
        ) {
          const targetContainerHeight = computeContainerDimensionForBoundText(
            height,
            container.type
          );
          mutateElement(container, { height: targetContainerHeight });
        } else {
          const { y: y3 } = computeBoundTextPosition(
            container,
            updatedTextElement,
            elementsMap
          );
          coordY = y3;
        }
      }
      const [viewportX, viewportY] = getViewportCoords(coordX, coordY);
      const initialSelectionStart = editable.selectionStart;
      const initialSelectionEnd = editable.selectionEnd;
      const initialLength = editable.value.length;
      if (initialSelectionStart === initialSelectionEnd && initialSelectionEnd !== initialLength) {
        const diff = initialLength - initialSelectionEnd;
        editable.selectionStart = editable.value.length - diff;
        editable.selectionEnd = editable.value.length - diff;
      }
      if (!container) {
        maxWidth = (appState.width - 8 - viewportX) / appState.zoom.value;
        width = Math.min(width, maxWidth);
      } else {
        width += 0.5;
      }
      height *= 1.05;
      const font = getFontString(updatedTextElement);
      const padding = !isSafari ? Math.ceil(updatedTextElement.fontSize / appState.zoom.value / 2) : 0;
      const editorMaxHeight = (appState.height - viewportY) / appState.zoom.value;
      Object.assign(editable.style, {
        font,
        // must be defined *after* font \_()_/
        lineHeight: updatedTextElement.lineHeight,
        width: `${width}px`,
        height: `${height}px`,
        left: `${viewportX - padding}px`,
        top: `${viewportY}px`,
        transform: getTransform(
          width,
          height,
          getTextElementAngle(updatedTextElement, container),
          appState,
          maxWidth,
          editorMaxHeight
        ),
        padding: `0 ${padding}px`,
        textAlign,
        verticalAlign,
        color: updatedTextElement.strokeColor,
        opacity: updatedTextElement.opacity / 100,
        filter: "var(--theme-filter)",
        maxHeight: `${editorMaxHeight}px`
      });
      editable.scrollTop = 0;
      if (isTestEnv()) {
        editable.style.fontFamily = getFontFamilyString(updatedTextElement);
      }
      mutateElement(updatedTextElement, { x: coordX, y: coordY });
    }
  };
  const editable = document.createElement("textarea");
  editable.dir = "auto";
  editable.tabIndex = 0;
  editable.dataset.type = "wysiwyg";
  editable.wrap = "off";
  editable.classList.add("excalidraw-wysiwyg");
  let whiteSpace = "pre";
  let wordBreak = "normal";
  if (isBoundToContainer(element) || !element.autoResize) {
    whiteSpace = "pre-wrap";
    wordBreak = "break-word";
  }
  Object.assign(editable.style, {
    position: "absolute",
    display: "inline-block",
    minHeight: "1em",
    backfaceVisibility: "hidden",
    margin: 0,
    border: 0,
    outline: 0,
    resize: "none",
    background: "transparent",
    overflow: "hidden",
    // must be specified because in dark mode canvas creates a stacking context
    zIndex: "var(--zIndex-wysiwyg)",
    wordBreak,
    // prevent line wrapping (`whitespace: nowrap` doesn't work on FF)
    whiteSpace,
    overflowWrap: "break-word",
    boxSizing: "content-box"
  });
  editable.value = element.originalText;
  updateWysiwygStyle();
  if (onChange) {
    editable.onpaste = async (event) => {
      const clipboardData = await parseClipboard(event, true);
      if (!clipboardData.text) {
        return;
      }
      const data = normalizeText(clipboardData.text);
      if (!data) {
        return;
      }
      const container = getContainerElement(
        element,
        app.scene.getNonDeletedElementsMap()
      );
      const font = getFontString({
        fontSize: app.state.currentItemFontSize,
        fontFamily: app.state.currentItemFontFamily
      });
      if (container) {
        const boundTextElement = getBoundTextElement(
          container,
          app.scene.getNonDeletedElementsMap()
        );
        const wrappedText = wrapText(
          `${editable.value}${data}`,
          font,
          getBoundTextMaxWidth(container, boundTextElement)
        );
        const width = getTextWidth(wrappedText, font, true);
        editable.style.width = `${width}px`;
      }
    };
    editable.oninput = () => {
      const normalized = normalizeText(editable.value);
      if (editable.value !== normalized) {
        const selectionStart = editable.selectionStart;
        editable.value = normalized;
        editable.selectionStart = selectionStart;
        editable.selectionEnd = selectionStart;
      }
      onChange(editable.value);
    };
  }
  editable.onkeydown = (event) => {
    if (!event.shiftKey && actionZoomIn.keyTest(event)) {
      event.preventDefault();
      app.actionManager.executeAction(actionZoomIn);
      updateWysiwygStyle();
    } else if (!event.shiftKey && actionZoomOut.keyTest(event)) {
      event.preventDefault();
      app.actionManager.executeAction(actionZoomOut);
      updateWysiwygStyle();
    } else if (!event.shiftKey && actionResetZoom.keyTest(event)) {
      event.preventDefault();
      app.actionManager.executeAction(actionResetZoom);
      updateWysiwygStyle();
    } else if (actionDecreaseFontSize.keyTest(event)) {
      app.actionManager.executeAction(actionDecreaseFontSize);
    } else if (actionIncreaseFontSize.keyTest(event)) {
      app.actionManager.executeAction(actionIncreaseFontSize);
    } else if (event.key === KEYS.ESCAPE) {
      event.preventDefault();
      submittedViaKeyboard = true;
      handleSubmit();
    } else if (event.key === KEYS.ENTER && event[KEYS.CTRL_OR_CMD]) {
      event.preventDefault();
      if (event.isComposing || event.keyCode === 229) {
        return;
      }
      submittedViaKeyboard = true;
      handleSubmit();
    } else if (event.key === KEYS.TAB || event[KEYS.CTRL_OR_CMD] && (event.code === CODES.BRACKET_LEFT || event.code === CODES.BRACKET_RIGHT)) {
      event.preventDefault();
      if (event.isComposing) {
        return;
      } else if (event.shiftKey || event.code === CODES.BRACKET_LEFT) {
        outdent();
      } else {
        indent();
      }
      editable.dispatchEvent(new Event("input"));
    }
  };
  const TAB_SIZE = 4;
  const TAB = " ".repeat(TAB_SIZE);
  const RE_LEADING_TAB = new RegExp(`^ {1,${TAB_SIZE}}`);
  const indent = () => {
    const { selectionStart, selectionEnd } = editable;
    const linesStartIndices = getSelectedLinesStartIndices();
    let value = editable.value;
    linesStartIndices.forEach((startIndex) => {
      const startValue = value.slice(0, startIndex);
      const endValue = value.slice(startIndex);
      value = `${startValue}${TAB}${endValue}`;
    });
    editable.value = value;
    editable.selectionStart = selectionStart + TAB_SIZE;
    editable.selectionEnd = selectionEnd + TAB_SIZE * linesStartIndices.length;
  };
  const outdent = () => {
    const { selectionStart, selectionEnd } = editable;
    const linesStartIndices = getSelectedLinesStartIndices();
    const removedTabs = [];
    let value = editable.value;
    linesStartIndices.forEach((startIndex) => {
      const tabMatch = value.slice(startIndex, startIndex + TAB_SIZE).match(RE_LEADING_TAB);
      if (tabMatch) {
        const startValue = value.slice(0, startIndex);
        const endValue = value.slice(startIndex + tabMatch[0].length);
        value = `${startValue}${endValue}`;
        removedTabs.push(startIndex);
      }
    });
    editable.value = value;
    if (removedTabs.length) {
      if (selectionStart > removedTabs[removedTabs.length - 1]) {
        editable.selectionStart = Math.max(
          selectionStart - TAB_SIZE,
          removedTabs[removedTabs.length - 1]
        );
      } else {
        editable.selectionStart = selectionStart;
      }
      editable.selectionEnd = Math.max(
        editable.selectionStart,
        selectionEnd - TAB_SIZE * removedTabs.length
      );
    }
  };
  const getSelectedLinesStartIndices = () => {
    let { selectionStart, selectionEnd, value } = editable;
    const startOffset = value.slice(0, selectionStart).match(/[^\n]*$/)[0].length;
    selectionStart = selectionStart - startOffset;
    const selected = value.slice(selectionStart, selectionEnd);
    return selected.split("\n").reduce(
      (startIndices, line, idx, lines) => startIndices.concat(
        idx ? (
          // curr line index is prev line's start + prev line's length + \n
          startIndices[idx - 1] + lines[idx - 1].length + 1
        ) : (
          // first selected line
          selectionStart
        )
      ),
      []
    ).reverse();
  };
  const stopEvent = (event) => {
    if (event.target instanceof HTMLCanvasElement) {
      event.preventDefault();
      event.stopPropagation();
    }
  };
  let submittedViaKeyboard = false;
  const handleSubmit = () => {
    if (isDestroyed) {
      return;
    }
    isDestroyed = true;
    cleanup();
    const updateElement = Scene_default.getScene(element)?.getElement(
      element.id
    );
    if (!updateElement) {
      return;
    }
    const container = getContainerElement(
      updateElement,
      app.scene.getNonDeletedElementsMap()
    );
    if (container) {
      if (editable.value.trim()) {
        const boundTextElementId = getBoundTextElementId(container);
        if (!boundTextElementId || boundTextElementId !== element.id) {
          mutateElement(container, {
            boundElements: (container.boundElements || []).concat({
              type: "text",
              id: element.id
            })
          });
        } else if (isArrowElement(container)) {
          bumpVersion(container);
        }
      } else {
        mutateElement(container, {
          boundElements: container.boundElements?.filter(
            (ele) => !isTextElement(
              ele
            )
          )
        });
      }
      redrawTextBoundingBox(
        updateElement,
        container,
        app.scene.getNonDeletedElementsMap()
      );
    }
    onSubmit({
      viaKeyboard: submittedViaKeyboard,
      nextOriginalText: editable.value
    });
  };
  const cleanup = () => {
    editable.onblur = null;
    editable.oninput = null;
    editable.onkeydown = null;
    if (observer) {
      observer.disconnect();
    }
    window.removeEventListener("resize", updateWysiwygStyle);
    window.removeEventListener("wheel", stopEvent, true);
    window.removeEventListener("pointerdown", onPointerDown);
    window.removeEventListener("pointerup", bindBlurEvent);
    window.removeEventListener("blur", handleSubmit);
    window.removeEventListener("beforeunload", handleSubmit);
    unbindUpdate();
    unbindOnScroll();
    editable.remove();
  };
  const bindBlurEvent = (event) => {
    window.removeEventListener("pointerup", bindBlurEvent);
    const target = event?.target;
    const isPropertiesTrigger = target instanceof HTMLElement && target.classList.contains("properties-trigger");
    setTimeout(() => {
      editable.onblur = handleSubmit;
      if (!isPropertiesTrigger) {
        editable.focus();
      }
    });
  };
  const temporarilyDisableSubmit = () => {
    editable.onblur = null;
    window.addEventListener("pointerup", bindBlurEvent);
    window.addEventListener("blur", handleSubmit);
  };
  const onPointerDown = (event) => {
    const target = event?.target;
    if (event.button === POINTER_BUTTON.WHEEL) {
      if (target instanceof HTMLTextAreaElement) {
        event.preventDefault();
        app.handleCanvasPanUsingWheelOrSpaceDrag(event);
      }
      temporarilyDisableSubmit();
      return;
    }
    const isPropertiesTrigger = target instanceof HTMLElement && target.classList.contains("properties-trigger");
    if ((event.target instanceof HTMLElement || event.target instanceof SVGElement) && event.target.closest(
      `.${CLASSES.SHAPE_ACTIONS_MENU}, .${CLASSES.ZOOM_ACTIONS}`
    ) && !isWritableElement(event.target) || isPropertiesTrigger) {
      temporarilyDisableSubmit();
    } else if (event.target instanceof HTMLCanvasElement && // Vitest simply ignores stopPropagation, capture-mode, or rAF
    // so without introducing crazier hacks, nothing we can do
    !isTestEnv()) {
      requestAnimationFrame(() => {
        handleSubmit();
      });
    }
  };
  const unbindUpdate = app.scene.onUpdate(() => {
    updateWysiwygStyle();
    const isPopupOpened = !!document.activeElement?.closest(
      ".properties-content"
    );
    if (!isPopupOpened) {
      editable.focus();
    }
  });
  const unbindOnScroll = app.onScrollChangeEmitter.on(() => {
    updateWysiwygStyle();
  });
  let isDestroyed = false;
  if (autoSelect) {
    editable.select();
  }
  bindBlurEvent();
  let observer = null;
  if (canvas && "ResizeObserver" in window) {
    observer = new window.ResizeObserver(() => {
      updateWysiwygStyle();
    });
    observer.observe(canvas);
  } else {
    window.addEventListener("resize", updateWysiwygStyle);
  }
  editable.onpointerdown = (event) => event.stopPropagation();
  requestAnimationFrame(() => {
    window.addEventListener("pointerdown", onPointerDown, { capture: true });
  });
  window.addEventListener("beforeunload", handleSubmit);
  excalidrawContainer?.querySelector(".excalidraw-textEditorContainer").appendChild(editable);
};

// actions/actionTextAutoResize.ts
init_define_import_meta_env();
var actionTextAutoResize = register({
  name: "autoResize",
  label: "labels.autoResize",
  icon: null,
  trackEvent: { category: "element" },
  predicate: (elements, appState, _, app) => {
    const selectedElements = getSelectedElements(elements, appState);
    return selectedElements.length === 1 && isTextElement(selectedElements[0]) && !selectedElements[0].autoResize;
  },
  perform: (elements, appState, _, app) => {
    const selectedElements = getSelectedElements(elements, appState);
    return {
      appState,
      elements: elements.map((element) => {
        if (element.id === selectedElements[0].id && isTextElement(element)) {
          const metrics = measureText(
            element.originalText,
            getFontString(element),
            element.lineHeight
          );
          return newElementWith(element, {
            autoResize: true,
            width: metrics.width,
            height: metrics.height,
            text: element.originalText
          });
        }
        return element;
      }),
      storeAction: StoreAction.CAPTURE
    };
  }
});

// mermaid.ts
init_define_import_meta_env();
var isMaybeMermaidDefinition = (text) => {
  const chartTypes = [
    "flowchart",
    "graph",
    "sequenceDiagram",
    "classDiagram",
    "stateDiagram",
    "stateDiagram-v2",
    "erDiagram",
    "journey",
    "gantt",
    "pie",
    "quadrantChart",
    "requirementDiagram",
    "gitGraph",
    "C4Context",
    "mindmap",
    "timeline",
    "zenuml",
    "sankey",
    "xychart",
    "block"
  ];
  const re = new RegExp(
    `^(?:%%{.*?}%%[\\s\\n]*)?\\b(?:${chartTypes.map((x3) => `\\s*${x3}(-beta)?`).join("|")})\\b`
  );
  return re.test(text.trim());
};

// components/canvases/NewElementCanvas.tsx
init_define_import_meta_env();
var import_react113 = __toESM(require_react(), 1);

// renderer/renderNewElementScene.ts
init_define_import_meta_env();
var _renderNewElementScene = ({
  canvas,
  rc,
  newElement: newElement2,
  elementsMap,
  allElementsMap,
  scale,
  appState,
  renderConfig
}) => {
  if (canvas) {
    const [normalizedWidth, normalizedHeight] = getNormalizedCanvasDimensions(
      canvas,
      scale
    );
    const context = bootstrapCanvas({
      canvas,
      scale,
      normalizedWidth,
      normalizedHeight
    });
    context.save();
    context.scale(appState.zoom.value, appState.zoom.value);
    if (newElement2 && newElement2.type !== "selection") {
      renderElement(
        newElement2,
        elementsMap,
        allElementsMap,
        rc,
        context,
        renderConfig,
        appState
      );
    } else {
      context.clearRect(0, 0, normalizedWidth, normalizedHeight);
    }
  }
};
var renderNewElementSceneThrottled = throttleRAF(
  (config) => {
    _renderNewElementScene(config);
  },
  { trailing: true }
);
var renderNewElementScene = (renderConfig, throttle5) => {
  if (throttle5) {
    renderNewElementSceneThrottled(renderConfig);
    return;
  }
  _renderNewElementScene(renderConfig);
};

// components/canvases/NewElementCanvas.tsx
var import_jsx_runtime145 = __toESM(require_jsx_runtime(), 1);
var NewElementCanvas = (props) => {
  const canvasRef = (0, import_react113.useRef)(null);
  (0, import_react113.useEffect)(() => {
    if (!canvasRef.current) {
      return;
    }
    renderNewElementScene(
      {
        canvas: canvasRef.current,
        scale: props.scale,
        newElement: props.appState.newElement,
        elementsMap: props.elementsMap,
        allElementsMap: props.allElementsMap,
        rc: props.rc,
        renderConfig: props.renderConfig,
        appState: props.appState
      },
      isRenderThrottlingEnabled()
    );
  });
  return /* @__PURE__ */ (0, import_jsx_runtime145.jsx)(
    "canvas",
    {
      className: "excalidraw__canvas",
      style: {
        width: props.appState.width,
        height: props.appState.height
      },
      width: props.appState.width * props.scale,
      height: props.appState.height * props.scale,
      ref: canvasRef
    }
  );
};
var NewElementCanvas_default = NewElementCanvas;

// components/App.tsx
var import_jsx_runtime146 = __toESM(require_jsx_runtime(), 1);
var AppContext = import_react114.default.createContext(null);
var AppPropsContext = import_react114.default.createContext(null);
var deviceContextInitialValue = {
  viewport: {
    isMobile: false,
    isLandscape: false
  },
  editor: {
    isMobile: false,
    canFitSidebar: false
  },
  isTouchScreen: false
};
var DeviceContext = import_react114.default.createContext(deviceContextInitialValue);
DeviceContext.displayName = "DeviceContext";
var ExcalidrawContainerContext = import_react114.default.createContext({ container: null, id: null });
ExcalidrawContainerContext.displayName = "ExcalidrawContainerContext";
var ExcalidrawElementsContext = import_react114.default.createContext([]);
ExcalidrawElementsContext.displayName = "ExcalidrawElementsContext";
var ExcalidrawAppStateContext = import_react114.default.createContext({
  ...getDefaultAppState(),
  width: 0,
  height: 0,
  offsetLeft: 0,
  offsetTop: 0
});
ExcalidrawAppStateContext.displayName = "ExcalidrawAppStateContext";
var ExcalidrawSetAppStateContext = import_react114.default.createContext(() => {
  console.warn("Uninitialized ExcalidrawSetAppStateContext context!");
});
ExcalidrawSetAppStateContext.displayName = "ExcalidrawSetAppStateContext";
var ExcalidrawActionManagerContext = import_react114.default.createContext(
  null
);
ExcalidrawActionManagerContext.displayName = "ExcalidrawActionManagerContext";
var useApp = () => (0, import_react114.useContext)(AppContext);
var useAppProps = () => (0, import_react114.useContext)(AppPropsContext);
var useDevice = () => (0, import_react114.useContext)(DeviceContext);
var useExcalidrawContainer = () => (0, import_react114.useContext)(ExcalidrawContainerContext);
var useExcalidrawElements = () => (0, import_react114.useContext)(ExcalidrawElementsContext);
var useExcalidrawAppState = () => (0, import_react114.useContext)(ExcalidrawAppStateContext);
var useExcalidrawSetAppState = () => (0, import_react114.useContext)(ExcalidrawSetAppStateContext);
var useExcalidrawActionManager = () => (0, import_react114.useContext)(ExcalidrawActionManagerContext);
var didTapTwice = false;
var tappedTwiceTimer = 0;
var isHoldingSpace = false;
var isPanning = false;
var isDraggingScrollBar = false;
var currentScrollBars = { horizontal: null, vertical: null };
var touchTimeout = 0;
var invalidateContextMenu = false;
var YOUTUBE_VIDEO_STATES = /* @__PURE__ */ new Map();
var IS_PLAIN_PASTE = false;
var IS_PLAIN_PASTE_TIMER = 0;
var PLAIN_PASTE_TOAST_SHOWN = false;
var lastPointerUp = null;
var gesture = {
  pointers: /* @__PURE__ */ new Map(),
  lastCenter: null,
  initialDistance: null,
  initialScale: null
};
var App = class _App extends import_react114.default.Component {
  canvas;
  interactiveCanvas = null;
  rc;
  unmounted = false;
  actionManager;
  device = deviceContextInitialValue;
  excalidrawContainerRef = import_react114.default.createRef();
  scene;
  fonts;
  renderer;
  visibleElements;
  resizeObserver;
  nearestScrollableContainer;
  library;
  libraryItemsFromStorage;
  id;
  store;
  history;
  excalidrawContainerValue;
  files = {};
  imageCache = /* @__PURE__ */ new Map();
  iFrameRefs = /* @__PURE__ */ new Map();
  /**
   * Indicates whether the embeddable's url has been validated for rendering.
   * If value not set, indicates that the validation is pending.
   * Initially or on url change the flag is not reset so that we can guarantee
   * the validation came from a trusted source (the editor).
   **/
  embedsValidationStatus = /* @__PURE__ */ new Map();
  /** embeds that have been inserted to DOM (as a perf optim, we don't want to
   * insert to DOM before user initially scrolls to them) */
  initializedEmbeds = /* @__PURE__ */ new Set();
  elementsPendingErasure = /* @__PURE__ */ new Set();
  flowChartCreator = new FlowChartCreator();
  flowChartNavigator = new FlowChartNavigator();
  hitLinkElement;
  lastPointerDownEvent = null;
  lastPointerUpEvent = null;
  lastPointerMoveEvent = null;
  lastViewportPosition = { x: 0, y: 0 };
  animationFrameHandler = new AnimationFrameHandler();
  laserTrails = new LaserTrails(this.animationFrameHandler, this);
  eraserTrail = new AnimatedTrail(this.animationFrameHandler, this, {
    streamline: 0.2,
    size: 5,
    keepHead: true,
    sizeMapping: (c3) => {
      const DECAY_TIME = 200;
      const DECAY_LENGTH = 10;
      const t3 = Math.max(0, 1 - (performance.now() - c3.pressure) / DECAY_TIME);
      const l3 = (DECAY_LENGTH - Math.min(DECAY_LENGTH, c3.totalLength - c3.currentIndex)) / DECAY_LENGTH;
      return Math.min(easeOut(l3), easeOut(t3));
    },
    fill: () => this.state.theme === THEME.LIGHT ? "rgba(0, 0, 0, 0.2)" : "rgba(255, 255, 255, 0.2)"
  });
  onChangeEmitter = new Emitter();
  onPointerDownEmitter = new Emitter();
  onPointerUpEmitter = new Emitter();
  onUserFollowEmitter = new Emitter();
  onScrollChangeEmitter = new Emitter();
  missingPointerEventCleanupEmitter = new Emitter();
  onRemoveEventListenersEmitter = new Emitter();
  constructor(props) {
    super(props);
    const defaultAppState = getDefaultAppState();
    const {
      excalidrawAPI,
      viewModeEnabled = false,
      zenModeEnabled = false,
      gridModeEnabled = false,
      objectsSnapModeEnabled = false,
      theme = defaultAppState.theme,
      name = `${t("labels.untitled")}-${getDateTime()}`
    } = props;
    this.state = {
      ...defaultAppState,
      theme,
      isLoading: true,
      ...this.getCanvasOffsets(),
      viewModeEnabled,
      zenModeEnabled,
      objectsSnapModeEnabled,
      gridModeEnabled: gridModeEnabled ?? defaultAppState.gridModeEnabled,
      name,
      width: window.innerWidth,
      height: window.innerHeight
    };
    this.id = nanoid();
    this.library = new library_default(this);
    this.actionManager = new ActionManager(
      this.syncActionResult,
      () => this.state,
      () => this.scene.getElementsIncludingDeleted(),
      this
    );
    this.scene = new Scene_default();
    this.canvas = document.createElement("canvas");
    this.rc = rough_default.canvas(this.canvas);
    this.renderer = new Renderer(this.scene);
    this.visibleElements = [];
    this.store = new Store();
    this.history = new History();
    if (excalidrawAPI) {
      const api = {
        updateScene: this.updateScene,
        updateLibrary: this.library.updateLibrary,
        addFiles: this.addFiles,
        resetScene: this.resetScene,
        getSceneElementsIncludingDeleted: this.getSceneElementsIncludingDeleted,
        history: {
          clear: this.resetHistory
        },
        scrollToContent: this.scrollToContent,
        getSceneElements: this.getSceneElements,
        getAppState: () => this.state,
        getFiles: () => this.files,
        getName: this.getName,
        registerAction: (action) => {
          this.actionManager.registerAction(action);
        },
        refresh: this.refresh,
        setToast: this.setToast,
        id: this.id,
        setActiveTool: this.setActiveTool,
        setCursor: this.setCursor,
        resetCursor: this.resetCursor,
        updateFrameRendering: this.updateFrameRendering,
        toggleSidebar: this.toggleSidebar,
        onChange: (cb) => this.onChangeEmitter.on(cb),
        onPointerDown: (cb) => this.onPointerDownEmitter.on(cb),
        onPointerUp: (cb) => this.onPointerUpEmitter.on(cb),
        onScrollChange: (cb) => this.onScrollChangeEmitter.on(cb),
        onUserFollow: (cb) => this.onUserFollowEmitter.on(cb)
      };
      if (typeof excalidrawAPI === "function") {
        excalidrawAPI(api);
      } else {
        console.error("excalidrawAPI should be a function!");
      }
    }
    this.excalidrawContainerValue = {
      container: this.excalidrawContainerRef.current,
      id: this.id
    };
    this.fonts = new Fonts({ scene: this.scene });
    this.history = new History();
    this.actionManager.registerAll(actions);
    this.actionManager.registerAction(
      createUndoAction(this.history, this.store)
    );
    this.actionManager.registerAction(
      createRedoAction(this.history, this.store)
    );
  }
  onWindowMessage(event) {
    if (event.origin !== "https://player.vimeo.com" && event.origin !== "https://www.youtube.com") {
      return;
    }
    let data = null;
    try {
      data = JSON.parse(event.data);
    } catch (e3) {
    }
    if (!data) {
      return;
    }
    switch (event.origin) {
      case "https://player.vimeo.com":
        if (data.method === "paused") {
          let source = null;
          const iframes = document.body.querySelectorAll(
            "iframe.excalidraw__embeddable"
          );
          if (!iframes) {
            break;
          }
          for (const iframe of iframes) {
            if (iframe.contentWindow === event.source) {
              source = iframe.contentWindow;
            }
          }
          source?.postMessage(
            JSON.stringify({
              method: data.value ? "play" : "pause",
              value: true
            }),
            "*"
          );
        }
        break;
      case "https://www.youtube.com":
        if (data.event === "infoDelivery" && data.info && data.id && typeof data.info.playerState === "number") {
          const id = data.id;
          const playerState = data.info.playerState;
          if (Object.values(YOUTUBE_STATES).includes(playerState)) {
            YOUTUBE_VIDEO_STATES.set(
              id,
              playerState
            );
          }
        }
        break;
    }
  }
  cacheEmbeddableRef(element, ref) {
    if (ref) {
      this.iFrameRefs.set(element.id, ref);
    }
  }
  /**
   * Returns gridSize taking into account `gridModeEnabled`.
   * If disabled, returns null.
   */
  getEffectiveGridSize = () => {
    return isGridModeEnabled(this) ? this.state.gridSize : null;
  };
  getHTMLIFrameElement(element) {
    return this.iFrameRefs.get(element.id);
  }
  handleEmbeddableCenterClick(element) {
    if (this.state.activeEmbeddable?.element === element && this.state.activeEmbeddable?.state === "active") {
      return;
    }
    setTimeout(() => {
      this.setState({
        activeEmbeddable: { element, state: "active" },
        selectedElementIds: { [element.id]: true },
        newElement: null,
        selectionElement: null
      });
    }, 100);
    if (isIframeElement(element)) {
      return;
    }
    const iframe = this.getHTMLIFrameElement(element);
    if (!iframe?.contentWindow) {
      return;
    }
    if (iframe.src.includes("youtube")) {
      const state = YOUTUBE_VIDEO_STATES.get(element.id);
      if (!state) {
        YOUTUBE_VIDEO_STATES.set(element.id, YOUTUBE_STATES.UNSTARTED);
        iframe.contentWindow.postMessage(
          JSON.stringify({
            event: "listening",
            id: element.id
          }),
          "*"
        );
      }
      switch (state) {
        case YOUTUBE_STATES.PLAYING:
        case YOUTUBE_STATES.BUFFERING:
          iframe.contentWindow?.postMessage(
            JSON.stringify({
              event: "command",
              func: "pauseVideo",
              args: ""
            }),
            "*"
          );
          break;
        default:
          iframe.contentWindow?.postMessage(
            JSON.stringify({
              event: "command",
              func: "playVideo",
              args: ""
            }),
            "*"
          );
      }
    }
    if (iframe.src.includes("player.vimeo.com")) {
      iframe.contentWindow.postMessage(
        JSON.stringify({
          method: "paused"
          //video play/pause in onWindowMessage handler
        }),
        "*"
      );
    }
  }
  isIframeLikeElementCenter(el, event, sceneX, sceneY) {
    return el && !event.altKey && !event.shiftKey && !event.metaKey && !event.ctrlKey && (this.state.activeEmbeddable?.element !== el || this.state.activeEmbeddable?.state === "hover" || !this.state.activeEmbeddable) && sceneX >= el.x + el.width / 3 && sceneX <= el.x + 2 * el.width / 3 && sceneY >= el.y + el.height / 3 && sceneY <= el.y + 2 * el.height / 3;
  }
  updateEmbedValidationStatus = (element, status) => {
    this.embedsValidationStatus.set(element.id, status);
    ShapeCache.delete(element);
  };
  updateEmbeddables = () => {
    const iframeLikes = /* @__PURE__ */ new Set();
    let updated = false;
    this.scene.getNonDeletedElements().filter((element) => {
      if (isEmbeddableElement(element)) {
        iframeLikes.add(element.id);
        if (!this.embedsValidationStatus.has(element.id)) {
          updated = true;
          const validated = embeddableURLValidator(
            element.link,
            this.props.validateEmbeddable
          );
          this.updateEmbedValidationStatus(element, validated);
        }
      } else if (isIframeElement(element)) {
        iframeLikes.add(element.id);
      }
      return false;
    });
    if (updated) {
      this.scene.triggerUpdate();
    }
    this.iFrameRefs.forEach((ref, id) => {
      if (!iframeLikes.has(id)) {
        this.iFrameRefs.delete(id);
      }
    });
  };
  renderEmbeddables() {
    const scale = this.state.zoom.value;
    const normalizedWidth = this.state.width;
    const normalizedHeight = this.state.height;
    const embeddableElements = this.scene.getNonDeletedElements().filter(
      (el) => isEmbeddableElement(el) && this.embedsValidationStatus.get(el.id) === true || isIframeElement(el)
    );
    return /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(import_jsx_runtime146.Fragment, { children: embeddableElements.map((el) => {
      const { x: x3, y: y3 } = sceneCoordsToViewportCoords(
        { sceneX: el.x, sceneY: el.y },
        this.state
      );
      const isVisible = isElementInViewport(
        el,
        normalizedWidth,
        normalizedHeight,
        this.state,
        this.scene.getNonDeletedElementsMap()
      );
      const hasBeenInitialized = this.initializedEmbeds.has(el.id);
      if (isVisible && !hasBeenInitialized) {
        this.initializedEmbeds.add(el.id);
      }
      const shouldRender = isVisible || hasBeenInitialized;
      if (!shouldRender) {
        return null;
      }
      let src;
      if (isIframeElement(el)) {
        src = null;
        const data = (el.customData?.generationData ?? this.magicGenerations.get(el.id)) || {
          status: "error",
          message: "No generation data",
          code: "ERR_NO_GENERATION_DATA"
        };
        if (data.status === "done") {
          const html = data.html;
          src = {
            intrinsicSize: { w: el.width, h: el.height },
            type: "document",
            srcdoc: () => {
              return html;
            }
          };
        } else if (data.status === "pending") {
          src = {
            intrinsicSize: { w: el.width, h: el.height },
            type: "document",
            srcdoc: () => {
              return createSrcDoc(`
                    <style>
                      html, body {
                        width: 100%;
                        height: 100%;
                        color: ${this.state.theme === THEME.DARK ? "white" : "black"};
                      }
                      body {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        flex-direction: column;
                        gap: 1rem;
                      }

                      .Spinner {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        margin-left: auto;
                        margin-right: auto;
                      }

                      .Spinner svg {
                        animation: rotate 1.6s linear infinite;
                        transform-origin: center center;
                        width: 40px;
                        height: 40px;
                      }

                      .Spinner circle {
                        stroke: currentColor;
                        animation: dash 1.6s linear 0s infinite;
                        stroke-linecap: round;
                      }

                      @keyframes rotate {
                        100% {
                          transform: rotate(360deg);
                        }
                      }

                      @keyframes dash {
                        0% {
                          stroke-dasharray: 1, 300;
                          stroke-dashoffset: 0;
                        }
                        50% {
                          stroke-dasharray: 150, 300;
                          stroke-dashoffset: -200;
                        }
                        100% {
                          stroke-dasharray: 1, 300;
                          stroke-dashoffset: -280;
                        }
                      }
                    </style>
                    <div class="Spinner">
                      <svg
                        viewBox="0 0 100 100"
                      >
                        <circle
                          cx="50"
                          cy="50"
                          r="46"
                          stroke-width="8"
                          fill="none"
                          stroke-miter-limit="10"
                        />
                      </svg>
                    </div>
                    <div>Generating...</div>
                  `);
            }
          };
        } else {
          let message;
          if (data.code === "ERR_GENERATION_INTERRUPTED") {
            message = "Generation was interrupted...";
          } else {
            message = data.message || "Generation failed";
          }
          src = {
            intrinsicSize: { w: el.width, h: el.height },
            type: "document",
            srcdoc: () => {
              return createSrcDoc(`
                    <style>
                    html, body {
                      height: 100%;
                    }
                      body {
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                        color: ${COLOR_PALETTE.red[3]};
                      }
                      h1, h3 {
                        margin-top: 0;
                        margin-bottom: 0.5rem;
                      }
                    </style>
                    <h1>Error!</h1>
                    <h3>${message}</h3>
                  `);
            }
          };
        }
      } else {
        src = getEmbedLink(toValidURL(el.link || ""));
      }
      const isActive = this.state.activeEmbeddable?.element === el && this.state.activeEmbeddable?.state === "active";
      const isHovered = this.state.activeEmbeddable?.element === el && this.state.activeEmbeddable?.state === "hover";
      return /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(
        "div",
        {
          className: clsx_m_default("excalidraw__embeddable-container", {
            "is-hovered": isHovered
          }),
          style: {
            transform: isVisible ? `translate(${x3 - this.state.offsetLeft}px, ${y3 - this.state.offsetTop}px) scale(${scale})` : "none",
            display: isVisible ? "block" : "none",
            opacity: getRenderOpacity(
              el,
              getContainingFrame(el, this.scene.getNonDeletedElementsMap()),
              this.elementsPendingErasure,
              null
            ),
            ["--embeddable-radius"]: `${getCornerRadius(
              Math.min(el.width, el.height),
              el
            )}px`
          },
          children: /* @__PURE__ */ (0, import_jsx_runtime146.jsxs)(
            "div",
            {
              className: "excalidraw__embeddable-container__inner",
              style: {
                width: isVisible ? `${el.width}px` : 0,
                height: isVisible ? `${el.height}px` : 0,
                transform: isVisible ? `rotate(${el.angle}rad)` : "none",
                pointerEvents: isActive ? POINTER_EVENTS.enabled : POINTER_EVENTS.disabled
              },
              children: [
                isHovered && /* @__PURE__ */ (0, import_jsx_runtime146.jsx)("div", { className: "excalidraw__embeddable-hint", children: t("buttons.embeddableInteractionButton") }),
                /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(
                  "div",
                  {
                    className: "excalidraw__embeddable__outer",
                    style: {
                      padding: `${el.strokeWidth}px`
                    },
                    children: (isEmbeddableElement(el) ? this.props.renderEmbeddable?.(el, this.state) : null) ?? /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(
                      "iframe",
                      {
                        ref: (ref) => this.cacheEmbeddableRef(el, ref),
                        className: "excalidraw__embeddable",
                        srcDoc: src?.type === "document" ? src.srcdoc(this.state.theme) : void 0,
                        src: src?.type !== "document" ? src?.link ?? "" : void 0,
                        scrolling: "no",
                        referrerPolicy: "no-referrer-when-downgrade",
                        title: "Excalidraw Embedded Content",
                        allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",
                        allowFullScreen: true,
                        sandbox: `${src?.sandbox?.allowSameOrigin ? "allow-same-origin" : ""} allow-scripts allow-forms allow-popups allow-popups-to-escape-sandbox allow-presentation allow-downloads`
                      }
                    )
                  }
                )
              ]
            }
          )
        },
        el.id
      );
    }) });
  }
  getFrameNameDOMId = (frameElement) => {
    return `${this.id}-frame-name-${frameElement.id}`;
  };
  frameNameBoundsCache = {
    get: (frameElement) => {
      let bounds = this.frameNameBoundsCache._cache.get(frameElement.id);
      if (!bounds || bounds.zoom !== this.state.zoom.value || bounds.versionNonce !== frameElement.versionNonce) {
        const frameNameDiv = document.getElementById(
          this.getFrameNameDOMId(frameElement)
        );
        if (frameNameDiv) {
          const box = frameNameDiv.getBoundingClientRect();
          const boxSceneTopLeft = viewportCoordsToSceneCoords(
            { clientX: box.x, clientY: box.y },
            this.state
          );
          const boxSceneBottomRight = viewportCoordsToSceneCoords(
            { clientX: box.right, clientY: box.bottom },
            this.state
          );
          bounds = {
            x: boxSceneTopLeft.x,
            y: boxSceneTopLeft.y,
            width: boxSceneBottomRight.x - boxSceneTopLeft.x,
            height: boxSceneBottomRight.y - boxSceneTopLeft.y,
            angle: 0,
            zoom: this.state.zoom.value,
            versionNonce: frameElement.versionNonce
          };
          this.frameNameBoundsCache._cache.set(frameElement.id, bounds);
          return bounds;
        }
        return null;
      }
      return bounds;
    },
    /**
     * @private
     */
    _cache: /* @__PURE__ */ new Map()
  };
  renderFrameNames = () => {
    if (!this.state.frameRendering.enabled || !this.state.frameRendering.name) {
      return null;
    }
    const isDarkTheme = this.state.theme === THEME.DARK;
    return this.scene.getNonDeletedFramesLikes().map((f3) => {
      if (!isElementInViewport(
        f3,
        this.canvas.width / window.devicePixelRatio,
        this.canvas.height / window.devicePixelRatio,
        {
          offsetLeft: this.state.offsetLeft,
          offsetTop: this.state.offsetTop,
          scrollX: this.state.scrollX,
          scrollY: this.state.scrollY,
          zoom: this.state.zoom
        },
        this.scene.getNonDeletedElementsMap()
      )) {
        return null;
      }
      const { x: x1, y: y1 } = sceneCoordsToViewportCoords(
        { sceneX: f3.x, sceneY: f3.y },
        this.state
      );
      const FRAME_NAME_EDIT_PADDING = 6;
      const reset = () => {
        mutateElement(f3, { name: f3.name?.trim() || null });
        this.setState({ editingFrame: null });
      };
      let frameNameJSX;
      const frameName = getFrameLikeTitle(f3);
      if (f3.id === this.state.editingFrame) {
        const frameNameInEdit = frameName;
        frameNameJSX = /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(
          "input",
          {
            autoFocus: true,
            value: frameNameInEdit,
            onChange: (e3) => {
              mutateElement(f3, {
                name: e3.target.value
              });
            },
            onFocus: (e3) => e3.target.select(),
            onBlur: () => reset(),
            onKeyDown: (event) => {
              if (event.key === KEYS.ESCAPE || event.key === KEYS.ENTER) {
                reset();
              }
            },
            style: {
              background: this.state.viewBackgroundColor,
              filter: isDarkTheme ? THEME_FILTER : "none",
              zIndex: 2,
              border: "none",
              display: "block",
              padding: `${FRAME_NAME_EDIT_PADDING}px`,
              borderRadius: 4,
              boxShadow: "inset 0 0 0 1px var(--color-primary)",
              fontFamily: "Assistant",
              fontSize: "14px",
              transform: `translate(-${FRAME_NAME_EDIT_PADDING}px, ${FRAME_NAME_EDIT_PADDING}px)`,
              color: "var(--color-gray-80)",
              overflow: "hidden",
              maxWidth: `${document.body.clientWidth - x1 - FRAME_NAME_EDIT_PADDING}px`
            },
            size: frameNameInEdit.length + 1 || 1,
            dir: "auto",
            autoComplete: "off",
            autoCapitalize: "off",
            autoCorrect: "off"
          }
        );
      } else {
        frameNameJSX = frameName;
      }
      return /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(
        "div",
        {
          id: this.getFrameNameDOMId(f3),
          style: {
            position: "absolute",
            // Positioning from bottom so that we don't to either
            // calculate text height or adjust using transform (which)
            // messes up input position when editing the frame name.
            // This makes the positioning deterministic and we can calculate
            // the same position when rendering to canvas / svg.
            bottom: `${this.state.height + FRAME_STYLE.nameOffsetY - y1 + this.state.offsetTop}px`,
            left: `${x1 - this.state.offsetLeft}px`,
            zIndex: 2,
            fontSize: FRAME_STYLE.nameFontSize,
            color: isDarkTheme ? FRAME_STYLE.nameColorDarkTheme : FRAME_STYLE.nameColorLightTheme,
            lineHeight: FRAME_STYLE.nameLineHeight,
            width: "max-content",
            maxWidth: `${f3.width}px`,
            overflow: f3.id === this.state.editingFrame ? "visible" : "hidden",
            whiteSpace: "nowrap",
            textOverflow: "ellipsis",
            cursor: CURSOR_TYPE.MOVE,
            pointerEvents: this.state.viewModeEnabled ? POINTER_EVENTS.disabled : POINTER_EVENTS.enabled
          },
          onPointerDown: (event) => this.handleCanvasPointerDown(event),
          onWheel: (event) => this.handleWheel(event),
          onContextMenu: this.handleCanvasContextMenu,
          onDoubleClick: () => {
            this.setState({
              editingFrame: f3.id
            });
          },
          children: frameNameJSX
        },
        f3.id
      );
    });
  };
  toggleOverscrollBehavior(event) {
    document.documentElement.style.overscrollBehaviorX = event.type === "pointerenter" ? "none" : "auto";
  }
  render() {
    const selectedElements = this.scene.getSelectedElements(this.state);
    const { renderTopRightUI, renderCustomStats } = this.props;
    const sceneNonce = this.scene.getSceneNonce();
    const { elementsMap, visibleElements } = this.renderer.getRenderableElements({
      sceneNonce,
      zoom: this.state.zoom,
      offsetLeft: this.state.offsetLeft,
      offsetTop: this.state.offsetTop,
      scrollX: this.state.scrollX,
      scrollY: this.state.scrollY,
      height: this.state.height,
      width: this.state.width,
      editingTextElement: this.state.editingTextElement,
      newElementId: this.state.newElement?.id,
      pendingImageElementId: this.state.pendingImageElementId
    });
    this.visibleElements = visibleElements;
    const allElementsMap = this.scene.getNonDeletedElementsMap();
    const shouldBlockPointerEvents = this.state.selectionElement || this.state.newElement || this.state.selectedElementsAreBeingDragged || this.state.resizingElement || this.state.activeTool.type === "laser" && // technically we can just test on this once we make it more safe
    this.state.cursorButton === "down";
    const firstSelectedElement = selectedElements[0];
    return /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(
      "div",
      {
        className: clsx_m_default("excalidraw excalidraw-container", {
          "excalidraw--view-mode": this.state.viewModeEnabled,
          "excalidraw--mobile": this.device.editor.isMobile
        }),
        style: {
          ["--ui-pointerEvents"]: shouldBlockPointerEvents ? POINTER_EVENTS.disabled : POINTER_EVENTS.enabled
        },
        ref: this.excalidrawContainerRef,
        onDrop: this.handleAppOnDrop,
        tabIndex: 0,
        onKeyDown: this.props.handleKeyboardGlobally ? void 0 : this.onKeyDown,
        onPointerEnter: this.toggleOverscrollBehavior,
        onPointerLeave: this.toggleOverscrollBehavior,
        children: /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(AppContext.Provider, { value: this, children: /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(AppPropsContext.Provider, { value: this.props, children: /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(
          ExcalidrawContainerContext.Provider,
          {
            value: this.excalidrawContainerValue,
            children: /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(DeviceContext.Provider, { value: this.device, children: /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(ExcalidrawSetAppStateContext.Provider, { value: this.setAppState, children: /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(ExcalidrawAppStateContext.Provider, { value: this.state, children: /* @__PURE__ */ (0, import_jsx_runtime146.jsxs)(
              ExcalidrawElementsContext.Provider,
              {
                value: this.scene.getNonDeletedElements(),
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime146.jsxs)(
                    ExcalidrawActionManagerContext.Provider,
                    {
                      value: this.actionManager,
                      children: [
                        /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(
                          LayerUI_default,
                          {
                            canvas: this.canvas,
                            appState: this.state,
                            files: this.files,
                            setAppState: this.setAppState,
                            actionManager: this.actionManager,
                            elements: this.scene.getNonDeletedElements(),
                            onLockToggle: this.toggleLock,
                            onPenModeToggle: this.togglePenMode,
                            onHandToolToggle: this.onHandToolToggle,
                            langCode: getLanguage().code,
                            renderTopRightUI,
                            renderCustomStats,
                            showExitZenModeBtn: typeof this.props?.zenModeEnabled === "undefined" && this.state.zenModeEnabled,
                            UIOptions: this.props.UIOptions,
                            onExportImage: this.onExportImage,
                            renderWelcomeScreen: !this.state.isLoading && this.state.showWelcomeScreen && this.state.activeTool.type === "selection" && !this.state.zenModeEnabled && !this.scene.getElementsIncludingDeleted().length,
                            app: this,
                            isCollaborating: this.props.isCollaborating,
                            children: this.props.children
                          }
                        ),
                        /* @__PURE__ */ (0, import_jsx_runtime146.jsx)("div", { className: "excalidraw-textEditorContainer" }),
                        /* @__PURE__ */ (0, import_jsx_runtime146.jsx)("div", { className: "excalidraw-contextMenuContainer" }),
                        /* @__PURE__ */ (0, import_jsx_runtime146.jsx)("div", { className: "excalidraw-eye-dropper-container" }),
                        /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(
                          SVGLayer,
                          {
                            trails: [this.laserTrails, this.eraserTrail]
                          }
                        ),
                        selectedElements.length === 1 && this.state.showHyperlinkPopup && /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(
                          Hyperlink,
                          {
                            element: firstSelectedElement,
                            elementsMap: allElementsMap,
                            setAppState: this.setAppState,
                            onLinkOpen: this.props.onLinkOpen,
                            setToast: this.setToast,
                            updateEmbedValidationStatus: this.updateEmbedValidationStatus
                          },
                          firstSelectedElement.id
                        ),
                        this.props.aiEnabled !== false && selectedElements.length === 1 && isMagicFrameElement(firstSelectedElement) && /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(
                          ElementCanvasButtons,
                          {
                            element: firstSelectedElement,
                            elementsMap,
                            children: /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(
                              ElementCanvasButton,
                              {
                                title: t("labels.convertToCode"),
                                icon: MagicIcon,
                                checked: false,
                                onChange: () => this.onMagicFrameGenerate(
                                  firstSelectedElement,
                                  "button"
                                )
                              }
                            )
                          }
                        ),
                        selectedElements.length === 1 && isIframeElement(firstSelectedElement) && firstSelectedElement.customData?.generationData?.status === "done" && /* @__PURE__ */ (0, import_jsx_runtime146.jsxs)(
                          ElementCanvasButtons,
                          {
                            element: firstSelectedElement,
                            elementsMap,
                            children: [
                              /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(
                                ElementCanvasButton,
                                {
                                  title: t("labels.copySource"),
                                  icon: copyIcon,
                                  checked: false,
                                  onChange: () => this.onIframeSrcCopy(firstSelectedElement)
                                }
                              ),
                              /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(
                                ElementCanvasButton,
                                {
                                  title: "Enter fullscreen",
                                  icon: fullscreenIcon,
                                  checked: false,
                                  onChange: () => {
                                    const iframe = this.getHTMLIFrameElement(
                                      firstSelectedElement
                                    );
                                    if (iframe) {
                                      try {
                                        iframe.requestFullscreen();
                                        this.setState({
                                          activeEmbeddable: {
                                            element: firstSelectedElement,
                                            state: "active"
                                          },
                                          selectedElementIds: {
                                            [firstSelectedElement.id]: true
                                          },
                                          newElement: null,
                                          selectionElement: null
                                        });
                                      } catch (err) {
                                        console.warn(err);
                                        this.setState({
                                          errorMessage: "Couldn't enter fullscreen"
                                        });
                                      }
                                    }
                                  }
                                }
                              )
                            ]
                          }
                        ),
                        this.state.toast !== null && /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(
                          Toast,
                          {
                            message: this.state.toast.message,
                            onClose: () => this.setToast(null),
                            duration: this.state.toast.duration,
                            closable: this.state.toast.closable
                          }
                        ),
                        this.state.contextMenu && /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(
                          ContextMenu,
                          {
                            items: this.state.contextMenu.items,
                            top: this.state.contextMenu.top,
                            left: this.state.contextMenu.left,
                            actionManager: this.actionManager,
                            onClose: (callback) => {
                              this.setState({ contextMenu: null }, () => {
                                this.focusContainer();
                                callback?.();
                              });
                            }
                          }
                        ),
                        /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(
                          StaticCanvas_default,
                          {
                            canvas: this.canvas,
                            rc: this.rc,
                            elementsMap,
                            allElementsMap,
                            visibleElements,
                            sceneNonce,
                            selectionNonce: this.state.selectionElement?.versionNonce,
                            scale: window.devicePixelRatio,
                            appState: this.state,
                            renderConfig: {
                              imageCache: this.imageCache,
                              isExporting: false,
                              renderGrid: isGridModeEnabled(this),
                              canvasBackgroundColor: this.state.viewBackgroundColor,
                              embedsValidationStatus: this.embedsValidationStatus,
                              elementsPendingErasure: this.elementsPendingErasure,
                              pendingFlowchartNodes: this.flowChartCreator.pendingNodes
                            }
                          }
                        ),
                        this.state.newElement && /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(
                          NewElementCanvas_default,
                          {
                            appState: this.state,
                            scale: window.devicePixelRatio,
                            rc: this.rc,
                            elementsMap,
                            allElementsMap,
                            renderConfig: {
                              imageCache: this.imageCache,
                              isExporting: false,
                              renderGrid: false,
                              canvasBackgroundColor: this.state.viewBackgroundColor,
                              embedsValidationStatus: this.embedsValidationStatus,
                              elementsPendingErasure: this.elementsPendingErasure,
                              pendingFlowchartNodes: null
                            }
                          }
                        ),
                        /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(
                          InteractiveCanvas_default,
                          {
                            containerRef: this.excalidrawContainerRef,
                            canvas: this.interactiveCanvas,
                            elementsMap,
                            visibleElements,
                            allElementsMap,
                            selectedElements,
                            sceneNonce,
                            selectionNonce: this.state.selectionElement?.versionNonce,
                            scale: window.devicePixelRatio,
                            appState: this.state,
                            device: this.device,
                            renderInteractiveSceneCallback: this.renderInteractiveSceneCallback,
                            handleCanvasRef: this.handleInteractiveCanvasRef,
                            onContextMenu: this.handleCanvasContextMenu,
                            onPointerMove: this.handleCanvasPointerMove,
                            onPointerUp: this.handleCanvasPointerUp,
                            onPointerCancel: this.removePointer,
                            onTouchMove: this.handleTouchMove,
                            onPointerDown: this.handleCanvasPointerDown,
                            onDoubleClick: this.handleCanvasDoubleClick
                          }
                        ),
                        this.state.userToFollow && /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(
                          FollowMode_default,
                          {
                            width: this.state.width,
                            height: this.state.height,
                            userToFollow: this.state.userToFollow,
                            onDisconnect: this.maybeUnfollowRemoteUser
                          }
                        ),
                        this.renderFrameNames()
                      ]
                    }
                  ),
                  this.renderEmbeddables()
                ]
              }
            ) }) }) })
          }
        ) }) })
      }
    );
  }
  focusContainer = () => {
    this.excalidrawContainerRef.current?.focus();
  };
  getSceneElementsIncludingDeleted = () => {
    return this.scene.getElementsIncludingDeleted();
  };
  getSceneElements = () => {
    return this.scene.getNonDeletedElements();
  };
  onInsertElements = (elements) => {
    this.addElementsFromPasteOrLibrary({
      elements,
      position: "center",
      files: null
    });
  };
  onExportImage = async (type, elements, opts) => {
    trackEvent("export", type, "ui");
    const fileHandle = await exportCanvas(
      type,
      elements,
      this.state,
      this.files,
      {
        exportBackground: this.state.exportBackground,
        name: this.getName(),
        viewBackgroundColor: this.state.viewBackgroundColor,
        exportingFrame: opts.exportingFrame
      }
    ).catch(muteFSAbortError).catch((error) => {
      console.error(error);
      this.setState({ errorMessage: error.message });
    });
    if (this.state.exportEmbedScene && fileHandle && isImageFileHandle(fileHandle)) {
      this.setState({ fileHandle });
    }
  };
  magicGenerations = /* @__PURE__ */ new Map();
  updateMagicGeneration = ({
    frameElement,
    data
  }) => {
    if (data.status === "pending") {
      mutateElement(
        frameElement,
        { customData: { generationData: void 0 } },
        false
      );
    } else {
      mutateElement(
        frameElement,
        { customData: { generationData: data } },
        false
      );
    }
    this.magicGenerations.set(frameElement.id, data);
    this.triggerRender();
  };
  plugins = {};
  setPlugins(plugins) {
    Object.assign(this.plugins, plugins);
  }
  async onMagicFrameGenerate(magicFrame, source) {
    const generateDiagramToCode = this.plugins.diagramToCode?.generate;
    if (!generateDiagramToCode) {
      this.setState({
        errorMessage: "No diagram to code plugin found"
      });
      return;
    }
    const magicFrameChildren = getElementsOverlappingFrame(
      this.scene.getNonDeletedElements(),
      magicFrame
    ).filter((el) => !isMagicFrameElement(el));
    if (!magicFrameChildren.length) {
      if (source === "button") {
        this.setState({ errorMessage: "Cannot generate from an empty frame" });
        trackEvent("ai", "generate (no-children)", "d2c");
      } else {
        this.setActiveTool({ type: "magicframe" });
      }
      return;
    }
    const frameElement = this.insertIframeElement({
      sceneX: magicFrame.x + magicFrame.width + 30,
      sceneY: magicFrame.y,
      width: magicFrame.width,
      height: magicFrame.height
    });
    if (!frameElement) {
      return;
    }
    this.updateMagicGeneration({
      frameElement,
      data: { status: "pending" }
    });
    this.setState({
      selectedElementIds: { [frameElement.id]: true }
    });
    trackEvent("ai", "generate (start)", "d2c");
    try {
      const { html } = await generateDiagramToCode({
        frame: magicFrame,
        children: magicFrameChildren
      });
      trackEvent("ai", "generate (success)", "d2c");
      if (!html.trim()) {
        this.updateMagicGeneration({
          frameElement,
          data: {
            status: "error",
            code: "ERR_OAI",
            message: "Nothing genereated :("
          }
        });
        return;
      }
      const parsedHtml = html.includes("<!DOCTYPE html>") && html.includes("</html>") ? html.slice(
        html.indexOf("<!DOCTYPE html>"),
        html.indexOf("</html>") + "</html>".length
      ) : html;
      this.updateMagicGeneration({
        frameElement,
        data: { status: "done", html: parsedHtml }
      });
    } catch (error) {
      trackEvent("ai", "generate (failed)", "d2c");
      this.updateMagicGeneration({
        frameElement,
        data: {
          status: "error",
          code: "ERR_OAI",
          message: error.message || "Unknown error during generation"
        }
      });
    }
  }
  onIframeSrcCopy(element) {
    if (element.customData?.generationData?.status === "done") {
      copyTextToSystemClipboard(element.customData.generationData.html);
      this.setToast({
        message: "copied to clipboard",
        closable: false,
        duration: 1500
      });
    }
  }
  onMagicframeToolSelect = () => {
    const selectedElements = this.scene.getSelectedElements({
      selectedElementIds: this.state.selectedElementIds
    });
    if (selectedElements.length === 0) {
      this.setActiveTool({ type: TOOL_TYPE.magicframe });
      trackEvent("ai", "tool-select (empty-selection)", "d2c");
    } else {
      const selectedMagicFrame = selectedElements.length === 1 && isMagicFrameElement(selectedElements[0]) && selectedElements[0];
      if (!selectedMagicFrame && selectedElements.some((el) => isFrameLikeElement(el) || el.frameId)) {
        this.setActiveTool({ type: TOOL_TYPE.magicframe });
        return;
      }
      trackEvent("ai", "tool-select (existing selection)", "d2c");
      let frame;
      if (selectedMagicFrame) {
        frame = selectedMagicFrame;
      } else {
        const [minX, minY, maxX, maxY] = getCommonBounds(selectedElements);
        const padding = 50;
        frame = newMagicFrameElement({
          ...FRAME_STYLE,
          x: minX - padding,
          y: minY - padding,
          width: maxX - minX + padding * 2,
          height: maxY - minY + padding * 2,
          opacity: 100,
          locked: false
        });
        this.scene.insertElement(frame);
        for (const child of selectedElements) {
          mutateElement(child, { frameId: frame.id });
        }
        this.setState({
          selectedElementIds: { [frame.id]: true }
        });
      }
      this.onMagicFrameGenerate(frame, "upstream");
    }
  };
  openEyeDropper = ({ type }) => {
    jotaiStore.set(activeEyeDropperAtom, {
      swapPreviewOnAlt: true,
      colorPickerType: type === "stroke" ? "elementStroke" : "elementBackground",
      onSelect: (color, event) => {
        const shouldUpdateStrokeColor = type === "background" && event.altKey || type === "stroke" && !event.altKey;
        const selectedElements = this.scene.getSelectedElements(this.state);
        if (!selectedElements.length || this.state.activeTool.type !== "selection") {
          if (shouldUpdateStrokeColor) {
            this.syncActionResult({
              appState: { ...this.state, currentItemStrokeColor: color },
              storeAction: StoreAction.CAPTURE
            });
          } else {
            this.syncActionResult({
              appState: { ...this.state, currentItemBackgroundColor: color },
              storeAction: StoreAction.CAPTURE
            });
          }
        } else {
          this.updateScene({
            elements: this.scene.getElementsIncludingDeleted().map((el) => {
              if (this.state.selectedElementIds[el.id]) {
                return newElementWith(el, {
                  [shouldUpdateStrokeColor ? "strokeColor" : "backgroundColor"]: color
                });
              }
              return el;
            }),
            storeAction: StoreAction.CAPTURE
          });
        }
      },
      keepOpenOnAlt: false
    });
  };
  dismissLinearEditor = () => {
    setTimeout(() => {
      this.setState({
        editingLinearElement: null
      });
    });
  };
  syncActionResult = withBatchedUpdates((actionResult) => {
    if (this.unmounted || actionResult === false) {
      return;
    }
    if (actionResult.storeAction === StoreAction.UPDATE) {
      this.store.shouldUpdateSnapshot();
    } else if (actionResult.storeAction === StoreAction.CAPTURE) {
      this.store.shouldCaptureIncrement();
    }
    let didUpdate = false;
    let editingTextElement = null;
    if (actionResult.elements) {
      this.scene.replaceAllElements(actionResult.elements);
      didUpdate = true;
    }
    if (actionResult.files) {
      this.files = actionResult.replaceFiles ? actionResult.files : { ...this.files, ...actionResult.files };
      this.addNewImagesToImageCache();
    }
    if (actionResult.appState || editingTextElement || this.state.contextMenu) {
      let viewModeEnabled = actionResult?.appState?.viewModeEnabled || false;
      let zenModeEnabled = actionResult?.appState?.zenModeEnabled || false;
      const theme = actionResult?.appState?.theme || this.props.theme || THEME.LIGHT;
      const name = actionResult?.appState?.name ?? this.state.name;
      const errorMessage = actionResult?.appState?.errorMessage ?? this.state.errorMessage;
      if (typeof this.props.viewModeEnabled !== "undefined") {
        viewModeEnabled = this.props.viewModeEnabled;
      }
      if (typeof this.props.zenModeEnabled !== "undefined") {
        zenModeEnabled = this.props.zenModeEnabled;
      }
      editingTextElement = actionResult.appState?.editingTextElement || null;
      if (actionResult.elements && editingTextElement) {
        actionResult.elements.forEach((element) => {
          if (editingTextElement?.id === element.id && editingTextElement !== element && isNonDeletedElement(element) && isTextElement(element)) {
            editingTextElement = element;
          }
        });
      }
      if (editingTextElement?.isDeleted) {
        editingTextElement = null;
      }
      this.setState((state) => {
        return Object.assign(actionResult.appState || {}, {
          // NOTE this will prevent opening context menu using an action
          // or programmatically from the host, so it will need to be
          // rewritten later
          contextMenu: null,
          editingTextElement,
          viewModeEnabled,
          zenModeEnabled,
          theme,
          name,
          errorMessage
        });
      });
      didUpdate = true;
    }
    if (!didUpdate && actionResult.storeAction !== StoreAction.NONE) {
      this.scene.triggerUpdate();
    }
  });
  // Lifecycle
  onBlur = withBatchedUpdates(() => {
    isHoldingSpace = false;
    this.setState({ isBindingEnabled: true });
  });
  onUnload = () => {
    this.onBlur();
  };
  disableEvent = (event) => {
    event.preventDefault();
  };
  resetHistory = () => {
    this.history.clear();
  };
  resetStore = () => {
    this.store.clear();
  };
  /**
   * Resets scene & history.
   * ! Do not use to clear scene user action !
   */
  resetScene = withBatchedUpdates(
    (opts) => {
      this.scene.replaceAllElements([]);
      this.setState((state) => ({
        ...getDefaultAppState(),
        isLoading: opts?.resetLoadingState ? false : state.isLoading,
        theme: this.state.theme
      }));
      this.resetStore();
      this.resetHistory();
    }
  );
  initializeScene = async () => {
    if ("launchQueue" in window && "LaunchParams" in window) {
      window.launchQueue.setConsumer(
        async (launchParams) => {
          if (!launchParams.files.length) {
            return;
          }
          const fileHandle = launchParams.files[0];
          const blob = await fileHandle.getFile();
          this.loadFileToCanvas(
            new File([blob], blob.name || "", { type: blob.type }),
            fileHandle
          );
        }
      );
    }
    if (this.props.theme) {
      this.setState({ theme: this.props.theme });
    }
    if (!this.state.isLoading) {
      this.setState({ isLoading: true });
    }
    let initialData = null;
    try {
      if (typeof this.props.initialData === "function") {
        initialData = await this.props.initialData() || null;
      } else {
        initialData = await this.props.initialData || null;
      }
      if (initialData?.libraryItems) {
        this.library.updateLibrary({
          libraryItems: initialData.libraryItems,
          merge: true
        }).catch((error) => {
          console.error(error);
        });
      }
    } catch (error) {
      console.error(error);
      initialData = {
        appState: {
          errorMessage: error.message || "Encountered an error during importing or restoring scene data"
        }
      };
    }
    const scene = restore(initialData, null, null, { repairBindings: true });
    scene.appState = {
      ...scene.appState,
      theme: this.props.theme || scene.appState.theme,
      // we're falling back to current (pre-init) state when deciding
      // whether to open the library, to handle a case where we
      // update the state outside of initialData (e.g. when loading the app
      // with a library install link, which should auto-open the library)
      openSidebar: scene.appState?.openSidebar || this.state.openSidebar,
      activeTool: scene.appState.activeTool.type === "image" ? { ...scene.appState.activeTool, type: "selection" } : scene.appState.activeTool,
      isLoading: false,
      toast: this.state.toast
    };
    if (initialData?.scrollToContent) {
      scene.appState = {
        ...scene.appState,
        ...calculateScrollCenter(scene.elements, {
          ...scene.appState,
          width: this.state.width,
          height: this.state.height,
          offsetTop: this.state.offsetTop,
          offsetLeft: this.state.offsetLeft
        })
      };
    }
    this.resetStore();
    this.resetHistory();
    this.syncActionResult({
      ...scene,
      storeAction: StoreAction.UPDATE
    });
    this.clearImageShapeCache();
    this.fonts.loadSceneFonts();
  };
  isMobileBreakpoint = (width, height) => {
    return width < MQ_MAX_WIDTH_PORTRAIT || height < MQ_MAX_HEIGHT_LANDSCAPE && width < MQ_MAX_WIDTH_LANDSCAPE;
  };
  refreshViewportBreakpoints = () => {
    const container = this.excalidrawContainerRef.current;
    if (!container) {
      return;
    }
    const { clientWidth: viewportWidth, clientHeight: viewportHeight } = document.body;
    const prevViewportState = this.device.viewport;
    const nextViewportState = updateObject(prevViewportState, {
      isLandscape: viewportWidth > viewportHeight,
      isMobile: this.isMobileBreakpoint(viewportWidth, viewportHeight)
    });
    if (prevViewportState !== nextViewportState) {
      this.device = { ...this.device, viewport: nextViewportState };
      return true;
    }
    return false;
  };
  refreshEditorBreakpoints = () => {
    const container = this.excalidrawContainerRef.current;
    if (!container) {
      return;
    }
    const { width: editorWidth, height: editorHeight } = container.getBoundingClientRect();
    const sidebarBreakpoint = this.props.UIOptions.dockedSidebarBreakpoint != null ? this.props.UIOptions.dockedSidebarBreakpoint : MQ_RIGHT_SIDEBAR_MIN_WIDTH;
    const prevEditorState = this.device.editor;
    const nextEditorState = updateObject(prevEditorState, {
      isMobile: this.isMobileBreakpoint(editorWidth, editorHeight),
      canFitSidebar: editorWidth > sidebarBreakpoint
    });
    if (prevEditorState !== nextEditorState) {
      this.device = { ...this.device, editor: nextEditorState };
      return true;
    }
    return false;
  };
  clearImageShapeCache(filesMap) {
    const files = filesMap ?? this.files;
    this.scene.getNonDeletedElements().forEach((element) => {
      if (isInitializedImageElement(element) && files[element.fileId]) {
        this.imageCache.delete(element.fileId);
        ShapeCache.delete(element);
      }
    });
  }
  async componentDidMount() {
    this.unmounted = false;
    this.excalidrawContainerValue.container = this.excalidrawContainerRef.current;
    if (define_import_meta_env_default.MODE === ENV.TEST || define_import_meta_env_default.DEV) {
      const setState = this.setState.bind(this);
      Object.defineProperties(window.h, {
        state: {
          configurable: true,
          get: () => {
            return this.state;
          }
        },
        setState: {
          configurable: true,
          value: (...args) => {
            return this.setState(...args);
          }
        },
        app: {
          configurable: true,
          value: this
        },
        history: {
          configurable: true,
          value: this.history
        },
        store: {
          configurable: true,
          value: this.store
        },
        fonts: {
          configurable: true,
          value: this.fonts
        }
      });
    }
    this.store.onStoreIncrementEmitter.on((increment) => {
      this.history.record(increment.elementsChange, increment.appStateChange);
    });
    this.scene.onUpdate(this.triggerRender);
    this.addEventListeners();
    if (this.props.autoFocus && this.excalidrawContainerRef.current) {
      this.focusContainer();
    }
    if (
      // bounding rects don't work in tests so updating
      // the state on init would result in making the test enviro run
      // in mobile breakpoint (0 width/height), making everything fail
      !isTestEnv()
    ) {
      this.refreshViewportBreakpoints();
      this.refreshEditorBreakpoints();
    }
    if (supportsResizeObserver && this.excalidrawContainerRef.current) {
      this.resizeObserver = new ResizeObserver(() => {
        this.refreshEditorBreakpoints();
        this.updateDOMRect();
      });
      this.resizeObserver?.observe(this.excalidrawContainerRef.current);
    }
    const searchParams = new URLSearchParams(window.location.search.slice(1));
    if (searchParams.has("web-share-target")) {
      this.restoreFileFromShare();
    } else {
      this.updateDOMRect(this.initializeScene);
    }
    if (isBrave() && !isMeasureTextSupported()) {
      this.setState({
        errorMessage: /* @__PURE__ */ (0, import_jsx_runtime146.jsx)(BraveMeasureTextError_default, {})
      });
    }
  }
  componentWillUnmount() {
    window.launchQueue?.setConsumer(() => {
    });
    this.renderer.destroy();
    this.scene.destroy();
    this.scene = new Scene_default();
    this.fonts = new Fonts({ scene: this.scene });
    this.renderer = new Renderer(this.scene);
    this.files = {};
    this.imageCache.clear();
    this.resizeObserver?.disconnect();
    this.unmounted = true;
    this.removeEventListeners();
    this.library.destroy();
    this.laserTrails.stop();
    this.eraserTrail.stop();
    this.onChangeEmitter.clear();
    this.store.onStoreIncrementEmitter.clear();
    ShapeCache.destroy();
    SnapCache.destroy();
    clearTimeout(touchTimeout);
    isSomeElementSelected.clearCache();
    selectGroupsForSelectedElements.clearCache();
    touchTimeout = 0;
    document.documentElement.style.overscrollBehaviorX = "";
  }
  onResize = withBatchedUpdates(() => {
    this.scene.getElementsIncludingDeleted().forEach((element) => ShapeCache.delete(element));
    this.refreshViewportBreakpoints();
    this.updateDOMRect();
    if (!supportsResizeObserver) {
      this.refreshEditorBreakpoints();
    }
    this.setState({});
  });
  /** generally invoked only if fullscreen was invoked programmatically */
  onFullscreenChange = () => {
    if (
      // points to the iframe element we fullscreened
      !document.fullscreenElement && this.state.activeEmbeddable?.state === "active"
    ) {
      this.setState({
        activeEmbeddable: null
      });
    }
  };
  removeEventListeners() {
    this.onRemoveEventListenersEmitter.trigger();
  }
  addEventListeners() {
    this.removeEventListeners();
    if (this.props.handleKeyboardGlobally) {
      this.onRemoveEventListenersEmitter.once(
        addEventListener(document, "keydown" /* KEYDOWN */, this.onKeyDown, false)
      );
    }
    this.onRemoveEventListenersEmitter.once(
      addEventListener(
        this.excalidrawContainerRef.current,
        "wheel" /* WHEEL */,
        this.handleWheel,
        { passive: false }
      ),
      addEventListener(window, "message" /* MESSAGE */, this.onWindowMessage, false),
      addEventListener(document, "pointerup" /* POINTER_UP */, this.removePointer),
      // #3553
      addEventListener(document, "copy" /* COPY */, this.onCopy),
      addEventListener(document, "keyup" /* KEYUP */, this.onKeyUp, { passive: true }),
      addEventListener(
        document,
        "pointermove" /* POINTER_MOVE */,
        this.updateCurrentCursorPosition
      ),
      // rerender text elements on font load to fix #637 && #1553
      addEventListener(document.fonts, "loadingdone", (event) => {
        const loadedFontFaces = event.fontfaces;
        this.fonts.onLoaded(loadedFontFaces);
      }),
      // Safari-only desktop pinch zoom
      addEventListener(
        document,
        "gesturestart" /* GESTURE_START */,
        this.onGestureStart,
        false
      ),
      addEventListener(
        document,
        "gesturechange" /* GESTURE_CHANGE */,
        this.onGestureChange,
        false
      ),
      addEventListener(
        document,
        "gestureend" /* GESTURE_END */,
        this.onGestureEnd,
        false
      ),
      addEventListener(window, "focus" /* FOCUS */, () => {
        this.maybeCleanupAfterMissingPointerUp(null);
        this.triggerRender(true);
      })
    );
    if (this.state.viewModeEnabled) {
      return;
    }
    this.onRemoveEventListenersEmitter.once(
      addEventListener(
        document,
        "fullscreenchange" /* FULLSCREENCHANGE */,
        this.onFullscreenChange
      ),
      addEventListener(document, "paste" /* PASTE */, this.pasteFromClipboard),
      addEventListener(document, "cut" /* CUT */, this.onCut),
      addEventListener(window, "resize" /* RESIZE */, this.onResize, false),
      addEventListener(window, "unload" /* UNLOAD */, this.onUnload, false),
      addEventListener(window, "blur" /* BLUR */, this.onBlur, false),
      addEventListener(
        this.excalidrawContainerRef.current,
        "wheel" /* WHEEL */,
        this.handleWheel
      ),
      addEventListener(
        this.excalidrawContainerRef.current,
        "dragover" /* DRAG_OVER */,
        this.disableEvent,
        false
      ),
      addEventListener(
        this.excalidrawContainerRef.current,
        "drop" /* DROP */,
        this.disableEvent,
        false
      )
    );
    if (this.props.detectScroll) {
      this.onRemoveEventListenersEmitter.once(
        addEventListener(
          getNearestScrollableContainer(this.excalidrawContainerRef.current),
          "scroll" /* SCROLL */,
          this.onScroll
        )
      );
    }
  }
  componentDidUpdate(prevProps, prevState) {
    this.updateEmbeddables();
    const elements = this.scene.getElementsIncludingDeleted();
    const elementsMap = this.scene.getElementsMapIncludingDeleted();
    const nonDeletedElementsMap = this.scene.getNonDeletedElementsMap();
    if (!this.state.showWelcomeScreen && !elements.length) {
      this.setState({ showWelcomeScreen: true });
    }
    if (prevProps.UIOptions.dockedSidebarBreakpoint !== this.props.UIOptions.dockedSidebarBreakpoint) {
      this.refreshEditorBreakpoints();
    }
    const hasFollowedPersonLeft = prevState.userToFollow && !this.state.collaborators.has(prevState.userToFollow.socketId);
    if (hasFollowedPersonLeft) {
      this.maybeUnfollowRemoteUser();
    }
    if (prevState.zoom.value !== this.state.zoom.value || prevState.scrollX !== this.state.scrollX || prevState.scrollY !== this.state.scrollY) {
      this.props?.onScrollChange?.(
        this.state.scrollX,
        this.state.scrollY,
        this.state.zoom
      );
      this.onScrollChangeEmitter.trigger(
        this.state.scrollX,
        this.state.scrollY,
        this.state.zoom
      );
    }
    if (prevState.userToFollow !== this.state.userToFollow) {
      if (prevState.userToFollow) {
        this.onUserFollowEmitter.trigger({
          userToFollow: prevState.userToFollow,
          action: "UNFOLLOW"
        });
      }
      if (this.state.userToFollow) {
        this.onUserFollowEmitter.trigger({
          userToFollow: this.state.userToFollow,
          action: "FOLLOW"
        });
      }
    }
    if (Object.keys(this.state.selectedElementIds).length && isEraserActive(this.state)) {
      this.setState({
        activeTool: updateActiveTool(this.state, { type: "selection" })
      });
    }
    if (this.state.activeTool.type === "eraser" && prevState.theme !== this.state.theme) {
      setEraserCursor(this.interactiveCanvas, this.state.theme);
    }
    if (prevState.activeTool.type === "selection" && this.state.activeTool.type !== "selection" && this.state.showHyperlinkPopup) {
      this.setState({ showHyperlinkPopup: false });
    }
    if (prevProps.langCode !== this.props.langCode) {
      this.updateLanguage();
    }
    if (isEraserActive(prevState) && !isEraserActive(this.state)) {
      this.eraserTrail.endPath();
    }
    if (prevProps.viewModeEnabled !== this.props.viewModeEnabled) {
      this.setState({ viewModeEnabled: !!this.props.viewModeEnabled });
    }
    if (prevState.viewModeEnabled !== this.state.viewModeEnabled) {
      this.addEventListeners();
      this.deselectElements();
    }
    if (prevProps.zenModeEnabled !== this.props.zenModeEnabled) {
      this.setState({ zenModeEnabled: !!this.props.zenModeEnabled });
    }
    if (prevProps.theme !== this.props.theme && this.props.theme) {
      this.setState({ theme: this.props.theme });
    }
    this.excalidrawContainerRef.current?.classList.toggle(
      "theme--dark",
      this.state.theme === THEME.DARK
    );
    if (this.state.editingLinearElement && !this.state.selectedElementIds[this.state.editingLinearElement.elementId]) {
      setTimeout(() => {
        this.state.editingLinearElement && this.actionManager.executeAction(actionFinalize);
      });
    }
    if (this.state.editingTextElement?.isDeleted) {
      this.setState({ editingTextElement: null });
    }
    if (this.state.selectedLinearElement && !this.state.selectedElementIds[this.state.selectedLinearElement.elementId]) {
      this.setState({ selectedLinearElement: null });
    }
    const { multiElement } = prevState;
    if (prevState.activeTool !== this.state.activeTool && multiElement != null && isBindingEnabled(this.state) && isBindingElement(multiElement, false)) {
      maybeBindLinearElement(
        multiElement,
        this.state,
        tupleToCoors(
          LinearElementEditor.getPointAtIndexGlobalCoordinates(
            multiElement,
            -1,
            nonDeletedElementsMap
          )
        ),
        this.scene.getNonDeletedElementsMap(),
        this.scene.getNonDeletedElements()
      );
    }
    this.store.commit(elementsMap, this.state);
    if (!this.state.isLoading) {
      this.props.onChange?.(elements, this.state, this.files);
      this.onChangeEmitter.trigger(elements, this.state, this.files);
    }
  }
  renderInteractiveSceneCallback = ({
    atLeastOneVisibleElement,
    scrollBars,
    elementsMap
  }) => {
    if (scrollBars) {
      currentScrollBars = scrollBars;
    }
    const scrolledOutside = (
      // hide when editing text
      this.state.editingTextElement ? false : !atLeastOneVisibleElement && elementsMap.size > 0
    );
    if (this.state.scrolledOutside !== scrolledOutside) {
      this.setState({ scrolledOutside });
    }
    this.scheduleImageRefresh();
  };
  onScroll = debounce(() => {
    const { offsetTop, offsetLeft } = this.getCanvasOffsets();
    this.setState((state) => {
      if (state.offsetLeft === offsetLeft && state.offsetTop === offsetTop) {
        return null;
      }
      return { offsetTop, offsetLeft };
    });
  }, SCROLL_TIMEOUT);
  // Copy/paste
  onCut = withBatchedUpdates((event) => {
    const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(
      document.activeElement
    );
    if (!isExcalidrawActive || isWritableElement(event.target)) {
      return;
    }
    this.actionManager.executeAction(actionCut, "keyboard", event);
    event.preventDefault();
    event.stopPropagation();
  });
  onCopy = withBatchedUpdates((event) => {
    const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(
      document.activeElement
    );
    if (!isExcalidrawActive || isWritableElement(event.target)) {
      return;
    }
    this.actionManager.executeAction(actionCopy, "keyboard", event);
    event.preventDefault();
    event.stopPropagation();
  });
  static resetTapTwice() {
    didTapTwice = false;
  }
  onTouchStart = (event) => {
    if (isIOS) {
      event.preventDefault();
    }
    if (!didTapTwice) {
      didTapTwice = true;
      clearTimeout(tappedTwiceTimer);
      tappedTwiceTimer = window.setTimeout(
        _App.resetTapTwice,
        TAP_TWICE_TIMEOUT
      );
      return;
    }
    if (didTapTwice && event.touches.length === 1) {
      const touch = event.touches[0];
      this.handleCanvasDoubleClick({
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      didTapTwice = false;
      clearTimeout(tappedTwiceTimer);
    }
    if (event.touches.length === 2) {
      this.setState({
        selectedElementIds: makeNextSelectedElementIds({}, this.state),
        activeEmbeddable: null
      });
    }
  };
  onTouchEnd = (event) => {
    this.resetContextMenuTimer();
    if (event.touches.length > 0) {
      this.setState({
        previousSelectedElementIds: {},
        selectedElementIds: makeNextSelectedElementIds(
          this.state.previousSelectedElementIds,
          this.state
        )
      });
    } else {
      gesture.pointers.clear();
    }
  };
  pasteFromClipboard = withBatchedUpdates(
    async (event) => {
      const isPlainPaste = !!IS_PLAIN_PASTE;
      const target = document.activeElement;
      const isExcalidrawActive = this.excalidrawContainerRef.current?.contains(target);
      if (event && !isExcalidrawActive) {
        return;
      }
      const elementUnderCursor = document.elementFromPoint(
        this.lastViewportPosition.x,
        this.lastViewportPosition.y
      );
      if (event && (!(elementUnderCursor instanceof HTMLCanvasElement) || isWritableElement(target))) {
        return;
      }
      const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(
        {
          clientX: this.lastViewportPosition.x,
          clientY: this.lastViewportPosition.y
        },
        this.state
      );
      let file = event?.clipboardData?.files[0];
      const data = await parseClipboard(event, isPlainPaste);
      if (!file && !isPlainPaste) {
        if (data.mixedContent) {
          return this.addElementsFromMixedContentPaste(data.mixedContent, {
            isPlainPaste,
            sceneX,
            sceneY
          });
        } else if (data.text) {
          const string = data.text.trim();
          if (string.startsWith("<svg") && string.endsWith("</svg>")) {
            file = SVGStringToFile(string);
          }
        }
      }
      if (isSupportedImageFile(file) && !data.spreadsheet) {
        if (!this.isToolSupported("image")) {
          this.setState({ errorMessage: t("errors.imageToolNotSupported") });
          return;
        }
        const imageElement = this.createImageElement({ sceneX, sceneY });
        this.insertImageElement(imageElement, file);
        this.initializeImageDimensions(imageElement);
        this.setState({
          selectedElementIds: makeNextSelectedElementIds(
            {
              [imageElement.id]: true
            },
            this.state
          )
        });
        return;
      }
      if (this.props.onPaste) {
        try {
          if (await this.props.onPaste(data, event) === false) {
            return;
          }
        } catch (error) {
          console.error(error);
        }
      }
      if (data.errorMessage) {
        this.setState({ errorMessage: data.errorMessage });
      } else if (data.spreadsheet && !isPlainPaste) {
        this.setState({
          pasteDialog: {
            data: data.spreadsheet,
            shown: true
          }
        });
      } else if (data.elements) {
        const elements = data.programmaticAPI ? convertToExcalidrawElements(
          data.elements
        ) : data.elements;
        this.addElementsFromPasteOrLibrary({
          elements,
          files: data.files || null,
          position: "cursor",
          retainSeed: isPlainPaste
        });
      } else if (data.text) {
        if (data.text && isMaybeMermaidDefinition(data.text)) {
          const api = await import("./excalidraw-assets-dev/dist-YRQVIX7L.js");
          try {
            const { elements: skeletonElements, files } = await api.parseMermaidToExcalidraw(data.text);
            const elements = convertToExcalidrawElements(skeletonElements, {
              regenerateIds: true
            });
            this.addElementsFromPasteOrLibrary({
              elements,
              files,
              position: "cursor"
            });
            return;
          } catch (err) {
            console.warn(
              `parsing pasted text as mermaid definition failed: ${err.message}`
            );
          }
        }
        const nonEmptyLines = normalizeEOL(data.text).split(/\n+/).map((s3) => s3.trim()).filter(Boolean);
        const embbeddableUrls = nonEmptyLines.map((str) => maybeParseEmbedSrc(str)).filter((string) => {
          return embeddableURLValidator(string, this.props.validateEmbeddable) && (/^(http|https):\/\/[^\s/$.?#].[^\s]*$/.test(string) || getEmbedLink(string)?.type === "video");
        });
        if (!IS_PLAIN_PASTE && embbeddableUrls.length > 0 && // if there were non-embeddable text (lines) mixed in with embeddable
        // urls, ignore and paste as text
        embbeddableUrls.length === nonEmptyLines.length) {
          const embeddables = [];
          for (const url of embbeddableUrls) {
            const prevEmbeddable = embeddables[embeddables.length - 1];
            const embeddable = this.insertEmbeddableElement({
              sceneX: prevEmbeddable ? prevEmbeddable.x + prevEmbeddable.width + 20 : sceneX,
              sceneY,
              link: normalizeLink(url)
            });
            if (embeddable) {
              embeddables.push(embeddable);
            }
          }
          if (embeddables.length) {
            this.setState({
              selectedElementIds: Object.fromEntries(
                embeddables.map((embeddable) => [embeddable.id, true])
              )
            });
          }
          return;
        }
        this.addTextFromPaste(data.text, isPlainPaste);
      }
      this.setActiveTool({ type: "selection" });
      event?.preventDefault();
    }
  );
  addElementsFromPasteOrLibrary = (opts) => {
    let elements = opts.elements.map((el, _, elements2) => {
      if (isElbowArrow(el)) {
        const startEndElements = [
          el.startBinding && elements2.find((l3) => l3.id === el.startBinding?.elementId),
          el.endBinding && elements2.find((l3) => l3.id === el.endBinding?.elementId)
        ];
        const startBinding = startEndElements[0] ? el.startBinding : null;
        const endBinding = startEndElements[1] ? el.endBinding : null;
        return {
          ...el,
          ...updateElbowArrow(
            {
              ...el,
              startBinding,
              endBinding
            },
            toBrandedType(
              new Map(
                startEndElements.filter((x4) => x4 != null).map(
                  (el2) => [el2.id, el2]
                )
              )
            ),
            [el.points[0], el.points[el.points.length - 1]]
          )
        };
      }
      return el;
    });
    elements = restoreElements(elements, null, void 0);
    const [minX, minY, maxX, maxY] = getCommonBounds(elements);
    const elementsCenterX = distance(minX, maxX) / 2;
    const elementsCenterY = distance(minY, maxY) / 2;
    const clientX = typeof opts.position === "object" ? opts.position.clientX : opts.position === "cursor" ? this.lastViewportPosition.x : this.state.width / 2 + this.state.offsetLeft;
    const clientY = typeof opts.position === "object" ? opts.position.clientY : opts.position === "cursor" ? this.lastViewportPosition.y : this.state.height / 2 + this.state.offsetTop;
    const { x: x3, y: y3 } = viewportCoordsToSceneCoords(
      { clientX, clientY },
      this.state
    );
    const dx = x3 - elementsCenterX;
    const dy = y3 - elementsCenterY;
    const [gridX, gridY] = getGridPoint(dx, dy, this.getEffectiveGridSize());
    const newElements = duplicateElements(
      elements.map((element) => {
        return newElementWith(element, {
          x: element.x + gridX - minX,
          y: element.y + gridY - minY
        });
      }),
      {
        randomizeSeed: !opts.retainSeed
      }
    );
    const prevElements = this.scene.getElementsIncludingDeleted();
    const nextElements = [...prevElements, ...newElements];
    syncMovedIndices(nextElements, arrayToMap(newElements));
    const topLayerFrame = this.getTopLayerFrameAtSceneCoords({ x: x3, y: y3 });
    if (topLayerFrame) {
      const eligibleElements = filterElementsEligibleAsFrameChildren(
        newElements,
        topLayerFrame
      );
      addElementsToFrame(nextElements, eligibleElements, topLayerFrame);
    }
    this.scene.replaceAllElements(nextElements);
    newElements.forEach((newElement2) => {
      if (isTextElement(newElement2) && isBoundToContainer(newElement2)) {
        const container = getContainerElement(
          newElement2,
          this.scene.getElementsMapIncludingDeleted()
        );
        redrawTextBoundingBox(
          newElement2,
          container,
          this.scene.getElementsMapIncludingDeleted()
        );
      }
    });
    if (opts.files) {
      this.files = { ...this.files, ...opts.files };
    }
    this.store.shouldCaptureIncrement();
    const nextElementsToSelect = excludeElementsInFramesFromSelection(newElements);
    this.setState(
      {
        ...this.state,
        // keep sidebar (presumably the library) open if it's docked and
        // can fit.
        //
        // Note, we should close the sidebar only if we're dropping items
        // from library, not when pasting from clipboard. Alas.
        openSidebar: this.state.openSidebar && this.device.editor.canFitSidebar && jotaiStore.get(isSidebarDockedAtom) ? this.state.openSidebar : null,
        ...selectGroupsForSelectedElements(
          {
            editingGroupId: null,
            selectedElementIds: nextElementsToSelect.reduce(
              (acc, element) => {
                if (!isBoundToContainer(element)) {
                  acc[element.id] = true;
                }
                return acc;
              },
              {}
            )
          },
          this.scene.getNonDeletedElements(),
          this.state,
          this
        )
      },
      () => {
        if (opts.files) {
          this.addNewImagesToImageCache();
        }
      }
    );
    this.setActiveTool({ type: "selection" });
    if (opts.fitToContent) {
      this.scrollToContent(newElements, {
        fitToContent: true,
        canvasOffsets: this.getEditorUIOffsets()
      });
    }
  };
  // TODO rewrite this to paste both text & images at the same time if
  // pasted data contains both
  async addElementsFromMixedContentPaste(mixedContent, {
    isPlainPaste,
    sceneX,
    sceneY
  }) {
    if (!isPlainPaste && mixedContent.some((node) => node.type === "imageUrl") && this.isToolSupported("image")) {
      const imageURLs = mixedContent.filter((node) => node.type === "imageUrl").map((node) => node.value);
      const responses = await Promise.all(
        imageURLs.map(async (url) => {
          try {
            return { file: await ImageURLToFile(url) };
          } catch (error2) {
            let errorMessage = error2.message;
            if (error2.cause === "FETCH_ERROR") {
              errorMessage = t("errors.failedToFetchImage");
            } else if (error2.cause === "UNSUPPORTED") {
              errorMessage = t("errors.unsupportedFileType");
            }
            return { errorMessage };
          }
        })
      );
      let y3 = sceneY;
      let firstImageYOffsetDone = false;
      const nextSelectedIds = {};
      for (const response of responses) {
        if (response.file) {
          const imageElement = this.createImageElement({
            sceneX,
            sceneY: y3
          });
          const initializedImageElement = await this.insertImageElement(
            imageElement,
            response.file
          );
          if (initializedImageElement) {
            if (!firstImageYOffsetDone) {
              firstImageYOffsetDone = true;
              y3 -= initializedImageElement.height / 2;
            }
            mutateElement(initializedImageElement, { y: y3 }, false);
            y3 = imageElement.y + imageElement.height + 25;
            nextSelectedIds[imageElement.id] = true;
          }
        }
      }
      this.setState({
        selectedElementIds: makeNextSelectedElementIds(
          nextSelectedIds,
          this.state
        )
      });
      const error = responses.find((response) => !!response.errorMessage);
      if (error && error.errorMessage) {
        this.setState({ errorMessage: error.errorMessage });
      }
    } else {
      const textNodes = mixedContent.filter((node) => node.type === "text");
      if (textNodes.length) {
        this.addTextFromPaste(
          textNodes.map((node) => node.value).join("\n\n"),
          isPlainPaste
        );
      }
    }
  }
  addTextFromPaste(text, isPlainPaste = false) {
    const { x: x3, y: y3 } = viewportCoordsToSceneCoords(
      {
        clientX: this.lastViewportPosition.x,
        clientY: this.lastViewportPosition.y
      },
      this.state
    );
    const textElementProps = {
      x: x3,
      y: y3,
      strokeColor: this.state.currentItemStrokeColor,
      backgroundColor: this.state.currentItemBackgroundColor,
      fillStyle: this.state.currentItemFillStyle,
      strokeWidth: this.state.currentItemStrokeWidth,
      strokeStyle: this.state.currentItemStrokeStyle,
      roundness: null,
      roughness: this.state.currentItemRoughness,
      opacity: this.state.currentItemOpacity,
      text,
      fontSize: this.state.currentItemFontSize,
      fontFamily: this.state.currentItemFontFamily,
      textAlign: DEFAULT_TEXT_ALIGN,
      verticalAlign: DEFAULT_VERTICAL_ALIGN,
      locked: false
    };
    const fontString = getFontString({
      fontSize: textElementProps.fontSize,
      fontFamily: textElementProps.fontFamily
    });
    const lineHeight = getLineHeight(textElementProps.fontFamily);
    const [x1, , x22] = getVisibleSceneBounds(this.state);
    const maxTextWidth = Math.max(Math.min((x22 - x1) * 0.5, 800), 200);
    const LINE_GAP = 10;
    let currentY = y3;
    const lines = isPlainPaste ? [text] : text.split("\n");
    const textElements = lines.reduce(
      (acc, line, idx) => {
        const originalText = normalizeText(line).trim();
        if (originalText.length) {
          const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
            x: x3,
            y: currentY
          });
          let metrics = measureText(originalText, fontString, lineHeight);
          const isTextUnwrapped = metrics.width > maxTextWidth;
          const text2 = isTextUnwrapped ? wrapText(originalText, fontString, maxTextWidth) : originalText;
          metrics = isTextUnwrapped ? measureText(text2, fontString, lineHeight) : metrics;
          const startX = x3 - metrics.width / 2;
          const startY = currentY - metrics.height / 2;
          const element = newTextElement({
            ...textElementProps,
            x: startX,
            y: startY,
            text: text2,
            originalText,
            lineHeight,
            autoResize: !isTextUnwrapped,
            frameId: topLayerFrame ? topLayerFrame.id : null
          });
          acc.push(element);
          currentY += element.height + LINE_GAP;
        } else {
          const prevLine = lines[idx - 1]?.trim();
          if (prevLine) {
            currentY += getLineHeightInPx(textElementProps.fontSize, lineHeight) + LINE_GAP;
          }
        }
        return acc;
      },
      []
    );
    if (textElements.length === 0) {
      return;
    }
    this.scene.insertElements(textElements);
    this.setState({
      selectedElementIds: makeNextSelectedElementIds(
        Object.fromEntries(textElements.map((el) => [el.id, true])),
        this.state
      )
    });
    if (!isPlainPaste && textElements.length > 1 && PLAIN_PASTE_TOAST_SHOWN === false && !this.device.editor.isMobile) {
      this.setToast({
        message: t("toast.pasteAsSingleElement", {
          shortcut: getShortcutKey("CtrlOrCmd+Shift+V")
        }),
        duration: 5e3
      });
      PLAIN_PASTE_TOAST_SHOWN = true;
    }
    this.store.shouldCaptureIncrement();
  }
  setAppState = (state, callback) => {
    this.setState(state, callback);
  };
  removePointer = (event) => {
    if (touchTimeout) {
      this.resetContextMenuTimer();
    }
    gesture.pointers.delete(event.pointerId);
  };
  toggleLock = (source = "ui") => {
    if (!this.state.activeTool.locked) {
      trackEvent(
        "toolbar",
        "toggleLock",
        `${source} (${this.device.editor.isMobile ? "mobile" : "desktop"})`
      );
    }
    this.setState((prevState) => {
      return {
        activeTool: {
          ...prevState.activeTool,
          ...updateActiveTool(
            this.state,
            prevState.activeTool.locked ? { type: "selection" } : prevState.activeTool
          ),
          locked: !prevState.activeTool.locked
        }
      };
    });
  };
  updateFrameRendering = (opts) => {
    this.setState((prevState) => {
      const next = typeof opts === "function" ? opts(prevState.frameRendering) : opts;
      return {
        frameRendering: {
          enabled: next?.enabled ?? prevState.frameRendering.enabled,
          clip: next?.clip ?? prevState.frameRendering.clip,
          name: next?.name ?? prevState.frameRendering.name,
          outline: next?.outline ?? prevState.frameRendering.outline
        }
      };
    });
  };
  togglePenMode = (force) => {
    this.setState((prevState) => {
      return {
        penMode: force ?? !prevState.penMode,
        penDetected: true
      };
    });
  };
  onHandToolToggle = () => {
    this.actionManager.executeAction(actionToggleHandTool);
  };
  /**
   * Zooms on canvas viewport center
   */
  zoomCanvas = (value) => {
    this.setState({
      ...getStateForZoom(
        {
          viewportX: this.state.width / 2 + this.state.offsetLeft,
          viewportY: this.state.height / 2 + this.state.offsetTop,
          nextZoom: getNormalizedZoom(value)
        },
        this.state
      )
    });
  };
  cancelInProgressAnimation = null;
  scrollToContent = (target = this.scene.getNonDeletedElements(), opts) => {
    this.cancelInProgressAnimation?.();
    const targetElements = Array.isArray(target) ? target : [target];
    let zoom = this.state.zoom;
    let scrollX = this.state.scrollX;
    let scrollY = this.state.scrollY;
    if (opts?.fitToContent || opts?.fitToViewport) {
      const { appState } = zoomToFit({
        canvasOffsets: opts.canvasOffsets,
        targetElements,
        appState: this.state,
        fitToViewport: !!opts?.fitToViewport,
        viewportZoomFactor: opts?.viewportZoomFactor,
        minZoom: opts?.minZoom,
        maxZoom: opts?.maxZoom
      });
      zoom = appState.zoom;
      scrollX = appState.scrollX;
      scrollY = appState.scrollY;
    } else {
      const scroll = calculateScrollCenter(targetElements, this.state);
      scrollX = scroll.scrollX;
      scrollY = scroll.scrollY;
    }
    if (opts?.animate) {
      const origScrollX = this.state.scrollX;
      const origScrollY = this.state.scrollY;
      const origZoom = this.state.zoom.value;
      const cancel = easeToValuesRAF({
        fromValues: {
          scrollX: origScrollX,
          scrollY: origScrollY,
          zoom: origZoom
        },
        toValues: { scrollX, scrollY, zoom: zoom.value },
        interpolateValue: (from, to, progress, key) => {
          if (key === "zoom") {
            return from * Math.pow(to / from, easeOut(progress));
          }
          return void 0;
        },
        onStep: ({ scrollX: scrollX2, scrollY: scrollY2, zoom: zoom2 }) => {
          this.setState({
            scrollX: scrollX2,
            scrollY: scrollY2,
            zoom: { value: zoom2 }
          });
        },
        onStart: () => {
          this.setState({ shouldCacheIgnoreZoom: true });
        },
        onEnd: () => {
          this.setState({ shouldCacheIgnoreZoom: false });
        },
        onCancel: () => {
          this.setState({ shouldCacheIgnoreZoom: false });
        },
        duration: opts?.duration ?? 500
      });
      this.cancelInProgressAnimation = () => {
        cancel();
        this.cancelInProgressAnimation = null;
      };
    } else {
      this.setState({ scrollX, scrollY, zoom });
    }
  };
  maybeUnfollowRemoteUser = () => {
    if (this.state.userToFollow) {
      this.setState({ userToFollow: null });
    }
  };
  /** use when changing scrollX/scrollY/zoom based on user interaction */
  translateCanvas = (state) => {
    this.cancelInProgressAnimation?.();
    this.maybeUnfollowRemoteUser();
    this.setState(state);
  };
  setToast = (toast) => {
    this.setState({ toast });
  };
  restoreFileFromShare = async () => {
    try {
      const webShareTargetCache = await caches.open("web-share-target");
      const response = await webShareTargetCache.match("shared-file");
      if (response) {
        const blob = await response.blob();
        const file = new File([blob], blob.name || "", { type: blob.type });
        this.loadFileToCanvas(file, null);
        await webShareTargetCache.delete("shared-file");
        window.history.replaceState(null, APP_NAME, window.location.pathname);
      }
    } catch (error) {
      this.setState({ errorMessage: error.message });
    }
  };
  /** adds supplied files to existing files in the appState */
  addFiles = withBatchedUpdates(
    (files) => {
      const filesMap = files.reduce((acc, fileData) => {
        acc.set(fileData.id, fileData);
        return acc;
      }, /* @__PURE__ */ new Map());
      this.files = { ...this.files, ...Object.fromEntries(filesMap) };
      this.clearImageShapeCache(Object.fromEntries(filesMap));
      this.scene.triggerUpdate();
      this.addNewImagesToImageCache();
    }
  );
  updateScene = withBatchedUpdates(
    (sceneData) => {
      const nextElements = syncInvalidIndices(sceneData.elements ?? []);
      if (sceneData.storeAction && sceneData.storeAction !== StoreAction.NONE) {
        const prevCommittedAppState = this.store.snapshot.appState;
        const prevCommittedElements = this.store.snapshot.elements;
        const nextCommittedAppState = sceneData.appState ? Object.assign({}, prevCommittedAppState, sceneData.appState) : prevCommittedAppState;
        const nextCommittedElements = sceneData.elements ? this.store.filterUncomittedElements(
          this.scene.getElementsMapIncludingDeleted(),
          // Only used to detect uncomitted local elements
          arrayToMap(nextElements)
          // We expect all (already reconciled) elements
        ) : prevCommittedElements;
        if (sceneData.storeAction === StoreAction.CAPTURE) {
          this.store.captureIncrement(
            nextCommittedElements,
            nextCommittedAppState
          );
        } else if (sceneData.storeAction === StoreAction.UPDATE) {
          this.store.updateSnapshot(
            nextCommittedElements,
            nextCommittedAppState
          );
        }
      }
      if (sceneData.appState) {
        this.setState(sceneData.appState);
      }
      if (sceneData.elements) {
        this.scene.replaceAllElements(nextElements);
      }
      if (sceneData.collaborators) {
        this.setState({ collaborators: sceneData.collaborators });
      }
    }
  );
  triggerRender = (force) => {
    if (force === true) {
      this.scene.triggerUpdate();
    } else {
      this.setState({});
    }
  };
  /**
   * @returns whether the menu was toggled on or off
   */
  toggleSidebar = ({
    name,
    tab,
    force
  }) => {
    let nextName;
    if (force === void 0) {
      nextName = this.state.openSidebar?.name === name && this.state.openSidebar?.tab === tab ? null : name;
    } else {
      nextName = force ? name : null;
    }
    const nextState = nextName ? { name: nextName } : null;
    if (nextState && tab) {
      nextState.tab = tab;
    }
    this.setState({ openSidebar: nextState });
    return !!nextName;
  };
  updateCurrentCursorPosition = withBatchedUpdates(
    (event) => {
      this.lastViewportPosition.x = event.clientX;
      this.lastViewportPosition.y = event.clientY;
    }
  );
  getEditorUIOffsets = () => {
    const toolbarBottom = this.excalidrawContainerRef?.current?.querySelector(".App-toolbar")?.getBoundingClientRect()?.bottom ?? 0;
    const sidebarRect = this.excalidrawContainerRef?.current?.querySelector(".sidebar")?.getBoundingClientRect();
    const propertiesPanelRect = this.excalidrawContainerRef?.current?.querySelector(".App-menu__left")?.getBoundingClientRect();
    const PADDING = 16;
    return getLanguage().rtl ? {
      top: toolbarBottom + PADDING,
      right: Math.max(
        this.state.width - (propertiesPanelRect?.left ?? this.state.width),
        0
      ) + PADDING,
      bottom: PADDING,
      left: Math.max(sidebarRect?.right ?? 0, 0) + PADDING
    } : {
      top: toolbarBottom + PADDING,
      right: Math.max(
        this.state.width - (sidebarRect?.left ?? this.state.width) + PADDING,
        0
      ),
      bottom: PADDING,
      left: Math.max(propertiesPanelRect?.right ?? 0, 0) + PADDING
    };
  };
  // Input handling
  onKeyDown = withBatchedUpdates(
    (event) => {
      if ("Proxy" in window && (!event.shiftKey && /^[A-Z]$/.test(event.key) || event.shiftKey && /^[a-z]$/.test(event.key))) {
        event = new Proxy(event, {
          get(ev, prop) {
            const value = ev[prop];
            if (typeof value === "function") {
              return value.bind(ev);
            }
            return prop === "key" ? (
              // CapsLock inverts capitalization based on ShiftKey, so invert
              // it back
              event.shiftKey ? ev.key.toUpperCase() : ev.key.toLowerCase()
            ) : value;
          }
        });
      }
      if (!isInputLike(event.target)) {
        if (event.key === KEYS.ESCAPE && this.flowChartCreator.isCreatingChart) {
          this.flowChartCreator.clear();
          this.triggerRender(true);
          return;
        }
        const arrowKeyPressed = isArrowKey(event.key);
        if (event[KEYS.CTRL_OR_CMD] && arrowKeyPressed && !event.shiftKey) {
          event.preventDefault();
          const selectedElements = getSelectedElements(
            this.scene.getNonDeletedElementsMap(),
            this.state
          );
          if (selectedElements.length === 1 && isFlowchartNodeElement(selectedElements[0])) {
            this.flowChartCreator.createNodes(
              selectedElements[0],
              this.scene.getNonDeletedElementsMap(),
              this.state,
              getLinkDirectionFromKey(event.key)
            );
          }
          if (this.flowChartCreator.pendingNodes?.length && !isElementCompletelyInViewport(
            this.flowChartCreator.pendingNodes,
            this.canvas.width / window.devicePixelRatio,
            this.canvas.height / window.devicePixelRatio,
            {
              offsetLeft: this.state.offsetLeft,
              offsetTop: this.state.offsetTop,
              scrollX: this.state.scrollX,
              scrollY: this.state.scrollY,
              zoom: this.state.zoom
            },
            this.scene.getNonDeletedElementsMap(),
            this.getEditorUIOffsets()
          )) {
            this.scrollToContent(this.flowChartCreator.pendingNodes, {
              animate: true,
              duration: 300,
              fitToContent: true,
              canvasOffsets: this.getEditorUIOffsets()
            });
          }
          return;
        }
        if (event.altKey) {
          const selectedElements = getSelectedElements(
            this.scene.getNonDeletedElementsMap(),
            this.state
          );
          if (selectedElements.length === 1 && arrowKeyPressed) {
            event.preventDefault();
            const nextId = this.flowChartNavigator.exploreByDirection(
              selectedElements[0],
              this.scene.getNonDeletedElementsMap(),
              getLinkDirectionFromKey(event.key)
            );
            if (nextId) {
              this.setState((prevState) => ({
                selectedElementIds: makeNextSelectedElementIds(
                  {
                    [nextId]: true
                  },
                  prevState
                )
              }));
              const nextNode = this.scene.getNonDeletedElementsMap().get(nextId);
              if (nextNode && !isElementCompletelyInViewport(
                [nextNode],
                this.canvas.width / window.devicePixelRatio,
                this.canvas.height / window.devicePixelRatio,
                {
                  offsetLeft: this.state.offsetLeft,
                  offsetTop: this.state.offsetTop,
                  scrollX: this.state.scrollX,
                  scrollY: this.state.scrollY,
                  zoom: this.state.zoom
                },
                this.scene.getNonDeletedElementsMap(),
                this.getEditorUIOffsets()
              )) {
                this.scrollToContent(nextNode, {
                  animate: true,
                  duration: 300,
                  canvasOffsets: this.getEditorUIOffsets()
                });
              }
            }
            return;
          }
        }
      }
      if (event[KEYS.CTRL_OR_CMD] && event.key === KEYS.P && !event.shiftKey && !event.altKey) {
        this.setToast({
          message: t("commandPalette.shortcutHint", {
            shortcut: getShortcutFromShortcutName("commandPalette")
          })
        });
        event.preventDefault();
        return;
      }
      if (event[KEYS.CTRL_OR_CMD] && event.key.toLowerCase() === KEYS.V) {
        IS_PLAIN_PASTE = event.shiftKey;
        clearTimeout(IS_PLAIN_PASTE_TIMER);
        IS_PLAIN_PASTE_TIMER = window.setTimeout(() => {
          IS_PLAIN_PASTE = false;
        }, 100);
      }
      if (event[KEYS.CTRL_OR_CMD] && isWritableElement(event.target)) {
        if (event.code === CODES.MINUS || event.code === CODES.EQUAL) {
          event.preventDefault();
          return;
        }
      }
      if (
        // inside an input
        isWritableElement(event.target) && // unless pressing escape (finalize action)
        event.key !== KEYS.ESCAPE || // or unless using arrows (to move between buttons)
        isArrowKey(event.key) && isInputLike(event.target)
      ) {
        return;
      }
      if (event.key === KEYS.QUESTION_MARK) {
        this.setState({
          openDialog: { name: "help" }
        });
        return;
      } else if (event.key.toLowerCase() === KEYS.E && event.shiftKey && event[KEYS.CTRL_OR_CMD]) {
        event.preventDefault();
        this.setState({ openDialog: { name: "imageExport" } });
        return;
      }
      if (event.key === KEYS.PAGE_UP || event.key === KEYS.PAGE_DOWN) {
        let offset = (event.shiftKey ? this.state.width : this.state.height) / this.state.zoom.value;
        if (event.key === KEYS.PAGE_DOWN) {
          offset = -offset;
        }
        if (event.shiftKey) {
          this.translateCanvas((state) => ({
            scrollX: state.scrollX + offset
          }));
        } else {
          this.translateCanvas((state) => ({
            scrollY: state.scrollY + offset
          }));
        }
      }
      if (this.actionManager.handleKeyDown(event)) {
        return;
      }
      if (this.state.viewModeEnabled) {
        return;
      }
      if (event[KEYS.CTRL_OR_CMD] && this.state.isBindingEnabled) {
        this.setState({ isBindingEnabled: false });
      }
      if (isArrowKey(event.key)) {
        let selectedElements = this.scene.getSelectedElements({
          selectedElementIds: this.state.selectedElementIds,
          includeBoundTextElement: true,
          includeElementsInFrames: true
        });
        const elbowArrow = selectedElements.find(isElbowArrow);
        const arrowIdsToRemove = /* @__PURE__ */ new Set();
        selectedElements.filter(isElbowArrow).filter((arrow2) => {
          const startElementNotInSelection = arrow2.startBinding && !selectedElements.some(
            (el) => el.id === arrow2.startBinding?.elementId
          );
          const endElementNotInSelection = arrow2.endBinding && !selectedElements.some(
            (el) => el.id === arrow2.endBinding?.elementId
          );
          return startElementNotInSelection || endElementNotInSelection;
        }).forEach((arrow2) => arrowIdsToRemove.add(arrow2.id));
        selectedElements = selectedElements.filter(
          (el) => !arrowIdsToRemove.has(el.id)
        );
        const step = this.getEffectiveGridSize() && (event.shiftKey ? ELEMENT_TRANSLATE_AMOUNT : this.getEffectiveGridSize()) || (event.shiftKey ? ELEMENT_SHIFT_TRANSLATE_AMOUNT : ELEMENT_TRANSLATE_AMOUNT);
        let offsetX = 0;
        let offsetY = 0;
        if (event.key === KEYS.ARROW_LEFT) {
          offsetX = -step;
        } else if (event.key === KEYS.ARROW_RIGHT) {
          offsetX = step;
        } else if (event.key === KEYS.ARROW_UP) {
          offsetY = -step;
        } else if (event.key === KEYS.ARROW_DOWN) {
          offsetY = step;
        }
        selectedElements.forEach((element) => {
          mutateElement(element, {
            x: element.x + offsetX,
            y: element.y + offsetY
          });
          updateBoundElements(element, this.scene.getNonDeletedElementsMap(), {
            simultaneouslyUpdated: selectedElements
          });
        });
        this.setState({
          suggestedBindings: getSuggestedBindingsForArrows(
            selectedElements.filter(
              (element) => element.id !== elbowArrow?.id || step !== 0
            ),
            this.scene.getNonDeletedElementsMap()
          )
        });
        event.preventDefault();
      } else if (event.key === KEYS.ENTER) {
        const selectedElements = this.scene.getSelectedElements(this.state);
        if (selectedElements.length === 1) {
          const selectedElement = selectedElements[0];
          if (event[KEYS.CTRL_OR_CMD]) {
            if (isLinearElement(selectedElement)) {
              if (!this.state.editingLinearElement || this.state.editingLinearElement.elementId !== selectedElements[0].id) {
                this.store.shouldCaptureIncrement();
                if (!isElbowArrow(selectedElement)) {
                  this.setState({
                    editingLinearElement: new LinearElementEditor(
                      selectedElement
                    )
                  });
                }
              }
            }
          } else if (isTextElement(selectedElement) || isValidTextContainer(selectedElement)) {
            let container;
            if (!isTextElement(selectedElement)) {
              container = selectedElement;
            }
            const midPoint = getContainerCenter(
              selectedElement,
              this.state,
              this.scene.getNonDeletedElementsMap()
            );
            const sceneX = midPoint.x;
            const sceneY = midPoint.y;
            this.startTextEditing({
              sceneX,
              sceneY,
              container
            });
            event.preventDefault();
            return;
          } else if (isFrameLikeElement(selectedElement)) {
            this.setState({
              editingFrame: selectedElement.id
            });
          }
        }
      } else if (!event.ctrlKey && !event.altKey && !event.metaKey && !this.state.newElement && !this.state.selectionElement && !this.state.selectedElementsAreBeingDragged) {
        const shape = findShapeByKey(event.key);
        if (shape) {
          if (this.state.activeTool.type !== shape) {
            trackEvent(
              "toolbar",
              shape,
              `keyboard (${this.device.editor.isMobile ? "mobile" : "desktop"})`
            );
          }
          if (shape === "arrow" && this.state.activeTool.type === "arrow") {
            this.setState((prevState) => ({
              currentItemArrowType: prevState.currentItemArrowType === ARROW_TYPE.sharp ? ARROW_TYPE.round : prevState.currentItemArrowType === ARROW_TYPE.round ? ARROW_TYPE.elbow : ARROW_TYPE.sharp
            }));
          }
          this.setActiveTool({ type: shape });
          event.stopPropagation();
        } else if (event.key === KEYS.Q) {
          this.toggleLock("keyboard");
          event.stopPropagation();
        }
      }
      if (event.key === KEYS.SPACE && gesture.pointers.size === 0) {
        isHoldingSpace = true;
        setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);
        event.preventDefault();
      }
      if ((event.key === KEYS.G || event.key === KEYS.S) && !event.altKey && !event[KEYS.CTRL_OR_CMD]) {
        const selectedElements = this.scene.getSelectedElements(this.state);
        if (this.state.activeTool.type === "selection" && !selectedElements.length) {
          return;
        }
        if (event.key === KEYS.G && (hasBackground(this.state.activeTool.type) || selectedElements.some((element) => hasBackground(element.type)))) {
          this.setState({ openPopup: "elementBackground" });
          event.stopPropagation();
        }
        if (event.key === KEYS.S) {
          this.setState({ openPopup: "elementStroke" });
          event.stopPropagation();
        }
      }
      if (!event[KEYS.CTRL_OR_CMD] && event.shiftKey && event.key.toLowerCase() === KEYS.F) {
        const selectedElements = this.scene.getSelectedElements(this.state);
        if (this.state.activeTool.type === "selection" && !selectedElements.length) {
          return;
        }
        if (this.state.activeTool.type === "text" || selectedElements.find(
          (element) => isTextElement(element) || getBoundTextElement(
            element,
            this.scene.getNonDeletedElementsMap()
          )
        )) {
          event.preventDefault();
          this.setState({ openPopup: "fontFamily" });
        }
      }
      if (event.key === KEYS.K && !event.altKey && !event[KEYS.CTRL_OR_CMD]) {
        if (this.state.activeTool.type === "laser") {
          this.setActiveTool({ type: "selection" });
        } else {
          this.setActiveTool({ type: "laser" });
        }
        return;
      }
      if (event[KEYS.CTRL_OR_CMD] && (event.key === KEYS.BACKSPACE || event.key === KEYS.DELETE)) {
        jotaiStore.set(activeConfirmDialogAtom, "clearCanvas");
      }
      const lowerCased = event.key.toLocaleLowerCase();
      const isPickingStroke = lowerCased === KEYS.S && event.shiftKey;
      const isPickingBackground = event.key === KEYS.I || lowerCased === KEYS.G && event.shiftKey;
      if (isPickingStroke || isPickingBackground) {
        this.openEyeDropper({
          type: isPickingStroke ? "stroke" : "background"
        });
      }
    }
  );
  onKeyUp = withBatchedUpdates((event) => {
    if (event.key === KEYS.SPACE) {
      if (this.state.viewModeEnabled) {
        setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);
      } else if (this.state.activeTool.type === "selection") {
        resetCursor(this.interactiveCanvas);
      } else {
        setCursorForShape(this.interactiveCanvas, this.state);
        this.setState({
          selectedElementIds: makeNextSelectedElementIds({}, this.state),
          selectedGroupIds: {},
          editingGroupId: null,
          activeEmbeddable: null
        });
      }
      isHoldingSpace = false;
    }
    if (!event[KEYS.CTRL_OR_CMD] && !this.state.isBindingEnabled) {
      this.setState({ isBindingEnabled: true });
    }
    if (isArrowKey(event.key)) {
      bindOrUnbindLinearElements(
        this.scene.getSelectedElements(this.state).filter(isLinearElement),
        this.scene.getNonDeletedElementsMap(),
        this.scene.getNonDeletedElements(),
        this.scene,
        isBindingEnabled(this.state),
        this.state.selectedLinearElement?.selectedPointsIndices ?? []
      );
      this.setState({ suggestedBindings: [] });
    }
    if (!event.altKey) {
      if (this.flowChartNavigator.isExploring) {
        this.flowChartNavigator.clear();
        this.syncActionResult({ storeAction: StoreAction.CAPTURE });
      }
    }
    if (!event[KEYS.CTRL_OR_CMD]) {
      if (this.flowChartCreator.isCreatingChart) {
        if (this.flowChartCreator.pendingNodes?.length) {
          this.scene.insertElements(this.flowChartCreator.pendingNodes);
        }
        const firstNode = this.flowChartCreator.pendingNodes?.[0];
        if (firstNode) {
          this.setState((prevState) => ({
            selectedElementIds: makeNextSelectedElementIds(
              {
                [firstNode.id]: true
              },
              prevState
            )
          }));
          if (!isElementCompletelyInViewport(
            [firstNode],
            this.canvas.width / window.devicePixelRatio,
            this.canvas.height / window.devicePixelRatio,
            {
              offsetLeft: this.state.offsetLeft,
              offsetTop: this.state.offsetTop,
              scrollX: this.state.scrollX,
              scrollY: this.state.scrollY,
              zoom: this.state.zoom
            },
            this.scene.getNonDeletedElementsMap(),
            this.getEditorUIOffsets()
          )) {
            this.scrollToContent(firstNode, {
              animate: true,
              duration: 300,
              canvasOffsets: this.getEditorUIOffsets()
            });
          }
        }
        this.flowChartCreator.clear();
        this.syncActionResult({ storeAction: StoreAction.CAPTURE });
      }
    }
  });
  // We purposely widen the `tool` type so this helper can be called with
  // any tool without having to type check it
  isToolSupported = (tool) => {
    return this.props.UIOptions.tools?.[tool] !== false;
  };
  setActiveTool = (tool) => {
    if (!this.isToolSupported(tool.type)) {
      console.warn(
        `"${tool.type}" tool is disabled via "UIOptions.canvasActions.tools.${tool.type}"`
      );
      return;
    }
    const nextActiveTool = updateActiveTool(this.state, tool);
    if (nextActiveTool.type === "hand") {
      setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);
    } else if (!isHoldingSpace) {
      setCursorForShape(this.interactiveCanvas, this.state);
    }
    if (isToolIcon(document.activeElement)) {
      this.focusContainer();
    }
    if (!isLinearElementType(nextActiveTool.type)) {
      this.setState({ suggestedBindings: [] });
    }
    if (nextActiveTool.type === "image") {
      this.onImageAction({
        insertOnCanvasDirectly: (tool.type === "image" && tool.insertOnCanvasDirectly) ?? false
      });
    }
    this.setState((prevState) => {
      const commonResets = {
        snapLines: prevState.snapLines.length ? [] : prevState.snapLines,
        originSnapOffset: null,
        activeEmbeddable: null
      };
      if (nextActiveTool.type === "freedraw") {
        this.store.shouldCaptureIncrement();
      }
      if (nextActiveTool.type !== "selection") {
        return {
          ...prevState,
          activeTool: nextActiveTool,
          selectedElementIds: makeNextSelectedElementIds({}, prevState),
          selectedGroupIds: makeNextSelectedElementIds({}, prevState),
          editingGroupId: null,
          multiElement: null,
          ...commonResets
        };
      }
      return {
        ...prevState,
        activeTool: nextActiveTool,
        ...commonResets
      };
    });
  };
  setOpenDialog = (dialogType) => {
    this.setState({ openDialog: dialogType });
  };
  setCursor = (cursor) => {
    setCursor(this.interactiveCanvas, cursor);
  };
  resetCursor = () => {
    resetCursor(this.interactiveCanvas);
  };
  /**
   * returns whether user is making a gesture with >= 2 fingers (points)
   * on o touch screen (not on a trackpad). Currently only relates to Darwin
   * (iOS/iPadOS,MacOS), but may work on other devices in the future if
   * GestureEvent is standardized.
   */
  isTouchScreenMultiTouchGesture = () => {
    return gesture.pointers.size >= 2;
  };
  getName = () => {
    return this.state.name || this.props.name || `${t("labels.untitled")}-${getDateTime()}`;
  };
  // fires only on Safari
  onGestureStart = withBatchedUpdates((event) => {
    event.preventDefault();
    if (this.isTouchScreenMultiTouchGesture()) {
      this.setState({
        selectedElementIds: makeNextSelectedElementIds({}, this.state),
        activeEmbeddable: null
      });
    }
    gesture.initialScale = this.state.zoom.value;
  });
  // fires only on Safari
  onGestureChange = withBatchedUpdates((event) => {
    event.preventDefault();
    if (this.isTouchScreenMultiTouchGesture()) {
      return;
    }
    const initialScale = gesture.initialScale;
    if (initialScale) {
      this.setState((state) => ({
        ...getStateForZoom(
          {
            viewportX: this.lastViewportPosition.x,
            viewportY: this.lastViewportPosition.y,
            nextZoom: getNormalizedZoom(initialScale * event.scale)
          },
          state
        )
      }));
    }
  });
  // fires only on Safari
  onGestureEnd = withBatchedUpdates((event) => {
    event.preventDefault();
    if (this.isTouchScreenMultiTouchGesture()) {
      this.setState({
        previousSelectedElementIds: {},
        selectedElementIds: makeNextSelectedElementIds(
          this.state.previousSelectedElementIds,
          this.state
        )
      });
    }
    gesture.initialScale = null;
  });
  handleTextWysiwyg(element, {
    isExistingElement = false
  }) {
    const elementsMap = this.scene.getElementsMapIncludingDeleted();
    const updateElement = (nextOriginalText, isDeleted) => {
      this.scene.replaceAllElements([
        // Not sure why we include deleted elements as well hence using deleted elements map
        ...this.scene.getElementsIncludingDeleted().map((_element) => {
          if (_element.id === element.id && isTextElement(_element)) {
            return newElementWith(_element, {
              originalText: nextOriginalText,
              isDeleted: isDeleted ?? _element.isDeleted,
              // returns (wrapped) text and new dimensions
              ...refreshTextDimensions(
                _element,
                getContainerElement(_element, elementsMap),
                elementsMap,
                nextOriginalText
              )
            });
          }
          return _element;
        })
      ]);
    };
    textWysiwyg({
      id: element.id,
      canvas: this.canvas,
      getViewportCoords: (x3, y3) => {
        const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(
          {
            sceneX: x3,
            sceneY: y3
          },
          this.state
        );
        return [
          viewportX - this.state.offsetLeft,
          viewportY - this.state.offsetTop
        ];
      },
      onChange: withBatchedUpdates((nextOriginalText) => {
        updateElement(nextOriginalText, false);
        if (isNonDeletedElement(element)) {
          updateBoundElements(element, this.scene.getNonDeletedElementsMap());
        }
      }),
      onSubmit: withBatchedUpdates(({ viaKeyboard, nextOriginalText }) => {
        const isDeleted = !nextOriginalText.trim();
        updateElement(nextOriginalText, isDeleted);
        if (!isDeleted && viaKeyboard) {
          const elementIdToSelect = element.containerId ? element.containerId : element.id;
          (0, import_react_dom9.flushSync)(() => {
            this.setState((prevState) => ({
              selectedElementIds: makeNextSelectedElementIds(
                {
                  ...prevState.selectedElementIds,
                  [elementIdToSelect]: true
                },
                prevState
              )
            }));
          });
        }
        if (isDeleted) {
          fixBindingsAfterDeletion(this.scene.getNonDeletedElements(), [
            element
          ]);
        }
        if (!isDeleted || isExistingElement) {
          this.store.shouldCaptureIncrement();
        }
        this.setState({
          newElement: null,
          editingTextElement: null
        });
        if (this.state.activeTool.locked) {
          setCursorForShape(this.interactiveCanvas, this.state);
        }
        this.focusContainer();
      }),
      element,
      excalidrawContainer: this.excalidrawContainerRef.current,
      app: this,
      // when text is selected, it's hard (at least on iOS) to re-position the
      // caret (i.e. deselect). There's not much use for always selecting
      // the text on edit anyway (and users can select-all from contextmenu
      // if needed)
      autoSelect: !this.device.isTouchScreen
    });
    this.deselectElements();
    updateElement(element.originalText, false);
  }
  deselectElements() {
    this.setState({
      selectedElementIds: makeNextSelectedElementIds({}, this.state),
      selectedGroupIds: {},
      editingGroupId: null,
      activeEmbeddable: null
    });
  }
  getTextElementAtPosition(x3, y3) {
    const element = this.getElementAtPosition(x3, y3, {
      includeBoundTextElement: true
    });
    if (element && isTextElement(element) && !element.isDeleted) {
      return element;
    }
    return null;
  }
  getElementAtPosition(x3, y3, opts) {
    const allHitElements = this.getElementsAtPosition(
      x3,
      y3,
      opts?.includeBoundTextElement,
      opts?.includeLockedElements
    );
    if (allHitElements.length > 1) {
      if (opts?.preferSelected) {
        for (let index2 = allHitElements.length - 1; index2 > -1; index2--) {
          if (this.state.selectedElementIds[allHitElements[index2].id]) {
            return allHitElements[index2];
          }
        }
      }
      const elementWithHighestZIndex = allHitElements[allHitElements.length - 1];
      return hitElementItself({
        x: x3,
        y: y3,
        element: elementWithHighestZIndex,
        shape: getElementShape(
          elementWithHighestZIndex,
          this.scene.getNonDeletedElementsMap()
        ),
        // when overlapping, we would like to be more precise
        // this also avoids the need to update past tests
        threshold: this.getElementHitThreshold() / 2,
        frameNameBound: isFrameLikeElement(elementWithHighestZIndex) ? this.frameNameBoundsCache.get(elementWithHighestZIndex) : null
      }) ? elementWithHighestZIndex : allHitElements[allHitElements.length - 2];
    }
    if (allHitElements.length === 1) {
      return allHitElements[0];
    }
    return null;
  }
  getElementsAtPosition(x3, y3, includeBoundTextElement = false, includeLockedElements = false) {
    const iframeLikes = [];
    const elementsMap = this.scene.getNonDeletedElementsMap();
    const elements = (includeBoundTextElement && includeLockedElements ? this.scene.getNonDeletedElements() : this.scene.getNonDeletedElements().filter(
      (element) => (includeLockedElements || !element.locked) && (includeBoundTextElement || !(isTextElement(element) && element.containerId))
    )).filter((el) => this.hitElement(x3, y3, el)).filter((element) => {
      const containingFrame = getContainingFrame(element, elementsMap);
      return containingFrame && this.state.frameRendering.enabled && this.state.frameRendering.clip ? isCursorInFrame({ x: x3, y: y3 }, containingFrame, elementsMap) : true;
    }).filter((el) => {
      if (isIframeElement(el)) {
        iframeLikes.push(el);
        return false;
      }
      return true;
    }).concat(iframeLikes);
    return elements;
  }
  getElementHitThreshold() {
    return DEFAULT_COLLISION_THRESHOLD / this.state.zoom.value;
  }
  hitElement(x3, y3, element, considerBoundingBox = true) {
    if (considerBoundingBox && this.state.selectedElementIds[element.id] && shouldShowBoundingBox([element], this.state)) {
      const selectionShape = getSelectionBoxShape(
        element,
        this.scene.getNonDeletedElementsMap(),
        this.getElementHitThreshold()
      );
      return isPointInShape(pointFrom(x3, y3), selectionShape);
    }
    const hitBoundTextOfElement = hitElementBoundText(
      x3,
      y3,
      getBoundTextShape(element, this.scene.getNonDeletedElementsMap())
    );
    if (hitBoundTextOfElement) {
      return true;
    }
    return hitElementItself({
      x: x3,
      y: y3,
      element,
      shape: getElementShape(element, this.scene.getNonDeletedElementsMap()),
      threshold: this.getElementHitThreshold(),
      frameNameBound: isFrameLikeElement(element) ? this.frameNameBoundsCache.get(element) : null
    });
  }
  getTextBindableContainerAtPosition(x3, y3) {
    const elements = this.scene.getNonDeletedElements();
    const selectedElements = this.scene.getSelectedElements(this.state);
    if (selectedElements.length === 1) {
      return isTextBindableContainer(selectedElements[0], false) ? selectedElements[0] : null;
    }
    let hitElement = null;
    for (let index2 = elements.length - 1; index2 >= 0; --index2) {
      if (elements[index2].isDeleted) {
        continue;
      }
      const [x1, y1, x22, y22] = getElementAbsoluteCoords(
        elements[index2],
        this.scene.getNonDeletedElementsMap()
      );
      if (isArrowElement(elements[index2]) && hitElementItself({
        x: x3,
        y: y3,
        element: elements[index2],
        shape: getElementShape(
          elements[index2],
          this.scene.getNonDeletedElementsMap()
        ),
        threshold: this.getElementHitThreshold()
      })) {
        hitElement = elements[index2];
        break;
      } else if (x1 < x3 && x3 < x22 && y1 < y3 && y3 < y22) {
        hitElement = elements[index2];
        break;
      }
    }
    return isTextBindableContainer(hitElement, false) ? hitElement : null;
  }
  startTextEditing = ({
    sceneX,
    sceneY,
    insertAtParentCenter = true,
    container,
    autoEdit = true
  }) => {
    let shouldBindToContainer = false;
    let parentCenterPosition = insertAtParentCenter && this.getTextWysiwygSnappedToCenterPosition(
      sceneX,
      sceneY,
      this.state,
      container
    );
    if (container && parentCenterPosition) {
      const boundTextElementToContainer = getBoundTextElement(
        container,
        this.scene.getNonDeletedElementsMap()
      );
      if (!boundTextElementToContainer) {
        shouldBindToContainer = true;
      }
    }
    let existingTextElement = null;
    const selectedElements = this.scene.getSelectedElements(this.state);
    if (selectedElements.length === 1) {
      if (isTextElement(selectedElements[0])) {
        existingTextElement = selectedElements[0];
      } else if (container) {
        existingTextElement = getBoundTextElement(
          selectedElements[0],
          this.scene.getNonDeletedElementsMap()
        );
      } else {
        existingTextElement = this.getTextElementAtPosition(sceneX, sceneY);
      }
    } else {
      existingTextElement = this.getTextElementAtPosition(sceneX, sceneY);
    }
    const fontFamily = existingTextElement?.fontFamily || this.state.currentItemFontFamily;
    const lineHeight = existingTextElement?.lineHeight || getLineHeight(fontFamily);
    const fontSize = this.state.currentItemFontSize;
    if (!existingTextElement && shouldBindToContainer && container && !isArrowElement(container)) {
      const fontString = {
        fontSize,
        fontFamily
      };
      const minWidth = getApproxMinLineWidth(
        getFontString(fontString),
        lineHeight
      );
      const minHeight = getApproxMinLineHeight(fontSize, lineHeight);
      const newHeight = Math.max(container.height, minHeight);
      const newWidth = Math.max(container.width, minWidth);
      mutateElement(container, { height: newHeight, width: newWidth });
      sceneX = container.x + newWidth / 2;
      sceneY = container.y + newHeight / 2;
      if (parentCenterPosition) {
        parentCenterPosition = this.getTextWysiwygSnappedToCenterPosition(
          sceneX,
          sceneY,
          this.state,
          container
        );
      }
    }
    const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
      x: sceneX,
      y: sceneY
    });
    const element = existingTextElement ? existingTextElement : newTextElement({
      x: parentCenterPosition ? parentCenterPosition.elementCenterX : sceneX,
      y: parentCenterPosition ? parentCenterPosition.elementCenterY : sceneY,
      strokeColor: this.state.currentItemStrokeColor,
      backgroundColor: this.state.currentItemBackgroundColor,
      fillStyle: this.state.currentItemFillStyle,
      strokeWidth: this.state.currentItemStrokeWidth,
      strokeStyle: this.state.currentItemStrokeStyle,
      roughness: this.state.currentItemRoughness,
      opacity: this.state.currentItemOpacity,
      text: "",
      fontSize,
      fontFamily,
      textAlign: parentCenterPosition ? "center" : this.state.currentItemTextAlign,
      verticalAlign: parentCenterPosition ? VERTICAL_ALIGN.MIDDLE : DEFAULT_VERTICAL_ALIGN,
      containerId: shouldBindToContainer ? container?.id : void 0,
      groupIds: container?.groupIds ?? [],
      lineHeight,
      angle: container?.angle ?? 0,
      frameId: topLayerFrame ? topLayerFrame.id : null
    });
    if (!existingTextElement && shouldBindToContainer && container) {
      mutateElement(container, {
        boundElements: (container.boundElements || []).concat({
          type: "text",
          id: element.id
        })
      });
    }
    this.setState({ editingTextElement: element });
    if (!existingTextElement) {
      if (container && shouldBindToContainer) {
        const containerIndex = this.scene.getElementIndex(container.id);
        this.scene.insertElementAtIndex(element, containerIndex + 1);
      } else {
        this.scene.insertElement(element);
      }
    }
    if (autoEdit || existingTextElement || container) {
      this.handleTextWysiwyg(element, {
        isExistingElement: !!existingTextElement
      });
    } else {
      this.setState({
        newElement: element,
        multiElement: null
      });
    }
  };
  handleCanvasDoubleClick = (event) => {
    if (this.state.multiElement) {
      return;
    }
    if (this.state.activeTool.type !== "selection") {
      return;
    }
    const selectedElements = this.scene.getSelectedElements(this.state);
    if (selectedElements.length === 1 && isLinearElement(selectedElements[0])) {
      if (event[KEYS.CTRL_OR_CMD] && (!this.state.editingLinearElement || this.state.editingLinearElement.elementId !== selectedElements[0].id) && !isElbowArrow(selectedElements[0])) {
        this.store.shouldCaptureIncrement();
        this.setState({
          editingLinearElement: new LinearElementEditor(selectedElements[0])
        });
        return;
      }
    }
    resetCursor(this.interactiveCanvas);
    let { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(
      event,
      this.state
    );
    const selectedGroupIds = getSelectedGroupIds(this.state);
    if (selectedGroupIds.length > 0) {
      const hitElement = this.getElementAtPosition(sceneX, sceneY);
      const selectedGroupId = hitElement && getSelectedGroupIdForElement(hitElement, this.state.selectedGroupIds);
      if (selectedGroupId) {
        this.store.shouldCaptureIncrement();
        this.setState((prevState) => ({
          ...prevState,
          ...selectGroupsForSelectedElements(
            {
              editingGroupId: selectedGroupId,
              selectedElementIds: { [hitElement.id]: true }
            },
            this.scene.getNonDeletedElements(),
            prevState,
            this
          )
        }));
        return;
      }
    }
    resetCursor(this.interactiveCanvas);
    if (!event[KEYS.CTRL_OR_CMD] && !this.state.viewModeEnabled) {
      const hitElement = this.getElementAtPosition(sceneX, sceneY);
      if (isIframeLikeElement(hitElement)) {
        this.setState({
          activeEmbeddable: { element: hitElement, state: "active" }
        });
        return;
      }
      const container = this.getTextBindableContainerAtPosition(sceneX, sceneY);
      if (container) {
        if (hasBoundTextElement(container) || !isTransparent(container.backgroundColor) || hitElementItself({
          x: sceneX,
          y: sceneY,
          element: container,
          shape: getElementShape(
            container,
            this.scene.getNonDeletedElementsMap()
          ),
          threshold: this.getElementHitThreshold()
        })) {
          const midPoint = getContainerCenter(
            container,
            this.state,
            this.scene.getNonDeletedElementsMap()
          );
          sceneX = midPoint.x;
          sceneY = midPoint.y;
        }
      }
      this.startTextEditing({
        sceneX,
        sceneY,
        insertAtParentCenter: !event.altKey,
        container
      });
    }
  };
  getElementLinkAtPosition = (scenePointer, hitElement) => {
    const elements = this.scene.getNonDeletedElements().slice().reverse();
    let hitElementIndex = Infinity;
    return elements.find((element, index2) => {
      if (hitElement && element.id === hitElement.id) {
        hitElementIndex = index2;
      }
      return element.link && index2 <= hitElementIndex && isPointHittingLink(
        element,
        this.scene.getNonDeletedElementsMap(),
        this.state,
        pointFrom(scenePointer.x, scenePointer.y),
        this.device.editor.isMobile
      );
    });
  };
  redirectToLink = (event, isTouchScreen) => {
    const draggedDistance = pointDistance(
      pointFrom(
        this.lastPointerDownEvent.clientX,
        this.lastPointerDownEvent.clientY
      ),
      pointFrom(
        this.lastPointerUpEvent.clientX,
        this.lastPointerUpEvent.clientY
      )
    );
    if (!this.hitLinkElement || // For touch screen allow dragging threshold else strict check
    isTouchScreen && draggedDistance > DRAGGING_THRESHOLD || !isTouchScreen && draggedDistance !== 0) {
      return;
    }
    const lastPointerDownCoords = viewportCoordsToSceneCoords(
      this.lastPointerDownEvent,
      this.state
    );
    const elementsMap = this.scene.getNonDeletedElementsMap();
    const lastPointerDownHittingLinkIcon = isPointHittingLink(
      this.hitLinkElement,
      elementsMap,
      this.state,
      pointFrom(lastPointerDownCoords.x, lastPointerDownCoords.y),
      this.device.editor.isMobile
    );
    const lastPointerUpCoords = viewportCoordsToSceneCoords(
      this.lastPointerUpEvent,
      this.state
    );
    const lastPointerUpHittingLinkIcon = isPointHittingLink(
      this.hitLinkElement,
      elementsMap,
      this.state,
      pointFrom(lastPointerUpCoords.x, lastPointerUpCoords.y),
      this.device.editor.isMobile
    );
    if (lastPointerDownHittingLinkIcon && lastPointerUpHittingLinkIcon) {
      let url = this.hitLinkElement.link;
      if (url) {
        url = normalizeLink(url);
        let customEvent;
        if (this.props.onLinkOpen) {
          customEvent = wrapEvent("excalidraw-link" /* EXCALIDRAW_LINK */, event.nativeEvent);
          this.props.onLinkOpen(
            {
              ...this.hitLinkElement,
              link: url
            },
            customEvent
          );
        }
        if (!customEvent?.defaultPrevented) {
          const target = isLocalLink(url) ? "_self" : "_blank";
          const newWindow = window.open(void 0, target);
          if (newWindow) {
            newWindow.opener = null;
            newWindow.location = url;
          }
        }
      }
    }
  };
  getTopLayerFrameAtSceneCoords = (sceneCoords) => {
    const elementsMap = this.scene.getNonDeletedElementsMap();
    const frames = this.scene.getNonDeletedFramesLikes().filter(
      (frame) => isCursorInFrame(sceneCoords, frame, elementsMap)
    );
    return frames.length ? frames[frames.length - 1] : null;
  };
  handleCanvasPointerMove = (event) => {
    this.savePointer(event.clientX, event.clientY, this.state.cursorButton);
    this.lastPointerMoveEvent = event.nativeEvent;
    if (gesture.pointers.has(event.pointerId)) {
      gesture.pointers.set(event.pointerId, {
        x: event.clientX,
        y: event.clientY
      });
    }
    const initialScale = gesture.initialScale;
    if (gesture.pointers.size === 2 && gesture.lastCenter && initialScale && gesture.initialDistance) {
      const center = getCenter(gesture.pointers);
      const deltaX = center.x - gesture.lastCenter.x;
      const deltaY = center.y - gesture.lastCenter.y;
      gesture.lastCenter = center;
      const distance2 = getDistance(Array.from(gesture.pointers.values()));
      const scaleFactor = this.state.activeTool.type === "freedraw" && this.state.penMode ? 1 : distance2 / gesture.initialDistance;
      const nextZoom = scaleFactor ? getNormalizedZoom(initialScale * scaleFactor) : this.state.zoom.value;
      this.setState((state) => {
        const zoomState = getStateForZoom(
          {
            viewportX: center.x,
            viewportY: center.y,
            nextZoom
          },
          state
        );
        this.translateCanvas({
          zoom: zoomState.zoom,
          // 2x multiplier is just a magic number that makes this work correctly
          // on touchscreen devices (note: if we get report that panning is slower/faster
          // than actual movement, consider swapping with devicePixelRatio)
          scrollX: zoomState.scrollX + 2 * (deltaX / nextZoom),
          scrollY: zoomState.scrollY + 2 * (deltaY / nextZoom),
          shouldCacheIgnoreZoom: true
        });
      });
      this.resetShouldCacheIgnoreZoomDebounced();
    } else {
      gesture.lastCenter = gesture.initialDistance = gesture.initialScale = null;
    }
    if (isHoldingSpace || isPanning || isDraggingScrollBar || isHandToolActive(this.state)) {
      return;
    }
    const isPointerOverScrollBars = isOverScrollBars(
      currentScrollBars,
      event.clientX - this.state.offsetLeft,
      event.clientY - this.state.offsetTop
    );
    const isOverScrollBar = isPointerOverScrollBars.isOverEither;
    if (!this.state.newElement && !this.state.selectionElement && !this.state.selectedElementsAreBeingDragged && !this.state.multiElement) {
      if (isOverScrollBar) {
        resetCursor(this.interactiveCanvas);
      } else {
        setCursorForShape(this.interactiveCanvas, this.state);
      }
    }
    const scenePointer = viewportCoordsToSceneCoords(event, this.state);
    const { x: scenePointerX, y: scenePointerY } = scenePointer;
    if (!this.state.newElement && isActiveToolNonLinearSnappable(this.state.activeTool.type)) {
      const { originOffset, snapLines } = getSnapLinesAtPointer(
        this.scene.getNonDeletedElements(),
        this,
        {
          x: scenePointerX,
          y: scenePointerY
        },
        event,
        this.scene.getNonDeletedElementsMap()
      );
      this.setState((prevState) => {
        const nextSnapLines = updateStable(prevState.snapLines, snapLines);
        const nextOriginOffset = prevState.originSnapOffset ? updateStable(prevState.originSnapOffset, originOffset) : originOffset;
        if (prevState.snapLines === nextSnapLines && prevState.originSnapOffset === nextOriginOffset) {
          return null;
        }
        return {
          snapLines: nextSnapLines,
          originSnapOffset: nextOriginOffset
        };
      });
    } else if (!this.state.newElement && !this.state.selectedElementsAreBeingDragged && !this.state.selectionElement) {
      this.setState((prevState) => {
        if (prevState.snapLines.length) {
          return {
            snapLines: []
          };
        }
        return null;
      });
    }
    if (this.state.editingLinearElement && !this.state.editingLinearElement.isDragging) {
      const editingLinearElement = LinearElementEditor.handlePointerMove(
        event,
        scenePointerX,
        scenePointerY,
        this,
        this.scene.getNonDeletedElementsMap()
      );
      if (editingLinearElement && editingLinearElement !== this.state.editingLinearElement) {
        (0, import_react_dom9.flushSync)(() => {
          this.setState({
            editingLinearElement
          });
        });
      }
      if (editingLinearElement?.lastUncommittedPoint != null) {
        this.maybeSuggestBindingAtCursor(scenePointer);
      } else {
        (0, import_react_dom9.flushSync)(() => {
          this.setState({ suggestedBindings: [] });
        });
      }
    }
    if (isBindingElementType(this.state.activeTool.type)) {
      const { newElement: newElement2 } = this.state;
      if (isBindingElement(newElement2, false)) {
        this.maybeSuggestBindingsForLinearElementAtCoords(
          newElement2,
          [scenePointer],
          this.state.startBoundElement
        );
      } else {
        this.maybeSuggestBindingAtCursor(scenePointer);
      }
    }
    if (this.state.multiElement) {
      const { multiElement } = this.state;
      const { x: rx, y: ry } = multiElement;
      const { points, lastCommittedPoint } = multiElement;
      const lastPoint = points[points.length - 1];
      setCursorForShape(this.interactiveCanvas, this.state);
      if (lastPoint === lastCommittedPoint) {
        if (pointDistance(
          pointFrom(scenePointerX - rx, scenePointerY - ry),
          lastPoint
        ) >= LINE_CONFIRM_THRESHOLD) {
          mutateElement(
            multiElement,
            {
              points: [
                ...points,
                pointFrom(scenePointerX - rx, scenePointerY - ry)
              ]
            },
            false
          );
        } else {
          setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
        }
      } else if (points.length > 2 && lastCommittedPoint && pointDistance(
        pointFrom(scenePointerX - rx, scenePointerY - ry),
        lastCommittedPoint
      ) < LINE_CONFIRM_THRESHOLD) {
        setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
        mutateElement(
          multiElement,
          {
            points: points.slice(0, -1)
          },
          false
        );
      } else {
        const [gridX, gridY] = getGridPoint(
          scenePointerX,
          scenePointerY,
          event[KEYS.CTRL_OR_CMD] || isElbowArrow(multiElement) ? null : this.getEffectiveGridSize()
        );
        const [lastCommittedX, lastCommittedY] = multiElement?.lastCommittedPoint ?? [0, 0];
        let dxFromLastCommitted = gridX - rx - lastCommittedX;
        let dyFromLastCommitted = gridY - ry - lastCommittedY;
        if (shouldRotateWithDiscreteAngle(event)) {
          ({ width: dxFromLastCommitted, height: dyFromLastCommitted } = getLockedLinearCursorAlignSize(
            // actual coordinate of the last committed point
            lastCommittedX + rx,
            lastCommittedY + ry,
            // cursor-grid coordinate
            gridX,
            gridY
          ));
        }
        if (isPathALoop(points, this.state.zoom.value)) {
          setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
        }
        if (isElbowArrow(multiElement)) {
          mutateElbowArrow(
            multiElement,
            this.scene.getNonDeletedElementsMap(),
            [
              ...points.slice(0, -1),
              pointFrom(
                lastCommittedX + dxFromLastCommitted,
                lastCommittedY + dyFromLastCommitted
              )
            ],
            void 0,
            void 0,
            {
              isDragging: true,
              informMutation: false
            }
          );
        } else {
          mutateElement(
            multiElement,
            {
              points: [
                ...points.slice(0, -1),
                pointFrom(
                  lastCommittedX + dxFromLastCommitted,
                  lastCommittedY + dyFromLastCommitted
                )
              ]
            },
            false
          );
        }
        this.triggerRender(false);
      }
      return;
    }
    const hasDeselectedButton = Boolean(event.buttons);
    if (hasDeselectedButton || this.state.activeTool.type !== "selection" && this.state.activeTool.type !== "text" && this.state.activeTool.type !== "eraser") {
      return;
    }
    const elements = this.scene.getNonDeletedElements();
    const selectedElements = this.scene.getSelectedElements(this.state);
    if (selectedElements.length === 1 && !isOverScrollBar && !this.state.editingLinearElement) {
      if (this.state.selectedLinearElement) {
        this.handleHoverSelectedLinearElement(
          this.state.selectedLinearElement,
          scenePointerX,
          scenePointerY
        );
      }
      if ((!this.state.selectedLinearElement || this.state.selectedLinearElement.hoverPointIndex === -1) && !(selectedElements.length === 1 && isElbowArrow(selectedElements[0]))) {
        const elementWithTransformHandleType = getElementWithTransformHandleType(
          elements,
          this.state,
          scenePointerX,
          scenePointerY,
          this.state.zoom,
          event.pointerType,
          this.scene.getNonDeletedElementsMap(),
          this.device
        );
        if (elementWithTransformHandleType && elementWithTransformHandleType.transformHandleType) {
          setCursor(
            this.interactiveCanvas,
            getCursorForResizingElement(elementWithTransformHandleType)
          );
          return;
        }
      }
    } else if (selectedElements.length > 1 && !isOverScrollBar) {
      const transformHandleType = getTransformHandleTypeFromCoords(
        getCommonBounds(selectedElements),
        scenePointerX,
        scenePointerY,
        this.state.zoom,
        event.pointerType,
        this.device
      );
      if (transformHandleType) {
        setCursor(
          this.interactiveCanvas,
          getCursorForResizingElement({
            transformHandleType
          })
        );
        return;
      }
    }
    const hitElement = this.getElementAtPosition(
      scenePointer.x,
      scenePointer.y
    );
    this.hitLinkElement = this.getElementLinkAtPosition(
      scenePointer,
      hitElement
    );
    if (isEraserActive(this.state)) {
      return;
    }
    if (this.hitLinkElement && !this.state.selectedElementIds[this.hitLinkElement.id]) {
      setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
      showHyperlinkTooltip(
        this.hitLinkElement,
        this.state,
        this.scene.getNonDeletedElementsMap()
      );
    } else {
      hideHyperlinkToolip();
      if (hitElement && (hitElement.link || isEmbeddableElement(hitElement)) && this.state.selectedElementIds[hitElement.id] && !this.state.contextMenu && !this.state.showHyperlinkPopup) {
        this.setState({ showHyperlinkPopup: "info" });
      } else if (this.state.activeTool.type === "text") {
        setCursor(
          this.interactiveCanvas,
          isTextElement(hitElement) ? CURSOR_TYPE.TEXT : CURSOR_TYPE.CROSSHAIR
        );
      } else if (this.state.viewModeEnabled) {
        setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);
      } else if (isOverScrollBar) {
        setCursor(this.interactiveCanvas, CURSOR_TYPE.AUTO);
      } else if (this.state.selectedLinearElement) {
        this.handleHoverSelectedLinearElement(
          this.state.selectedLinearElement,
          scenePointerX,
          scenePointerY
        );
      } else if (
        // if using cmd/ctrl, we're not dragging
        !event[KEYS.CTRL_OR_CMD]
      ) {
        if ((hitElement || this.isHittingCommonBoundingBoxOfSelectedElements(
          scenePointer,
          selectedElements
        )) && !hitElement?.locked) {
          if (hitElement && isIframeLikeElement(hitElement) && this.isIframeLikeElementCenter(
            hitElement,
            event,
            scenePointerX,
            scenePointerY
          )) {
            setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
            this.setState({
              activeEmbeddable: { element: hitElement, state: "hover" }
            });
          } else {
            setCursor(this.interactiveCanvas, CURSOR_TYPE.MOVE);
            if (this.state.activeEmbeddable?.state === "hover") {
              this.setState({ activeEmbeddable: null });
            }
          }
        }
      } else {
        setCursor(this.interactiveCanvas, CURSOR_TYPE.AUTO);
      }
    }
  };
  handleEraser = (event, pointerDownState, scenePointer) => {
    this.eraserTrail.addPointToPath(scenePointer.x, scenePointer.y);
    let didChange = false;
    const processedGroups = /* @__PURE__ */ new Set();
    const nonDeletedElements = this.scene.getNonDeletedElements();
    const processElements = (elements) => {
      for (const element of elements) {
        if (element.locked) {
          return;
        }
        if (event.altKey) {
          if (this.elementsPendingErasure.delete(element.id)) {
            didChange = true;
          }
        } else if (!this.elementsPendingErasure.has(element.id)) {
          didChange = true;
          this.elementsPendingErasure.add(element.id);
        }
        if (didChange && element.groupIds?.length) {
          const shallowestGroupId = element.groupIds.at(-1);
          if (!processedGroups.has(shallowestGroupId)) {
            processedGroups.add(shallowestGroupId);
            const elems = getElementsInGroup(
              nonDeletedElements,
              shallowestGroupId
            );
            for (const elem of elems) {
              if (event.altKey) {
                this.elementsPendingErasure.delete(elem.id);
              } else {
                this.elementsPendingErasure.add(elem.id);
              }
            }
          }
        }
      }
    };
    const distance2 = pointDistance(
      pointFrom(pointerDownState.lastCoords.x, pointerDownState.lastCoords.y),
      pointFrom(scenePointer.x, scenePointer.y)
    );
    const threshold = this.getElementHitThreshold();
    const p3 = { ...pointerDownState.lastCoords };
    let samplingInterval = 0;
    while (samplingInterval <= distance2) {
      const hitElements = this.getElementsAtPosition(p3.x, p3.y);
      processElements(hitElements);
      if (samplingInterval === distance2) {
        break;
      }
      samplingInterval = Math.min(samplingInterval + threshold, distance2);
      const distanceRatio = samplingInterval / distance2;
      const nextX = (1 - distanceRatio) * p3.x + distanceRatio * scenePointer.x;
      const nextY = (1 - distanceRatio) * p3.y + distanceRatio * scenePointer.y;
      p3.x = nextX;
      p3.y = nextY;
    }
    pointerDownState.lastCoords.x = scenePointer.x;
    pointerDownState.lastCoords.y = scenePointer.y;
    if (didChange) {
      for (const element of this.scene.getNonDeletedElements()) {
        if (isBoundToContainer(element) && (this.elementsPendingErasure.has(element.id) || this.elementsPendingErasure.has(element.containerId))) {
          if (event.altKey) {
            this.elementsPendingErasure.delete(element.id);
            this.elementsPendingErasure.delete(element.containerId);
          } else {
            this.elementsPendingErasure.add(element.id);
            this.elementsPendingErasure.add(element.containerId);
          }
        }
      }
      this.elementsPendingErasure = new Set(this.elementsPendingErasure);
      this.triggerRender();
    }
  };
  // set touch moving for mobile context menu
  handleTouchMove = (event) => {
    invalidateContextMenu = true;
  };
  handleHoverSelectedLinearElement(linearElementEditor, scenePointerX, scenePointerY) {
    const elementsMap = this.scene.getNonDeletedElementsMap();
    const element = LinearElementEditor.getElement(
      linearElementEditor.elementId,
      elementsMap
    );
    if (!element) {
      return;
    }
    if (this.state.selectedLinearElement) {
      let hoverPointIndex = -1;
      let segmentMidPointHoveredCoords = null;
      if (hitElementItself({
        x: scenePointerX,
        y: scenePointerY,
        element,
        shape: getElementShape(
          element,
          this.scene.getNonDeletedElementsMap()
        )
      })) {
        hoverPointIndex = LinearElementEditor.getPointIndexUnderCursor(
          element,
          elementsMap,
          this.state.zoom,
          scenePointerX,
          scenePointerY
        );
        segmentMidPointHoveredCoords = LinearElementEditor.getSegmentMidpointHitCoords(
          linearElementEditor,
          { x: scenePointerX, y: scenePointerY },
          this.state,
          this.scene.getNonDeletedElementsMap()
        );
        if (hoverPointIndex >= 0 || segmentMidPointHoveredCoords) {
          setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
        } else if (this.hitElement(scenePointerX, scenePointerY, element)) {
          setCursor(this.interactiveCanvas, CURSOR_TYPE.MOVE);
        }
      } else if (this.hitElement(scenePointerX, scenePointerY, element)) {
        if (!isElbowArrow(element) || !(element.startBinding || element.endBinding)) {
          setCursor(this.interactiveCanvas, CURSOR_TYPE.MOVE);
        }
      }
      if (this.state.selectedLinearElement.hoverPointIndex !== hoverPointIndex) {
        this.setState({
          selectedLinearElement: {
            ...this.state.selectedLinearElement,
            hoverPointIndex
          }
        });
      }
      if (!LinearElementEditor.arePointsEqual(
        this.state.selectedLinearElement.segmentMidPointHoveredCoords,
        segmentMidPointHoveredCoords
      )) {
        this.setState({
          selectedLinearElement: {
            ...this.state.selectedLinearElement,
            segmentMidPointHoveredCoords
          }
        });
      }
    } else {
      setCursor(this.interactiveCanvas, CURSOR_TYPE.AUTO);
    }
  }
  handleCanvasPointerDown = (event) => {
    this.maybeCleanupAfterMissingPointerUp(event.nativeEvent);
    this.maybeUnfollowRemoteUser();
    if (this.state.searchMatches) {
      this.setState((state) => ({
        searchMatches: state.searchMatches.map((searchMatch) => ({
          ...searchMatch,
          focus: false
        }))
      }));
      jotaiStore.set(searchItemInFocusAtom, null);
    }
    if (this.state.contextMenu) {
      this.setState({ contextMenu: null });
    }
    if (this.state.snapLines) {
      this.setAppState({ snapLines: [] });
    }
    this.updateGestureOnPointerDown(event);
    if (event.pointerType === "touch" && this.state.newElement && this.state.newElement.type === "freedraw") {
      const element = this.state.newElement;
      this.updateScene({
        ...element.points.length < 10 ? {
          elements: this.scene.getElementsIncludingDeleted().filter((el) => el.id !== element.id)
        } : {},
        appState: {
          newElement: null,
          editingTextElement: null,
          startBoundElement: null,
          suggestedBindings: [],
          selectedElementIds: makeNextSelectedElementIds(
            Object.keys(this.state.selectedElementIds).filter((key) => key !== element.id).reduce((obj, key) => {
              obj[key] = this.state.selectedElementIds[key];
              return obj;
            }, {}),
            this.state
          )
        },
        storeAction: StoreAction.UPDATE
      });
      return;
    }
    const selection = document.getSelection();
    if (selection?.anchorNode) {
      selection.removeAllRanges();
    }
    this.maybeOpenContextMenuAfterPointerDownOnTouchDevices(event);
    if (!this.state.penDetected && event.pointerType === "pen") {
      this.setState((prevState) => {
        return {
          penMode: true,
          penDetected: true
        };
      });
    }
    if (!this.device.isTouchScreen && ["pen", "touch"].includes(event.pointerType)) {
      this.device = updateObject(this.device, { isTouchScreen: true });
    }
    if (isPanning) {
      return;
    }
    this.lastPointerDownEvent = event;
    if (this.handleCanvasPanUsingWheelOrSpaceDrag(event)) {
      return;
    }
    this.setState({
      lastPointerDownWith: event.pointerType,
      cursorButton: "down"
    });
    this.savePointer(event.clientX, event.clientY, "down");
    if (event.button === POINTER_BUTTON.ERASER && this.state.activeTool.type !== TOOL_TYPE.eraser) {
      this.setState(
        {
          activeTool: updateActiveTool(this.state, {
            type: TOOL_TYPE.eraser,
            lastActiveToolBeforeEraser: this.state.activeTool
          })
        },
        () => {
          this.handleCanvasPointerDown(event);
          const onPointerUp2 = () => {
            unsubPointerUp();
            unsubCleanup?.();
            if (isEraserActive(this.state)) {
              this.setState({
                activeTool: updateActiveTool(this.state, {
                  ...this.state.activeTool.lastActiveTool || {
                    type: TOOL_TYPE.selection
                  },
                  lastActiveToolBeforeEraser: null
                })
              });
            }
          };
          const unsubPointerUp = addEventListener(
            window,
            "pointerup" /* POINTER_UP */,
            onPointerUp2,
            {
              once: true
            }
          );
          let unsubCleanup;
          requestAnimationFrame(() => {
            unsubCleanup = this.missingPointerEventCleanupEmitter.once(onPointerUp2);
          });
        }
      );
      return;
    }
    if (event.button !== POINTER_BUTTON.MAIN && event.button !== POINTER_BUTTON.TOUCH && event.button !== POINTER_BUTTON.ERASER) {
      return;
    }
    if (gesture.pointers.size > 1) {
      return;
    }
    const pointerDownState = this.initialPointerDownState(event);
    this.setState({
      selectedElementsAreBeingDragged: false
    });
    if (this.handleDraggingScrollBar(event, pointerDownState)) {
      return;
    }
    this.clearSelectionIfNotUsingSelection();
    this.updateBindingEnabledOnPointerMove(event);
    if (this.handleSelectionOnPointerDown(event, pointerDownState)) {
      return;
    }
    const allowOnPointerDown = !this.state.penMode || event.pointerType !== "touch" || this.state.activeTool.type === "selection" || this.state.activeTool.type === "text" || this.state.activeTool.type === "image";
    if (!allowOnPointerDown) {
      return;
    }
    if (this.state.activeTool.type === "text") {
      this.handleTextOnPointerDown(event, pointerDownState);
    } else if (this.state.activeTool.type === "arrow" || this.state.activeTool.type === "line") {
      this.handleLinearElementOnPointerDown(
        event,
        this.state.activeTool.type,
        pointerDownState
      );
    } else if (this.state.activeTool.type === "image") {
      setCursor(this.interactiveCanvas, CURSOR_TYPE.CROSSHAIR);
      const pendingImageElement = this.state.pendingImageElementId && this.scene.getElement(this.state.pendingImageElementId);
      if (!pendingImageElement) {
        return;
      }
      this.setState({
        newElement: pendingImageElement,
        pendingImageElementId: null,
        multiElement: null
      });
      const { x: x3, y: y3 } = viewportCoordsToSceneCoords(event, this.state);
      const frame = this.getTopLayerFrameAtSceneCoords({ x: x3, y: y3 });
      mutateElement(pendingImageElement, {
        x: x3,
        y: y3,
        frameId: frame ? frame.id : null
      });
    } else if (this.state.activeTool.type === "freedraw") {
      this.handleFreeDrawElementOnPointerDown(
        event,
        this.state.activeTool.type,
        pointerDownState
      );
    } else if (this.state.activeTool.type === "custom") {
      setCursorForShape(this.interactiveCanvas, this.state);
    } else if (this.state.activeTool.type === TOOL_TYPE.frame || this.state.activeTool.type === TOOL_TYPE.magicframe) {
      this.createFrameElementOnPointerDown(
        pointerDownState,
        this.state.activeTool.type
      );
    } else if (this.state.activeTool.type === "laser") {
      this.laserTrails.startPath(
        pointerDownState.lastCoords.x,
        pointerDownState.lastCoords.y
      );
    } else if (this.state.activeTool.type !== "eraser" && this.state.activeTool.type !== "hand") {
      this.createGenericElementOnPointerDown(
        this.state.activeTool.type,
        pointerDownState
      );
    }
    this.props?.onPointerDown?.(this.state.activeTool, pointerDownState);
    this.onPointerDownEmitter.trigger(
      this.state.activeTool,
      pointerDownState,
      event
    );
    if (this.state.activeTool.type === "eraser") {
      this.eraserTrail.startPath(
        pointerDownState.lastCoords.x,
        pointerDownState.lastCoords.y
      );
    }
    const onPointerMove = this.onPointerMoveFromPointerDownHandler(pointerDownState);
    const onPointerUp = this.onPointerUpFromPointerDownHandler(pointerDownState);
    const onKeyDown = this.onKeyDownFromPointerDownHandler(pointerDownState);
    const onKeyUp = this.onKeyUpFromPointerDownHandler(pointerDownState);
    this.missingPointerEventCleanupEmitter.once(
      (_event) => onPointerUp(_event || event.nativeEvent)
    );
    if (!this.state.viewModeEnabled || this.state.activeTool.type === "laser") {
      window.addEventListener("pointermove" /* POINTER_MOVE */, onPointerMove);
      window.addEventListener("pointerup" /* POINTER_UP */, onPointerUp);
      window.addEventListener("keydown" /* KEYDOWN */, onKeyDown);
      window.addEventListener("keyup" /* KEYUP */, onKeyUp);
      pointerDownState.eventListeners.onMove = onPointerMove;
      pointerDownState.eventListeners.onUp = onPointerUp;
      pointerDownState.eventListeners.onKeyUp = onKeyUp;
      pointerDownState.eventListeners.onKeyDown = onKeyDown;
    }
  };
  handleCanvasPointerUp = (event) => {
    this.removePointer(event);
    this.lastPointerUpEvent = event;
    const scenePointer = viewportCoordsToSceneCoords(
      { clientX: event.clientX, clientY: event.clientY },
      this.state
    );
    const clicklength = event.timeStamp - (this.lastPointerDownEvent?.timeStamp ?? 0);
    if (this.device.editor.isMobile && clicklength < 300) {
      const hitElement = this.getElementAtPosition(
        scenePointer.x,
        scenePointer.y
      );
      if (isIframeLikeElement(hitElement) && this.isIframeLikeElementCenter(
        hitElement,
        event,
        scenePointer.x,
        scenePointer.y
      )) {
        this.handleEmbeddableCenterClick(hitElement);
        return;
      }
    }
    if (this.device.isTouchScreen) {
      const hitElement = this.getElementAtPosition(
        scenePointer.x,
        scenePointer.y
      );
      this.hitLinkElement = this.getElementLinkAtPosition(
        scenePointer,
        hitElement
      );
    }
    if (this.hitLinkElement && !this.state.selectedElementIds[this.hitLinkElement.id]) {
      if (clicklength < 300 && isIframeLikeElement(this.hitLinkElement) && !isPointHittingLinkIcon(
        this.hitLinkElement,
        this.scene.getNonDeletedElementsMap(),
        this.state,
        pointFrom(scenePointer.x, scenePointer.y)
      )) {
        this.handleEmbeddableCenterClick(this.hitLinkElement);
      } else {
        this.redirectToLink(event, this.device.isTouchScreen);
      }
    } else if (this.state.viewModeEnabled) {
      this.setState({
        activeEmbeddable: null,
        selectedElementIds: {}
      });
    }
  };
  maybeOpenContextMenuAfterPointerDownOnTouchDevices = (event) => {
    if (event.pointerType === "touch") {
      invalidateContextMenu = false;
      if (touchTimeout) {
        invalidateContextMenu = true;
      } else {
        touchTimeout = window.setTimeout(() => {
          touchTimeout = 0;
          if (!invalidateContextMenu) {
            this.handleCanvasContextMenu(event);
          }
        }, TOUCH_CTX_MENU_TIMEOUT);
      }
    }
  };
  resetContextMenuTimer = () => {
    clearTimeout(touchTimeout);
    touchTimeout = 0;
    invalidateContextMenu = false;
  };
  /**
   * pointerup may not fire in certian cases (user tabs away...), so in order
   * to properly cleanup pointerdown state, we need to fire any hanging
   * pointerup handlers manually
   */
  maybeCleanupAfterMissingPointerUp = (event) => {
    lastPointerUp?.();
    this.missingPointerEventCleanupEmitter.trigger(event).clear();
  };
  // Returns whether the event is a panning
  handleCanvasPanUsingWheelOrSpaceDrag = (event) => {
    if (!(gesture.pointers.size <= 1 && (event.button === POINTER_BUTTON.WHEEL || event.button === POINTER_BUTTON.MAIN && isHoldingSpace || isHandToolActive(this.state) || this.state.viewModeEnabled))) {
      return false;
    }
    isPanning = true;
    this.focusContainer();
    if (!this.state.editingTextElement) {
      event.preventDefault();
    }
    let nextPastePrevented = false;
    const isLinux = typeof window === void 0 ? false : /Linux/.test(window.navigator.platform);
    setCursor(this.interactiveCanvas, CURSOR_TYPE.GRABBING);
    let { clientX: lastX, clientY: lastY } = event;
    const onPointerMove = withBatchedUpdatesThrottled((event2) => {
      const deltaX = lastX - event2.clientX;
      const deltaY = lastY - event2.clientY;
      lastX = event2.clientX;
      lastY = event2.clientY;
      if (isLinux && !nextPastePrevented && (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1)) {
        nextPastePrevented = true;
        const preventNextPaste = (event3) => {
          document.body.removeEventListener("paste" /* PASTE */, preventNextPaste);
          event3.stopPropagation();
        };
        const enableNextPaste = () => {
          setTimeout(() => {
            document.body.removeEventListener("paste" /* PASTE */, preventNextPaste);
            window.removeEventListener("pointerup" /* POINTER_UP */, enableNextPaste);
          }, 100);
        };
        document.body.addEventListener("paste" /* PASTE */, preventNextPaste);
        window.addEventListener("pointerup" /* POINTER_UP */, enableNextPaste);
      }
      this.translateCanvas({
        scrollX: this.state.scrollX - deltaX / this.state.zoom.value,
        scrollY: this.state.scrollY - deltaY / this.state.zoom.value
      });
    });
    const teardown = withBatchedUpdates(
      lastPointerUp = () => {
        lastPointerUp = null;
        isPanning = false;
        if (!isHoldingSpace) {
          if (this.state.viewModeEnabled) {
            setCursor(this.interactiveCanvas, CURSOR_TYPE.GRAB);
          } else {
            setCursorForShape(this.interactiveCanvas, this.state);
          }
        }
        this.setState({
          cursorButton: "up"
        });
        this.savePointer(event.clientX, event.clientY, "up");
        window.removeEventListener("pointermove" /* POINTER_MOVE */, onPointerMove);
        window.removeEventListener("pointerup" /* POINTER_UP */, teardown);
        window.removeEventListener("blur" /* BLUR */, teardown);
        onPointerMove.flush();
      }
    );
    window.addEventListener("blur" /* BLUR */, teardown);
    window.addEventListener("pointermove" /* POINTER_MOVE */, onPointerMove, {
      passive: true
    });
    window.addEventListener("pointerup" /* POINTER_UP */, teardown);
    return true;
  };
  updateGestureOnPointerDown(event) {
    gesture.pointers.set(event.pointerId, {
      x: event.clientX,
      y: event.clientY
    });
    if (gesture.pointers.size === 2) {
      gesture.lastCenter = getCenter(gesture.pointers);
      gesture.initialScale = this.state.zoom.value;
      gesture.initialDistance = getDistance(
        Array.from(gesture.pointers.values())
      );
    }
  }
  initialPointerDownState(event) {
    const origin = viewportCoordsToSceneCoords(event, this.state);
    const selectedElements = this.scene.getSelectedElements(this.state);
    const [minX, minY, maxX, maxY] = getCommonBounds(selectedElements);
    const isElbowArrowOnly = selectedElements.findIndex(isElbowArrow) === 0;
    return {
      origin,
      withCmdOrCtrl: event[KEYS.CTRL_OR_CMD],
      originInGrid: tupleToCoors(
        getGridPoint(
          origin.x,
          origin.y,
          event[KEYS.CTRL_OR_CMD] || isElbowArrowOnly ? null : this.getEffectiveGridSize()
        )
      ),
      scrollbars: isOverScrollBars(
        currentScrollBars,
        event.clientX - this.state.offsetLeft,
        event.clientY - this.state.offsetTop
      ),
      // we need to duplicate because we'll be updating this state
      lastCoords: { ...origin },
      originalElements: this.scene.getNonDeletedElements().reduce((acc, element) => {
        acc.set(element.id, deepCopyElement(element));
        return acc;
      }, /* @__PURE__ */ new Map()),
      resize: {
        handleType: false,
        isResizing: false,
        offset: { x: 0, y: 0 },
        arrowDirection: "origin",
        center: { x: (maxX + minX) / 2, y: (maxY + minY) / 2 }
      },
      hit: {
        element: null,
        allHitElements: [],
        wasAddedToSelection: false,
        hasBeenDuplicated: false,
        hasHitCommonBoundingBoxOfSelectedElements: this.isHittingCommonBoundingBoxOfSelectedElements(
          origin,
          selectedElements
        )
      },
      drag: {
        hasOccurred: false,
        offset: null
      },
      eventListeners: {
        onMove: null,
        onUp: null,
        onKeyUp: null,
        onKeyDown: null
      },
      boxSelection: {
        hasOccurred: false
      }
    };
  }
  // Returns whether the event is a dragging a scrollbar
  handleDraggingScrollBar(event, pointerDownState) {
    if (!(pointerDownState.scrollbars.isOverEither && !this.state.multiElement)) {
      return false;
    }
    isDraggingScrollBar = true;
    pointerDownState.lastCoords.x = event.clientX;
    pointerDownState.lastCoords.y = event.clientY;
    const onPointerMove = withBatchedUpdatesThrottled((event2) => {
      const target = event2.target;
      if (!(target instanceof HTMLElement)) {
        return;
      }
      this.handlePointerMoveOverScrollbars(event2, pointerDownState);
    });
    const onPointerUp = withBatchedUpdates(() => {
      lastPointerUp = null;
      isDraggingScrollBar = false;
      setCursorForShape(this.interactiveCanvas, this.state);
      this.setState({
        cursorButton: "up"
      });
      this.savePointer(event.clientX, event.clientY, "up");
      window.removeEventListener("pointermove" /* POINTER_MOVE */, onPointerMove);
      window.removeEventListener("pointerup" /* POINTER_UP */, onPointerUp);
      onPointerMove.flush();
    });
    lastPointerUp = onPointerUp;
    window.addEventListener("pointermove" /* POINTER_MOVE */, onPointerMove);
    window.addEventListener("pointerup" /* POINTER_UP */, onPointerUp);
    return true;
  }
  clearSelectionIfNotUsingSelection = () => {
    if (this.state.activeTool.type !== "selection") {
      this.setState({
        selectedElementIds: makeNextSelectedElementIds({}, this.state),
        selectedGroupIds: {},
        editingGroupId: null,
        activeEmbeddable: null
      });
    }
  };
  /**
   * @returns whether the pointer event has been completely handled
   */
  handleSelectionOnPointerDown = (event, pointerDownState) => {
    if (this.state.activeTool.type === "selection") {
      const elements = this.scene.getNonDeletedElements();
      const elementsMap = this.scene.getNonDeletedElementsMap();
      const selectedElements = this.scene.getSelectedElements(this.state);
      if (selectedElements.length === 1 && !this.state.editingLinearElement && !(this.state.selectedLinearElement && this.state.selectedLinearElement.hoverPointIndex !== -1)) {
        const elementWithTransformHandleType = getElementWithTransformHandleType(
          elements,
          this.state,
          pointerDownState.origin.x,
          pointerDownState.origin.y,
          this.state.zoom,
          event.pointerType,
          this.scene.getNonDeletedElementsMap(),
          this.device
        );
        if (elementWithTransformHandleType != null) {
          this.setState({
            resizingElement: elementWithTransformHandleType.element
          });
          pointerDownState.resize.handleType = elementWithTransformHandleType.transformHandleType;
        }
      } else if (selectedElements.length > 1) {
        pointerDownState.resize.handleType = getTransformHandleTypeFromCoords(
          getCommonBounds(selectedElements),
          pointerDownState.origin.x,
          pointerDownState.origin.y,
          this.state.zoom,
          event.pointerType,
          this.device
        );
      }
      if (pointerDownState.resize.handleType) {
        pointerDownState.resize.isResizing = true;
        pointerDownState.resize.offset = tupleToCoors(
          getResizeOffsetXY(
            pointerDownState.resize.handleType,
            selectedElements,
            elementsMap,
            pointerDownState.origin.x,
            pointerDownState.origin.y
          )
        );
        if (selectedElements.length === 1 && isLinearElement(selectedElements[0]) && selectedElements[0].points.length === 2) {
          pointerDownState.resize.arrowDirection = getResizeArrowDirection(
            pointerDownState.resize.handleType,
            selectedElements[0]
          );
        }
      } else {
        if (this.state.selectedLinearElement) {
          const linearElementEditor = this.state.editingLinearElement || this.state.selectedLinearElement;
          const ret = LinearElementEditor.handlePointerDown(
            event,
            this,
            this.store,
            pointerDownState.origin,
            linearElementEditor,
            this.scene
          );
          if (ret.hitElement) {
            pointerDownState.hit.element = ret.hitElement;
          }
          if (ret.linearElementEditor) {
            this.setState({ selectedLinearElement: ret.linearElementEditor });
            if (this.state.editingLinearElement) {
              this.setState({ editingLinearElement: ret.linearElementEditor });
            }
          }
          if (ret.didAddPoint) {
            return true;
          }
        }
        pointerDownState.hit.element = pointerDownState.hit.element ?? this.getElementAtPosition(
          pointerDownState.origin.x,
          pointerDownState.origin.y
        );
        if (pointerDownState.hit.element) {
          const hitLinkElement = this.getElementLinkAtPosition(
            {
              x: pointerDownState.origin.x,
              y: pointerDownState.origin.y
            },
            pointerDownState.hit.element
          );
          if (hitLinkElement) {
            return false;
          }
        }
        pointerDownState.hit.allHitElements = this.getElementsAtPosition(
          pointerDownState.origin.x,
          pointerDownState.origin.y
        );
        const hitElement = pointerDownState.hit.element;
        const someHitElementIsSelected = pointerDownState.hit.allHitElements.some(
          (element) => this.isASelectedElement(element)
        );
        if ((hitElement === null || !someHitElementIsSelected) && !event.shiftKey && !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements) {
          this.clearSelection(hitElement);
        }
        if (this.state.editingLinearElement) {
          this.setState({
            selectedElementIds: makeNextSelectedElementIds(
              {
                [this.state.editingLinearElement.elementId]: true
              },
              this.state
            )
          });
        } else if (hitElement != null) {
          if (event[KEYS.CTRL_OR_CMD]) {
            if (!this.state.selectedElementIds[hitElement.id]) {
              pointerDownState.hit.wasAddedToSelection = true;
            }
            this.setState((prevState) => ({
              ...editGroupForSelectedElement(prevState, hitElement),
              previousSelectedElementIds: this.state.selectedElementIds
            }));
            return false;
          }
          if (!this.state.selectedElementIds[hitElement.id]) {
            if (this.state.editingGroupId && !isElementInGroup(hitElement, this.state.editingGroupId)) {
              this.setState({
                selectedElementIds: makeNextSelectedElementIds({}, this.state),
                selectedGroupIds: {},
                editingGroupId: null,
                activeEmbeddable: null
              });
            }
            if (!someHitElementIsSelected && !pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements) {
              this.setState((prevState) => {
                const nextSelectedElementIds = {
                  ...prevState.selectedElementIds,
                  [hitElement.id]: true
                };
                const previouslySelectedElements = [];
                Object.keys(prevState.selectedElementIds).forEach((id) => {
                  const element = this.scene.getElement(id);
                  element && previouslySelectedElements.push(element);
                });
                if (isFrameLikeElement(hitElement)) {
                  getFrameChildren(
                    previouslySelectedElements,
                    hitElement.id
                  ).forEach((element) => {
                    delete nextSelectedElementIds[element.id];
                  });
                } else if (hitElement.frameId) {
                  if (nextSelectedElementIds[hitElement.frameId]) {
                    delete nextSelectedElementIds[hitElement.id];
                  }
                } else {
                  const groupIds = hitElement.groupIds;
                  const framesInGroups = new Set(
                    groupIds.flatMap(
                      (gid) => getElementsInGroup(
                        this.scene.getNonDeletedElements(),
                        gid
                      )
                    ).filter((element) => isFrameLikeElement(element)).map((frame) => frame.id)
                  );
                  if (framesInGroups.size > 0) {
                    previouslySelectedElements.forEach((element) => {
                      if (element.frameId && framesInGroups.has(element.frameId)) {
                        delete nextSelectedElementIds[element.id];
                        element.groupIds.flatMap(
                          (gid) => getElementsInGroup(
                            this.scene.getNonDeletedElements(),
                            gid
                          )
                        ).forEach((element2) => {
                          delete nextSelectedElementIds[element2.id];
                        });
                      }
                    });
                  }
                }
                return {
                  ...selectGroupsForSelectedElements(
                    {
                      editingGroupId: prevState.editingGroupId,
                      selectedElementIds: nextSelectedElementIds
                    },
                    this.scene.getNonDeletedElements(),
                    prevState,
                    this
                  ),
                  showHyperlinkPopup: hitElement.link || isEmbeddableElement(hitElement) ? "info" : false
                };
              });
              pointerDownState.hit.wasAddedToSelection = true;
            }
          }
        }
        this.setState({
          previousSelectedElementIds: this.state.selectedElementIds
        });
      }
    }
    return false;
  };
  isASelectedElement(hitElement) {
    return hitElement != null && this.state.selectedElementIds[hitElement.id];
  }
  isHittingCommonBoundingBoxOfSelectedElements(point, selectedElements) {
    if (selectedElements.length < 2) {
      return false;
    }
    const threshold = this.getElementHitThreshold();
    const [x1, y1, x22, y22] = getCommonBounds(selectedElements);
    return point.x > x1 - threshold && point.x < x22 + threshold && point.y > y1 - threshold && point.y < y22 + threshold;
  }
  handleTextOnPointerDown = (event, pointerDownState) => {
    if (this.state.editingTextElement) {
      return;
    }
    let sceneX = pointerDownState.origin.x;
    let sceneY = pointerDownState.origin.y;
    const element = this.getElementAtPosition(sceneX, sceneY, {
      includeBoundTextElement: true
    });
    let container = this.getTextBindableContainerAtPosition(sceneX, sceneY);
    if (hasBoundTextElement(element)) {
      container = element;
      sceneX = element.x + element.width / 2;
      sceneY = element.y + element.height / 2;
    }
    this.startTextEditing({
      sceneX,
      sceneY,
      insertAtParentCenter: !event.altKey,
      container,
      autoEdit: false
    });
    resetCursor(this.interactiveCanvas);
    if (!this.state.activeTool.locked) {
      this.setState({
        activeTool: updateActiveTool(this.state, { type: "selection" })
      });
    }
  };
  handleFreeDrawElementOnPointerDown = (event, elementType, pointerDownState) => {
    const [gridX, gridY] = getGridPoint(
      pointerDownState.origin.x,
      pointerDownState.origin.y,
      null
    );
    const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
      x: gridX,
      y: gridY
    });
    const simulatePressure = event.pressure === 0.5;
    const element = newFreeDrawElement({
      type: elementType,
      x: gridX,
      y: gridY,
      strokeColor: this.state.currentItemStrokeColor,
      backgroundColor: this.state.currentItemBackgroundColor,
      fillStyle: this.state.currentItemFillStyle,
      strokeWidth: this.state.currentItemStrokeWidth,
      strokeStyle: this.state.currentItemStrokeStyle,
      roughness: this.state.currentItemRoughness,
      opacity: this.state.currentItemOpacity,
      roundness: null,
      simulatePressure,
      locked: false,
      frameId: topLayerFrame ? topLayerFrame.id : null,
      points: [pointFrom(0, 0)],
      pressures: simulatePressure ? [] : [event.pressure]
    });
    this.scene.insertElement(element);
    this.setState((prevState) => {
      const nextSelectedElementIds = {
        ...prevState.selectedElementIds
      };
      delete nextSelectedElementIds[element.id];
      return {
        selectedElementIds: makeNextSelectedElementIds(
          nextSelectedElementIds,
          prevState
        )
      };
    });
    const boundElement = getHoveredElementForBinding(
      pointerDownState.origin,
      this.scene.getNonDeletedElements(),
      this.scene.getNonDeletedElementsMap()
    );
    this.setState({
      newElement: element,
      startBoundElement: boundElement,
      suggestedBindings: []
    });
  };
  insertIframeElement = ({
    sceneX,
    sceneY,
    width,
    height
  }) => {
    const [gridX, gridY] = getGridPoint(
      sceneX,
      sceneY,
      this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
    );
    const element = newIframeElement({
      type: "iframe",
      x: gridX,
      y: gridY,
      strokeColor: "transparent",
      backgroundColor: "transparent",
      fillStyle: this.state.currentItemFillStyle,
      strokeWidth: this.state.currentItemStrokeWidth,
      strokeStyle: this.state.currentItemStrokeStyle,
      roughness: this.state.currentItemRoughness,
      roundness: this.getCurrentItemRoundness("iframe"),
      opacity: this.state.currentItemOpacity,
      locked: false,
      width,
      height
    });
    this.scene.insertElement(element);
    return element;
  };
  //create rectangle element with youtube top left on nearest grid point width / hight 640/360
  insertEmbeddableElement = ({
    sceneX,
    sceneY,
    link
  }) => {
    const [gridX, gridY] = getGridPoint(
      sceneX,
      sceneY,
      this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
    );
    const embedLink = getEmbedLink(link);
    if (!embedLink) {
      return;
    }
    if (embedLink.error instanceof URIError) {
      this.setToast({
        message: t("toast.unrecognizedLinkFormat"),
        closable: true
      });
    }
    const element = newEmbeddableElement({
      type: "embeddable",
      x: gridX,
      y: gridY,
      strokeColor: "transparent",
      backgroundColor: "transparent",
      fillStyle: this.state.currentItemFillStyle,
      strokeWidth: this.state.currentItemStrokeWidth,
      strokeStyle: this.state.currentItemStrokeStyle,
      roughness: this.state.currentItemRoughness,
      roundness: this.getCurrentItemRoundness("embeddable"),
      opacity: this.state.currentItemOpacity,
      locked: false,
      width: embedLink.intrinsicSize.w,
      height: embedLink.intrinsicSize.h,
      link
    });
    this.scene.insertElement(element);
    return element;
  };
  createImageElement = ({
    sceneX,
    sceneY,
    addToFrameUnderCursor = true
  }) => {
    const [gridX, gridY] = getGridPoint(
      sceneX,
      sceneY,
      this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
    );
    const topLayerFrame = addToFrameUnderCursor ? this.getTopLayerFrameAtSceneCoords({
      x: gridX,
      y: gridY
    }) : null;
    const element = newImageElement({
      type: "image",
      x: gridX,
      y: gridY,
      strokeColor: this.state.currentItemStrokeColor,
      backgroundColor: this.state.currentItemBackgroundColor,
      fillStyle: this.state.currentItemFillStyle,
      strokeWidth: this.state.currentItemStrokeWidth,
      strokeStyle: this.state.currentItemStrokeStyle,
      roughness: this.state.currentItemRoughness,
      roundness: null,
      opacity: this.state.currentItemOpacity,
      locked: false,
      frameId: topLayerFrame ? topLayerFrame.id : null
    });
    return element;
  };
  handleLinearElementOnPointerDown = (event, elementType, pointerDownState) => {
    if (this.state.multiElement) {
      const { multiElement } = this.state;
      if (multiElement.type === "line" && isPathALoop(multiElement.points, this.state.zoom.value)) {
        mutateElement(multiElement, {
          lastCommittedPoint: multiElement.points[multiElement.points.length - 1]
        });
        this.actionManager.executeAction(actionFinalize);
        return;
      }
      if (isElbowArrow(multiElement) && multiElement.points.length > 1) {
        mutateElement(multiElement, {
          lastCommittedPoint: multiElement.points[multiElement.points.length - 1]
        });
        this.actionManager.executeAction(actionFinalize);
        return;
      }
      const { x: rx, y: ry, lastCommittedPoint } = multiElement;
      if (multiElement.points.length > 1 && lastCommittedPoint && pointDistance(
        pointFrom(
          pointerDownState.origin.x - rx,
          pointerDownState.origin.y - ry
        ),
        lastCommittedPoint
      ) < LINE_CONFIRM_THRESHOLD) {
        this.actionManager.executeAction(actionFinalize);
        return;
      }
      this.setState((prevState) => ({
        selectedElementIds: makeNextSelectedElementIds(
          {
            ...prevState.selectedElementIds,
            [multiElement.id]: true
          },
          prevState
        )
      }));
      mutateElement(multiElement, {
        lastCommittedPoint: multiElement.points[multiElement.points.length - 1]
      });
      setCursor(this.interactiveCanvas, CURSOR_TYPE.POINTER);
    } else {
      const [gridX, gridY] = getGridPoint(
        pointerDownState.origin.x,
        pointerDownState.origin.y,
        event[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
      );
      const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
        x: gridX,
        y: gridY
      });
      const { currentItemStartArrowhead, currentItemEndArrowhead } = this.state;
      const [startArrowhead, endArrowhead] = elementType === "arrow" ? [currentItemStartArrowhead, currentItemEndArrowhead] : [null, null];
      const element = elementType === "arrow" ? newArrowElement({
        type: elementType,
        x: gridX,
        y: gridY,
        strokeColor: this.state.currentItemStrokeColor,
        backgroundColor: this.state.currentItemBackgroundColor,
        fillStyle: this.state.currentItemFillStyle,
        strokeWidth: this.state.currentItemStrokeWidth,
        strokeStyle: this.state.currentItemStrokeStyle,
        roughness: this.state.currentItemRoughness,
        opacity: this.state.currentItemOpacity,
        roundness: this.state.currentItemArrowType === ARROW_TYPE.round ? { type: ROUNDNESS.PROPORTIONAL_RADIUS } : (
          // note, roundness doesn't have any effect for elbow arrows,
          // but it's best to set it to null as well
          null
        ),
        startArrowhead,
        endArrowhead,
        locked: false,
        frameId: topLayerFrame ? topLayerFrame.id : null,
        elbowed: this.state.currentItemArrowType === ARROW_TYPE.elbow
      }) : newLinearElement({
        type: elementType,
        x: gridX,
        y: gridY,
        strokeColor: this.state.currentItemStrokeColor,
        backgroundColor: this.state.currentItemBackgroundColor,
        fillStyle: this.state.currentItemFillStyle,
        strokeWidth: this.state.currentItemStrokeWidth,
        strokeStyle: this.state.currentItemStrokeStyle,
        roughness: this.state.currentItemRoughness,
        opacity: this.state.currentItemOpacity,
        roundness: this.state.currentItemRoundness === "round" ? { type: ROUNDNESS.PROPORTIONAL_RADIUS } : null,
        locked: false,
        frameId: topLayerFrame ? topLayerFrame.id : null
      });
      this.setState((prevState) => {
        const nextSelectedElementIds = {
          ...prevState.selectedElementIds
        };
        delete nextSelectedElementIds[element.id];
        return {
          selectedElementIds: makeNextSelectedElementIds(
            nextSelectedElementIds,
            prevState
          )
        };
      });
      mutateElement(element, {
        points: [...element.points, pointFrom(0, 0)]
      });
      const boundElement = getHoveredElementForBinding(
        pointerDownState.origin,
        this.scene.getNonDeletedElements(),
        this.scene.getNonDeletedElementsMap(),
        isElbowArrow(element)
      );
      this.scene.insertElement(element);
      this.setState({
        newElement: element,
        startBoundElement: boundElement,
        suggestedBindings: []
      });
    }
  };
  getCurrentItemRoundness(elementType) {
    return this.state.currentItemRoundness === "round" ? {
      type: isUsingAdaptiveRadius(elementType) ? ROUNDNESS.ADAPTIVE_RADIUS : ROUNDNESS.PROPORTIONAL_RADIUS
    } : null;
  }
  createGenericElementOnPointerDown = (elementType, pointerDownState) => {
    const [gridX, gridY] = getGridPoint(
      pointerDownState.origin.x,
      pointerDownState.origin.y,
      this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
    );
    const topLayerFrame = this.getTopLayerFrameAtSceneCoords({
      x: gridX,
      y: gridY
    });
    const baseElementAttributes = {
      x: gridX,
      y: gridY,
      strokeColor: this.state.currentItemStrokeColor,
      backgroundColor: this.state.currentItemBackgroundColor,
      fillStyle: this.state.currentItemFillStyle,
      strokeWidth: this.state.currentItemStrokeWidth,
      strokeStyle: this.state.currentItemStrokeStyle,
      roughness: this.state.currentItemRoughness,
      opacity: this.state.currentItemOpacity,
      roundness: this.getCurrentItemRoundness(elementType),
      locked: false,
      frameId: topLayerFrame ? topLayerFrame.id : null
    };
    let element;
    if (elementType === "embeddable") {
      element = newEmbeddableElement({
        type: "embeddable",
        ...baseElementAttributes
      });
    } else {
      element = newElement({
        type: elementType,
        ...baseElementAttributes
      });
    }
    if (element.type === "selection") {
      this.setState({
        selectionElement: element
      });
    } else {
      this.scene.insertElement(element);
      this.setState({
        multiElement: null,
        newElement: element
      });
    }
  };
  createFrameElementOnPointerDown = (pointerDownState, type) => {
    const [gridX, gridY] = getGridPoint(
      pointerDownState.origin.x,
      pointerDownState.origin.y,
      this.lastPointerDownEvent?.[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
    );
    const constructorOpts = {
      x: gridX,
      y: gridY,
      opacity: this.state.currentItemOpacity,
      locked: false,
      ...FRAME_STYLE
    };
    const frame = type === TOOL_TYPE.magicframe ? newMagicFrameElement(constructorOpts) : newFrameElement(constructorOpts);
    this.scene.insertElement(frame);
    this.setState({
      multiElement: null,
      newElement: frame
    });
  };
  maybeCacheReferenceSnapPoints(event, selectedElements, recomputeAnyways = false) {
    if (isSnappingEnabled({
      event,
      app: this,
      selectedElements
    }) && (recomputeAnyways || !SnapCache.getReferenceSnapPoints())) {
      SnapCache.setReferenceSnapPoints(
        getReferenceSnapPoints(
          this.scene.getNonDeletedElements(),
          selectedElements,
          this.state,
          this.scene.getNonDeletedElementsMap()
        )
      );
    }
  }
  maybeCacheVisibleGaps(event, selectedElements, recomputeAnyways = false) {
    if (isSnappingEnabled({
      event,
      app: this,
      selectedElements
    }) && (recomputeAnyways || !SnapCache.getVisibleGaps())) {
      SnapCache.setVisibleGaps(
        getVisibleGaps(
          this.scene.getNonDeletedElements(),
          selectedElements,
          this.state,
          this.scene.getNonDeletedElementsMap()
        )
      );
    }
  }
  onKeyDownFromPointerDownHandler(pointerDownState) {
    return withBatchedUpdates((event) => {
      if (this.maybeHandleResize(pointerDownState, event)) {
        return;
      }
      this.maybeDragNewGenericElement(pointerDownState, event);
    });
  }
  onKeyUpFromPointerDownHandler(pointerDownState) {
    return withBatchedUpdates((event) => {
      event.key === KEYS.ALT && event.preventDefault();
      if (this.maybeHandleResize(pointerDownState, event)) {
        return;
      }
      this.maybeDragNewGenericElement(pointerDownState, event);
    });
  }
  onPointerMoveFromPointerDownHandler(pointerDownState) {
    return withBatchedUpdatesThrottled((event) => {
      if (pointerDownState.drag.offset === null) {
        pointerDownState.drag.offset = tupleToCoors(
          getDragOffsetXY(
            this.scene.getSelectedElements(this.state),
            pointerDownState.origin.x,
            pointerDownState.origin.y
          )
        );
      }
      const target = event.target;
      if (!(target instanceof HTMLElement)) {
        return;
      }
      if (this.handlePointerMoveOverScrollbars(event, pointerDownState)) {
        return;
      }
      const pointerCoords = viewportCoordsToSceneCoords(event, this.state);
      if (isEraserActive(this.state)) {
        this.handleEraser(event, pointerDownState, pointerCoords);
        return;
      }
      if (this.state.activeTool.type === "laser") {
        this.laserTrails.addPointToPath(pointerCoords.x, pointerCoords.y);
      }
      const [gridX, gridY] = getGridPoint(
        pointerCoords.x,
        pointerCoords.y,
        event[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
      );
      if (!pointerDownState.drag.hasOccurred && (this.state.activeTool.type === "arrow" || this.state.activeTool.type === "line")) {
        if (pointDistance(
          pointFrom(pointerCoords.x, pointerCoords.y),
          pointFrom(pointerDownState.origin.x, pointerDownState.origin.y)
        ) < DRAGGING_THRESHOLD) {
          return;
        }
      }
      if (pointerDownState.resize.isResizing) {
        pointerDownState.lastCoords.x = pointerCoords.x;
        pointerDownState.lastCoords.y = pointerCoords.y;
        if (this.maybeHandleResize(pointerDownState, event)) {
          return true;
        }
      }
      const elementsMap = this.scene.getNonDeletedElementsMap();
      if (this.state.selectedLinearElement) {
        const linearElementEditor = this.state.editingLinearElement || this.state.selectedLinearElement;
        if (LinearElementEditor.shouldAddMidpoint(
          this.state.selectedLinearElement,
          pointerCoords,
          this.state,
          elementsMap
        )) {
          const ret = LinearElementEditor.addMidpoint(
            this.state.selectedLinearElement,
            pointerCoords,
            this,
            !event[KEYS.CTRL_OR_CMD],
            elementsMap
          );
          if (!ret) {
            return;
          }
          (0, import_react_dom9.flushSync)(() => {
            if (this.state.selectedLinearElement) {
              this.setState({
                selectedLinearElement: {
                  ...this.state.selectedLinearElement,
                  pointerDownState: ret.pointerDownState,
                  selectedPointsIndices: ret.selectedPointsIndices
                }
              });
            }
            if (this.state.editingLinearElement) {
              this.setState({
                editingLinearElement: {
                  ...this.state.editingLinearElement,
                  pointerDownState: ret.pointerDownState,
                  selectedPointsIndices: ret.selectedPointsIndices
                }
              });
            }
          });
          return;
        } else if (linearElementEditor.pointerDownState.segmentMidpoint.value !== null && !linearElementEditor.pointerDownState.segmentMidpoint.added) {
          return;
        }
        const didDrag = LinearElementEditor.handlePointDragging(
          event,
          this,
          pointerCoords.x,
          pointerCoords.y,
          (element, pointsSceneCoords) => {
            this.maybeSuggestBindingsForLinearElementAtCoords(
              element,
              pointsSceneCoords
            );
          },
          linearElementEditor,
          this.scene
        );
        if (didDrag) {
          pointerDownState.lastCoords.x = pointerCoords.x;
          pointerDownState.lastCoords.y = pointerCoords.y;
          pointerDownState.drag.hasOccurred = true;
          if (this.state.editingLinearElement && !this.state.editingLinearElement.isDragging) {
            this.setState({
              editingLinearElement: {
                ...this.state.editingLinearElement,
                isDragging: true
              }
            });
          }
          if (!this.state.selectedLinearElement.isDragging) {
            this.setState({
              selectedLinearElement: {
                ...this.state.selectedLinearElement,
                isDragging: true
              }
            });
          }
          return;
        }
      }
      const hasHitASelectedElement = pointerDownState.hit.allHitElements.some(
        (element) => this.isASelectedElement(element)
      );
      const isSelectingPointsInLineEditor = this.state.editingLinearElement && event.shiftKey && this.state.editingLinearElement.elementId === pointerDownState.hit.element?.id;
      if ((hasHitASelectedElement || pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements) && !isSelectingPointsInLineEditor) {
        const selectedElements = this.scene.getSelectedElements(this.state);
        if (selectedElements.every((element) => element.locked)) {
          return;
        }
        const selectedElementsHasAFrame = selectedElements.find(
          (e3) => isFrameLikeElement(e3)
        );
        const topLayerFrame = this.getTopLayerFrameAtSceneCoords(pointerCoords);
        this.setState({
          frameToHighlight: topLayerFrame && !selectedElementsHasAFrame ? topLayerFrame : null
        });
        pointerDownState.drag.hasOccurred = true;
        if (selectedElements.length > 0 && !pointerDownState.withCmdOrCtrl && !this.state.editingTextElement && this.state.activeEmbeddable?.state !== "active") {
          const dragOffset = {
            x: pointerCoords.x - pointerDownState.origin.x,
            y: pointerCoords.y - pointerDownState.origin.y
          };
          const originalElements = [
            ...pointerDownState.originalElements.values()
          ];
          const lockDirection = event.shiftKey;
          if (lockDirection) {
            const distanceX = Math.abs(dragOffset.x);
            const distanceY = Math.abs(dragOffset.y);
            const lockX = lockDirection && distanceX < distanceY;
            const lockY = lockDirection && distanceX > distanceY;
            if (lockX) {
              dragOffset.x = 0;
            }
            if (lockY) {
              dragOffset.y = 0;
            }
          }
          this.maybeCacheVisibleGaps(event, selectedElements);
          this.maybeCacheReferenceSnapPoints(event, selectedElements);
          const { snapOffset, snapLines } = snapDraggedElements(
            originalElements,
            dragOffset,
            this,
            event,
            this.scene.getNonDeletedElementsMap()
          );
          this.setState({ snapLines });
          !this.state.editingFrame && dragSelectedElements(
            pointerDownState,
            selectedElements,
            dragOffset,
            this.scene,
            snapOffset,
            event[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
          );
          this.setState({
            selectedElementsAreBeingDragged: true,
            // element is being dragged and selectionElement that was created on pointer down
            // should be removed
            selectionElement: null
          });
          if (selectedElements.length !== 1 || !isElbowArrow(selectedElements[0])) {
            this.setState({
              suggestedBindings: getSuggestedBindingsForArrows(
                selectedElements,
                this.scene.getNonDeletedElementsMap()
              )
            });
          }
          if (event.altKey && !pointerDownState.hit.hasBeenDuplicated) {
            pointerDownState.hit.hasBeenDuplicated = true;
            const nextElements = [];
            const elementsToAppend = [];
            const groupIdMap = /* @__PURE__ */ new Map();
            const oldIdToDuplicatedId = /* @__PURE__ */ new Map();
            const hitElement = pointerDownState.hit.element;
            const selectedElementIds = new Set(
              this.scene.getSelectedElements({
                selectedElementIds: this.state.selectedElementIds,
                includeBoundTextElement: true,
                includeElementsInFrames: true
              }).map((element) => element.id)
            );
            const elements = this.scene.getElementsIncludingDeleted();
            for (const element of elements) {
              if (selectedElementIds.has(element.id) || // case: the state.selectedElementIds might not have been
              // updated yet by the time this mousemove event is fired
              element.id === hitElement?.id && pointerDownState.hit.wasAddedToSelection) {
                const duplicatedElement = duplicateElement(
                  this.state.editingGroupId,
                  groupIdMap,
                  element
                );
                const origElement = pointerDownState.originalElements.get(
                  element.id
                );
                mutateElement(duplicatedElement, {
                  x: origElement.x,
                  y: origElement.y
                });
                pointerDownState.originalElements.set(
                  duplicatedElement.id,
                  duplicatedElement
                );
                nextElements.push(duplicatedElement);
                elementsToAppend.push(element);
                oldIdToDuplicatedId.set(element.id, duplicatedElement.id);
              } else {
                nextElements.push(element);
              }
            }
            const nextSceneElements = [...nextElements, ...elementsToAppend];
            syncMovedIndices(nextSceneElements, arrayToMap(elementsToAppend));
            bindTextToShapeAfterDuplication(
              nextElements,
              elementsToAppend,
              oldIdToDuplicatedId
            );
            fixBindingsAfterDuplication(
              nextSceneElements,
              elementsToAppend,
              oldIdToDuplicatedId,
              "duplicatesServeAsOld"
            );
            bindElementsToFramesAfterDuplication(
              nextSceneElements,
              elementsToAppend,
              oldIdToDuplicatedId
            );
            this.scene.replaceAllElements(nextSceneElements);
            this.maybeCacheVisibleGaps(event, selectedElements, true);
            this.maybeCacheReferenceSnapPoints(event, selectedElements, true);
          }
          return;
        }
      }
      if (this.state.selectionElement) {
        pointerDownState.lastCoords.x = pointerCoords.x;
        pointerDownState.lastCoords.y = pointerCoords.y;
        this.maybeDragNewGenericElement(pointerDownState, event);
      } else {
        const newElement2 = this.state.newElement;
        if (!newElement2) {
          return;
        }
        if (newElement2.type === "freedraw") {
          const points = newElement2.points;
          const dx = pointerCoords.x - newElement2.x;
          const dy = pointerCoords.y - newElement2.y;
          const lastPoint = points.length > 0 && points[points.length - 1];
          const discardPoint = lastPoint && lastPoint[0] === dx && lastPoint[1] === dy;
          if (!discardPoint) {
            const pressures = newElement2.simulatePressure ? newElement2.pressures : [...newElement2.pressures, event.pressure];
            mutateElement(
              newElement2,
              {
                points: [...points, pointFrom(dx, dy)],
                pressures
              },
              false
            );
            this.setState({
              newElement: newElement2
            });
          }
        } else if (isLinearElement(newElement2)) {
          pointerDownState.drag.hasOccurred = true;
          const points = newElement2.points;
          let dx = gridX - newElement2.x;
          let dy = gridY - newElement2.y;
          if (shouldRotateWithDiscreteAngle(event) && points.length === 2) {
            ({ width: dx, height: dy } = getLockedLinearCursorAlignSize(
              newElement2.x,
              newElement2.y,
              pointerCoords.x,
              pointerCoords.y
            ));
          }
          if (points.length === 1) {
            mutateElement(
              newElement2,
              {
                points: [...points, pointFrom(dx, dy)]
              },
              false
            );
          } else if (points.length > 1 && isElbowArrow(newElement2)) {
            mutateElbowArrow(
              newElement2,
              elementsMap,
              [...points.slice(0, -1), pointFrom(dx, dy)],
              vector(0, 0),
              void 0,
              {
                isDragging: true,
                informMutation: false
              }
            );
          } else if (points.length === 2) {
            mutateElement(
              newElement2,
              {
                points: [...points.slice(0, -1), pointFrom(dx, dy)]
              },
              false
            );
          }
          this.setState({
            newElement: newElement2
          });
          if (isBindingElement(newElement2, false)) {
            this.maybeSuggestBindingsForLinearElementAtCoords(
              newElement2,
              [pointerCoords],
              this.state.startBoundElement
            );
          }
        } else {
          pointerDownState.lastCoords.x = pointerCoords.x;
          pointerDownState.lastCoords.y = pointerCoords.y;
          this.maybeDragNewGenericElement(pointerDownState, event, false);
        }
      }
      if (this.state.activeTool.type === "selection") {
        pointerDownState.boxSelection.hasOccurred = true;
        const elements = this.scene.getNonDeletedElements();
        if (this.state.editingLinearElement) {
          LinearElementEditor.handleBoxSelection(
            event,
            this.state,
            this.setState.bind(this),
            this.scene.getNonDeletedElementsMap()
          );
        } else {
          let shouldReuseSelection = true;
          if (!event.shiftKey && isSomeElementSelected(elements, this.state)) {
            if (pointerDownState.withCmdOrCtrl && pointerDownState.hit.element) {
              this.setState(
                (prevState) => selectGroupsForSelectedElements(
                  {
                    ...prevState,
                    selectedElementIds: {
                      [pointerDownState.hit.element.id]: true
                    }
                  },
                  this.scene.getNonDeletedElements(),
                  prevState,
                  this
                )
              );
            } else {
              shouldReuseSelection = false;
            }
          }
          const elementsWithinSelection = this.state.selectionElement ? getElementsWithinSelection(
            elements,
            this.state.selectionElement,
            this.scene.getNonDeletedElementsMap()
          ) : [];
          this.setState((prevState) => {
            const nextSelectedElementIds = {
              ...shouldReuseSelection && prevState.selectedElementIds,
              ...elementsWithinSelection.reduce(
                (acc, element) => {
                  acc[element.id] = true;
                  return acc;
                },
                {}
              )
            };
            if (pointerDownState.hit.element) {
              if (!elementsWithinSelection.length) {
                nextSelectedElementIds[pointerDownState.hit.element.id] = true;
              } else {
                delete nextSelectedElementIds[pointerDownState.hit.element.id];
              }
            }
            prevState = !shouldReuseSelection ? { ...prevState, selectedGroupIds: {}, editingGroupId: null } : prevState;
            return {
              ...selectGroupsForSelectedElements(
                {
                  editingGroupId: prevState.editingGroupId,
                  selectedElementIds: nextSelectedElementIds
                },
                this.scene.getNonDeletedElements(),
                prevState,
                this
              ),
              // select linear element only when we haven't box-selected anything else
              selectedLinearElement: elementsWithinSelection.length === 1 && isLinearElement(elementsWithinSelection[0]) ? new LinearElementEditor(elementsWithinSelection[0]) : null,
              showHyperlinkPopup: elementsWithinSelection.length === 1 && (elementsWithinSelection[0].link || isEmbeddableElement(elementsWithinSelection[0])) ? "info" : false
            };
          });
        }
      }
    });
  }
  // Returns whether the pointer move happened over either scrollbar
  handlePointerMoveOverScrollbars(event, pointerDownState) {
    if (pointerDownState.scrollbars.isOverHorizontal) {
      const x3 = event.clientX;
      const dx = x3 - pointerDownState.lastCoords.x;
      this.translateCanvas({
        scrollX: this.state.scrollX - dx / this.state.zoom.value
      });
      pointerDownState.lastCoords.x = x3;
      return true;
    }
    if (pointerDownState.scrollbars.isOverVertical) {
      const y3 = event.clientY;
      const dy = y3 - pointerDownState.lastCoords.y;
      this.translateCanvas({
        scrollY: this.state.scrollY - dy / this.state.zoom.value
      });
      pointerDownState.lastCoords.y = y3;
      return true;
    }
    return false;
  }
  onPointerUpFromPointerDownHandler(pointerDownState) {
    return withBatchedUpdates((childEvent) => {
      this.removePointer(childEvent);
      if (pointerDownState.eventListeners.onMove) {
        pointerDownState.eventListeners.onMove.flush();
      }
      const {
        newElement: newElement2,
        resizingElement,
        multiElement,
        activeTool,
        isResizing,
        isRotating
      } = this.state;
      this.setState((prevState) => ({
        isResizing: false,
        isRotating: false,
        resizingElement: null,
        selectionElement: null,
        frameToHighlight: null,
        elementsToHighlight: null,
        cursorButton: "up",
        snapLines: updateStable(prevState.snapLines, []),
        originSnapOffset: null
      }));
      SnapCache.setReferenceSnapPoints(null);
      SnapCache.setVisibleGaps(null);
      this.savePointer(childEvent.clientX, childEvent.clientY, "up");
      this.setState({
        selectedElementsAreBeingDragged: false
      });
      const elementsMap = this.scene.getNonDeletedElementsMap();
      if (this.state.editingLinearElement) {
        if (!pointerDownState.boxSelection.hasOccurred && pointerDownState.hit?.element?.id !== this.state.editingLinearElement.elementId) {
          this.actionManager.executeAction(actionFinalize);
        } else {
          const editingLinearElement = LinearElementEditor.handlePointerUp(
            childEvent,
            this.state.editingLinearElement,
            this.state,
            this.scene
          );
          if (editingLinearElement !== this.state.editingLinearElement) {
            this.setState({
              editingLinearElement,
              suggestedBindings: []
            });
          }
        }
      } else if (this.state.selectedLinearElement) {
        if (pointerDownState.hit?.element?.id !== this.state.selectedLinearElement.elementId) {
          const selectedELements = this.scene.getSelectedElements(this.state);
          if (selectedELements.length > 1) {
            this.setState({ selectedLinearElement: null });
          }
        } else {
          const linearElementEditor = LinearElementEditor.handlePointerUp(
            childEvent,
            this.state.selectedLinearElement,
            this.state,
            this.scene
          );
          const { startBindingElement, endBindingElement } = linearElementEditor;
          const element = this.scene.getElement(linearElementEditor.elementId);
          if (isBindingElement(element)) {
            bindOrUnbindLinearElement(
              element,
              startBindingElement,
              endBindingElement,
              elementsMap,
              this.scene
            );
          }
          if (linearElementEditor !== this.state.selectedLinearElement) {
            this.setState({
              selectedLinearElement: {
                ...linearElementEditor,
                selectedPointsIndices: null
              },
              suggestedBindings: []
            });
          }
        }
      }
      this.missingPointerEventCleanupEmitter.clear();
      window.removeEventListener(
        "pointermove" /* POINTER_MOVE */,
        pointerDownState.eventListeners.onMove
      );
      window.removeEventListener(
        "pointerup" /* POINTER_UP */,
        pointerDownState.eventListeners.onUp
      );
      window.removeEventListener(
        "keydown" /* KEYDOWN */,
        pointerDownState.eventListeners.onKeyDown
      );
      window.removeEventListener(
        "keyup" /* KEYUP */,
        pointerDownState.eventListeners.onKeyUp
      );
      if (this.state.pendingImageElementId) {
        this.setState({ pendingImageElementId: null });
      }
      this.props?.onPointerUp?.(activeTool, pointerDownState);
      this.onPointerUpEmitter.trigger(
        this.state.activeTool,
        pointerDownState,
        childEvent
      );
      if (newElement2?.type === "freedraw") {
        const pointerCoords = viewportCoordsToSceneCoords(
          childEvent,
          this.state
        );
        const points = newElement2.points;
        let dx = pointerCoords.x - newElement2.x;
        let dy = pointerCoords.y - newElement2.y;
        if (dx === points[0][0] && dy === points[0][1]) {
          dy += 1e-4;
          dx += 1e-4;
        }
        const pressures = newElement2.simulatePressure ? [] : [...newElement2.pressures, childEvent.pressure];
        mutateElement(newElement2, {
          points: [...points, pointFrom(dx, dy)],
          pressures,
          lastCommittedPoint: pointFrom(dx, dy)
        });
        this.actionManager.executeAction(actionFinalize);
        return;
      }
      if (isImageElement(newElement2)) {
        const imageElement = newElement2;
        try {
          this.initializeImageDimensions(imageElement);
          this.setState(
            {
              selectedElementIds: makeNextSelectedElementIds(
                { [imageElement.id]: true },
                this.state
              )
            },
            () => {
              this.actionManager.executeAction(actionFinalize);
            }
          );
        } catch (error) {
          console.error(error);
          this.scene.replaceAllElements(
            this.scene.getElementsIncludingDeleted().filter((el) => el.id !== imageElement.id)
          );
          this.actionManager.executeAction(actionFinalize);
        }
        return;
      }
      if (isLinearElement(newElement2)) {
        if (newElement2.points.length > 1) {
          this.store.shouldCaptureIncrement();
        }
        const pointerCoords = viewportCoordsToSceneCoords(
          childEvent,
          this.state
        );
        if (!pointerDownState.drag.hasOccurred && newElement2 && !multiElement) {
          mutateElement(newElement2, {
            points: [
              ...newElement2.points,
              pointFrom(
                pointerCoords.x - newElement2.x,
                pointerCoords.y - newElement2.y
              )
            ]
          });
          this.setState({
            multiElement: newElement2,
            newElement: newElement2
          });
        } else if (pointerDownState.drag.hasOccurred && !multiElement) {
          if (isBindingEnabled(this.state) && isBindingElement(newElement2, false)) {
            maybeBindLinearElement(
              newElement2,
              this.state,
              pointerCoords,
              this.scene.getNonDeletedElementsMap(),
              this.scene.getNonDeletedElements()
            );
          }
          this.setState({ suggestedBindings: [], startBoundElement: null });
          if (!activeTool.locked) {
            resetCursor(this.interactiveCanvas);
            this.setState((prevState) => ({
              newElement: null,
              activeTool: updateActiveTool(this.state, {
                type: "selection"
              }),
              selectedElementIds: makeNextSelectedElementIds(
                {
                  ...prevState.selectedElementIds,
                  [newElement2.id]: true
                },
                prevState
              ),
              selectedLinearElement: new LinearElementEditor(newElement2)
            }));
          } else {
            this.setState((prevState) => ({
              newElement: null
            }));
          }
          this.scene.triggerUpdate();
        }
        return;
      }
      if (isTextElement(newElement2)) {
        const minWidth = getMinTextElementWidth(
          getFontString({
            fontSize: newElement2.fontSize,
            fontFamily: newElement2.fontFamily
          }),
          newElement2.lineHeight
        );
        if (newElement2.width < minWidth) {
          mutateElement(newElement2, {
            autoResize: true
          });
        }
        this.resetCursor();
        this.handleTextWysiwyg(newElement2, {
          isExistingElement: true
        });
      }
      if (activeTool.type !== "selection" && newElement2 && isInvisiblySmallElement(newElement2)) {
        this.updateScene({
          elements: this.scene.getElementsIncludingDeleted().filter((el) => el.id !== newElement2.id),
          appState: {
            newElement: null
          },
          storeAction: StoreAction.UPDATE
        });
        return;
      }
      if (isFrameLikeElement(newElement2)) {
        const elementsInsideFrame = getElementsInNewFrame(
          this.scene.getElementsIncludingDeleted(),
          newElement2,
          this.scene.getNonDeletedElementsMap()
        );
        this.scene.replaceAllElements(
          addElementsToFrame(
            this.scene.getElementsMapIncludingDeleted(),
            elementsInsideFrame,
            newElement2
          )
        );
      }
      if (newElement2) {
        mutateElement(newElement2, getNormalizedDimensions(newElement2));
        this.scene.triggerUpdate();
      }
      if (pointerDownState.drag.hasOccurred) {
        const sceneCoords = viewportCoordsToSceneCoords(childEvent, this.state);
        if (this.state.selectedLinearElement && this.state.selectedLinearElement.isDragging) {
          const linearElement = this.scene.getElement(
            this.state.selectedLinearElement.elementId
          );
          if (linearElement?.frameId) {
            const frame = getContainingFrame(linearElement, elementsMap);
            if (frame && linearElement) {
              if (!elementOverlapsWithFrame(
                linearElement,
                frame,
                this.scene.getNonDeletedElementsMap()
              )) {
                mutateElement(linearElement, {
                  groupIds: []
                });
                removeElementsFromFrame(
                  [linearElement],
                  this.scene.getNonDeletedElementsMap()
                );
                this.scene.triggerUpdate();
              }
            }
          }
        } else {
          const topLayerFrame = this.getTopLayerFrameAtSceneCoords(sceneCoords);
          const selectedElements = this.scene.getSelectedElements(this.state);
          let nextElements = this.scene.getElementsMapIncludingDeleted();
          const updateGroupIdsAfterEditingGroup = (elements) => {
            if (elements.length > 0) {
              for (const element of elements) {
                const index2 = element.groupIds.indexOf(
                  this.state.editingGroupId
                );
                mutateElement(
                  element,
                  {
                    groupIds: element.groupIds.slice(0, index2)
                  },
                  false
                );
              }
              nextElements.forEach((element) => {
                if (element.groupIds.length && getElementsInGroup(
                  nextElements,
                  element.groupIds[element.groupIds.length - 1]
                ).length < 2) {
                  mutateElement(
                    element,
                    {
                      groupIds: []
                    },
                    false
                  );
                }
              });
              this.setState({
                editingGroupId: null
              });
            }
          };
          if (topLayerFrame && !this.state.selectedElementIds[topLayerFrame.id]) {
            const elementsToAdd = selectedElements.filter(
              (element) => element.frameId !== topLayerFrame.id && isElementInFrame(element, nextElements, this.state)
            );
            if (this.state.editingGroupId) {
              updateGroupIdsAfterEditingGroup(elementsToAdd);
            }
            nextElements = addElementsToFrame(
              nextElements,
              elementsToAdd,
              topLayerFrame
            );
          } else if (!topLayerFrame) {
            if (this.state.editingGroupId) {
              const elementsToRemove = selectedElements.filter(
                (element) => element.frameId && !isElementInFrame(element, nextElements, this.state)
              );
              updateGroupIdsAfterEditingGroup(elementsToRemove);
            }
          }
          nextElements = updateFrameMembershipOfSelectedElements(
            nextElements,
            this.state,
            this
          );
          this.scene.replaceAllElements(nextElements);
        }
      }
      if (resizingElement) {
        this.store.shouldCaptureIncrement();
      }
      if (resizingElement && isInvisiblySmallElement(resizingElement)) {
        this.updateScene({
          elements: this.scene.getElementsIncludingDeleted().filter((el) => el.id !== resizingElement.id),
          storeAction: StoreAction.UPDATE
        });
      }
      if (pointerDownState.resize.isResizing) {
        let nextElements = updateFrameMembershipOfSelectedElements(
          this.scene.getElementsIncludingDeleted(),
          this.state,
          this
        );
        const selectedFrames = this.scene.getSelectedElements(this.state).filter(
          (element) => isFrameLikeElement(element)
        );
        for (const frame of selectedFrames) {
          nextElements = replaceAllElementsInFrame(
            nextElements,
            getElementsInResizingFrame(
              this.scene.getElementsIncludingDeleted(),
              frame,
              this.state,
              elementsMap
            ),
            frame,
            this
          );
        }
        this.scene.replaceAllElements(nextElements);
      }
      const hitElement = pointerDownState.hit.element;
      if (this.state.selectedLinearElement?.elementId !== hitElement?.id && isLinearElement(hitElement)) {
        const selectedELements = this.scene.getSelectedElements(this.state);
        if (selectedELements.length === 1) {
          this.setState({
            selectedLinearElement: new LinearElementEditor(hitElement)
          });
        }
      }
      const pointerStart = this.lastPointerDownEvent;
      const pointerEnd = this.lastPointerUpEvent || this.lastPointerMoveEvent;
      if (isEraserActive(this.state) && pointerStart && pointerEnd) {
        this.eraserTrail.endPath();
        const draggedDistance = pointDistance(
          pointFrom(pointerStart.clientX, pointerStart.clientY),
          pointFrom(pointerEnd.clientX, pointerEnd.clientY)
        );
        if (draggedDistance === 0) {
          const scenePointer = viewportCoordsToSceneCoords(
            {
              clientX: pointerEnd.clientX,
              clientY: pointerEnd.clientY
            },
            this.state
          );
          const hitElements = this.getElementsAtPosition(
            scenePointer.x,
            scenePointer.y
          );
          hitElements.forEach(
            (hitElement2) => this.elementsPendingErasure.add(hitElement2.id)
          );
        }
        this.eraseElements();
        return;
      } else if (this.elementsPendingErasure.size) {
        this.restoreReadyToEraseElements();
      }
      if (hitElement && !pointerDownState.drag.hasOccurred && !pointerDownState.hit.wasAddedToSelection && // if we're editing a line, pointerup shouldn't switch selection if
      // box selected
      (!this.state.editingLinearElement || !pointerDownState.boxSelection.hasOccurred)) {
        if (childEvent.shiftKey && !this.state.editingLinearElement) {
          if (this.state.selectedElementIds[hitElement.id]) {
            if (isSelectedViaGroup(this.state, hitElement)) {
              this.setState((_prevState) => {
                const nextSelectedElementIds = {
                  ..._prevState.selectedElementIds
                };
                for (const groupedElement of hitElement.groupIds.flatMap(
                  (groupId) => getElementsInGroup(
                    this.scene.getNonDeletedElements(),
                    groupId
                  )
                )) {
                  delete nextSelectedElementIds[groupedElement.id];
                }
                return {
                  selectedGroupIds: {
                    ..._prevState.selectedElementIds,
                    ...hitElement.groupIds.map((gId) => ({ [gId]: false })).reduce((prev, acc) => ({ ...prev, ...acc }), {})
                  },
                  selectedElementIds: makeNextSelectedElementIds(
                    nextSelectedElementIds,
                    _prevState
                  )
                };
              });
            } else if (!this.state.selectedLinearElement?.isDragging) {
              this.setState((prevState) => {
                const newSelectedElementIds = {
                  ...prevState.selectedElementIds
                };
                delete newSelectedElementIds[hitElement.id];
                const newSelectedElements = getSelectedElements(
                  this.scene.getNonDeletedElements(),
                  { selectedElementIds: newSelectedElementIds }
                );
                return {
                  ...selectGroupsForSelectedElements(
                    {
                      editingGroupId: prevState.editingGroupId,
                      selectedElementIds: newSelectedElementIds
                    },
                    this.scene.getNonDeletedElements(),
                    prevState,
                    this
                  ),
                  // set selectedLinearElement only if thats the only element selected
                  selectedLinearElement: newSelectedElements.length === 1 && isLinearElement(newSelectedElements[0]) ? new LinearElementEditor(newSelectedElements[0]) : prevState.selectedLinearElement
                };
              });
            }
          } else if (hitElement.frameId && this.state.selectedElementIds[hitElement.frameId]) {
            this.setState((prevState) => {
              const nextSelectedElementIds = {
                ...prevState.selectedElementIds,
                [hitElement.id]: true
              };
              delete nextSelectedElementIds[hitElement.frameId];
              (this.scene.getElement(hitElement.frameId)?.groupIds ?? []).flatMap(
                (gid) => getElementsInGroup(this.scene.getNonDeletedElements(), gid)
              ).forEach((element) => {
                delete nextSelectedElementIds[element.id];
              });
              return {
                ...selectGroupsForSelectedElements(
                  {
                    editingGroupId: prevState.editingGroupId,
                    selectedElementIds: nextSelectedElementIds
                  },
                  this.scene.getNonDeletedElements(),
                  prevState,
                  this
                ),
                showHyperlinkPopup: hitElement.link || isEmbeddableElement(hitElement) ? "info" : false
              };
            });
          } else {
            this.setState((_prevState) => ({
              selectedElementIds: makeNextSelectedElementIds(
                {
                  ..._prevState.selectedElementIds,
                  [hitElement.id]: true
                },
                _prevState
              )
            }));
          }
        } else {
          this.setState((prevState) => ({
            ...selectGroupsForSelectedElements(
              {
                editingGroupId: prevState.editingGroupId,
                selectedElementIds: { [hitElement.id]: true }
              },
              this.scene.getNonDeletedElements(),
              prevState,
              this
            ),
            selectedLinearElement: isLinearElement(hitElement) && // Don't set `selectedLinearElement` if its same as the hitElement, this is mainly to prevent resetting the `hoverPointIndex` to -1.
            // Future we should update the API to take care of setting the correct `hoverPointIndex` when initialized
            prevState.selectedLinearElement?.elementId !== hitElement.id ? new LinearElementEditor(hitElement) : prevState.selectedLinearElement
          }));
        }
      }
      if (
        // not dragged
        !pointerDownState.drag.hasOccurred && // not resized
        !this.state.isResizing && // only hitting the bounding box of the previous hit element
        (hitElement && hitElementBoundingBoxOnly(
          {
            x: pointerDownState.origin.x,
            y: pointerDownState.origin.y,
            element: hitElement,
            shape: getElementShape(
              hitElement,
              this.scene.getNonDeletedElementsMap()
            ),
            threshold: this.getElementHitThreshold(),
            frameNameBound: isFrameLikeElement(hitElement) ? this.frameNameBoundsCache.get(hitElement) : null
          },
          elementsMap
        ) || !hitElement && pointerDownState.hit.hasHitCommonBoundingBoxOfSelectedElements)
      ) {
        if (this.state.editingLinearElement) {
          this.setState({ editingLinearElement: null });
        } else {
          this.setState({
            selectedElementIds: makeNextSelectedElementIds({}, this.state),
            selectedGroupIds: {},
            editingGroupId: null,
            activeEmbeddable: null
          });
        }
        setCursor(this.interactiveCanvas, CURSOR_TYPE.AUTO);
        return;
      }
      if (!activeTool.locked && activeTool.type !== "freedraw" && newElement2) {
        this.setState((prevState) => ({
          selectedElementIds: makeNextSelectedElementIds(
            {
              ...prevState.selectedElementIds,
              [newElement2.id]: true
            },
            prevState
          ),
          showHyperlinkPopup: isEmbeddableElement(newElement2) && !newElement2.link ? "editor" : prevState.showHyperlinkPopup
        }));
      }
      if (activeTool.type !== "selection" || isSomeElementSelected(this.scene.getNonDeletedElements(), this.state) || !isShallowEqual(
        this.state.previousSelectedElementIds,
        this.state.selectedElementIds
      )) {
        this.store.shouldCaptureIncrement();
      }
      if (pointerDownState.drag.hasOccurred || isResizing || isRotating) {
        const linearElements = this.scene.getSelectedElements(this.state).filter(isLinearElement);
        bindOrUnbindLinearElements(
          linearElements,
          this.scene.getNonDeletedElementsMap(),
          this.scene.getNonDeletedElements(),
          this.scene,
          isBindingEnabled(this.state),
          this.state.selectedLinearElement?.selectedPointsIndices ?? []
        );
      }
      if (activeTool.type === "laser") {
        this.laserTrails.endPath();
        return;
      }
      if (!activeTool.locked && activeTool.type !== "freedraw") {
        resetCursor(this.interactiveCanvas);
        this.setState({
          newElement: null,
          suggestedBindings: [],
          activeTool: updateActiveTool(this.state, { type: "selection" })
        });
      } else {
        this.setState({
          newElement: null,
          suggestedBindings: []
        });
      }
      if (hitElement && this.lastPointerUpEvent && this.lastPointerDownEvent && this.lastPointerUpEvent.timeStamp - this.lastPointerDownEvent.timeStamp < 300 && gesture.pointers.size <= 1 && isIframeLikeElement(hitElement) && this.isIframeLikeElementCenter(
        hitElement,
        this.lastPointerUpEvent,
        pointerDownState.origin.x,
        pointerDownState.origin.y
      )) {
        this.handleEmbeddableCenterClick(hitElement);
      }
    });
  }
  restoreReadyToEraseElements = () => {
    this.elementsPendingErasure = /* @__PURE__ */ new Set();
    this.triggerRender();
  };
  eraseElements = () => {
    let didChange = false;
    const elements = this.scene.getElementsIncludingDeleted().map((ele) => {
      if (this.elementsPendingErasure.has(ele.id) || ele.frameId && this.elementsPendingErasure.has(ele.frameId) || isBoundToContainer(ele) && this.elementsPendingErasure.has(ele.containerId)) {
        didChange = true;
        return newElementWith(ele, { isDeleted: true });
      }
      return ele;
    });
    this.elementsPendingErasure = /* @__PURE__ */ new Set();
    if (didChange) {
      this.store.shouldCaptureIncrement();
      this.scene.replaceAllElements(elements);
    }
  };
  initializeImage = async ({
    imageFile,
    imageElement: _imageElement,
    showCursorImagePreview = false
  }) => {
    if (!isSupportedImageFile(imageFile)) {
      throw new Error(t("errors.unsupportedFileType"));
    }
    const mimeType = imageFile.type;
    setCursor(this.interactiveCanvas, "wait");
    if (mimeType === MIME_TYPES.svg) {
      try {
        imageFile = SVGStringToFile(
          await normalizeSVG(await imageFile.text()),
          imageFile.name
        );
      } catch (error) {
        console.warn(error);
        throw new Error(t("errors.svgImageInsertError"));
      }
    }
    const fileId = await (this.props.generateIdForFile?.(
      imageFile
    ) || generateIdFromFile(imageFile));
    if (!fileId) {
      console.warn(
        "Couldn't generate file id or the supplied `generateIdForFile` didn't resolve to one."
      );
      throw new Error(t("errors.imageInsertError"));
    }
    const existingFileData = this.files[fileId];
    if (!existingFileData?.dataURL) {
      try {
        imageFile = await resizeImageFile(imageFile, {
          maxWidthOrHeight: DEFAULT_MAX_IMAGE_WIDTH_OR_HEIGHT
        });
      } catch (error) {
        console.error(
          "Error trying to resizing image file on insertion",
          error
        );
      }
      if (imageFile.size > MAX_ALLOWED_FILE_BYTES) {
        throw new Error(
          t("errors.fileTooBig", {
            maxSize: `${Math.trunc(MAX_ALLOWED_FILE_BYTES / 1024 / 1024)}MB`
          })
        );
      }
    }
    if (showCursorImagePreview) {
      const dataURL2 = this.files[fileId]?.dataURL;
      const resizedFile = dataURL2 && dataURLToFile(dataURL2);
      this.setImagePreviewCursor(resizedFile || imageFile);
    }
    const dataURL = this.files[fileId]?.dataURL || await getDataURL(imageFile);
    const imageElement = mutateElement(
      _imageElement,
      {
        fileId
      },
      false
    );
    return new Promise(
      async (resolve, reject) => {
        try {
          this.files = {
            ...this.files,
            [fileId]: {
              mimeType,
              id: fileId,
              dataURL,
              created: Date.now(),
              lastRetrieved: Date.now()
            }
          };
          const cachedImageData = this.imageCache.get(fileId);
          if (!cachedImageData) {
            this.addNewImagesToImageCache();
            await this.updateImageCache([imageElement]);
          }
          if (cachedImageData?.image instanceof Promise) {
            await cachedImageData.image;
          }
          if (this.state.pendingImageElementId !== imageElement.id && this.state.newElement?.id !== imageElement.id) {
            this.initializeImageDimensions(imageElement, true);
          }
          resolve(imageElement);
        } catch (error) {
          console.error(error);
          reject(new Error(t("errors.imageInsertError")));
        } finally {
          if (!showCursorImagePreview) {
            resetCursor(this.interactiveCanvas);
          }
        }
      }
    );
  };
  /**
   * inserts image into elements array and rerenders
   */
  insertImageElement = async (imageElement, imageFile, showCursorImagePreview) => {
    if (!this.isToolSupported("image")) {
      this.setState({ errorMessage: t("errors.imageToolNotSupported") });
      return;
    }
    this.scene.insertElement(imageElement);
    try {
      return await this.initializeImage({
        imageFile,
        imageElement,
        showCursorImagePreview
      });
    } catch (error) {
      mutateElement(imageElement, {
        isDeleted: true
      });
      this.actionManager.executeAction(actionFinalize);
      this.setState({
        errorMessage: error.message || t("errors.imageInsertError")
      });
      return null;
    }
  };
  setImagePreviewCursor = async (imageFile) => {
    const cursorImageSizePx = 96;
    let imagePreview;
    try {
      imagePreview = await resizeImageFile(imageFile, {
        maxWidthOrHeight: cursorImageSizePx
      });
    } catch (e3) {
      if (e3.cause === "UNSUPPORTED") {
        throw new Error(t("errors.unsupportedFileType"));
      }
      throw e3;
    }
    let previewDataURL = await getDataURL(imagePreview);
    if (imageFile.type === MIME_TYPES.svg) {
      const img = await loadHTMLImageElement(previewDataURL);
      let height = Math.min(img.height, cursorImageSizePx);
      let width = height * (img.width / img.height);
      if (width > cursorImageSizePx) {
        width = cursorImageSizePx;
        height = width * (img.height / img.width);
      }
      const canvas = document.createElement("canvas");
      canvas.height = height;
      canvas.width = width;
      const context = canvas.getContext("2d");
      context.drawImage(img, 0, 0, width, height);
      previewDataURL = canvas.toDataURL(MIME_TYPES.svg);
    }
    if (this.state.pendingImageElementId) {
      setCursor(this.interactiveCanvas, `url(${previewDataURL}) 4 4, auto`);
    }
  };
  onImageAction = async ({
    insertOnCanvasDirectly
  }) => {
    try {
      const clientX = this.state.width / 2 + this.state.offsetLeft;
      const clientY = this.state.height / 2 + this.state.offsetTop;
      const { x: x3, y: y3 } = viewportCoordsToSceneCoords(
        { clientX, clientY },
        this.state
      );
      const imageFile = await fileOpen({
        description: "Image",
        extensions: Object.keys(
          IMAGE_MIME_TYPES
        )
      });
      const imageElement = this.createImageElement({
        sceneX: x3,
        sceneY: y3,
        addToFrameUnderCursor: false
      });
      if (insertOnCanvasDirectly) {
        this.insertImageElement(imageElement, imageFile);
        this.initializeImageDimensions(imageElement);
        this.setState(
          {
            selectedElementIds: makeNextSelectedElementIds(
              { [imageElement.id]: true },
              this.state
            )
          },
          () => {
            this.actionManager.executeAction(actionFinalize);
          }
        );
      } else {
        this.setState(
          {
            pendingImageElementId: imageElement.id
          },
          () => {
            this.insertImageElement(
              imageElement,
              imageFile,
              /* showCursorImagePreview */
              true
            );
          }
        );
      }
    } catch (error) {
      if (error.name !== "AbortError") {
        console.error(error);
      } else {
        console.warn(error);
      }
      this.setState(
        {
          pendingImageElementId: null,
          newElement: null,
          activeTool: updateActiveTool(this.state, { type: "selection" })
        },
        () => {
          this.actionManager.executeAction(actionFinalize);
        }
      );
    }
  };
  initializeImageDimensions = (imageElement, forceNaturalSize = false) => {
    const image = isInitializedImageElement(imageElement) && this.imageCache.get(imageElement.fileId)?.image;
    if (!image || image instanceof Promise) {
      if (imageElement.width < DRAGGING_THRESHOLD / this.state.zoom.value && imageElement.height < DRAGGING_THRESHOLD / this.state.zoom.value) {
        const placeholderSize = 100 / this.state.zoom.value;
        mutateElement(imageElement, {
          x: imageElement.x - placeholderSize / 2,
          y: imageElement.y - placeholderSize / 2,
          width: placeholderSize,
          height: placeholderSize
        });
      }
      return;
    }
    if (forceNaturalSize || // if user-created bounding box is below threshold, assume the
    // intention was to click instead of drag, and use the image's
    // intrinsic size
    imageElement.width < DRAGGING_THRESHOLD / this.state.zoom.value && imageElement.height < DRAGGING_THRESHOLD / this.state.zoom.value) {
      const minHeight = Math.max(this.state.height - 120, 160);
      const maxHeight = Math.min(
        minHeight,
        Math.floor(this.state.height * 0.5) / this.state.zoom.value
      );
      const height = Math.min(image.naturalHeight, maxHeight);
      const width = height * (image.naturalWidth / image.naturalHeight);
      const x3 = imageElement.x + imageElement.width / 2 - width / 2;
      const y3 = imageElement.y + imageElement.height / 2 - height / 2;
      mutateElement(imageElement, { x: x3, y: y3, width, height });
    }
  };
  /** updates image cache, refreshing updated elements and/or setting status
      to error for images that fail during <img> element creation */
  updateImageCache = async (elements, files = this.files) => {
    const { updatedFiles, erroredFiles } = await updateImageCache({
      imageCache: this.imageCache,
      fileIds: elements.map((element) => element.fileId),
      files
    });
    if (updatedFiles.size || erroredFiles.size) {
      for (const element of elements) {
        if (updatedFiles.has(element.fileId)) {
          ShapeCache.delete(element);
        }
      }
    }
    if (erroredFiles.size) {
      this.scene.replaceAllElements(
        this.scene.getElementsIncludingDeleted().map((element) => {
          if (isInitializedImageElement(element) && erroredFiles.has(element.fileId)) {
            return newElementWith(element, {
              status: "error"
            });
          }
          return element;
        })
      );
    }
    return { updatedFiles, erroredFiles };
  };
  /** adds new images to imageCache and re-renders if needed */
  addNewImagesToImageCache = async (imageElements = getInitializedImageElements(
    this.scene.getNonDeletedElements()
  ), files = this.files) => {
    const uncachedImageElements = imageElements.filter(
      (element) => !element.isDeleted && !this.imageCache.has(element.fileId)
    );
    if (uncachedImageElements.length) {
      const { updatedFiles } = await this.updateImageCache(
        uncachedImageElements,
        files
      );
      if (updatedFiles.size) {
        this.scene.triggerUpdate();
      }
    }
  };
  /** generally you should use `addNewImagesToImageCache()` directly if you need
   *  to render new images. This is just a failsafe  */
  scheduleImageRefresh = (0, import_lodash4.default)(() => {
    this.addNewImagesToImageCache();
  }, IMAGE_RENDER_TIMEOUT);
  updateBindingEnabledOnPointerMove = (event) => {
    const shouldEnableBinding = shouldEnableBindingForPointerEvent(event);
    if (this.state.isBindingEnabled !== shouldEnableBinding) {
      this.setState({ isBindingEnabled: shouldEnableBinding });
    }
  };
  maybeSuggestBindingAtCursor = (pointerCoords) => {
    const hoveredBindableElement = getHoveredElementForBinding(
      pointerCoords,
      this.scene.getNonDeletedElements(),
      this.scene.getNonDeletedElementsMap()
    );
    this.setState({
      suggestedBindings: hoveredBindableElement != null ? [hoveredBindableElement] : []
    });
  };
  maybeSuggestBindingsForLinearElementAtCoords = (linearElement, pointerCoords, oppositeBindingBoundElement) => {
    if (!pointerCoords.length) {
      return;
    }
    const suggestedBindings = pointerCoords.reduce(
      (acc, coords) => {
        const hoveredBindableElement = getHoveredElementForBinding(
          coords,
          this.scene.getNonDeletedElements(),
          this.scene.getNonDeletedElementsMap(),
          isArrowElement(linearElement) && isElbowArrow(linearElement)
        );
        if (hoveredBindableElement != null && !isLinearElementSimpleAndAlreadyBound(
          linearElement,
          oppositeBindingBoundElement?.id,
          hoveredBindableElement
        )) {
          acc.push(hoveredBindableElement);
        }
        return acc;
      },
      []
    );
    this.setState({ suggestedBindings });
  };
  clearSelection(hitElement) {
    this.setState((prevState) => ({
      selectedElementIds: makeNextSelectedElementIds({}, prevState),
      activeEmbeddable: null,
      selectedGroupIds: {},
      // Continue editing the same group if the user selected a different
      // element from it
      editingGroupId: prevState.editingGroupId && hitElement != null && isElementInGroup(hitElement, prevState.editingGroupId) ? prevState.editingGroupId : null
    }));
    this.setState({
      selectedElementIds: makeNextSelectedElementIds({}, this.state),
      activeEmbeddable: null,
      previousSelectedElementIds: this.state.selectedElementIds
    });
  }
  handleInteractiveCanvasRef = (canvas) => {
    if (canvas !== null) {
      this.interactiveCanvas = canvas;
      this.interactiveCanvas.addEventListener(
        "touchstart" /* TOUCH_START */,
        this.onTouchStart
      );
      this.interactiveCanvas.addEventListener("touchend" /* TOUCH_END */, this.onTouchEnd);
    } else {
      this.interactiveCanvas?.removeEventListener(
        "touchstart" /* TOUCH_START */,
        this.onTouchStart
      );
      this.interactiveCanvas?.removeEventListener(
        "touchend" /* TOUCH_END */,
        this.onTouchEnd
      );
    }
  };
  handleAppOnDrop = async (event) => {
    const { file, fileHandle } = await getFileFromEvent(event);
    const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(
      event,
      this.state
    );
    try {
      if (isSupportedImageFile(file) && this.isToolSupported("image")) {
        if (file?.type === MIME_TYPES.png || file?.type === MIME_TYPES.svg) {
          try {
            const scene = await loadFromBlob(
              file,
              this.state,
              this.scene.getElementsIncludingDeleted(),
              fileHandle
            );
            this.syncActionResult({
              ...scene,
              appState: {
                ...scene.appState || this.state,
                isLoading: false
              },
              replaceFiles: true,
              storeAction: StoreAction.CAPTURE
            });
            return;
          } catch (error) {
            if (error.name !== "EncodingError") {
              throw new Error(t("alerts.couldNotLoadInvalidFile"));
            }
          }
        }
        const imageElement = this.createImageElement({ sceneX, sceneY });
        this.insertImageElement(imageElement, file);
        this.initializeImageDimensions(imageElement);
        this.setState({
          selectedElementIds: makeNextSelectedElementIds(
            { [imageElement.id]: true },
            this.state
          )
        });
        return;
      }
    } catch (error) {
      return this.setState({
        isLoading: false,
        errorMessage: error.message
      });
    }
    const libraryJSON = event.dataTransfer.getData(MIME_TYPES.excalidrawlib);
    if (libraryJSON && typeof libraryJSON === "string") {
      try {
        const libraryItems = parseLibraryJSON(libraryJSON);
        this.addElementsFromPasteOrLibrary({
          elements: distributeLibraryItemsOnSquareGrid(libraryItems),
          position: event,
          files: null
        });
      } catch (error) {
        this.setState({ errorMessage: error.message });
      }
      return;
    }
    if (file) {
      await this.loadFileToCanvas(file, fileHandle);
    }
    if (event.dataTransfer?.types?.includes("text/plain")) {
      const text = event.dataTransfer?.getData("text");
      if (text && embeddableURLValidator(text, this.props.validateEmbeddable) && (/^(http|https):\/\/[^\s/$.?#].[^\s]*$/.test(text) || getEmbedLink(text)?.type === "video")) {
        const embeddable = this.insertEmbeddableElement({
          sceneX,
          sceneY,
          link: normalizeLink(text)
        });
        if (embeddable) {
          this.setState({ selectedElementIds: { [embeddable.id]: true } });
        }
      }
    }
  };
  loadFileToCanvas = async (file, fileHandle) => {
    file = await normalizeFile(file);
    try {
      const elements = this.scene.getElementsIncludingDeleted();
      let ret;
      try {
        ret = await loadSceneOrLibraryFromBlob(
          file,
          this.state,
          elements,
          fileHandle
        );
      } catch (error) {
        const imageSceneDataError = error instanceof ImageSceneDataError;
        if (imageSceneDataError && error.code === "IMAGE_NOT_CONTAINS_SCENE_DATA" && !this.isToolSupported("image")) {
          this.setState({
            isLoading: false,
            errorMessage: t("errors.imageToolNotSupported")
          });
          return;
        }
        const errorMessage = imageSceneDataError ? t("alerts.cannotRestoreFromImage") : t("alerts.couldNotLoadInvalidFile");
        this.setState({
          isLoading: false,
          errorMessage
        });
      }
      if (!ret) {
        return;
      }
      if (ret.type === MIME_TYPES.excalidraw) {
        syncInvalidIndices(elements.concat(ret.data.elements));
        this.store.updateSnapshot(arrayToMap(elements), this.state);
        this.setState({ isLoading: true });
        this.syncActionResult({
          ...ret.data,
          appState: {
            ...ret.data.appState || this.state,
            isLoading: false
          },
          replaceFiles: true,
          storeAction: StoreAction.CAPTURE
        });
      } else if (ret.type === MIME_TYPES.excalidrawlib) {
        await this.library.updateLibrary({
          libraryItems: file,
          merge: true,
          openLibraryMenu: true
        }).catch((error) => {
          console.error(error);
          this.setState({ errorMessage: t("errors.importLibraryError") });
        });
      }
    } catch (error) {
      this.setState({ isLoading: false, errorMessage: error.message });
    }
  };
  handleCanvasContextMenu = (event) => {
    event.preventDefault();
    if (("pointerType" in event.nativeEvent && event.nativeEvent.pointerType === "touch" || "pointerType" in event.nativeEvent && event.nativeEvent.pointerType === "pen" && // always allow if user uses a pen secondary button
    event.button !== POINTER_BUTTON.SECONDARY) && this.state.activeTool.type !== "selection") {
      return;
    }
    const { x: x3, y: y3 } = viewportCoordsToSceneCoords(event, this.state);
    const element = this.getElementAtPosition(x3, y3, {
      preferSelected: true,
      includeLockedElements: true
    });
    const selectedElements = this.scene.getSelectedElements(this.state);
    const isHittingCommonBoundBox = this.isHittingCommonBoundingBoxOfSelectedElements(
      { x: x3, y: y3 },
      selectedElements
    );
    const type = element || isHittingCommonBoundBox ? "element" : "canvas";
    const container = this.excalidrawContainerRef.current;
    const { top: offsetTop, left: offsetLeft } = container.getBoundingClientRect();
    const left = event.clientX - offsetLeft;
    const top = event.clientY - offsetTop;
    trackEvent("contextMenu", "openContextMenu", type);
    this.setState(
      {
        ...element && !this.state.selectedElementIds[element.id] ? {
          ...this.state,
          ...selectGroupsForSelectedElements(
            {
              editingGroupId: this.state.editingGroupId,
              selectedElementIds: { [element.id]: true }
            },
            this.scene.getNonDeletedElements(),
            this.state,
            this
          ),
          selectedLinearElement: isLinearElement(element) ? new LinearElementEditor(element) : null
        } : this.state,
        showHyperlinkPopup: false
      },
      () => {
        this.setState({
          contextMenu: { top, left, items: this.getContextMenuItems(type) }
        });
      }
    );
  };
  maybeDragNewGenericElement = (pointerDownState, event, informMutation = true) => {
    const selectionElement = this.state.selectionElement;
    const pointerCoords = pointerDownState.lastCoords;
    if (selectionElement && this.state.activeTool.type !== "eraser") {
      dragNewElement({
        newElement: selectionElement,
        elementType: this.state.activeTool.type,
        originX: pointerDownState.origin.x,
        originY: pointerDownState.origin.y,
        x: pointerCoords.x,
        y: pointerCoords.y,
        width: distance(pointerDownState.origin.x, pointerCoords.x),
        height: distance(pointerDownState.origin.y, pointerCoords.y),
        shouldMaintainAspectRatio: shouldMaintainAspectRatio(event),
        shouldResizeFromCenter: shouldResizeFromCenter(event),
        zoom: this.state.zoom.value,
        informMutation
      });
      return;
    }
    const newElement2 = this.state.newElement;
    if (!newElement2) {
      return;
    }
    let [gridX, gridY] = getGridPoint(
      pointerCoords.x,
      pointerCoords.y,
      event[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
    );
    const image = isInitializedImageElement(newElement2) && this.imageCache.get(newElement2.fileId)?.image;
    const aspectRatio = image && !(image instanceof Promise) ? image.width / image.height : null;
    this.maybeCacheReferenceSnapPoints(event, [newElement2]);
    const { snapOffset, snapLines } = snapNewElement(
      newElement2,
      this,
      event,
      {
        x: pointerDownState.originInGrid.x + (this.state.originSnapOffset?.x ?? 0),
        y: pointerDownState.originInGrid.y + (this.state.originSnapOffset?.y ?? 0)
      },
      {
        x: gridX - pointerDownState.originInGrid.x,
        y: gridY - pointerDownState.originInGrid.y
      },
      this.scene.getNonDeletedElementsMap()
    );
    gridX += snapOffset.x;
    gridY += snapOffset.y;
    this.setState({
      snapLines
    });
    dragNewElement({
      newElement: newElement2,
      elementType: this.state.activeTool.type,
      originX: pointerDownState.originInGrid.x,
      originY: pointerDownState.originInGrid.y,
      x: gridX,
      y: gridY,
      width: distance(pointerDownState.originInGrid.x, gridX),
      height: distance(pointerDownState.originInGrid.y, gridY),
      shouldMaintainAspectRatio: isImageElement(newElement2) ? !shouldMaintainAspectRatio(event) : shouldMaintainAspectRatio(event),
      shouldResizeFromCenter: shouldResizeFromCenter(event),
      zoom: this.state.zoom.value,
      widthAspectRatio: aspectRatio,
      originOffset: this.state.originSnapOffset,
      informMutation
    });
    this.setState({
      newElement: newElement2
    });
    if (this.state.activeTool.type === TOOL_TYPE.frame || this.state.activeTool.type === TOOL_TYPE.magicframe) {
      this.setState({
        elementsToHighlight: getElementsInResizingFrame(
          this.scene.getNonDeletedElements(),
          newElement2,
          this.state,
          this.scene.getNonDeletedElementsMap()
        )
      });
    }
  };
  maybeHandleResize = (pointerDownState, event) => {
    const selectedElements = this.scene.getSelectedElements(this.state);
    const selectedFrames = selectedElements.filter(
      (element) => isFrameLikeElement(element)
    );
    const transformHandleType = pointerDownState.resize.handleType;
    if (
      // Frames cannot be rotated.
      selectedFrames.length > 0 && transformHandleType === "rotation" || // Elbow arrows cannot be transformed (resized or rotated).
      selectedElements.length === 1 && isElbowArrow(selectedElements[0])
    ) {
      return false;
    }
    this.setState({
      // TODO: rename this state field to "isScaling" to distinguish
      // it from the generic "isResizing" which includes scaling and
      // rotating
      isResizing: transformHandleType && transformHandleType !== "rotation",
      isRotating: transformHandleType === "rotation",
      activeEmbeddable: null
    });
    const pointerCoords = pointerDownState.lastCoords;
    let [resizeX, resizeY] = getGridPoint(
      pointerCoords.x - pointerDownState.resize.offset.x,
      pointerCoords.y - pointerDownState.resize.offset.y,
      event[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
    );
    const frameElementsOffsetsMap = /* @__PURE__ */ new Map();
    selectedFrames.forEach((frame) => {
      const elementsInFrame = getFrameChildren(
        this.scene.getNonDeletedElements(),
        frame.id
      );
      elementsInFrame.forEach((element) => {
        frameElementsOffsetsMap.set(frame.id + element.id, {
          x: element.x - frame.x,
          y: element.y - frame.y
        });
      });
    });
    if (!this.state.selectedElementsAreBeingDragged) {
      const [gridX, gridY] = getGridPoint(
        pointerCoords.x,
        pointerCoords.y,
        event[KEYS.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()
      );
      const dragOffset = {
        x: gridX - pointerDownState.originInGrid.x,
        y: gridY - pointerDownState.originInGrid.y
      };
      const originalElements = [...pointerDownState.originalElements.values()];
      this.maybeCacheReferenceSnapPoints(event, selectedElements);
      const { snapOffset, snapLines } = snapResizingElements(
        selectedElements,
        getSelectedElements(originalElements, this.state),
        this,
        event,
        dragOffset,
        transformHandleType
      );
      resizeX += snapOffset.x;
      resizeY += snapOffset.y;
      this.setState({
        snapLines
      });
    }
    if (transformElements(
      pointerDownState.originalElements,
      transformHandleType,
      selectedElements,
      this.scene.getElementsMapIncludingDeleted(),
      shouldRotateWithDiscreteAngle(event),
      shouldResizeFromCenter(event),
      selectedElements.some((element) => isImageElement(element)) ? !shouldMaintainAspectRatio(event) : shouldMaintainAspectRatio(event),
      resizeX,
      resizeY,
      pointerDownState.resize.center.x,
      pointerDownState.resize.center.y
    )) {
      const suggestedBindings = getSuggestedBindingsForArrows(
        selectedElements,
        this.scene.getNonDeletedElementsMap()
      );
      const elementsToHighlight = /* @__PURE__ */ new Set();
      selectedFrames.forEach((frame) => {
        getElementsInResizingFrame(
          this.scene.getNonDeletedElements(),
          frame,
          this.state,
          this.scene.getNonDeletedElementsMap()
        ).forEach((element) => elementsToHighlight.add(element));
      });
      this.setState({
        elementsToHighlight: [...elementsToHighlight],
        suggestedBindings
      });
      return true;
    }
    return false;
  };
  getContextMenuItems = (type) => {
    const options = [];
    options.push(actionCopyAsPng, actionCopyAsSvg);
    if (type === "canvas") {
      if (this.state.viewModeEnabled) {
        return [
          ...options,
          actionToggleGridMode,
          actionToggleZenMode,
          actionToggleViewMode,
          actionToggleStats
        ];
      }
      return [
        actionPaste,
        CONTEXT_MENU_SEPARATOR,
        actionCopyAsPng,
        actionCopyAsSvg,
        copyText,
        CONTEXT_MENU_SEPARATOR,
        actionSelectAll,
        actionUnlockAllElements,
        CONTEXT_MENU_SEPARATOR,
        actionToggleGridMode,
        actionToggleObjectsSnapMode,
        actionToggleZenMode,
        actionToggleViewMode,
        actionToggleStats
      ];
    }
    options.push(copyText);
    if (this.state.viewModeEnabled) {
      return [actionCopy, ...options];
    }
    return [
      CONTEXT_MENU_SEPARATOR,
      actionCut,
      actionCopy,
      actionPaste,
      actionSelectAllElementsInFrame,
      actionRemoveAllElementsFromFrame,
      CONTEXT_MENU_SEPARATOR,
      ...options,
      CONTEXT_MENU_SEPARATOR,
      actionCopyStyles,
      actionPasteStyles,
      CONTEXT_MENU_SEPARATOR,
      actionGroup,
      actionTextAutoResize,
      actionUnbindText,
      actionBindText,
      actionWrapTextInContainer,
      actionUngroup,
      CONTEXT_MENU_SEPARATOR,
      actionAddToLibrary,
      CONTEXT_MENU_SEPARATOR,
      actionSendBackward,
      actionBringForward,
      actionSendToBack,
      actionBringToFront,
      CONTEXT_MENU_SEPARATOR,
      actionFlipHorizontal,
      actionFlipVertical,
      CONTEXT_MENU_SEPARATOR,
      actionToggleLinearEditor,
      actionLink,
      actionDuplicateSelection,
      actionToggleElementLock,
      CONTEXT_MENU_SEPARATOR,
      actionDeleteSelected
    ];
  };
  handleWheel = withBatchedUpdates(
    (event) => {
      if (!(event.target instanceof HTMLCanvasElement || event.target instanceof HTMLTextAreaElement || event.target instanceof HTMLIFrameElement)) {
        if (event[KEYS.CTRL_OR_CMD]) {
          event.preventDefault();
        }
        return;
      }
      event.preventDefault();
      if (isPanning) {
        return;
      }
      const { deltaX, deltaY } = event;
      if (event.metaKey || event.ctrlKey) {
        const sign = Math.sign(deltaY);
        const MAX_STEP = ZOOM_STEP * 100;
        const absDelta = Math.abs(deltaY);
        let delta = deltaY;
        if (absDelta > MAX_STEP) {
          delta = MAX_STEP * sign;
        }
        let newZoom = this.state.zoom.value - delta / 100;
        newZoom += Math.log10(Math.max(1, this.state.zoom.value)) * -sign * // reduced amplification for small deltas (small movements on a trackpad)
        Math.min(1, absDelta / 20);
        this.translateCanvas((state) => ({
          ...getStateForZoom(
            {
              viewportX: this.lastViewportPosition.x,
              viewportY: this.lastViewportPosition.y,
              nextZoom: getNormalizedZoom(newZoom)
            },
            state
          ),
          shouldCacheIgnoreZoom: true
        }));
        this.resetShouldCacheIgnoreZoomDebounced();
        return;
      }
      if (event.shiftKey) {
        this.translateCanvas(({ zoom, scrollX }) => ({
          // on Mac, shift+wheel tends to result in deltaX
          scrollX: scrollX - (deltaY || deltaX) / zoom.value
        }));
        return;
      }
      this.translateCanvas(({ zoom, scrollX, scrollY }) => ({
        scrollX: scrollX - deltaX / zoom.value,
        scrollY: scrollY - deltaY / zoom.value
      }));
    }
  );
  getTextWysiwygSnappedToCenterPosition(x3, y3, appState, container) {
    if (container) {
      let elementCenterX = container.x + container.width / 2;
      let elementCenterY = container.y + container.height / 2;
      const elementCenter = getContainerCenter(
        container,
        appState,
        this.scene.getNonDeletedElementsMap()
      );
      if (elementCenter) {
        elementCenterX = elementCenter.x;
        elementCenterY = elementCenter.y;
      }
      const distanceToCenter = Math.hypot(
        x3 - elementCenterX,
        y3 - elementCenterY
      );
      const isSnappedToCenter = distanceToCenter < TEXT_TO_CENTER_SNAP_THRESHOLD;
      if (isSnappedToCenter) {
        const { x: viewportX, y: viewportY } = sceneCoordsToViewportCoords(
          { sceneX: elementCenterX, sceneY: elementCenterY },
          appState
        );
        return { viewportX, viewportY, elementCenterX, elementCenterY };
      }
    }
  }
  savePointer = (x3, y3, button) => {
    if (!x3 || !y3) {
      return;
    }
    const { x: sceneX, y: sceneY } = viewportCoordsToSceneCoords(
      { clientX: x3, clientY: y3 },
      this.state
    );
    if (isNaN(sceneX) || isNaN(sceneY)) {
    }
    const pointer = {
      x: sceneX,
      y: sceneY,
      tool: this.state.activeTool.type === "laser" ? "laser" : "pointer"
    };
    this.props.onPointerUpdate?.({
      pointer,
      button,
      pointersMap: gesture.pointers
    });
  };
  resetShouldCacheIgnoreZoomDebounced = debounce(() => {
    if (!this.unmounted) {
      this.setState({ shouldCacheIgnoreZoom: false });
    }
  }, 300);
  updateDOMRect = (cb) => {
    if (this.excalidrawContainerRef?.current) {
      const excalidrawContainer = this.excalidrawContainerRef.current;
      const {
        width,
        height,
        left: offsetLeft,
        top: offsetTop
      } = excalidrawContainer.getBoundingClientRect();
      const {
        width: currentWidth,
        height: currentHeight,
        offsetTop: currentOffsetTop,
        offsetLeft: currentOffsetLeft
      } = this.state;
      if (width === currentWidth && height === currentHeight && offsetLeft === currentOffsetLeft && offsetTop === currentOffsetTop) {
        if (cb) {
          cb();
        }
        return;
      }
      this.setState(
        {
          width,
          height,
          offsetLeft,
          offsetTop
        },
        () => {
          cb && cb();
        }
      );
    }
  };
  refresh = () => {
    this.setState({ ...this.getCanvasOffsets() });
  };
  getCanvasOffsets() {
    if (this.excalidrawContainerRef?.current) {
      const excalidrawContainer = this.excalidrawContainerRef.current;
      const { left, top } = excalidrawContainer.getBoundingClientRect();
      return {
        offsetLeft: left,
        offsetTop: top
      };
    }
    return {
      offsetLeft: 0,
      offsetTop: 0
    };
  }
  async updateLanguage() {
    const currentLang2 = languages.find((lang) => lang.code === this.props.langCode) || defaultLang;
    await setLanguage(currentLang2);
    this.setAppState({});
  }
};
var createTestHook = () => {
  if (define_import_meta_env_default.MODE === ENV.TEST || define_import_meta_env_default.DEV) {
    window.h = window.h || {};
    Object.defineProperties(window.h, {
      elements: {
        configurable: true,
        get() {
          return this.app?.scene.getElementsIncludingDeleted();
        },
        set(elements) {
          return this.app?.scene.replaceAllElements(
            syncInvalidIndices(elements)
          );
        }
      },
      scene: {
        configurable: true,
        get() {
          return this.app?.scene;
        }
      }
    });
  }
};
createTestHook();
var App_default = App;

// polyfill.ts
init_define_import_meta_env();
var polyfill = () => {
  if (!Array.prototype.at) {
    Object.defineProperty(Array.prototype, "at", {
      value: function(n3) {
        n3 = Math.trunc(n3) || 0;
        if (n3 < 0) {
          n3 += this.length;
        }
        if (n3 < 0 || n3 >= this.length) {
          return void 0;
        }
        return this[n3];
      },
      writable: true,
      enumerable: false,
      configurable: true
    });
  }
  if (!Element.prototype.replaceChildren) {
    Element.prototype.replaceChildren = function(...nodes) {
      this.innerHTML = "";
      this.append(...nodes);
    };
  }
};
var polyfill_default = polyfill;

// components/footer/FooterCenter.tsx
init_define_import_meta_env();
var import_jsx_runtime147 = __toESM(require_jsx_runtime(), 1);
var FooterCenter = ({ children }) => {
  const { FooterCenterTunnel } = useTunnels();
  const appState = useUIAppState();
  return /* @__PURE__ */ (0, import_jsx_runtime147.jsx)(FooterCenterTunnel.In, { children: /* @__PURE__ */ (0, import_jsx_runtime147.jsx)(
    "div",
    {
      className: clsx_m_default("footer-center zen-mode-transition", {
        "layer-ui__wrapper__footer-left--transition-bottom": appState.zenModeEnabled
      }),
      children
    }
  ) });
};
var FooterCenter_default = FooterCenter;
FooterCenter.displayName = "FooterCenter";

// components/welcome-screen/WelcomeScreen.tsx
init_define_import_meta_env();

// components/welcome-screen/WelcomeScreen.Center.tsx
init_define_import_meta_env();

// components/ExcalidrawLogo.tsx
init_define_import_meta_env();
var import_jsx_runtime148 = __toESM(require_jsx_runtime(), 1);
var LogoIcon = () => /* @__PURE__ */ (0, import_jsx_runtime148.jsx)(
  "svg",
  {
    viewBox: "0 0 40 40",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    className: "ExcalidrawLogo-icon",
    children: /* @__PURE__ */ (0, import_jsx_runtime148.jsx)(
      "path",
      {
        d: "M39.9 32.889a.326.326 0 0 0-.279-.056c-2.094-3.083-4.774-6-7.343-8.833l-.419-.472a.212.212 0 0 0-.056-.139.586.586 0 0 0-.167-.111l-.084-.083-.056-.056c-.084-.167-.28-.278-.475-.167-.782.39-1.507.973-2.206 1.528-.92.722-1.842 1.445-2.708 2.25a8.405 8.405 0 0 0-.977 1.028c-.14.194-.028.361.14.444-.615.611-1.23 1.223-1.843 1.861a.315.315 0 0 0-.084.223c0 .083.056.166.111.194l1.09.833v.028c1.535 1.528 4.244 3.611 7.12 5.861.418.334.865.667 1.284 1 .195.223.39.473.558.695.084.11.28.139.391.055.056.056.14.111.196.167a.398.398 0 0 0 .167.056.255.255 0 0 0 .224-.111.394.394 0 0 0 .055-.167c.029 0 .028.028.056.028a.318.318 0 0 0 .224-.084l5.082-5.528a.309.309 0 0 0 0-.444Zm-14.63-1.917a.485.485 0 0 0 .111.14c.586.5 1.2 1 1.843 1.555l-2.569-1.945-.251-.166c-.056-.028-.112-.084-.168-.111l-.195-.167.056-.056.055-.055.112-.111c.866-.861 2.346-2.306 3.1-3.028-.81.805-2.43 3.167-2.095 3.944Zm8.767 6.89-2.122-1.612a44.713 44.713 0 0 0-2.625-2.5c1.145.861 2.122 1.611 2.262 1.75 1.117.972 1.06.806 1.815 1.445l.921.666a1.06 1.06 0 0 1-.251.25Zm.558.416-.056-.028c.084-.055.168-.111.252-.194l-.196.222ZM1.089 5.75c.055.361.14.722.195 1.056.335 1.833.67 3.5 1.284 4.75l.252.944c.084.361.223.806.363.917 1.424 1.25 3.602 3.11 5.947 4.889a.295.295 0 0 0 .363 0s0 .027.028.027a.254.254 0 0 0 .196.084.318.318 0 0 0 .223-.084c2.988-3.305 5.221-6.027 6.813-8.305.112-.111.14-.278.14-.417.111-.111.195-.25.307-.333.111-.111.111-.306 0-.39l-.028-.027c0-.055-.028-.139-.084-.167-.698-.666-1.2-1.138-1.731-1.638-.922-.862-1.871-1.75-3.881-3.75l-.028-.028c-.028-.028-.056-.056-.112-.056-.558-.194-1.703-.389-3.127-.639C6.087 2.223 3.21 1.723.614.944c0 0-.168 0-.196.028l-.083.084c-.028.027-.056.055-.224.11h.056-.056c.028.167.028.278.084.473 0 .055.112.5.112.555l.782 3.556Zm15.496 3.278-.335-.334c.084.112.196.195.335.334Zm-3.546 4.666-.056.056c0-.028.028-.056.056-.056Zm-2.038-10c.168.167.866.834 1.033.973-.726-.334-2.54-1.167-3.379-1.445.838.167 1.983.334 2.346.472ZM1.424 2.306c.419.722.754 3.222 1.089 5.666-.196-.778-.335-1.555-.503-2.278-.251-1.277-.503-2.416-.838-3.416.056 0 .14 0 .252.028Zm-.168-.584c-.112 0-.223-.028-.307-.028 0-.027 0-.055-.028-.055.14 0 .223.028.335.083Zm-1.089.222c0-.027 0-.027 0 0ZM39.453 1.333c.028-.11-.558-.61-.363-.639.42-.027.42-.666 0-.666-.558.028-1.144.166-1.675.25-.977.194-1.982.389-2.96.61-2.205.473-4.383.973-6.561 1.557-.67.194-1.424.333-2.066.666-.224.111-.196.333-.084.472-.056.028-.084.028-.14.056-.195.028-.363.056-.558.083-.168.028-.252.167-.224.334 0 .027.028.083.028.11-1.173 1.556-2.485 3.195-3.909 4.945-1.396 1.611-2.876 3.306-4.356 5.056-4.719 5.5-10.052 11.75-15.943 17.25a.268.268 0 0 0 0 .389c.028.027.056.055.084.055-.084.084-.168.14-.252.222-.056.056-.084.111-.084.167a.605.605 0 0 0-.111.139c-.112.111-.112.305.028.389.111.11.307.11.39-.028.029-.028.029-.056.056-.056a.44.44 0 0 1 .615 0c.335.362.67.723.977 1.028l-.698-.583c-.112-.111-.307-.083-.39.028-.113.11-.085.305.027.389l7.427 6.194c.056.056.112.056.196.056s.14-.028.195-.084l.168-.166c.028.027.083.027.111.027.084 0 .14-.027.196-.083 10.052-10.055 18.15-17.639 27.42-24.417.083-.055.111-.166.111-.25.112 0 .196-.083.251-.194 1.704-5.194 2.039-9.806 2.15-12.083v-.028c0-.028.028-.056.028-.083.028-.056.028-.084.028-.084a1.626 1.626 0 0 0-.111-1.028ZM21.472 9.5c.446-.5.893-1.028 1.34-1.5-2.876 3.778-7.65 9.583-14.408 16.5 4.607-5.083 9.242-10.333 13.068-15ZM5.193 35.778h.084-.084Zm3.462 3.194c-.027-.028-.027-.028 0-.028v.028Zm4.16-3.583c.224-.25.448-.472.699-.722 0 0 0 .027.028.027-.252.223-.475.445-.726.695Zm1.146-1.111c.14-.14.279-.334.446-.5l.028-.028c1.648-1.694 3.351-3.389 5.082-5.111l.028-.028c.419-.333.921-.694 1.368-1.028a379.003 379.003 0 0 0-6.952 6.695ZM24.794 6.472c-.921 1.195-1.954 2.778-2.82 4.028-2.736 3.944-11.532 13.583-11.727 13.75a1976.983 1976.983 0 0 1-8.042 7.639l-.167.167c-.14-.167-.14-.417.028-.556C14.49 19.861 22.03 10.167 25.074 5.917c-.084.194-.14.36-.28.555Zm4.83 5.695c-1.116-.64-1.646-1.64-1.34-2.611l.084-.334c.028-.083.084-.194.14-.277.307-.5.754-.917 1.257-1.167.027 0 .055 0 .083-.028-.028-.056-.028-.139-.028-.222.028-.167.14-.278.335-.278.335 0 1.369.306 1.76.639.111.083.223.194.335.305.14.167.363.445.474.667.056.028.112.306.196.445.056.222.111.472.084.694-.028.028 0 .194-.028.194a2.668 2.668 0 0 1-.363 1.028c-.028.028-.028.056-.056.084l-.028.027c-.14.223-.335.417-.53.556-.643.444-1.369.583-2.095.389 0 0-.195-.084-.28-.111Zm8.154-.834a39.098 39.098 0 0 1-.893 3.167c0 .028-.028.083 0 .111-.056 0-.084.028-.14.056-2.206 1.61-4.356 3.305-6.506 5.028 1.843-1.64 3.686-3.306 5.613-4.945.558-.5.949-1.139 1.06-1.861l.28-1.667v-.055c.14-.334.67-.195.586.166Z",
        fill: "currentColor"
      }
    )
  }
);
var LogoText = () => /* @__PURE__ */ (0, import_jsx_runtime148.jsxs)(
  "svg",
  {
    viewBox: "0 0 450 55",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    className: "ExcalidrawLogo-text",
    children: [
      /* @__PURE__ */ (0, import_jsx_runtime148.jsx)(
        "path",
        {
          d: "M429.27 96.74c2.47-1.39 4.78-3.02 6.83-4.95 1.43-1.35 2.73-2.86 3.81-4.51-.66.9-1.4 1.77-2.23 2.59-2.91 2.84-5.72 5.09-8.42 6.87h.01ZM343.6 69.36c.33 3.13.58 6.27.79 9.4.09 1.37.18 2.75.25 4.12-.12-4.46-.27-8.93-.5-13.39-.11-2.08-.24-4.16-.4-6.24-.06 1.79-.11 3.85-.13 6.11h-.01ZM378.47 98.34c.01-.37.07-1.13.01-6.51-.11 1.9-.22 3.81-.31 5.71-.07 1.42-.22 2.91-.16 4.35.39.03.78.07 1.17.1-.92-.85-.76-2.01-.72-3.66l.01.01ZM344.09 86.12c-.09-2.41-.22-4.83-.39-7.24v12.21c.15-.05.32-.09.47-.14.05-1.61-.03-3.23-.09-4.83h.01ZM440.69 66.79c-.22-.34-.45-.67-.69-.99-3.71-4.87-9.91-7.14-15.65-8.55-1.05-.26-2.12-.49-3.18-.71 2.29.59 4.48 1.26 6.64 2.02 7.19 2.54 10.57 5.41 12.88 8.23ZM305.09 72.46l1.2 3.6c.84 2.53 1.67 5.06 2.46 7.61.24.78.5 1.57.73 2.36.22-.04.44-.08.67-.12a776.9 776.9 0 0 1-5.01-13.57c-.02.04-.03.09-.05.13v-.01ZM345.49 90.25v.31c1.48-.42 3.05-.83 4.66-1.2-1.56.25-3.12.52-4.66.89ZM371.02 90.22c0-.57-.04-1.14-.11-1.71-.06-.02-.12-.04-.19-.05-.21-.05-.43-.08-.65-.11.42.16.74.88.95 1.87ZM398.93 54.23c-.13 0-.27-.01-.4-.02l.03.4c.11-.15.23-.27.37-.38ZM401.57 62.28v-.15c-1.22-.24-2.86-.61-3.23-1.25-.09-.15-.18-.51-.27-.98-.09.37-.2.73-.33 1.09 1.24.56 2.52.98 3.83 1.29ZM421.73 88.68c-2.97 1.65-6.28 3.12-9.69 3.68v.18c4.72-.14 11.63-3.85 16.33-8.38-2.04 1.75-4.33 3.24-6.63 4.53l-.01-.01ZM411.28 80.92c-.05-1.2-.09-2.4-.15-3.6-.21 5.66-.46 11.38-.47 14.51.24-.02.48-.04.71-.07.15-3.61.05-7.23-.09-10.83v-.01Z",
          transform: "translate(-144.023 -51.76)"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime148.jsx)(
        "path",
        {
          d: "M425.38 67.41c-3.5-1.45-7.19-2.57-14.06-3.62.09 1.97.06 4.88-.03 8.12.03.04.06.09.06.15.19 1.36.28 2.73.37 4.1.25 3.77.39 7.55.41 11.33 0 1.38-.01 2.76-.07 4.13 1.4-.25 2.78-.65 4.12-1.15 4.07-1.5 7.94-3.78 11.28-6.54 2.33-1.92 5.13-4.49 5.88-7.58.63-3.53-2.45-6.68-7.97-8.96l.01.02ZM411.35 92.53v-.06l-.34.03c.11.01.22.03.34.03ZM314.26 64.06c-.23-.59-.47-1.17-.7-1.75.57 1.62 1.11 3.25 1.6 4.9l.15.54 2.35 6.05c.32.82.66 1.64.98 2.46-1.38-4.1-2.83-8.17-4.39-12.2h.01ZM156.82 103.07c-.18.13-.38.23-.58.33 1.32-.03 2.66-.2 3.93-.34.86-.09 1.72-.22 2.58-.33-2.12.1-4.12.17-5.94.34h.01ZM210.14 68.88s.03.04.05.07c.18-.31.39-.64.58-.96-.21.3-.42.6-.64.89h.01ZM201.65 82.8c-.5.77-1.02 1.56-1.49 2.37 1.11-1.55 2.21-3.1 3.2-4.59-.23.23-.49.51-.75.79-.32.47-.65.95-.96 1.43ZM194.03 98.66c-.33-.4-.65-.84-1.05-1.17-.24-.2-.07-.49.17-.56-.23-.26-.42-.5-.63-.75 1.51-2.55 3.93-5.87 6.4-9.28-.17-.08-.29-.28-.2-.49.04-.09.09-.17.13-.26-1.21 1.78-2.42 3.55-3.61 5.33-.87 1.31-1.74 2.64-2.54 4-.29.5-.63 1.04-.87 1.61.81.65 1.63 1.27 2.47 1.88-.09-.11-.18-.21-.27-.32v.01ZM307.79 82.93c-1-3.17-2.05-6.32-3.1-9.48-1.62 4.08-3.69 9.17-6.16 15.19 3.32-1.04 6.77-1.87 10.27-2.5-.32-1.08-.67-2.15-1.01-3.21ZM149.5 80.7c.05-1.71.04-3.43 0-5.14-.1 2.26-.16 4.51-.22 6.77-.02.73-.03 1.46-.04 2.19.14-1.27.2-2.55.24-3.82h.02ZM228.98 98.3c.39 1.25.91 3.03.94 3.91.06-.03.12-.07.17-.1.08-1.29-.55-2.65-1.11-3.81ZM307.72 53.36c.81.5 1.53 1.04 2.07 1.49-.38-.8-.78-1.58-1.21-2.35-.17.03-.34.06-.51.11-.43.12-.86.26-1.29.41.35-.01.53.1.94.34ZM283.69 96.14c3.91-7.25 6.89-13.35 8.88-18.15l1.1-2.66c-1.27 2.64-2.56 5.27-3.83 7.9-1.53 3.15-3.06 6.31-4.58 9.47-.87 1.81-1.76 3.62-2.54 5.47.04.02.07.04.11.07.05.05.1.09.15.14.05-.73.27-1.48.71-2.24ZM289.92 103.23s-.04.01-.05.03c0-.02.04-.03.05-.04.05-.05.11-.1.16-.15l.21-.21c-.55 0-1.5-.27-2.55-.72.4.26.8.51 1.22.74.24.13.48.26.73.37.05.02.1.03.14.05a.27.27 0 0 1 .08-.07h.01ZM269.23 68.49c-.39-.19-.82-.48-1.33-.87-3.06-1.56-6.31-2.78-9.36-2.35-3.5.49-5.7 1.11-7.74 2.44 5.71-2.6 12.82-2.07 18.44.79l-.01-.01ZM177.87 53.69l1.06.03c-.96-.22-2-.25-2.89-.3-4.95-.26-9.99.33-14.86 1.19-2.44.43-4.88.95-7.28 1.59 9.09-1.76 15.69-2.77 23.97-2.51ZM219.85 55.51c-.18.12-.36.27-.56.45-.45.53-.86 1.11-1.26 1.66-1.91 2.61-3.71 5.31-5.57 7.95l-.12.18 8.05-10.11c-.18-.05-.36-.1-.55-.13h.01ZM510.71 54.1c.12-.15.29-.3.53-.45.69-.4 3.72-.63 5.87-.74-.36-.02-.73-.04-1.09-.05-1.84-.03-3.67.09-5.49.35.05.3.12.59.18.88v.01ZM510.76 86.02c1.37-3.07 2.49-6.27 3.57-9.46.55-1.64 1.12-3.3 1.6-4.97-1.59 4.01-3.67 9.14-6.2 15.3.24-.08.5-.14.74-.22.1-.22.19-.44.29-.65ZM566.95 75.76c.11-.02.23.03.31.11-.05-.13-.09-.26-.14-.39-.05.09-.11.18-.17.28ZM511.33 86.41c3.08-.89 6.24-1.62 9.46-2.14-1.51-3.98-2.98-7.96-4.39-11.87-.05.15-.09.31-.14.46-1.02 3.32-2.15 6.61-3.39 9.85-.48 1.25-.98 2.49-1.53 3.7h-.01ZM578.24 74.45c.11-.44.23-.87.35-1.31-.31.7-.64 1.39-.97 2.08.09.21.19.4.28.61.12-.46.23-.92.35-1.38h-.01ZM520.62 53.11c-.09 0-.18-.01-.28-.02.38.34.29 1.08.93 2.53l6.65 17.15c2.2 5.68 4.69 11.36 7.41 16.87l1.06 2.17c-2.95-7.05-5.92-14.08-8.87-21.13-1.58-3.79-3.16-7.59-4.7-11.4-.78-1.92-1.73-3.89-2.25-5.91-.03-.1 0-.19.04-.26h.01ZM578.78 77.87c1.45-5.77 3.07-10.43 3.58-13.36.05-.34.16-.88.31-1.55-.67 1.79-1.37 3.56-2.08 5.33-.12.43-.23.86-.35 1.29-.65 2.43-1.29 4.86-1.9 7.3.14.33.29.65.43 1l.01-.01ZM545.3 94.66c.02-.44.03-.83.05-1.12.02-1.01.05-2.02.11-3.02.03-6.66-.46-14.33-1.46-22.8-.13-.42-.27-1.24-.56-2.89 0-.02 0-.04-.01-.06.62 6.61.95 13.25 1.32 19.87.17 3.08.33 6.16.52 9.23.02.25.03.52.04.78l-.01.01ZM580.77 102.81c.13.2.27.38.37.49.27-.11.53-.22.8-.32-.43.09-.82.05-1.17-.16v-.01ZM530.48 104.07h.33c-.36-.13-.71-.32-1.04-.56.14.24.3.47.45.7.06-.08.14-.13.26-.13v-.01ZM542.63 58.82c.06.23.11.47.15.71.14-.33.36-.62.7-.86-.28.05-.57.11-.85.15ZM583.81 57.87c.15-.7.29-1.41.42-2.11-.14.45-.28.9-.42 1.34-.46 1.44-.89 2.89-1.31 4.34.44-1.19.88-2.37 1.31-3.57ZM523.62 91.48c-4.66 1.17-9.05 2.89-14.02 5.27 4.65-1.84 9.48-3.29 14.28-4.63-.09-.22-.17-.41-.26-.64ZM460.64 78.3c-.04-2.9-.11-5.81-.28-8.71-.1-1.68-.17-3.43-.5-5.09-.07.02-.14.03-.2.05.3 6.54.45 12.17.51 17.12.17-.07.34-.14.51-.2 0-1.06-.01-2.11-.03-3.17h-.01ZM470.63 63.24c-3.38-.26-6.81.32-10.1 1.1.41 2.01.47 4.14.57 6.18.18 3.55.25 7.11.27 10.67 3.31-1.38 6.5-3.12 9.3-5.35 1.96-1.56 3.86-3.41 5.02-5.66.73-1.41 1.19-3.22.26-4.65-1.09-1.7-3.46-2.14-5.32-2.29ZM460.29 63.68c1-.24 2.01-.46 3.04-.65-1.15.16-2.37.38-3.71.69v.13c.07-.02.15-.04.22-.05.11-.13.3-.18.45-.11v-.01ZM457.24 100.96c.43-.03.86-.07 1.29-.11.14-.49.27-.99.38-1.49-.44.7-1 1.23-1.67 1.6ZM482.88 104.98c-.18.23-.36.38-.55.47.14.09.27.19.4.28a70.76 70.76 0 0 0 4.37-4.63c.76-.89 1.52-1.81 2.19-2.77-.3-.27-.61-.53-.92-.79-.07 1.94-4.62 6.32-5.49 7.45v-.01Z",
          transform: "translate(-144.023 -51.76)"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime148.jsx)(
        "path",
        {
          d: "M474.36 63.31c-.4-.16-.84-.27-1.29-.37 1.56.42 3.08 1.22 3.76 2.74.62 1.4.32 2.95-.28 4.32.7-1.22.94-2.34.74-3.47-.24-1.33-1.19-2.54-2.93-3.21v-.01ZM477.34 89.18c-1.2-.81-2.4-1.62-3.6-2.42-.14.1-.26.19-.4.29 1.4.67 2.73 1.39 4 2.13ZM465.88 93.85c.37.25.74.5 1.1.75.46.32.92.65 1.38.97-1.57-1.2-2.01-1.61-2.49-1.72h.01ZM574.92 90.06c-2.28-5.21-4.93-11.13-5.67-12.26-.1-.15-1.57-3.01-1.63-3.08 0 0-.01.02-.02.02.4 1.37 1.09 2.69 1.65 3.99 2.14 4.95 4.36 9.86 6.67 14.73.6 1.26 1.21 2.52 1.83 3.78-.75-2.01-1.64-4.45-2.83-7.18ZM448.73 65.29c.1.2.22.38.34.57.22-.02.43-.06.65-.08v-.08c-.14-.05-.25 0-.99-.41ZM460.16 94.81c-.02.31-.06.59-.1.89-.03 1.71-.33 3.43-.79 5.07.15-.02.3-.03.45-.05.01-.04.02-.08.03-.11.09-.34.15-.69.2-1.03.17-1.07.25-2.16.33-3.24.05-.69.08-1.39.12-2.08-.27.1-.27.26-.24.57v-.02Z",
          transform: "translate(-144.023 -51.76)"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime148.jsx)(
        "path",
        {
          d: "m328.67 98.12-3.22-6.58c-1.29-2.63-2.53-5.29-3.72-7.97-.25-.85-.52-1.69-.79-2.53-.81-2.57-1.67-5.12-2.55-7.67-1.92-5.53-3.9-11.08-6.32-16.41-.72-1.58-1.46-3.44-2.63-4.79-.03-.17-.16-.29-.34-.36a.282.282 0 0 0-.23-.04c-.06-.01-.12 0-.18.01-.74.06-1.5.38-2.19.61-2.22.77-4.4 1.64-6.63 2.38-.03-.08-.06-.16-.09-.25-.15-.42-.82-.24-.67.19.03.09.07.19.1.28l-.18.06c-.36.11-.28.6 0 .68.18 1.18.63 2.36.98 3.49.03.09.06.17.08.26-.08.23-.17.46-.24.64-.37.98-.79 1.94-1.21 2.9-1.27 2.89-2.62 5.75-3.98 8.6-3.18 6.67-6.44 13.31-9.64 19.97-1.08 2.25-2.2 4.5-3.15 6.81-.13.32.24.5.5.37 1.34 1.33 2.84 2.5 4.4 3.57.65.44 1.31.87 2.01 1.24.4.22.86.48 1.33.5.24.01.35-.19.33-.37.11-.1.21-.21.28-.28.41-.41.81-.84 1.2-1.26.85-.92 1.69-1.87 2.5-2.84 6.31-2.34 12.6-4.31 18.71-5.84 2.14 5.3 3.43 8.43 3.97 9.58.55 1.05 1.15 1.88 1.82 2.52 1.32.56 6.96-.03 9.23-1.96.87-1.28 1.19-2.67.93-4.15-.09-.5-.22-.95-.4-1.33l-.01-.03Zm-20.09-45.61c.43.77.83 1.56 1.21 2.35-.54-.45-1.27-.99-2.07-1.49-.42-.24-.6-.35-.94-.34.43-.15.85-.29 1.29-.41.17-.05.34-.08.51-.11Zm-25.86 45.66c.78-1.85 1.67-3.66 2.54-5.47 1.51-3.16 3.05-6.31 4.58-9.47 1.28-2.63 2.56-5.26 3.83-7.9l-1.1 2.66c-1.99 4.79-4.97 10.9-8.88 18.15-.43.76-.66 1.51-.71 2.24-.05-.05-.1-.09-.15-.14a.259.259 0 0 0-.11-.07Zm6.24 4.71c-.42-.23-.82-.48-1.22-.74 1.05.45 2 .72 2.55.72l-.21.21c-.05.05-.11.1-.16.15-.01.01-.04.03-.05.04 0-.02.03-.02.05-.03a.27.27 0 0 0-.08.07c-.05-.02-.1-.03-.14-.05-.25-.1-.49-.24-.73-.37h-.01Zm15.73-29.43c1.05 3.15 2.1 6.31 3.1 9.48.34 1.06.69 2.13 1.01 3.21-3.5.63-6.95 1.46-10.27 2.5 2.48-6.03 4.54-11.11 6.16-15.19Zm4.79 12.57c-.23-.79-.49-1.58-.73-2.36-.79-2.54-1.63-5.08-2.46-7.61l-1.2-3.6c.02-.04.04-.09.05-.13 1.6 4.45 3.28 9 5.01 13.57l-.67.12v.01Zm5.83-18.27-.15-.54c-.49-1.64-1.03-3.28-1.6-4.9.23.58.47 1.17.7 1.75 1.56 4.03 3.01 8.1 4.39 12.2-.33-.82-.67-1.64-.98-2.46l-2.35-6.05h-.01ZM390.43 79.37c-.13-10.43-.22-17.5-.24-19.97-.24-1.6.21-2.88-.65-3.65-.14-.13-.32-.23-.52-.32h.03c.45 0 .45-.69 0-.7-1.75-.03-3.5-.04-5.25-.14-1.38-.08-2.76-.21-4.15-.31-.07 0-.12.01-.17.04-.21-.07-.47.03-.45.31l.03.45c-.11.14-.19.3-.22.5-.21 1.26-.32 13.67-.36 23.59-.32 5.79-.67 11.57-.97 17.36-.09 1.73-.29 3.54-.21 5.3-.39.02-.38.64.04.69v.12c.05.44.74.45.7 0v-.06c1.1.09 2.2.21 3.3.3 1.14.19 2.44.2 3.29.17 1.73-.05 2.92-.05 3.8-.37.45-.05.9-.11 1.35-.17.44-.06.25-.73-.19-.67h-.01c.24-.32.45-.72.62-1.25.66-1.84.41-6.36.34-11.33l-.13-9.9.02.01Zm-12.26 18.17c.09-1.91.2-3.81.31-5.71.06 5.38 0 6.14-.01 6.51-.05 1.65-.21 2.81.72 3.66-.39-.04-.78-.07-1.17-.1-.06-1.44.09-2.93.16-4.35l-.01-.01ZM588.97 53.85c-2.06-.25-3.17-.51-3.76-.6a.3.3 0 0 1 .04-.08c.22-.39-.39-.75-.6-.35-.56 1.02-.9 2.19-1.26 3.29-.61 1.88-1.17 3.78-1.72 5.68-.63 2.19-1.24 4.39-1.83 6.59-.81 2.03-1.67 4.05-2.61 6.03-1.7-3.64-3.11-6.04-4.03-7.57-2.26-3.74-2.85-5.48-3.57-6.08l.31-.09c.43-.12.25-.8-.19-.67-1.06.3-2.12.6-3.17.95-.93.32-1.85.69-2.76 1.07-.13.05-.19.16-.22.27-.04.02-.08.05-.11.07-.04-.06-.07-.12-.11-.18a.354.354 0 0 0-.48-.12c-.16.09-.22.32-.13.48l.33.54c0 .09.02.18.06.28.51 1.16.78 1.38.72 1.47-2.42 3.44-5.41 7.86-6.2 9.1-1.27 1.97-2.01 3.14-2.45 3.84l-.91-6.56-.43-4.1c-.19-1.85-.37-3.23-.53-4.13-.19-1.1-.3-2.15-.45-3.16-.2-1.36-.29-2.06-.47-2.42h.04c.45.02.45-.68 0-.7-3.43-.16-6.81.94-10.17 1.48-.24-.22-.73-.04-.58.32.24.59.33 1.25.43 1.87.17 1.06.29 2.13.4 3.2.32 3.09.53 6.2.74 9.3.44 6.75.77 13.51 1.17 20.26.11 1.95.13 3.96.46 5.89.05.3.37.31.55.14.74 1.71 2.87 1.27 6.13 1.27 1.34 0 2.39.04 2.99-.11.02.32.48.53.63.18 3.61-8.26 7.41-16.46 12.05-24.2.03-.05.04-.1.05-.15.3.73.64 1.45.94 2.16.97 2.26 1.97 4.52 2.98 6.76 2.26 5.03 4.54 10.07 7.09 14.96.47.9.94 1.79 1.47 2.65.2.32.4.67.66.96-.18.25 0 .68.34.54.91-.38 1.82-.75 2.76-1.07 1.04-.35 2.11-.65 3.17-.95.39-.11.28-.66-.07-.68.62-.4.95-.96.87-1.91-.3-3.34.72-7.47.86-8.52l2.14-11.43c1.75-10.74 3.13-17.51 3.23-20.86.02-.49.08-2.84.13-3.24.17-1.25.48-1-4.96-1.65l.03-.02Zm-46.19 5.67c-.04-.24-.09-.48-.15-.71l.85-.15c-.34.24-.56.53-.7.86Zm1.95 25.12c-.36-6.63-.7-13.26-1.32-19.87 0 .02 0 .04.01.06.29 1.65.44 2.47.56 2.89 1 8.46 1.5 16.14 1.46 22.8-.06.99-.1 2-.11 3.02-.01.29-.03.68-.05 1.12-.01-.26-.03-.53-.04-.78-.19-3.08-.35-6.16-.52-9.23l.01-.01Zm36.4 18.66c-.11-.11-.24-.29-.37-.49.35.21.74.26 1.17.16-.27.11-.53.22-.8.32v.01Zm-.89-33.72c.12-.43.23-.86.35-1.29.71-1.77 1.41-3.55 2.08-5.33-.15.68-.26 1.22-.31 1.55-.5 2.94-2.13 7.59-3.58 13.36-.15-.35-.29-.66-.43-1 .61-2.44 1.25-4.87 1.9-7.3l-.01.01Zm3.56-12.48c.14-.44.28-.89.42-1.34-.13.7-.27 1.41-.42 2.11-.43 1.19-.86 2.38-1.31 3.57.42-1.45.85-2.9 1.31-4.34Zm-5.22 16.05c-.11.44-.23.87-.35 1.31-.12.46-.23.92-.35 1.38-.1-.22-.19-.4-.28-.61.34-.69.66-1.38.97-2.08h.01Zm-11.64 2.62c.06-.1.12-.19.17-.28.05.13.09.26.14.39a.398.398 0 0 0-.31-.11Zm2.3 2.98c-.56-1.3-1.25-2.63-1.65-3.99 0 0 .01-.02.02-.02.06.08 1.52 2.93 1.63 3.08.73 1.13 3.38 7.04 5.67 12.26 1.2 2.73 2.08 5.17 2.83 7.18-.62-1.25-1.23-2.51-1.83-3.78-2.31-4.87-4.53-9.78-6.67-14.73ZM275.92 87.03c-1.06-2.18-1.13-3.45-2.44-2.93-1.52.57-2.94 1.3-4.5 2.1-1.4.72-2.68 1.44-3.92 2.12.01-.25-.24-.5-.51-.34-4.8 2.93-12.41 4.7-17.28 1.31-1.98-1.77-3.32-4.15-3.97-5.78-.29-.95-.49-1.94-.63-2.93-.14-3.34 1.58-6.53 3.9-9.12.8-.79 1.68-1.51 2.66-2.12 3.7-2.3 8.22-3.07 12.51-2.51 2.71.35 5.32 1.24 7.71 2.55.39.22.75-.39.35-.6-.18-.1-.37-.18-.55-.27.56.27 1.03.33 1.51.19l-.48.39c-.15.11-.23.3-.13.48.09.15.33.24.48.13 1.3-.97 2.46-2.09 3.45-3.37.37-.29.64-.6.65-.97v-.02c.08-.33-.03-.7-.21-1.08-.31-.87-.98-2.01-2.19-3.26-2.43-2.52-3.79-3.45-5.68-4.26-1.14-.49-3.12-1.06-4.42-1.23-3.28-.42-10.64-1.21-18.18 4.11-7.74 5.46-11.94 12.3-12.23 20.61-.08 2.06.04 3.98.34 5.71.74 4.18 2.57 8 5.44 11.34 4.26 4.99 9.76 7.52 16.34 7.52 4.85 0 9.69-1.77 14.89-4.62.23-.12.45-.23.68-.35 2.19-1.1 4.37-2.23 6.46-3.5.49-.3 1.03-.61 1.5-.98 1.47-.87 1.11-1.12.49-2.95-.39-1.14-.76-2.7-2.06-5.36l.02-.01Zm-17.38-21.76c3.05-.42 6.31.79 9.36 2.35.51.39.94.68 1.33.87-5.61-2.86-12.72-3.39-18.44-.79 2.05-1.33 4.24-1.95 7.74-2.44l.01.01ZM443.67 72.67c-.4-2.2-1.15-4.33-2.37-6.22-1.49-2.32-3.58-4.19-5.91-5.64-6.17-3.81-13.75-5.11-20.83-6.01-3.23-.41-6.47-.69-9.72-.92l-1.39-.12c-.85-.07-1.52-.1-2.05-.1-1.08-.06-2.17-.12-3.25-.17-.08 0-.14.02-.19.05-.1.05-.18.14-.16.3.27 2.55-.01 5.12-.92 7.52-.15.38.4.56.62.28 1.32.59 2.68 1.05 4.08 1.37 0 2.78-.14 7.58-.33 12.91 0 0 0 .02-.01.03-.61 3.66-.79 7.42-1 11.12-.23 4.01-.43 8.03-.44 12.05 0 .64 0 1.28.03 1.93.02.31 0 .68.15.96.06.11.14.16.24.17-.2.17-.21.54.11.59 3.83.67 7.78.71 11.68.25 2.3-.19 4.87-.65 7.65-1.56 1.85-.54 3.67-1.18 5.43-1.91 7.2-3.02 14.31-8.07 17.35-15.53.76-1.86 1.17-3.8 1.31-5.75.3-1.93.28-3.82-.09-5.58l.01-.02Zm-19.32-15.42c5.74 1.41 11.94 3.68 15.65 8.55.25.32.47.65.69.99-2.3-2.82-5.68-5.69-12.88-8.23-2.16-.76-4.35-1.43-6.64-2.02 1.06.21 2.13.45 3.18.71Zm-25.82-3.04c.13 0 .27.01.4.02-.14.1-.26.23-.37.38 0-.13-.02-.26-.03-.4Zm34.82 22.17c-.75 3.09-3.55 5.66-5.88 7.58-3.35 2.76-7.21 5.03-11.28 6.54-1.33.49-2.71.9-4.12 1.15.06-1.38.08-2.76.07-4.13-.02-3.78-.16-7.56-.41-11.33-.09-1.37-.18-2.74-.37-4.1 0-.06-.03-.11-.06-.15.09-3.25.12-6.16.03-8.12 6.86 1.05 10.56 2.17 14.06 3.62 5.52 2.28 8.59 5.44 7.97 8.96l-.01-.02Zm-22 16.15c-.12 0-.23-.02-.34-.03l.34-.03v.06Zm-.69-.7c0-3.13.26-8.84.47-14.51.06 1.2.11 2.41.15 3.6.15 3.6.25 7.23.09 10.83-.24.03-.48.05-.71.07v.01Zm-12.33-30.94c.37.63 2.01 1.01 3.23 1.25v.15c-1.31-.31-2.59-.73-3.83-1.29.12-.36.23-.72.33-1.09.08.48.18.84.27.98Zm13.7 31.65v-.18c3.41-.56 6.71-2.02 9.69-3.68 2.31-1.28 4.59-2.78 6.63-4.53-4.69 4.53-11.61 8.24-16.33 8.38l.01.01Zm24.07-.75c-2.05 1.93-4.37 3.56-6.83 4.95 2.7-1.78 5.52-4.03 8.42-6.87.82-.82 1.56-1.69 2.23-2.59-1.08 1.65-2.38 3.16-3.81 4.51h-.01ZM187.16 92.14c-.79-2.47-2.1-7.12-3.1-6.87-.19-.01-2.09.77-4.08 1.54-3.06 1.18-5.91 2.13-10.09 2.82-2.74.42-5.87 1.01-10.61 1.06.04-3.34.05-6.01.05-7.99 7.97-.65 12.33-2.11 16.37-3.55 1.11-.39 2.69-1.01 2.63-1.8-.08-.35-.55-1.39-1.17-2.61-.47-1.16-.98-2.31-1.61-3.38-.42-.71-1.04-1.69-1.86-2.06-.11-.08-.22-.13-.29-.12-.02 0-.04 0-.07.01-.19-.04-.39-.05-.6-.01-.17.03-.24.15-.25.28-.04.02-.09.04-.14.05-4.33 1.48-8.85 2.33-13.24 3.61a499.1 499.1 0 0 0-.31-8.19c4.51-.99 8.88-1.38 13.11-1.82 3.68-.38 6.28.12 7.47.34.59.11.9.16 1.16.18h.1c-.1.37.44.66.62.28.02-.04.03-.08.05-.13.15.2.53.22.62-.1.17-.58.19-1.21.21-1.81v-.36c.03-.15.05-.3.07-.45.52-2.47.33-5.09-.64-7.44-.11-.27-.44-.28-.6-.14-.08-.21-.15-.42-.24-.62-.19-.41-.79-.05-.6.35.03.07.05.15.09.22-.98-.42-2.15-.54-3.17-.63-2.17-.19-4.37-.14-6.54 0-5.7.35-11.4 1.3-16.91 2.79-2.08.56-4.13 1.22-6.14 2-4.54 1.05-3.79 1.51-2.17 6.07.18.51.46 1.68.54 1.94.82 2.47 1.08 2.13 3.1 2.13s0 .05 0 .08h.52c-.48 2.66-.51 5.45-.62 8.13-.15 3.48-.22 6.96-.28 10.45 0 .41-.01.82-.02 1.23-.16.29-.33.57-.51.85-.05.38-.09.77-.14 1.18-.42 3.52-.59 6.48-.52 8.8v.34c.02.47.05.76.06.87.16 1.57-.26 3.47 1.35 3.79 1.61.32 3.5.55 4.85.55.11 0 .22-.02.33-.02 1.79.24 3.67.05 5.45-.12 2.85-.28 5.69-.7 8.51-1.19 3.03-.53 6.05-1.14 9.04-1.86 2.4-.58 4.82-1.19 7.13-2.06.51-.19 1.73-.57 2.46-1.14 1.81-.68 2.18-1 1.57-2.67-.23-.62-.48-1.49-.91-2.78l-.03-.02Zm-11.12-38.71c.89.05 1.93.08 2.89.3-.33 0-.68-.02-1.06-.03-8.28-.26-14.88.75-23.97 2.51 2.41-.64 4.85-1.16 7.28-1.59 4.87-.86 9.91-1.45 14.86-1.19Zm-26.53 22.13c.03 1.71.04 3.43 0 5.14-.04 1.27-.11 2.55-.24 3.82 0-.73.02-1.46.04-2.19.05-2.26.12-4.51.22-6.77h-.02Zm6.73 27.85c.2-.1.4-.21.58-.33 1.82-.17 3.82-.24 5.94-.34-.86.11-1.72.24-2.58.33-1.27.14-2.61.31-3.93.34h-.01ZM534.48 85.44c-3.52-8.38-7.07-16.75-10.5-25.17-.63-1.54-1.25-3.09-1.86-4.65-.31-.8-.65-1.6-.87-2.43-.04-.17-.17-.24-.31-.25.1-.2 0-.51-.29-.53-1.59-.08-3.18-.22-4.78-.25-1.96-.03-3.91.13-5.84.42-.31.05-.31.38-.13.56-.03.06-.05.14-.04.22.23 1.54.63 3.06 1.16 4.53.13.35.27.7.41 1.06l-2.68 6.18c-.11.03-.2.09-.25.22-.67 1.9-1.52 3.73-2.34 5.56a536.85 536.85 0 0 1-3.9 8.45c-2.64 5.64-5.34 11.25-7.91 16.93-.44.97-.88 1.94-1.29 2.93-.2.48-.47 1-.55 1.52v.05c-.02.12.02.26.16.34 1.19.73 2.41 1.41 3.66 2.05 1.2.62 2.45 1.25 3.76 1.61.43.12.62-.55.19-.67-1.13-.31-2.2-.83-3.24-1.36 1.09.36 2.1.69 2.75.93 2.82 1.01 2.38 1.1 4.3-3.75 2.1-1.09 4.34-1.96 6.53-2.79 4.35-1.64 8.8-3.03 13.27-4.29.82 2.01 1.77 3.97 2.72 5.92.35.83.62 1.45.79 1.82.22.42.45.8.69 1.15.17.33.33.67.5 1 .42.8.84 1.63 1.4 2.35.23.29.6 0 .55-.31 1.53-.02 3.06-.07 4.58-.27.92-.12 1.82-.32 2.71-.54 1.39-.27 3.85-1.11 3.74-1.42-.67-1.96-1.55-3.87-2.34-5.78-1.57-3.78-3.16-7.56-4.75-11.33v-.01Zm-11.65-26.16c1.54 3.81 3.12 7.6 4.7 11.4 2.94 7.05 5.91 14.09 8.87 21.13l-1.06-2.17c-2.71-5.51-5.2-11.19-7.41-16.87l-6.65-17.15c-.65-1.45-.55-2.19-.93-2.53.09 0 .18.01.28.02a.29.29 0 0 0-.04.26c.52 2.02 1.47 3.98 2.25 5.91h-.01Zm-6.58 13.58c.05-.15.09-.31.14-.46 1.41 3.92 2.88 7.9 4.39 11.87-3.22.52-6.38 1.25-9.46 2.14.55-1.22 1.05-2.46 1.53-3.7 1.24-3.24 2.37-6.53 3.39-9.85h.01Zm-.23-20c.36 0 .73.03 1.09.05-2.15.1-5.18.33-5.87.74-.24.15-.41.3-.53.45-.06-.29-.13-.58-.18-.88 1.82-.26 3.65-.39 5.49-.35v-.01Zm-.09 18.72c-.49 1.67-1.05 3.33-1.6 4.97-1.07 3.19-2.19 6.38-3.57 9.46-.09.21-.19.43-.29.65-.25.07-.5.14-.74.22 2.53-6.16 4.61-11.29 6.2-15.3Zm-6.34 25.16c4.97-2.38 9.37-4.1 14.02-5.27l.26.64c-4.8 1.35-9.63 2.8-14.28 4.63Zm20.17 6.76c.33.23.68.42 1.04.56h-.33c-.12 0-.21.06-.26.13-.15-.23-.31-.45-.45-.7v.01ZM226.57 91.75c-3.55-4.74-6.68-9.11-9.31-12.99 9.2-15.25 10.05-17.81 10.35-18.38.17-.34 1.09-2.27.64-2.53-1.13-.65-1.03-.65-2.97-1.71-1.19-.65-3.04-1.61-4.53-2.12-1.71-.59-1.24-.36-3 2.77-.06.1-.11.2-.17.3-.75 1.02-1.48 2.05-2.2 3.09-1.88 2.71-3.73 5.45-5.69 8.1-3.68-4.91-6.88-8.76-9.51-11.43-.15-.15-.3-.29-.46-.42-1.27-1.28-7.24 3.53-7.93 5.58-.09.09-.19.16-.28.25-.27.26.03.64.33.58.19.65.5 1.29.94 1.91 3.85 5.06 7.19 9.76 9.94 14-1.23 2.61-3.06 5-4.67 7.38l-2.28 3.33c-.5.66-.93 1.23-1.29 1.69-.67.93-2.09 2.61-2.3 3.87-.51.85-1.16 1.84-1.29 2.83-.06.44.61.63.67.19.01-.08.04-.15.06-.22 1.36 1.08 2.76 2.11 4.19 3.11 1.3.91 2.62 1.85 4.04 2.56.21.1.4 0 .48-.17.24.07.48.14.72.2.44.1.62-.57.19-.67-2.02-.48-3.77-1.57-5.23-3.02-.47-.46-.9-.96-1.32-1.46 1.74 1.35 4.2 2.89 5.89 4.14 1.39 1.03 2.85-2.27 4.22-4.2 1.86-2.64 3.96-5.86 5.52-8.29l10.39 14.51c.67.81 1.14 1.21 1.57 1.36-.05.24.12.51.41.4 1.53-.58 3.05-1.19 4.54-1.87 1.52-.69 3.06-1.45 4.36-2.5a.28.28 0 0 0 .12-.23c1.66-1.1.81-1.74-1.41-4.91-1.13-1.58-1.71-2.36-3.7-5.01l-.03-.02Zm2.41 6.54c.56 1.15 1.19 2.52 1.11 3.81-.06.04-.12.07-.17.1-.03-.88-.55-2.66-.94-3.91Zm-16.51-32.73c1.86-2.65 3.65-5.35 5.57-7.95.4-.55.81-1.13 1.26-1.66.19-.18.38-.33.56-.45.18.03.36.08.55.13l-8.05 10.11.12-.18h-.01ZM192.7 95.48c.79-1.37 1.66-2.69 2.54-4 1.19-1.79 2.4-3.56 3.61-5.33-.04.09-.09.17-.13.26-.1.22.03.41.2.49-2.47 3.42-4.89 6.73-6.4 9.28.21.24.4.48.63.75-.24.07-.4.36-.17.56.4.33.72.77 1.05 1.17.09.11.18.21.27.32-.84-.61-1.66-1.24-2.47-1.88.24-.57.58-1.11.87-1.61v-.01Zm7.46-10.32c.47-.81.98-1.59 1.49-2.37.31-.48.64-.95.96-1.43.26-.29.52-.56.75-.79-.99 1.48-2.09 3.03-3.2 4.59Zm10.03-16.22s-.03-.05-.05-.07c.22-.29.43-.59.64-.89-.2.32-.4.65-.58.96h-.01ZM371.54 87.96c-.01-.08-.01-.16-.03-.23-.06-.38-.58-.29-.66.03-.3-.05-.6-.08-.81-.11-1.14-.15-2.29-.19-3.44-.2 1.04-.09 2.09-.18 3.14-.23.45-.02.45-.72 0-.7-6.57.35-13.14 1.23-19.65 2.11-1.53.21-3.05.42-4.57.68-.01 0-.02.01-.04.01-.04-3.33-.13-6.66-.24-9.99-.19-5.7-.4-11.41-.88-17.1-.13-1.51-.23-3.07-.49-4.58 0-.25 0-.48-.02-.68-.06-1.19-.04-2.61-.68-2.78-.16-.07-.72-.16-1.5-.24.22-.17.16-.62-.2-.63-1.19-.04-2.39.09-3.57.23-1.2.14-2.41.32-3.59.6-.16-.1-.41-.06-.5.12-.06.02-.13.03-.19.05-.35.1-.29.55-.03.66-.26.6-.19 2.27-.21 3-.02.66-.66 33.73-.9 40.3-.03.65.06 1.12.04 1.45-.16 3.05.87 4.96 6.34 3.93 1.09-.08 2.75-.77 5.36-1.43 4.13-1.04 5.78-1.52 6.2-1.65 6.43-1.69 6.78-1.97 11.72-2.43.55-.05 4.8-.38 6.03-.3.64.04 1.19.07 1.65.1.09 0 .16-.03.24-.05.1.27.56.33.66-.02.39-1.32.61-2.71.78-4.08.2-1.61.29-3.24.15-4.86.24.03.52-.23.38-.53-.09-.2-.27-.33-.49-.43v-.02Zm-.63.56c.07.57.11 1.14.11 1.71-.21-.99-.53-1.71-.95-1.87.22.03.44.06.65.11.06.01.12.04.19.05Zm-25.41 1.73c1.54-.36 3.1-.64 4.66-.89-1.61.37-3.18.77-4.66 1.2v-.31Zm-.86-7.37c-.07-1.37-.16-2.75-.25-4.12-.21-3.13-.45-6.27-.79-9.4.02-2.25.08-4.31.13-6.11.16 2.08.29 4.16.4 6.24.23 4.46.38 8.93.5 13.39h.01Zm-.94-4c.16 2.41.29 4.83.39 7.24.06 1.6.14 3.22.09 4.83-.15.05-.32.09-.47.14V78.88h-.01ZM483.72 92.83c-3.05-2.28-6.22-4.4-9.38-6.51 8.86-6.49 13.49-12.95 13.73-19.23.04-.76 0-1.5-.13-2.2-.67-3.82-3.5-6.68-8.39-8.48.13.04.27.08.4.13 3.92 1.39 7.74 4.23 8.5 8.56.34 1.95-.05 3.96-.98 5.69-.21.4.39.75.6.35 1.86-3.46 1.46-7.55-.97-10.63-3.53-4.47-9.76-5.88-15.16-6.16-2.32-.12-4.64-.04-6.95.19-6 .32-12.71 1.68-17.63 3.21-.37.11-.67.23-.92.35-.2-.17-.62.02-.57.37v.03c-.64.68-.18 1.64.48 3.21.38.91.67 1.89 1.15 2.58.32.76.68 1.51 1.13 2.19.14.21.38.19.53.07.19-.02.38-.05.57-.08v1.57c-.06.06-.1.13-.11.23-.27 4.18-.34 8.38-.48 12.57l-.3 9.03c-.24 3.91-.44 6.77-.46 7.26-.05.88-.11 1.95.07 2.81-.01.22-.02.43-.04.65 0 .11-.02.23-.03.35 0 .05-.03.27-.01.16-.05.4.5.59.64.28.05.04.12.08.2.08 1.75.13 3.5.28 5.25.3 1.69.02 3.38-.12 5.06-.32.08.23.36.39.55.15.06-.08.11-.17.16-.26.18-.09.24-.32.18-.48.05-.2.1-.4.13-.6.16-.86.25-1.74.33-2.62.11-1.17.17-2.34.23-3.51.15-.01.32-.03.52-.04.36-.03 1.73-.15 2.06-.15.39 0 .7-.02.95-.04 1.76 1.11 3.45 2.35 5.14 3.55 2.83 2.01 5.64 4.04 8.47 6.04 1.42 1 2.85 2 4.29 2.97.1.06.19.07.27.04.08 0 .17-.02.25-.1 1.61-1.56 3.15-3.18 4.6-4.88.75-.88 1.49-1.78 2.15-2.73.01.01.03.02.04.03.34.3.83-.2.49-.49-2.16-1.9-4.34-3.76-6.64-5.48l.03-.01Zm-6.38-3.65a55.72 55.72 0 0 0-4-2.13c.14-.1.26-.19.4-.29 1.2.81 2.4 1.61 3.6 2.42Zm-20.1 11.78c.67-.37 1.23-.91 1.67-1.6-.11.5-.24 1-.38 1.49-.43.04-.86.08-1.29.11Zm2.38-37.24c1.34-.31 2.56-.52 3.71-.69-1.03.19-2.04.41-3.04.65-.14-.07-.34-.02-.45.11-.07.02-.15.04-.22.05v-.13.01Zm.04.84c.07-.02.14-.03.2-.05.34 1.66.41 3.41.5 5.09.17 2.9.24 5.81.28 8.71l.03 3.17c-.17.07-.34.14-.51.2-.06-4.96-.21-10.58-.51-17.12h.01Zm16.04 5.62c-1.16 2.25-3.06 4.1-5.02 5.66-2.8 2.23-5.99 3.97-9.3 5.35-.01-3.56-.09-7.12-.27-10.67-.1-2.04-.16-4.16-.57-6.18 3.3-.78 6.72-1.36 10.1-1.1 1.85.14 4.23.59 5.32 2.29.92 1.43.46 3.24-.26 4.65Zm.85-.18c.6-1.37.9-2.92.28-4.32-.67-1.52-2.2-2.32-3.76-2.74.46.1.89.21 1.29.37 1.74.67 2.69 1.88 2.93 3.21.2 1.13-.05 2.25-.74 3.47V70Zm-27.47-4.14c-.12-.19-.23-.38-.34-.57.74.42.85.36.99.41v.08c-.22.03-.43.06-.65.08Zm11.21 30.46c-.08 1.08-.16 2.17-.33 3.24-.05.35-.11.69-.2 1.03 0 .04-.02.07-.03.11-.15.02-.3.04-.45.05.45-1.64.76-3.36.79-5.07.03-.29.08-.57.1-.89-.03-.31-.03-.47.24-.57-.04.69-.07 1.39-.12 2.08v.02Zm5.6-2.47c.48.11.92.52 2.49 1.72-.46-.32-.92-.65-1.38-.97-.37-.25-.73-.5-1.1-.75h-.01Zm21.23 7.24a70.76 70.76 0 0 1-4.37 4.63c-.14-.09-.27-.19-.4-.28.19-.09.37-.24.55-.47.87-1.14 5.43-5.51 5.49-7.45.31.26.62.53.92.79-.67.97-1.42 1.88-2.19 2.77v.01Z",
          fill: "currentColor",
          transform: "translate(-144.023 -51.76)"
        }
      )
    ]
  }
);
var ExcalidrawLogo = ({
  style,
  size = "small",
  withText
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime148.jsxs)("div", { className: `ExcalidrawLogo is-${size}`, style, children: [
    /* @__PURE__ */ (0, import_jsx_runtime148.jsx)(LogoIcon, {}),
    withText && /* @__PURE__ */ (0, import_jsx_runtime148.jsx)(LogoText, {})
  ] });
};

// components/welcome-screen/WelcomeScreen.Center.tsx
var import_jsx_runtime149 = __toESM(require_jsx_runtime(), 1);
var WelcomeScreenMenuItemContent = ({
  icon,
  shortcut,
  children
}) => {
  const device = useDevice();
  return /* @__PURE__ */ (0, import_jsx_runtime149.jsxs)(import_jsx_runtime149.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime149.jsx)("div", { className: "welcome-screen-menu-item__icon", children: icon }),
    /* @__PURE__ */ (0, import_jsx_runtime149.jsx)("div", { className: "welcome-screen-menu-item__text", children }),
    shortcut && !device.editor.isMobile && /* @__PURE__ */ (0, import_jsx_runtime149.jsx)("div", { className: "welcome-screen-menu-item__shortcut", children: shortcut })
  ] });
};
WelcomeScreenMenuItemContent.displayName = "WelcomeScreenMenuItemContent";
var WelcomeScreenMenuItem = ({
  onSelect,
  children,
  icon,
  shortcut,
  className = "",
  ...props
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime149.jsx)(
    "button",
    {
      ...props,
      type: "button",
      className: `welcome-screen-menu-item ${className}`,
      onClick: onSelect,
      children: /* @__PURE__ */ (0, import_jsx_runtime149.jsx)(WelcomeScreenMenuItemContent, { icon, shortcut, children })
    }
  );
};
WelcomeScreenMenuItem.displayName = "WelcomeScreenMenuItem";
var WelcomeScreenMenuItemLink = ({
  children,
  href,
  icon,
  shortcut,
  className = "",
  ...props
}) => {
  return /* @__PURE__ */ (0, import_jsx_runtime149.jsx)(
    "a",
    {
      ...props,
      className: `welcome-screen-menu-item ${className}`,
      href,
      target: "_blank",
      rel: "noreferrer",
      children: /* @__PURE__ */ (0, import_jsx_runtime149.jsx)(WelcomeScreenMenuItemContent, { icon, shortcut, children })
    }
  );
};
WelcomeScreenMenuItemLink.displayName = "WelcomeScreenMenuItemLink";
var Center = ({ children }) => {
  const { WelcomeScreenCenterTunnel } = useTunnels();
  return /* @__PURE__ */ (0, import_jsx_runtime149.jsx)(WelcomeScreenCenterTunnel.In, { children: /* @__PURE__ */ (0, import_jsx_runtime149.jsx)("div", { className: "welcome-screen-center", children: children || /* @__PURE__ */ (0, import_jsx_runtime149.jsxs)(import_jsx_runtime149.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime149.jsx)(Logo, {}),
    /* @__PURE__ */ (0, import_jsx_runtime149.jsx)(Heading, { children: t("welcomeScreen.defaults.center_heading") }),
    /* @__PURE__ */ (0, import_jsx_runtime149.jsxs)(Menu, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime149.jsx)(MenuItemLoadScene, {}),
      /* @__PURE__ */ (0, import_jsx_runtime149.jsx)(MenuItemHelp, {})
    ] })
  ] }) }) });
};
Center.displayName = "Center";
var Logo = ({ children }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime149.jsx)("div", { className: "welcome-screen-center__logo excalifont welcome-screen-decor", children: children || /* @__PURE__ */ (0, import_jsx_runtime149.jsx)(ExcalidrawLogo, { withText: true }) });
};
Logo.displayName = "Logo";
var Heading = ({ children }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime149.jsx)("div", { className: "welcome-screen-center__heading welcome-screen-decor excalifont", children });
};
Heading.displayName = "Heading";
var Menu = ({ children }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime149.jsx)("div", { className: "welcome-screen-menu", children });
};
Menu.displayName = "Menu";
var MenuItemHelp = () => {
  const actionManager = useExcalidrawActionManager();
  return /* @__PURE__ */ (0, import_jsx_runtime149.jsx)(
    WelcomeScreenMenuItem,
    {
      onSelect: () => actionManager.executeAction(actionShortcuts),
      shortcut: "?",
      icon: HelpIcon,
      children: t("helpDialog.title")
    }
  );
};
MenuItemHelp.displayName = "MenuItemHelp";
var MenuItemLoadScene = () => {
  const appState = useUIAppState();
  const actionManager = useExcalidrawActionManager();
  if (appState.viewModeEnabled) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime149.jsx)(
    WelcomeScreenMenuItem,
    {
      onSelect: () => actionManager.executeAction(actionLoadScene),
      shortcut: getShortcutFromShortcutName("loadScene"),
      icon: LoadIcon,
      children: t("buttons.load")
    }
  );
};
MenuItemLoadScene.displayName = "MenuItemLoadScene";
var MenuItemLiveCollaborationTrigger = ({
  onSelect
}) => {
  const { t: t3 } = useI18n();
  return /* @__PURE__ */ (0, import_jsx_runtime149.jsx)(WelcomeScreenMenuItem, { shortcut: null, onSelect, icon: usersIcon, children: t3("labels.liveCollaboration") });
};
MenuItemLiveCollaborationTrigger.displayName = "MenuItemLiveCollaborationTrigger";
Center.Logo = Logo;
Center.Heading = Heading;
Center.Menu = Menu;
Center.MenuItem = WelcomeScreenMenuItem;
Center.MenuItemLink = WelcomeScreenMenuItemLink;
Center.MenuItemHelp = MenuItemHelp;
Center.MenuItemLoadScene = MenuItemLoadScene;
Center.MenuItemLiveCollaborationTrigger = MenuItemLiveCollaborationTrigger;

// components/welcome-screen/WelcomeScreen.Hints.tsx
init_define_import_meta_env();
var import_jsx_runtime150 = __toESM(require_jsx_runtime(), 1);
var MenuHint = ({ children }) => {
  const { WelcomeScreenMenuHintTunnel } = useTunnels();
  return /* @__PURE__ */ (0, import_jsx_runtime150.jsx)(WelcomeScreenMenuHintTunnel.In, { children: /* @__PURE__ */ (0, import_jsx_runtime150.jsxs)("div", { className: "excalifont welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--menu", children: [
    WelcomeScreenMenuArrow,
    /* @__PURE__ */ (0, import_jsx_runtime150.jsx)("div", { className: "welcome-screen-decor-hint__label", children: children || t("welcomeScreen.defaults.menuHint") })
  ] }) });
};
MenuHint.displayName = "MenuHint";
var ToolbarHint = ({ children }) => {
  const { WelcomeScreenToolbarHintTunnel } = useTunnels();
  return /* @__PURE__ */ (0, import_jsx_runtime150.jsx)(WelcomeScreenToolbarHintTunnel.In, { children: /* @__PURE__ */ (0, import_jsx_runtime150.jsxs)("div", { className: "excalifont welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--toolbar", children: [
    /* @__PURE__ */ (0, import_jsx_runtime150.jsx)("div", { className: "welcome-screen-decor-hint__label", children: children || t("welcomeScreen.defaults.toolbarHint") }),
    WelcomeScreenTopToolbarArrow
  ] }) });
};
ToolbarHint.displayName = "ToolbarHint";
var HelpHint = ({ children }) => {
  const { WelcomeScreenHelpHintTunnel } = useTunnels();
  return /* @__PURE__ */ (0, import_jsx_runtime150.jsx)(WelcomeScreenHelpHintTunnel.In, { children: /* @__PURE__ */ (0, import_jsx_runtime150.jsxs)("div", { className: "excalifont welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--help", children: [
    /* @__PURE__ */ (0, import_jsx_runtime150.jsx)("div", { children: children || t("welcomeScreen.defaults.helpHint") }),
    WelcomeScreenHelpArrow
  ] }) });
};
HelpHint.displayName = "HelpHint";

// components/welcome-screen/WelcomeScreen.tsx
var import_jsx_runtime151 = __toESM(require_jsx_runtime(), 1);
var WelcomeScreen = (props) => {
  return /* @__PURE__ */ (0, import_jsx_runtime151.jsx)(import_jsx_runtime151.Fragment, { children: props.children || /* @__PURE__ */ (0, import_jsx_runtime151.jsxs)(import_jsx_runtime151.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime151.jsx)(Center, {}),
    /* @__PURE__ */ (0, import_jsx_runtime151.jsx)(MenuHint, {}),
    /* @__PURE__ */ (0, import_jsx_runtime151.jsx)(ToolbarHint, {}),
    /* @__PURE__ */ (0, import_jsx_runtime151.jsx)(HelpHint, {})
  ] }) });
};
WelcomeScreen.displayName = "WelcomeScreen";
WelcomeScreen.Center = Center;
WelcomeScreen.Hints = { MenuHint, ToolbarHint, HelpHint };
var WelcomeScreen_default = WelcomeScreen;

// components/live-collaboration/LiveCollaborationTrigger.tsx
init_define_import_meta_env();
var import_jsx_runtime152 = __toESM(require_jsx_runtime(), 1);
var LiveCollaborationTrigger2 = ({
  isCollaborating,
  onSelect,
  ...rest
}) => {
  const appState = useUIAppState();
  const showIconOnly = appState.width < 830;
  return /* @__PURE__ */ (0, import_jsx_runtime152.jsxs)(
    Button,
    {
      ...rest,
      className: clsx_m_default("collab-button", { active: isCollaborating }),
      type: "button",
      onSelect,
      style: { position: "relative", width: showIconOnly ? void 0 : "auto" },
      title: t("labels.liveCollaboration"),
      children: [
        showIconOnly ? share : t("labels.share"),
        appState.collaborators.size > 0 && /* @__PURE__ */ (0, import_jsx_runtime152.jsx)("div", { className: "CollabButton-collaborators", children: appState.collaborators.size })
      ]
    }
  );
};
var LiveCollaborationTrigger_default = LiveCollaborationTrigger2;
LiveCollaborationTrigger2.displayName = "LiveCollaborationTrigger";

// data/reconcile.ts
init_define_import_meta_env();
var import_lodash5 = __toESM(require_lodash(), 1);
var shouldDiscardRemoteElement = (localAppState, local, remote) => {
  if (local && // local element is being edited
  (local.id === localAppState.editingTextElement?.id || local.id === localAppState.resizingElement?.id || local.id === localAppState.newElement?.id || // TODO: Is this still valid? As newElement is selection element, which is never part of the elements array
  // local element is newer
  local.version > remote.version || // resolve conflicting edits deterministically by taking the one with
  // the lowest versionNonce
  local.version === remote.version && local.versionNonce < remote.versionNonce)) {
    return true;
  }
  return false;
};
var validateIndicesThrottled = (0, import_lodash5.default)(
  (orderedElements, localElements, remoteElements) => {
    if (define_import_meta_env_default.DEV || define_import_meta_env_default.MODE === ENV.TEST || window?.DEBUG_FRACTIONAL_INDICES) {
      const elements = syncInvalidIndices(
        orderedElements.map((x3) => ({ ...x3 }))
      );
      validateFractionalIndices(elements, {
        // throw in dev & test only, to remain functional on `DEBUG_FRACTIONAL_INDICES`
        shouldThrow: define_import_meta_env_default.DEV || define_import_meta_env_default.MODE === ENV.TEST,
        includeBoundTextValidation: true,
        reconciliationContext: {
          localElements,
          remoteElements
        }
      });
    }
  },
  1e3 * 60,
  { leading: true, trailing: false }
);
var reconcileElements = (localElements, remoteElements, localAppState) => {
  const localElementsMap = arrayToMap(localElements);
  const reconciledElements = [];
  const added = /* @__PURE__ */ new Set();
  for (const remoteElement of remoteElements) {
    if (!added.has(remoteElement.id)) {
      const localElement = localElementsMap.get(remoteElement.id);
      const discardRemoteElement = shouldDiscardRemoteElement(
        localAppState,
        localElement,
        remoteElement
      );
      if (localElement && discardRemoteElement) {
        reconciledElements.push(localElement);
        added.add(localElement.id);
      } else {
        reconciledElements.push(remoteElement);
        added.add(remoteElement.id);
      }
    }
  }
  for (const localElement of localElements) {
    if (!added.has(localElement.id)) {
      reconciledElements.push(localElement);
      added.add(localElement.id);
    }
  }
  const orderedElements = orderByFractionalIndex(reconciledElements);
  validateIndicesThrottled(orderedElements, localElements, remoteElements);
  syncInvalidIndices(orderedElements);
  return orderedElements;
};

// components/TTDDialog/TTDDialogTrigger.tsx
init_define_import_meta_env();
var import_jsx_runtime153 = __toESM(require_jsx_runtime(), 1);
var TTDDialogTrigger = ({
  children,
  icon
}) => {
  const { TTDDialogTriggerTunnel } = useTunnels();
  const setAppState = useExcalidrawSetAppState();
  return /* @__PURE__ */ (0, import_jsx_runtime153.jsx)(TTDDialogTriggerTunnel.In, { children: /* @__PURE__ */ (0, import_jsx_runtime153.jsxs)(
    DropdownMenu_default.Item,
    {
      onSelect: () => {
        trackEvent("ai", "dialog open", "ttd");
        setAppState({ openDialog: { name: "ttd", tab: "text-to-diagram" } });
      },
      icon: icon ?? brainIcon,
      children: [
        children ?? t("labels.textToDiagram"),
        /* @__PURE__ */ (0, import_jsx_runtime153.jsx)(DropdownMenu_default.Item.Badge, { children: "AI" })
      ]
    }
  ) });
};
TTDDialogTrigger.displayName = "TTDDialogTrigger";

// components/DiagramToCodePlugin/DiagramToCodePlugin.tsx
init_define_import_meta_env();
var import_react115 = __toESM(require_react(), 1);
var DiagramToCodePlugin = (props) => {
  const app = useApp();
  (0, import_react115.useLayoutEffect)(() => {
    app.setPlugins({
      diagramToCode: { generate: props.generate }
    });
  }, [app, props.generate]);
  return null;
};

// index.tsx
var import_jsx_runtime154 = __toESM(require_jsx_runtime(), 1);
polyfill_default();
var ExcalidrawBase = (props) => {
  const {
    onChange,
    initialData,
    excalidrawAPI,
    isCollaborating = false,
    onPointerUpdate,
    renderTopRightUI,
    langCode = defaultLang.code,
    viewModeEnabled,
    zenModeEnabled,
    gridModeEnabled,
    libraryReturnUrl,
    theme,
    name,
    renderCustomStats,
    onPaste,
    detectScroll = true,
    handleKeyboardGlobally = false,
    onLibraryChange,
    autoFocus = false,
    generateIdForFile,
    onLinkOpen,
    onPointerDown,
    onPointerUp,
    onScrollChange,
    children,
    validateEmbeddable,
    renderEmbeddable,
    aiEnabled,
    showDeprecatedFonts
  } = props;
  const canvasActions = props.UIOptions?.canvasActions;
  const UIOptions = {
    ...props.UIOptions,
    canvasActions: {
      ...DEFAULT_UI_OPTIONS.canvasActions,
      ...canvasActions
    },
    tools: {
      image: props.UIOptions?.tools?.image ?? true
    }
  };
  if (canvasActions?.export) {
    UIOptions.canvasActions.export.saveFileToDisk = canvasActions.export?.saveFileToDisk ?? DEFAULT_UI_OPTIONS.canvasActions.export.saveFileToDisk;
  }
  if (UIOptions.canvasActions.toggleTheme === null && typeof theme === "undefined") {
    UIOptions.canvasActions.toggleTheme = true;
  }
  (0, import_react116.useEffect)(() => {
    const importPolyfill = async () => {
      await import("./excalidraw-assets-dev/roundRect-T5BX56ZF.js");
    };
    importPolyfill();
    const handleTouchMove = (event) => {
      if (typeof event.scale === "number" && event.scale !== 1) {
        event.preventDefault();
      }
    };
    document.addEventListener("touchmove", handleTouchMove, {
      passive: false
    });
    return () => {
      document.removeEventListener("touchmove", handleTouchMove);
    };
  }, []);
  return /* @__PURE__ */ (0, import_jsx_runtime154.jsx)(Provider, { unstable_createStore: () => jotaiStore, scope: jotaiScope, children: /* @__PURE__ */ (0, import_jsx_runtime154.jsx)(InitializeApp, { langCode, theme, children: /* @__PURE__ */ (0, import_jsx_runtime154.jsx)(
    App_default,
    {
      onChange,
      initialData,
      excalidrawAPI,
      isCollaborating,
      onPointerUpdate,
      renderTopRightUI,
      langCode,
      viewModeEnabled,
      zenModeEnabled,
      gridModeEnabled,
      libraryReturnUrl,
      theme,
      name,
      renderCustomStats,
      UIOptions,
      onPaste,
      detectScroll,
      handleKeyboardGlobally,
      onLibraryChange,
      autoFocus,
      generateIdForFile,
      onLinkOpen,
      onPointerDown,
      onPointerUp,
      onScrollChange,
      validateEmbeddable,
      renderEmbeddable,
      aiEnabled: aiEnabled !== false,
      showDeprecatedFonts,
      children
    }
  ) }) });
};
var areEqual5 = (prevProps, nextProps) => {
  if (prevProps.children !== nextProps.children) {
    return false;
  }
  const {
    initialData: prevInitialData,
    UIOptions: prevUIOptions = {},
    ...prev
  } = prevProps;
  const {
    initialData: nextInitialData,
    UIOptions: nextUIOptions = {},
    ...next
  } = nextProps;
  const prevUIOptionsKeys = Object.keys(prevUIOptions);
  const nextUIOptionsKeys = Object.keys(nextUIOptions);
  if (prevUIOptionsKeys.length !== nextUIOptionsKeys.length) {
    return false;
  }
  const isUIOptionsSame = prevUIOptionsKeys.every((key) => {
    if (key === "canvasActions") {
      const canvasOptionKeys = Object.keys(
        prevUIOptions.canvasActions
      );
      return canvasOptionKeys.every((key2) => {
        if (key2 === "export" && prevUIOptions?.canvasActions?.export && nextUIOptions?.canvasActions?.export) {
          return prevUIOptions.canvasActions.export.saveFileToDisk === nextUIOptions.canvasActions.export.saveFileToDisk;
        }
        return prevUIOptions?.canvasActions?.[key2] === nextUIOptions?.canvasActions?.[key2];
      });
    }
    return prevUIOptions[key] === nextUIOptions[key];
  });
  return isUIOptionsSame && isShallowEqual(prev, next);
};
var Excalidraw = import_react116.default.memo(ExcalidrawBase, areEqual5);
Excalidraw.displayName = "Excalidraw";
export {
  Button,
  DEFAULT_LASER_COLOR,
  DefaultSidebar,
  DiagramToCodePlugin,
  Excalidraw,
  FONT_FAMILY,
  FooterCenter_default as Footer,
  LiveCollaborationTrigger_default as LiveCollaborationTrigger,
  MIME_TYPES,
  MainMenu_default as MainMenu,
  ROUNDNESS,
  Sidebar,
  Stats,
  StoreAction,
  THEME,
  TTDDialog,
  TTDDialogTrigger,
  WelcomeScreen_default as WelcomeScreen,
  bumpVersion,
  convertToExcalidrawElements,
  defaultLang,
  elementPartiallyOverlapsWithOrContainsBBox,
  elementsOverlappingBBox,
  exportToBlob,
  exportToCanvas2 as exportToCanvas,
  exportToClipboard,
  exportToSvg2 as exportToSvg,
  getCommonBounds,
  getDataURL,
  getFreeDrawSvgPath,
  getLibraryItemsHash,
  getNonDeletedElements,
  getSceneVersion,
  getTextFromElements,
  getVisibleSceneBounds,
  hashElementsVersion,
  hashString,
  isElementInsideBBox,
  isInvisiblySmallElement,
  isLinearElement,
  languages,
  loadFromBlob,
  loadLibraryFromBlob,
  loadSceneOrLibraryFromBlob,
  mergeLibraryItems,
  mutateElement,
  newElementWith,
  normalizeLink,
  parseLibraryTokensFromUrl,
  reconcileElements,
  restore,
  restoreAppState,
  restoreElements,
  restoreLibraryItems,
  sceneCoordsToViewportCoords,
  serializeAsJSON,
  serializeLibraryAsJSON,
  useDevice,
  useHandleLibrary,
  useI18n,
  viewportCoordsToSceneCoords,
  zoomToFitBounds
};
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
//# sourceMappingURL=index.js.map
